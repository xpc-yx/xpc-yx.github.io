<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xiaopengcheng.top').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left"},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '420f506edca2c5290761c146d6bde3b2',
      indexName: 'xiaopengcheng.top',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="远行的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="远行&#39;s Blog">
<meta property="og:url" content="http://xiaopengcheng.top/index.html">
<meta property="og:site_name" content="远行&#39;s Blog">
<meta property="og:description" content="远行的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="远行">
<meta property="article:tag" content="UE4">
<meta property="article:tag" content="Unity3D">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xiaopengcheng.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>远行's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="远行's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">远行's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">STEP BY STEP</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/xpc-yx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>

  </li>
        <li class="menu-item menu-item-e-mail">

    <a href="mailto:xiaopengcheng4912@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>邮箱</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">基于Vulkan Specialization Constants的材质变体系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-24 12:28:30" itemprop="dateCreated datePublished" datetime="2025-04-24T12:28:30+08:00">2025-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="基于Vulkan Specialization Constants的材质变体系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="材质变体"><a href="#材质变体" class="headerlink" title="材质变体"></a>材质变体</h1><p>所谓材质变体，指的是一份材质代码文件，最终对应的是多份运行时gpu程序。比如，shader代码里面有开关或者选项，不同的组合对应不同的最终gpu program。那么，所有的这些组合对应的gpu program，可以统一理解为这个材质对应的所有变体。<br>比如下面shader代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">float4 color;</span><br><span class="line">float3 normal;</span><br><span class="line"></span><br><span class="line">void setColorAndNormal() {</span><br><span class="line">#if COLOR_RED</span><br><span class="line">	color = float4(1, 0, 0, 1);</span><br><span class="line">#else</span><br><span class="line">	color = float4(1, 1, 1, 1);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if NORMAL_POSITIVE</span><br><span class="line">	normal = float3(0, 1, 0);</span><br><span class="line">#else</span><br><span class="line">	normal = float3(0, -1, 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>有2个开关，COLOR_RED，NORMAL_POSITIVE。每个开关都有2种状态，开或者关。那么，可以组合出2*2=4种状态。<br>类似C语言，glsl或者hlsl也支持#define宏，因此也有大于2个状态的开关，比如COLOR_RED == 0、COLOR_RED == 1、COLOR_RED == 2。总的状态计算方式是所有开关的状态数相乘，也就是复杂度是指数级的。</p>
<h1 id="传统变体（静态编译变体）"><a href="#传统变体（静态编译变体）" class="headerlink" title="传统变体（静态编译变体）"></a>传统变体（静态编译变体）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>这里的传统变体指的是针对每一种组合状态都编译生成单独的着色器代码。实际上，目前绝大部分引擎实现的变体方案都是这种方式。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h3><p>算法基本思路很简单，遍历所有的状态组合，针对当前状态，#define相应的宏，然后编译当前代码。<br>比如，</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define COLOR_RED 1</span><br><span class="line">#define NORMAL_POSITIVE 0</span><br><span class="line"></span><br><span class="line">float4 color;</span><br><span class="line">float3 normal;</span><br><span class="line"></span><br><span class="line">void setColorAndNormal() {</span><br><span class="line">#if COLOR_RED</span><br><span class="line">	color = float4(1, 0, 0, 1);</span><br><span class="line">#else</span><br><span class="line">	color = float4(1, 1, 1, 1);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if NORMAL_POSITIVE</span><br><span class="line">	normal = float3(0, 1, 0);</span><br><span class="line">#else</span><br><span class="line">	normal = float3(0, -1, 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>对应的代码就是开关COLOR_RED打开、NORMAL_POSITIVE关闭的变体组合状态。<br>同时，将当前状态的激活关键字（变体开关）组合与编译后的代码做映射，保存在编译结果中。</p>
<h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>根据当前的变体开关选择，映射到具体的代码。这里的映射方式与编译期的算法类似。比如，在材质类里面有一个hashmap， 保持变体状态组合到具体gpu program的映射。如果，hashmap内不存在这个映射，那么从编译期生成的代码内加载具体的编译后shader code，然后创建gpu program。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于需要在编译期就决定所有的状态组合，那么很可能会出现包体和内存爆炸的情况。比如，有10个开关，每个开关有2种状态，那么就是1024个变体，对应1024份代码。假设，一份代码的尺寸是10kb，那么就是10mb，有10个这样的材质，那么包体占用就是100mb，内存占用会更大。这就是游戏项目中常说的变体爆炸问题。</p>
<h1 id="动态变体"><a href="#动态变体" class="headerlink" title="动态变体"></a>动态变体</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p> 相比于传统变体，动态变体的最大优势是不会出现变体爆炸问题。在编译期间的编译结果，只有一份代码，同时保存变体定义信息。在运行时，二次编译生成真正的中间代码（spir-v）或者gpu上的汇编代码。</p>
<h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="编译期-1"><a href="#编译期-1" class="headerlink" title="编译期"></a>编译期</h3><p>不需要复杂的遍历算法，直接编译shader代码即可。但是，需要工具链或者图形API支持。比如，使用vulkan支持的Specialization Constants实现变体，那么可以在编译期保存Specialization Constants定义信息的同时，使用spirv-tools编译生成一份spir-v中间代码。</p>
<h3 id="运行时-1"><a href="#运行时-1" class="headerlink" title="运行时"></a>运行时</h3><p>加载这份编译后的代码，比如spir-v中间代码。针对，当前的变体设置，对spir-v进一步处理成指定的变体状态或者将变体设置提交给vulkan，让驱动去编译。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>这种方式会有一定的局限性，无法优化所有的情况。比如驱动可能有bug，无法优化掉一些复杂变体组合的情况或者一些复杂的代码，导致真正运行的代码有多余的指令，引起性能大幅度下降。</p>
<h1 id="Vulkan-Specialization-Constants变体"><a href="#Vulkan-Specialization-Constants变体" class="headerlink" title="Vulkan Specialization Constants变体"></a>Vulkan Specialization Constants变体</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>不同的图形API对动态变体的支持情况不一样，比如OpenGL不支持，Vulkan支持Specialization Constants，metal支持Function Constants。<br>这里专门指代基于Vulkan Specialization Constants实现的变体系统。Vulkan的官方文章：<a href="https://docs.vulkan.org/samples/latest/samples/performance/specialization_constants/README.html">Utilizing Specialization Constants</a><br>对Specialization Constants有具体的介绍，并且与UBO做了对比。</p>
<h2 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="使用Specialization-Constants实现材质代码"><a href="#使用Specialization-Constants实现材质代码" class="headerlink" title="使用Specialization Constants实现材质代码"></a>使用Specialization Constants实现材质代码</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">layout(constant_id = 0) const bool COLOR_RED = true;</span><br><span class="line">layout(constant_id = 1) const bool NORMAL_POSITIVE = true;</span><br><span class="line"></span><br><span class="line">float4 color;</span><br><span class="line">float3 normal;</span><br><span class="line"></span><br><span class="line">void setColorAndNormal() {</span><br><span class="line">if (COLOR_RED) {</span><br><span class="line">	color = float4(1, 0, 0, 1);</span><br><span class="line">}</span><br><span class="line">else {</span><br><span class="line">	color = float4(1, 1, 1, 1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if (NORMAL_POSITIVE) {</span><br><span class="line">	normal = float3(0, 1, 0);</span><br><span class="line">}</span><br><span class="line">else {</span><br><span class="line">	normal = float3(0, -1, 0);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>比如上述代码，定义了2个Specialization Constants变量：COLOR_RED和NORMAL_POSITIVE 。同时在代码内使用了这2个变量作为开关进行分支选择，注意：从语法上，Specialization Constants是作为变量处理，而不是宏。</p>
<h3 id="使用spirv-tools编译带有Specialization-Constants信息的材质代码"><a href="#使用spirv-tools编译带有Specialization-Constants信息的材质代码" class="headerlink" title="使用spirv-tools编译带有Specialization Constants信息的材质代码"></a>使用spirv-tools编译带有Specialization Constants信息的材质代码</h3><p>这一步与传统变体的区别是不需要遍历所有的变体状态组合，直接编译代码即可。对于，vulkan来说，使用glslang库调用spirv-tools编译代码就可以获得带有Specialization Constants信息的spir-v中间代码。</p>
<h3 id="运行时决定Specialization-Constants"><a href="#运行时决定Specialization-Constants" class="headerlink" title="运行时决定Specialization Constants"></a>运行时决定Specialization Constants</h3><p>上一步得到的是一份带有Specialization Constants信息的spir-v中间代码，如果获得最终的运行时代码了？</p>
<h4 id="变体组合映射gpu-program"><a href="#变体组合映射gpu-program" class="headerlink" title="变体组合映射gpu program"></a>变体组合映射gpu program</h4><p>这部分类似传统变体方案，需要将变体组合状态映射到具体的Specialization Constants设置。</p>
<h4 id="设置Specialization-Constants"><a href="#设置Specialization-Constants" class="headerlink" title="设置Specialization Constants"></a>设置Specialization Constants</h4><p>有两种实现思路，各有优劣，下面具体说明。<br><strong>1. 使用vulkan的Specialization Constants接口</strong><br>使用vulkan的Specialization Constants，在在vulkan的pipeline中传递运行时的Specialization Constants设置信息。因为Specialization Constants是PSO的一部分，因此这种方式需要重新编译gpu program和PSO。由于，不需要完整编译gpu program，因此与切换gpu program的方案（传统变体）这个方案会编译更快。</p>
<p><strong>2. 使用spirv-optimizer剔除分支</strong><br>第二种方式是使用spir-optimizer里面的pass处理spir-v中间代码，比如设置Specialization Constants的值后，剔除dead code和Specialization Constants信息等，直接获得最终不带Specialization Constants信息的spir-v。这个spir-v就可以直接传递vulkan创建gpu program。</p>
<p><strong>3. 两个方案对比</strong></p>
<ul>
<li>vulkan的Specialization Constants依赖驱动的JIT编译结果，如果驱动实现有问题，那么实际上Specialization Constants无法精准剔除代码，导致性能达不到预期。</li>
<li>spirv-optimizer剔除代码的方式，可以避免驱动的问题，在不同的驱动上表现一致；而且方便调试，比如可以在RenderDoc上抓取最终运行代码，或者mali offline compiler离线查看，确定最终运行的变体状态，但是这个方案依赖这个中间处理工具的能力。</li>
</ul>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><ul>
<li>依赖高级特性，在传统图形API上不支持。只能针对运行Vulkan的平台做优化。</li>
<li>一些复杂的情况无法兼容，比如高通驱动无法优化比较复杂的使用Specialization Constants的代码等，会出现明显性能下降；spirv-optimizer对于将Specialization Constants作为变量传递的代码无法识别等。</li>
<li>使用vulkan的Specialization Constants接口在驱动上进行JIT编译的方案，运行结果依赖具体硬件的驱动实现，结果不稳定。</li>
<li>使用spirv-optimizer剔除分支的方案需要额外的运行时处理时间，会引起切换变体卡顿，引擎需要妥善处理，比如异步调用spirv-optimizer，同时对优化后的spir-v缓存。</li>
</ul>
<h1 id="动态变体与传统变体的对比"><a href="#动态变体与传统变体的对比" class="headerlink" title="动态变体与传统变体的对比"></a>动态变体与传统变体的对比</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>可以解决变体爆炸问题。</li>
<li>可能更快的编译PSO。</li>
</ul>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ul>
<li>跨平台差，需要高级图形API特性。</li>
<li>可能依赖硬件驱动实现。</li>
<li>可能引入运行时卡顿。</li>
</ul>
<h1 id="其它问题探讨"><a href="#其它问题探讨" class="headerlink" title="其它问题探讨"></a>其它问题探讨</h1><h2 id="变体收集"><a href="#变体收集" class="headerlink" title="变体收集"></a>变体收集</h2><p>变体收集是另一个经常讨论的问题。一般需要引擎支持才能实现完整的变体收集。下面讲一个之前实现过的方案。</p>
<ul>
<li>引擎runtime<br>引擎内有一个统一的ShaderProgramManger。该管理器内有2层hash，保存了所有材质和材质变体组合对应的gpu program。引擎内所有切换变体的操作最终都通过该类来查找gpu program。因此，该类完整收集了当前引擎运行状态下所有的变体组合。那么，可以在该类里面实现dump接口，遍历所有缓存的材质变体组合，输出文件作为变体集合文件。<br>实际项目中，可以用自动化系统运行常见的场景，在合适的时机调用dump接口进行收集。</li>
<li>变体集合编译<br>假如使用spirv-optimizer的方案实现动态变体，那么可以针对变体集合文件内的收集到的变体状态组合，提前编译出最终的spir-v。在ShaderProgramManger查找变体时候，判断有提前预编译的情况，可以直接加载，而不是去调用spirv-optimizer处理。</li>
</ul>
<h2 id="变体预热"><a href="#变体预热" class="headerlink" title="变体预热"></a>变体预热</h2><ul>
<li><p>变体切换<br>对于传统变体来说，就是根据变体设置查找相应的着色器代码；对于动态变体来说，可能需要对spir-v代码进行预处理。</p>
</li>
<li><p>编译PSO<br>对于使用vulkan的Specialization Constants接口的方案来说，gpu program已经确定，需要设置Specialization Constants，再重新编译PSO。这个过程实际上是对gpu program重新编译获得最终的版本，由于有之前的编译信息，会比编译完整的gpu program更快。<br>对于其它方案，实际上是编译完整的gpu program，与使用vulkan的Specialization Constants接口的方案对比，速度更慢。</p>
</li>
<li><p>实现思路<br>比如引擎可以加载变体集合文件，根据变体集合文件的描述，提前编译对应变体的代码以及PSO。</p>
</li>
</ul>
<h2 id="动态变体无法解决PSO编译的问题"><a href="#动态变体无法解决PSO编译的问题" class="headerlink" title="动态变体无法解决PSO编译的问题"></a>动态变体无法解决PSO编译的问题</h2><p>网上也有讨论Specialization Constants的文章，比如：<a href="https://zhuanlan.zhihu.com/p/678177922">【笔记】Shader变体大杀器：specialization constants</a>。该文章的评论里面提到Specialization Constants无法解决PSO的预热问题，从而对Specialization Constants进行了否定。实际上，这个是概念上的混淆。无论如何，PSO是需要重新编译的，因为最终的渲染状态数目是没有改变的；动态变体只是将确定最终gpu program的过程延迟到运行时决定，从而避免变体爆炸，并没有减少材质变体的状态总数。期望通过<br>Specialization Constants减少PSO数目或者加快PSO预热是方向上的错误。正确的思路是从PSO的收集缓存等方面来考虑，避免第一次切换到该PSO的卡顿。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2025/02/18/Vulkan%E4%B8%8EOpenGL%E7%9A%84%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/18/Vulkan%E4%B8%8EOpenGL%E7%9A%84%E5%AF%B9%E6%AF%94/" class="post-title-link" itemprop="url">Vulkan与OpenGL的对比</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-18 17:28:30" itemprop="dateCreated datePublished" datetime="2025-02-18T17:28:30+08:00">2025-02-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2025/02/18/Vulkan%E4%B8%8EOpenGL%E7%9A%84%E5%AF%B9%E6%AF%94/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan与OpenGL的对比" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/02/18/Vulkan%E4%B8%8EOpenGL%E7%9A%84%E5%AF%B9%E6%AF%94/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/02/18/Vulkan%E4%B8%8EOpenGL%E7%9A%84%E5%AF%B9%E6%AF%94/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="传统图形API与现代图形API"><a href="#传统图形API与现代图形API" class="headerlink" title="传统图形API与现代图形API"></a>传统图形API与现代图形API</h1><p>传统图形API指的是OpenGL/DirectX11这类简单易用、驱动托管严重的图形接口；而现代图形API则指的是Vulkan/Metal/DirectX12这类使用复杂、暴露更多底层硬件功能来显式控制的弱驱动设计的图形接口。<br>现代图形API与传统图形API相比，使用和设计上有不少的区别，下面总结一些Vulkan与OpenGL的区别来对比说明。</p>
<h1 id="渲染状态管理"><a href="#渲染状态管理" class="headerlink" title="渲染状态管理"></a>渲染状态管理</h1><p>OpenGL是一个全局的状态机，而Vulkan提供了PSO（PipelineState Object）来保存不同的管线状态。这样的区别是：</p>
<h2 id="驱动实现"><a href="#驱动实现" class="headerlink" title="驱动实现"></a>驱动实现</h2><p>OpenGL由于要在驱动内管理和保存全局的状态，实现复杂。而Vulkan将状态管理暴露给应用层管理，不再需要在驱动层处理，从而驱动实现更为简单。</p>
<h2 id="状态切换性能"><a href="#状态切换性能" class="headerlink" title="状态切换性能"></a>状态切换性能</h2><p>OpenGL由于是全局状态机，在渲染时候经常需要设置和恢复状态，都会触发驱动内对全局状态机的管理，容易引发CPU上的性能瓶颈。但是Vulkan的PSO可以进行预编译，将不同的状态提前存储到不同的PSO上，同时对PSO收集离线缓存和提前预加载编译，等到渲染时候进行PSO切换即可。这样可以大幅度降低因为渲染状态切换导致的CPU性能瓶颈。<br>同时，Vulkan的渲染状态是缓存在PSO内，相比OpenGL的全局状态管理，可能性能本身就更好。</p>
<h1 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h1><p>OpenGL只支持单线程提交DC，而Vulkan支持多线程提交DC。<br>具体思路：Vulkan支持多线程录制command后再提交到command queue。比如，每个线程创建一个command buffer，并行录制command到command buffer，再提交到指定的command queue。<br>更进一步，Vulkan支持多个command queue，这些queue可能在硬件层（驱动内）是并行的，比如Graphics的queue和compute的queue。</p>
<h1 id="Shader编译"><a href="#Shader编译" class="headerlink" title="Shader编译"></a>Shader编译</h1><p>OpenGL将Shader的编译直接交给驱动负责。而Vulkan则将Shader使用spirv-tools编译成跨平台的中间语言spir-v，驱动只负责编译spir-v。这样的好处是：</p>
<ol>
<li>跨平台：驱动只需要处理中间格式，方便使用工具将不同的语言比如hlsl、glsl等都统一编译成spirv。</li>
<li>性能：驱动只需要编译中间语言，不需要对着色器代码做负责的编译检查语法分析等，性能更好。</li>
</ol>
<h1 id="资源绑定"><a href="#资源绑定" class="headerlink" title="资源绑定"></a>资源绑定</h1><p>OpenGL的资源绑定都是一次API调用，比如glBindTexture等。而Vulkan支持在PSO上一次性绑定多个资产，以及Bindless等。具体可以参考文章：<a href="https://zhuanlan.zhihu.com/p/136449475">游戏引擎随笔 0x13：现代图形 API 的 Bindless</a>。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>OpenGL不支持显式的内存管理，都是托管给驱动负责。但是Vulkan支持或者说必须显式的管理与分配内存，因为驱动不再负责。具体来说是，Vulkan必须应用层申请内存同时进行管理，而OpenGL不需要。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Vulkan 显式分配显存</span><br><span class="line">VkMemoryAllocateInfo allocInfo{};</span><br><span class="line">allocInfo.allocationSize = size;</span><br><span class="line">allocInfo.memoryTypeIndex = findMemoryType(...);</span><br><span class="line">vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;deviceMemory);</span><br><span class="line">vkBindBufferMemory(device, buffer, deviceMemory, 0);</span><br><span class="line"></span><br><span class="line">// OpenGL 隐式分配</span><br><span class="line">GLuint buffer;</span><br><span class="line">glGenBuffers(1, &amp;buffer);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, buffer);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);</span><br></pre></td></tr></tbody></table></figure>
<p>比如上述代码，OpenGL是直接调用glGenBuffers获得buffer的id即可，内部由驱动去申请和管理内存；而Vulkan则需要调用vkAllocateMemory具体的申请内存，后续的管理和同步也需要应用层负责。因此，理论上Vulkan可以实现更接近应用需要的内存管理机制。</p>
<h1 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h1><p>这里的同步包括CPU和GPU的同步，以及GPU不同的渲染操作之间的同步等。OpenGL的同步都由驱动隐式完成，应用层无法控制。而Vulkan提供了多种手段来显式控制同步，以更好的优化性能。</p>
<ol>
<li>Fence用于CPU和GPU之间的同步，比如CPU等待某个GPU操作完成。</li>
<li>Semaphores用GPU内部的同步。</li>
<li>Pipeline Barrier用于同一个queue内同步。</li>
<li>Event可以用于等待Pipeline事件发生，也可以用于CPU和GPU之间的同步。</li>
</ol>
<h1 id="错误验证"><a href="#错误验证" class="headerlink" title="错误验证"></a>错误验证</h1><p>OpenGL由于是驱动管理全局的状态，而且驱动内置了错误管理和验证机制，导致驱动的实现复杂并且有较大的性能损失。相反，Vulkan的错误验证层是可选的组件，并且在Vulkan层，并没有在硬件的驱动内实现；在开发阶段，可以开启验证层排查问题，而真正的运行阶段并没有验证层。</p>
<ol>
<li>性能：Vulkan没有错误验证层性能更好，驱动实现更简单。</li>
<li>开发：Vulkan由于没有驱动兜底，因此开发难度更大，需要更仔细的调试和验证。</li>
</ol>
<h1 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h1><p>以上这些对比区别，都是CPU层面的，因此Vulkan这种现代图形API适合需要对CPU性能做极致优化的场景。如果，性能瓶颈在GPU上，将图形API从OpenGL切换到Vulkan上也无法解决问题。相信随着硬件的发作，Vulkan会逐渐替代OpenGL/OpenGLES成为事实上的默认跨平台图形API。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://www.cnblogs.com/timlly/p/15680064.html">剖析虚幻渲染体系（13）- RHI补充篇：现代图形API之奥义与指南 </a><br><a href="https://zhuanlan.zhihu.com/p/136449475">游戏引擎随笔 0x13：现代图形 API 的 Bindless</a><br><a href="https://zhuanlan.zhihu.com/p/100162469">游戏引擎随笔 0x07：现代图形 API 的同步</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">filament的材质系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-28 12:28:30" itemprop="dateCreated datePublished" datetime="2024-12-28T12:28:30+08:00">2024-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="filament的材质系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><p><a href="https://github.com/google/filament">filament</a>是Google开源的一个跨平台实时pbr渲染引擎。注意，这是一个渲染引擎，不是一个完整的游戏引擎。<br>filament的材质系统文档：<a href="https://google.github.io/filament/Materials.html">Filament Materials Guide</a>，pbr算法文档：<a href="https://google.github.io/filament/Filament.html">Physically Based Rendering in Filament</a>。这些文档只是从使用层面简单介绍材质系统和使用的PBR算法等，并没有深入介绍材质的整体流程和一些关键技术细节。因此，本文打算深入介绍材质系统相关的整体流程以及材质渲染相关的关键技术细节。</p>
<h1 id="一-材质编写"><a href="#一-材质编写" class="headerlink" title="一. 材质编写"></a>一. 材质编写</h1><p>这部分大概介绍下材质相关的语法。以下面的材质示例代码来说明：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">material {    </span><br><span class="line">    name : "Textured material",</span><br><span class="line">    requires : [ uv0, color ],    </span><br><span class="line">    shadingModel : lit,</span><br><span class="line">    blending : opaque,</span><br><span class="line">    parameters : [       </span><br><span class="line">        {    type : sampler2d,       name : baseColor        },    </span><br><span class="line">        {    type : float,           name : metallic       },     </span><br><span class="line">        {    type : float,           name : roughness      }</span><br><span class="line">    ],</span><br><span class="line">    constants : [</span><br><span class="line">        {</span><br><span class="line">           name : overrideAlpha,</span><br><span class="line">           type : bool</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">           name : customAlpha,</span><br><span class="line">           type : float,</span><br><span class="line">           default : 0.5</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">vertex {    </span><br><span class="line">    void materialVertex(inout MaterialVertexInputs material) { </span><br><span class="line">        material.color *= sin(getUserTime().x); </span><br><span class="line">        material.uv0 *= sin(getUserTime().x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fragment {  </span><br><span class="line">    void material(inout MaterialInputs material) { </span><br><span class="line">        prepareMaterial(material);</span><br><span class="line">        material.baseColor = texture(materialParams_baseColor, getUV0()); </span><br><span class="line">        material.metallic = materialParams.metallic;</span><br><span class="line">        material.roughness = materialParams.roughness;</span><br><span class="line">                </span><br><span class="line">                if (materialConstants_overrideAlpha) {</span><br><span class="line">            material.baseColor.a = materialConstants_customAlpha;</span><br><span class="line">            material.baseColor.rgb *= material.baseColor.a;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上述示例代码来看，一个材质分开三块：material、vertex、fragment。其中，material是材质熟悉块，vertex是顶点代码块，fragment是片元代码块。如果是一个compute材质，那么只有一个compute代码块。</p>
<h2 id="1-1-材质属性块"><a href="#1-1-材质属性块" class="headerlink" title="1.1 材质属性块"></a>1.1 材质属性块</h2><p>这部分包括所有的材质设置，比如渲染状态设置、材质的uniform参数以及各种其它设置。举例说明，blending是混合模式，是渲染状态设置；shadingModel是光照模型，类似一个材质变体设置；parameters则是uniform参数，比如float最终是存放在材质的uniform buffer内，而sampler2d是生成uniform sampler。</p>
<h2 id="1-2-代码块"><a href="#1-2-代码块" class="headerlink" title="1.2 代码块"></a>1.2 代码块</h2><p>filament的材质是一种surface材质。surface材质是一种受限制的材质，意思是一种只开放表面属性修改的材质，这种材质书写方式入门比较简单，但是功能比较受限制。unity的默认管线也支持surface材质，具体可以参考<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html">Introduction to surface shaders in the Built-In Render Pipeline</a>。</p>
<h3 id="1-2-1-顶点代码"><a href="#1-2-1-顶点代码" class="headerlink" title="1.2.1 顶点代码"></a>1.2.1 顶点代码</h3><p>vertex下的入口函数是materialVertex，只能在该函数内修改inout的MaterialVertexInputs参数material来定制顶点着色器。MaterialVertexInputs是顶点的输入定义结构体，定义如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct MaterialVertexInputs {</span><br><span class="line">#ifdef HAS_ATTRIBUTE_COLOR</span><br><span class="line">    vec4 color;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_UV0</span><br><span class="line">    vec2 uv0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_UV1</span><br><span class="line">    vec2 uv1;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM0</span><br><span class="line">    vec4 VARIABLE_CUSTOM0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM1</span><br><span class="line">    vec4 VARIABLE_CUSTOM1;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM2</span><br><span class="line">    vec4 VARIABLE_CUSTOM2;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM3</span><br><span class="line">    vec4 VARIABLE_CUSTOM3;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_TANGENTS</span><br><span class="line">    vec3 worldNormal;</span><br><span class="line">#endif</span><br><span class="line">    vec4 worldPosition;</span><br><span class="line">#ifdef VERTEX_DOMAIN_DEVICE</span><br><span class="line">#ifdef MATERIAL_HAS_CLIP_SPACE_TRANSFORM</span><br><span class="line">    mat4 clipSpaceTransform;</span><br><span class="line">#endif // MATERIAL_HAS_CLIP_SPACE_TRANSFORM</span><br><span class="line">#endif // VERTEX_DOMAIN_DEVICE</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>比如，color、uv0、uv1都是顶点属性。</p>
<h3 id="1-2-2-片元代码"><a href="#1-2-2-片元代码" class="headerlink" title="1.2.2 片元代码"></a>1.2.2 片元代码</h3><p>fragment也是类似的逻辑，入口函数是material，只能通过修改inout的MaterialInputs参数material来定制片元着色器。MaterialInputs结构体是pbr或者更复杂的渲染模型的属性，定义如下。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">struct MaterialInputs {</span><br><span class="line">    vec4  baseColor;</span><br><span class="line">#if !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">#if !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    float roughness;</span><br><span class="line">#endif</span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    float metallic;</span><br><span class="line">    float reflectance;</span><br><span class="line">#endif</span><br><span class="line">    float ambientOcclusion;</span><br><span class="line">#endif</span><br><span class="line">    vec4  emissive;</span><br><span class="line"></span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SUBSURFACE) &amp;&amp; !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">    vec3 sheenColor;</span><br><span class="line">    float sheenRoughness;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    float clearCoat;</span><br><span class="line">    float clearCoatRoughness;</span><br><span class="line"></span><br><span class="line">    float anisotropy;</span><br><span class="line">    vec3  anisotropyDirection;</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_SUBSURFACE) || defined(MATERIAL_HAS_REFRACTION)</span><br><span class="line">    float thickness;</span><br><span class="line">#endif</span><br><span class="line">#if defined(SHADING_MODEL_SUBSURFACE)</span><br><span class="line">    float subsurfacePower;</span><br><span class="line">    vec3  subsurfaceColor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_CLOTH)</span><br><span class="line">    vec3  sheenColor;</span><br><span class="line">#if defined(MATERIAL_HAS_SUBSURFACE_COLOR)</span><br><span class="line">    vec3  subsurfaceColor;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    vec3  specularColor;</span><br><span class="line">    float glossiness;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_NORMAL)</span><br><span class="line">    vec3  normal;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_BENT_NORMAL)</span><br><span class="line">    vec3  bentNormal;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_CLEAR_COAT) &amp;&amp; defined(MATERIAL_HAS_CLEAR_COAT_NORMAL)</span><br><span class="line">    vec3  clearCoatNormal;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_POST_LIGHTING_COLOR)</span><br><span class="line">    vec4  postLightingColor;</span><br><span class="line">    float postLightingMixFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SUBSURFACE) &amp;&amp; !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">#if defined(MATERIAL_HAS_REFRACTION)</span><br><span class="line">#if defined(MATERIAL_HAS_ABSORPTION)</span><br><span class="line">    vec3 absorption;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_TRANSMISSION)</span><br><span class="line">    float transmission;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_IOR)</span><br><span class="line">    float ior;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_MICRO_THICKNESS) &amp;&amp; (REFRACTION_TYPE == REFRACTION_TYPE_THIN)</span><br><span class="line">    float microThickness;</span><br><span class="line">#endif</span><br><span class="line">#elif !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">#if defined(MATERIAL_HAS_IOR)</span><br><span class="line">    float ior;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_SPECULAR_FACTOR)</span><br><span class="line">    float specularFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_SPECULAR_COLOR_FACTOR)</span><br><span class="line">    vec3 specularColorFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>因此，只需要简单的在入口函数内修改属性，就可以便捷的实现材质效果。</p>
<h3 id="1-2-3-compute代码块"><a href="#1-2-3-compute代码块" class="headerlink" title="1.2.3 compute代码块"></a>1.2.3 compute代码块</h3><p>如果使用的是compute材质，那么代码块是compute代码块。示例如下：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">material {</span><br><span class="line">    name: testCompute,</span><br><span class="line">    domain: compute,</span><br><span class="line">    groupSize: [32, 32, 1],</span><br><span class="line">    parameters: [</span><br><span class="line">        {type : sampler2d, name : color}</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">compute {</span><br><span class="line">    void compute() {</span><br><span class="line">        int3 id = int3(getGlobalInvocationID());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="二-材质编译"><a href="#二-材质编译" class="headerlink" title="二. 材质编译"></a>二. 材质编译</h1><p>filament有一个专门的材质编译工具matc。该工具主要做了两件事情：一个是解析material材质属性块，根据材质属性块生成代码，需要序列化的材质属性写入材质属性数据块中；一个是编译材质代码，将编译后的所有的变体代码写入到代码数据块中。<br>整体流程图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/filament材质编译流程.png"></p>
<h2 id="2-1-材质属性编译"><a href="#2-1-材质属性编译" class="headerlink" title="2.1 材质属性编译"></a>2.1 材质属性编译</h2><p>材质属性，指定是material块内的定义。材质属性主要包括两类，生成代码的属性和其它属性。生成代码的属性包括parameters和constants属性，parameters和constants属性会生成代码定义，同时也会进行序列化；而其它类型的材质属性会在解析后进行序列化。</p>
<h3 id="2-1-1-parameters属性"><a href="#2-1-1-parameters属性" class="headerlink" title="2.1.1 parameters属性"></a>2.1.1 parameters属性</h3><p>parameters块内定义的属性，type指定类型，主要是两类：数值类型和采样器类型。最终，所有的数值类型会存放到一个着材质实例的uniform buffer内。而每个采样器类型的参数，都会生成一个着材质实例的uniform sampler。</p>
<h3 id="2-1-2-其它属性"><a href="#2-1-2-其它属性" class="headerlink" title="2.1.2 其它属性"></a>2.1.2 其它属性</h3><p>这部分属性包括，材质渲染状态设置、光照模型相关等。对于编译器来说，这部分设置解析出来后再序列化就行。</p>
<h2 id="2-2-材质代码编译"><a href="#2-2-材质代码编译" class="headerlink" title="2.2 材质代码编译"></a>2.2 材质代码编译</h2><h3 id="2-2-1-生成材质属性定义"><a href="#2-2-1-生成材质属性定义" class="headerlink" title="2.2.1 生成材质属性定义"></a>2.2.1 生成材质属性定义</h3><p>示例代码的parameters生成的ubo定义可能如下：</p>
<ol>
<li><strong>Uniform Buffer生成</strong></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout(binding = 10, std140, set = 1) uniform MaterialParams {</span><br><span class="line">    float metallic;</span><br><span class="line">    float roughness;</span><br><span class="line">} materialParams;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>Uniform Sampler生成</strong><br>示例代码的parameters生成的uniform sampler定义可能如下：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout(binding = 10, set = 2) uniform lowp sampler2D materialParams_baseColor;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>Specialization Constants生成</strong><br>示例代码的constants生成的specialization constants定义可能如下</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout (constant_id = 8) const bool materialConstants_overrideAlpha = false;</span><br><span class="line">layout (constant_id = 9) const float materialConstants_customAlpha = 0.500000;</span><br></pre></td></tr></tbody></table></figure>
<p>至于什么是<strong>specialization constants</strong>，请参考文档：<a href="https://docs.vulkan.org/samples/latest/samples/performance/specialization_constants/README.htm">Utilizing Specialization Constants</a>。简而言之，这是一种将编译器的预处理阶段的宏延迟到gpu编译阶段的手段。</p>
<h1 id="三-材质加载和材质实例创建"><a href="#三-材质加载和材质实例创建" class="headerlink" title="三. 材质加载和材质实例创建"></a>三. 材质加载和材质实例创建</h1><h2 id="3-1-整体介绍"><a href="#3-1-整体介绍" class="headerlink" title="3.1 整体介绍"></a>3.1 整体介绍</h2><p>这部分主要涉及三个类，材质类Material、材质示例类MaterialInstance、材质解析类MaterialParser。Material类对应的是Unity的Shader类，MaterialInstance类对应的是Unity的Material类。整体流程如下：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/filament材质加载和材质实例创建.png"></p>
<h2 id="3-2-材质创建"><a href="#3-2-材质创建" class="headerlink" title="3.2 材质创建"></a>3.2 材质创建</h2><h3 id="3-2-1-数据解析"><a href="#3-2-1-数据解析" class="headerlink" title="3.2.1 数据解析"></a>3.2.1 数据解析</h3><ol>
<li><strong>MaterialParser</strong><br>材质创建的第一步是解析二进制的材质数据，即材质编译阶段序列化各种数据块，包括材质属性数据块以及材质代码数据块。该类的parse函数会遍历解析出所有的数据Chunk，保存起来作为后续真正的数据解析使用。</li>
<li><strong>兼容检测</strong><br>将所有的数据块全部加载到内存中后，再做一些基本的检测，比如材质版本号匹配、shaderModel（平台）匹配等，如果通过才真正去创建材质。<h3 id="3-2-2-创建材质对象"><a href="#3-2-2-创建材质对象" class="headerlink" title="3.2.2 创建材质对象"></a>3.2.2 创建材质对象</h3>材质数据加载后，并且通过兼容性检测后，会调用engine的createMaterial函数去创建材质对象。filament的所有gpu相关对象最终都是通过engine类来创建管理的。<h3 id="3-2-3-初始化材质属性"><a href="#3-2-3-初始化材质属性" class="headerlink" title="3.2.3 初始化材质属性"></a>3.2.3 初始化材质属性</h3>在FMaterial类的构造函数内，会通过调用MaterialParser的具体解析函数，将所有材质数据属性解析出来，然后做好相应的运行时状态初始化。</li>
<li><strong>描述集Layout</strong><br>材质内有两个DescriptorSetLayout，一个是材质本身的DescriptorSetLayout，一个是PerView的DescriptorSetLayout。这两个layout是用于提交材质级别和PerView级别的数据。材质本身的DescriptorSetLayout用于后续初始化材质实例的DescriptorSet；材质实例的DescriptorSet用于提交材质数据。</li>
<li><strong>SpecializationConstants</strong><br>specializationConstants是一种新的动态变体技术，具体在生成材质属性定义里面有介绍。在材质解析阶段，需要解析出材质的specializationConstants设置，然后在切换材质变体时候通过传递给对应的gpu program进行切换。<br>filament的specializationConstants变体问题<br>filament将specializationConstants数据保存在材质内，会导致设置时候引起该材质所有的材质实例变化。这并不喝了，因为变体从使用上是材质实例级别的，不同的材质实例需要保存不同的变体设置，所以应该通过材质实例来保存和设置变体数据。</li>
<li><strong>pushConstants</strong><br>关于什么是pushConstants ，参考文档：Push Constants。简单理解，即这是一块区分于UBO的小数据块，相比UBO有一定的性能优势，但是大小受限制。<br>实际上，当前版本的filament只是用pushConstants处理了引擎morphing数据，并没有开放材质级别的写法。如下代码，<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">utils::FixedCapacityVector&lt;filament::MaterialPushConstant&gt; const PUSH_CONSTANTS = {</span><br><span class="line">    {</span><br><span class="line">        "morphingBufferOffset",</span><br><span class="line">        filament::backend::ConstantType::INT,</span><br><span class="line">        filament::backend::ShaderStage::VERTEX,</span><br><span class="line">    },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
材质文件固定序列化上述代码的pushConstants。</li>
<li><strong>其它属性</strong><br>其它属性涉及范围比较广，比如渲染状态的设置，包括深度测试/写入、混合、模板测试等，也包括材质相关的设置，比如材质效果相关的设置等。这些属性都会序列化为数据块，然后在材质创建时候，通过MaterialParser解析出来保存在材质内。<h2 id="3-3-材质实例创建"><a href="#3-3-材质实例创建" class="headerlink" title="3.3 材质实例创建"></a>3.3 材质实例创建</h2>创建材质实例有两种路径，但是初始化流程是一致的，都是初始化描述集和其它材质属性。</li>
<li><strong>初始化描述集</strong><br>材质实例的DescriptorSet通过材质的DescriptorSetLayout进行初始化。材质实例使用该DescriptorSet进行数据的提交和绑定，包括Sampler和Uniform Buffer。因此，需要在初始化阶段将材质Uniform Buffer的通过调用setBuffer设置给DescriptorSet。</li>
<li><strong>初始化其它材质属性</strong><br>其它材质属性，基本是通过从材质或者其它材质实例内拷贝的方式设置的。这些存储在材质实例内的材质属性，通常与渲染状态或者渲染效果相关，比如混合、深度测试/写入等。</li>
</ol>
<h1 id="四-材质变体"><a href="#四-材质变体" class="headerlink" title="四. 材质变体"></a>四. 材质变体</h1><p>filament支持基于宏的传统变体，即每一个变体是一个gpu program。在编译材质时候，根据不同的宏定义组合编译出不同的gpu program；在运行阶段，根据stage和变体匹配到对应的gpu program。</p>
<h2 id="4-1-变体定义"><a href="#4-1-变体定义" class="headerlink" title="4.1 变体定义"></a>4.1 变体定义</h2><h3 id="4-1-1-Surface材质变体"><a href="#4-1-1-Surface材质变体" class="headerlink" title="4.1.1 Surface材质变体"></a>4.1.1 Surface材质变体</h3><p>filament有一个Variant类，里面定义了Surface材质可以使用的变体。如下摘自其变体注释代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// DIR: Directional Lighting</span><br><span class="line">// DYN: Dynamic Lighting</span><br><span class="line">// SRE: Shadow Receiver</span><br><span class="line">// SKN: Skinning</span><br><span class="line">// DEP: Depth only</span><br><span class="line">// FOG: Fog</span><br><span class="line">// PCK: Picking (depth variant only)</span><br><span class="line">// VSM: Variance shadow maps</span><br><span class="line">// STE: Instanced stereo rendering</span><br><span class="line">//</span><br><span class="line">//   X: either 1 or 0</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">// Variant              | STE | VSM | FOG | DEP | SKN | SRE | DYN | DIR |   256</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                                    PCK</span><br><span class="line">//</span><br><span class="line">// Standard variants:</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                      | STE | VSM | FOG |  0  | SKN | SRE | DYN | DIR |    128 - 44 = 84</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//      Vertex shader      X     0     0     0     X     X     X     X</span><br><span class="line">//    Fragment shader      0     X     X     0     0     X     X     X</span><br><span class="line">//       Fragment SSR      0     1     0     0     0     1     0     0</span><br><span class="line">//           Reserved      X     1     1     0     X     1     0     0      [ -4]</span><br><span class="line">//           Reserved      X     0     X     0     X     1     0     0      [ -8]</span><br><span class="line">//           Reserved      X     1     X     0     X     0     X     X      [-32]</span><br><span class="line">//</span><br><span class="line">// Depth variants:</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                      | STE | VSM | PCK |  1  | SKN |  0  |  0  |  0  |   16 - 4 = 12</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//       Vertex depth      X     X     0     1     X     0     0     0</span><br><span class="line">//     Fragment depth      0     X     X     1     0     0     0     0</span><br><span class="line">//           Reserved      X     1     1     1     X     0     0     0     [  -4]</span><br><span class="line">//</span><br><span class="line">// 96 variants used, 160 reserved (256 - 96)</span><br><span class="line">//</span><br><span class="line">// note: a valid variant can be neither a valid vertex nor a valid fragment variant</span><br><span class="line">//       (e.g.: FOG|SKN variants), the proper bits are filtered appropriately,</span><br><span class="line">//       see filterVariantVertex(), filterVariantFragment().</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>8位变体</li>
<li>顶点和片元的变体是分开的</li>
<li>X表示该变体位可以切换，1或者0表示只能设置为固定值。</li>
<li>Reserved是无效的变体组合。<h3 id="4-1-2-PostProcess材质变体"><a href="#4-1-2-PostProcess材质变体" class="headerlink" title="4.1.2 PostProcess材质变体"></a>4.1.2 PostProcess材质变体</h3></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static constexpr size_t POST_PROCESS_VARIANT_BITS = 1;</span><br><span class="line">static constexpr size_t POST_PROCESS_VARIANT_COUNT = (1u &lt;&lt; POST_PROCESS_VARIANT_BITS);</span><br><span class="line">static constexpr size_t POST_PROCESS_VARIANT_MASK = POST_PROCESS_VARIANT_COUNT - 1;</span><br><span class="line"></span><br><span class="line">enum class PostProcessVariant : uint8_t {</span><br><span class="line">    OPAQUE,</span><br><span class="line">    TRANSLUCENT</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>根据上述定义，后处理材质支持2个变体。</p>
<h3 id="4-1-3-Compute材质变体"><a href="#4-1-3-Compute材质变体" class="headerlink" title="4.1.3 Compute材质变体"></a>4.1.3 Compute材质变体</h3><p>compute材质不支持变体切换。</p>
<h2 id="4-2-变体编译"><a href="#4-2-变体编译" class="headerlink" title="4.2 变体编译"></a>4.2 变体编译</h2><ol>
<li><strong>计算所有有效变体组合</strong></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Generate all shaders and write the shader chunks.</span><br><span class="line"></span><br><span class="line">std::vector&lt;Variant&gt; variants;</span><br><span class="line">switch (mMaterialDomain) {</span><br><span class="line">    case MaterialDomain::SURFACE:</span><br><span class="line">        variants = determineSurfaceVariants(mVariantFilter, isLit(), mShadowMultiplier);</span><br><span class="line">        break;</span><br><span class="line">    case MaterialDomain::POST_PROCESS:</span><br><span class="line">        variants = determinePostProcessVariants();</span><br><span class="line">        break;</span><br><span class="line">    case MaterialDomain::COMPUTE:</span><br><span class="line">        variants = determineComputeVariants();</span><br><span class="line">        break;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>determineSurfaceVariants函数是跟Variant类的定义，遍历出所有有效的顶点变体和片元变体。determinePostProcessVariants则是返回2个固定的顶点和片元变体。determineComputeVariants返回默认的一个0变体。</p>
<ol>
<li><strong>根据变体组合生成宏定义</strong><br>材质编译工具的代码生成类ShaderGenerator里面有一个generateSurfaceMaterialVariantDefines函数，该函数会根据变体组合variant来生成对应的宏定义。其部分代码如下：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void ShaderGenerator::generateSurfaceMaterialVariantDefines(utils::io::sstream&amp; out,</span><br><span class="line">        ShaderStage stage, MaterialBuilder::FeatureLevel featureLevel,</span><br><span class="line">        MaterialInfo const&amp; material, filament::Variant variant) noexcept {</span><br><span class="line"></span><br><span class="line">    bool const litVariants = material.isLit || material.hasShadowMultiplier;</span><br><span class="line"></span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_DIRECTIONAL_LIGHTING",</span><br><span class="line">            litVariants &amp;&amp; variant.hasDirectionalLighting());</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_DYNAMIC_LIGHTING",</span><br><span class="line">            litVariants &amp;&amp; variant.hasDynamicLighting());</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_SHADOWING",</span><br><span class="line">            litVariants &amp;&amp; filament::Variant::isShadowReceiverVariant(variant));</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_VSM",</span><br><span class="line">            filament::Variant::isVSMVariant(variant));</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_STEREO",</span><br><span class="line">            hasStereo(variant, featureLevel));</span><br><span class="line"></span><br><span class="line">    switch (stage) {</span><br><span class="line">        case ShaderStage::VERTEX:</span><br><span class="line">        CodeGenerator::generateDefine(out, "VARIANT_HAS_SKINNING_OR_MORPHING",</span><br><span class="line">                hasSkinningOrMorphing(variant, featureLevel));</span><br><span class="line">            break;</span><br><span class="line">        case ShaderStage::FRAGMENT:</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_FOG",</span><br><span class="line">                    filament::Variant::isFogVariant(variant));</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_PICKING",</span><br><span class="line">                    filament::Variant::isPickingVariant(variant));</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_SSR",</span><br><span class="line">                    filament::Variant::isSSRVariant(variant));</span><br><span class="line">            break;</span><br><span class="line">        case ShaderStage::COMPUTE:</span><br><span class="line">            break;</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>所有的宏定义组合就对应一个变体组合的program。</p>
<h2 id="4-3-变体切换"><a href="#4-3-变体切换" class="headerlink" title="4.3 变体切换"></a>4.3 变体切换</h2><p>变体编译阶段是根据材质类型、Stage（顶点/片元）、变体组合来生成对应的program的。因此，变体切换阶段，也是根据这些信息查找出对应的program代码。然后，使用这个代码（比如SPIR-V中间代码）来创建gpu program。<br>部分关键代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void FMaterial::prepareProgramSlow(Variant variant,</span><br><span class="line">        backend::CompilerPriorityQueue priorityQueue) const noexcept {</span><br><span class="line">    assert_invariant(mEngine.hasFeatureLevel(mFeatureLevel));</span><br><span class="line">    switch (getMaterialDomain()) {</span><br><span class="line">        case MaterialDomain::SURFACE:</span><br><span class="line">            getSurfaceProgramSlow(variant, priorityQueue);</span><br><span class="line">            break;</span><br><span class="line">        case MaterialDomain::POST_PROCESS:</span><br><span class="line">            getPostProcessProgramSlow(variant, priorityQueue);</span><br><span class="line">            break;</span><br><span class="line">        case MaterialDomain::COMPUTE:</span><br><span class="line">            // TODO: implement MaterialDomain::COMPUTE</span><br><span class="line">            break;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool MaterialChunk::getBinaryShader(BlobDictionary const&amp; dictionary,</span><br><span class="line">        ShaderContent&amp; shaderContent, ShaderModel shaderModel, filament::Variant variant, ShaderStage shaderStage) {</span><br><span class="line"></span><br><span class="line">    if (mBase == nullptr) {</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    uint32_t key = makeKey(shaderModel, variant, shaderStage);</span><br><span class="line">    auto pos = mOffsets.find(key);</span><br><span class="line">    if (pos == mOffsets.end()) {</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shaderContent = dictionary[pos-&gt;second];</span><br><span class="line">    return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>getSurfaceProgramSlow最终会调用到MaterialChunk::getBinaryShader从二进制材质数据中查找出指定变体的二进制代码。makeKey函数的参数是shaderModel（平台）、variant、shaderStage，这个key就是变体查找的键值。</p>
<h2 id="4-4-变体使用"><a href="#4-4-变体使用" class="headerlink" title="4.4 变体使用"></a>4.4 变体使用</h2><p>filament的变体使用方式分为三步：</p>
<ol>
<li><strong>计算变体组合</strong><br>这一步通常是渲染管线或者渲染Pass在计算。比如，ColorPass或者DepthPass、PickingPass等。</li>
<li><strong>prepareProgram</strong><br>使用第一步计算出的变体调用材质函数的prepareProgram以准备变体。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void prepareProgram(Variant variant,</span><br><span class="line">        backend::CompilerPriorityQueue priorityQueue = CompilerPriorityQueue::HIGH) const noexcept {</span><br><span class="line">    if (UTILS_UNLIKELY(!isCached(variant))) {</span><br><span class="line">        prepareProgramSlow(variant, priorityQueue);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>getProgram</strong><br>使用第一步计算出的变体调用材质函数的getProgram获得对应变体的program的handle。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backend::Handle&lt;backend::HwProgram&gt; getProgram(Variant variant) const noexcept {</span><br><span class="line">    assert_invariant(mCachedPrograms[variant.key]);</span><br><span class="line">    return mCachedPrograms[variant.key];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pipeline.program = ma-&gt;getProgram(info.materialVariant);</span><br></pre></td></tr></tbody></table></figure>
<p>然后将获得的program赋值给pipeline的program。</p>
<h2 id="4-5-再谈SpecializationConstants变体"><a href="#4-5-再谈SpecializationConstants变体" class="headerlink" title="4.5 再谈SpecializationConstants变体"></a>4.5 再谈SpecializationConstants变体</h2><h3 id="4-5-1-filament变体的问题"><a href="#4-5-1-filament变体的问题" class="headerlink" title="4.5.1 filament变体的问题"></a>4.5.1 filament变体的问题</h3><p>根据前述变体使用的步骤，在使用filament的变体时候并不方便。</p>
<pre><code>1. 首先，变体设置是需要在外部计算的。
2. 其次，变体设置并没有保存在材质实例内，反而需要外部代码保存。
3.从使用角度上来说，应该在材质实例内保存其对应的variant，然后一个材质实例对应一个program才更方便理解。
</code></pre><h3 id="4-5-2-filament的SpecializationConstants变体问题"><a href="#4-5-2-filament的SpecializationConstants变体问题" class="headerlink" title="4.5.2 filament的SpecializationConstants变体问题"></a>4.5.2 filament的SpecializationConstants变体问题</h3><p>filament的specializationConstants变体也存在类似的问题。specializationConstants变体是通过传入设置数据给gpu program对象来生效的，而且specializationConstants变体的设置还存在在材质内。</p>
<h3 id="4-5-3-优化思路"><a href="#4-5-3-优化思路" class="headerlink" title="4.5.3 优化思路"></a>4.5.3 优化思路</h3><p>因此，比较好的优化方向是将variant和specializationConstants的状态都保存在材质实例内；然后，通过材质实例来从材质中获得不同的program和设置不同的specializationConstants数据。</p>
<h1 id="五-渲染数据的提交和绑定"><a href="#五-渲染数据的提交和绑定" class="headerlink" title="五. 渲染数据的提交和绑定"></a>五. 渲染数据的提交和绑定</h1><p>最后再来讲一讲渲染使用的数据提交和绑定。渲染数据一般指定是Buffer和Sampler，也包括其它一些特殊数据，比如SpecializationConstants和pushConstants。从作用范围上来区分，渲染数据一般能分为三个级别，渲染当前pass要使用的全局数据、当前使用材质的数据、当前drawcall对应的物体的数据。<br>DescriptorSet<br>首先，需要明确filament提交和绑定Buffer和Sampler数据的封装类DescriptorSet。filament通过该类提交和绑定Buffer和Sampler。因此，后续三个级别的数据提交都是通过对该类的封装进行。</p>
<h2 id="5-1-渲染Pass数据提交和绑定"><a href="#5-1-渲染Pass数据提交和绑定" class="headerlink" title="5.1 渲染Pass数据提交和绑定"></a>5.1 渲染Pass数据提交和绑定</h2><p>通常是封装一个Pass级别的数据提交类，比如ColorPassDescriptorSet、PostProcessDescriptorSet、SsrPassDescriptorSet。这些类里面有一个DescriptorSet对象用于真正的数据提交和绑定。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class PostProcessDescriptorSet {</span><br><span class="line">public:</span><br><span class="line">    explicit PostProcessDescriptorSet() noexcept;</span><br><span class="line"></span><br><span class="line">    void init(FEngine&amp; engine) noexcept;</span><br><span class="line"></span><br><span class="line">    void terminate(HwDescriptorSetLayoutFactory&amp; factory, backend::DriverApi&amp; driver);</span><br><span class="line"></span><br><span class="line">    void setFrameUniforms(backend::DriverApi&amp; driver,</span><br><span class="line">            TypedUniformBuffer&lt;PerViewUib&gt;&amp; uniforms) noexcept;</span><br><span class="line"></span><br><span class="line">    void bind(backend::DriverApi&amp; driver) noexcept;</span><br><span class="line"></span><br><span class="line">    DescriptorSetLayout const&amp; getLayout() const noexcept {</span><br><span class="line">        return mDescriptorSetLayout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DescriptorSetLayout mDescriptorSetLayout;</span><br><span class="line">    DescriptorSet mDescriptorSet;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void PostProcessManager::setFrameUniforms(backend::DriverApi&amp; driver,</span><br><span class="line">        TypedUniformBuffer&lt;PerViewUib&gt;&amp; uniforms) noexcept {</span><br><span class="line">    mPostProcessDescriptorSet.setFrameUniforms(driver, uniforms);</span><br><span class="line">    mSsrPassDescriptorSet.setFrameUniforms(uniforms);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void PostProcessManager::bindPostProcessDescriptorSet(backend::DriverApi&amp; driver) const noexcept {</span><br><span class="line">    mPostProcessDescriptorSet.bind(driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>后处理Pass会在适当的时候调用相关函数进行数据提交和绑定，一般是在Pass的最开始进行设置。<br>实际上，一些数据是全局的，可以一次设置后不用改变。所以，Pass级别的数据不一定完全遵守Pass级别的作用域。比如，PostProcessDescriptorSet的setFrameUniforms实际上是在renderJob一开始就调用了，如下代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void FRenderer::renderJob(RootArenaScope&amp; rootArenaScope, FView&amp; view) {</span><br><span class="line">    FEngine&amp; engine = mEngine;</span><br><span class="line">    JobSystem&amp; js = engine.getJobSystem();</span><br><span class="line">    FEngine::DriverApi&amp; driver = engine.getDriverApi();</span><br><span class="line">    PostProcessManager&amp; ppm = engine.getPostProcessManager();</span><br><span class="line">    ppm.setFrameUniforms(driver, view.getFrameUniforms());</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-2-材质数据提交和绑定"><a href="#5-2-材质数据提交和绑定" class="headerlink" title="5.2 材质数据提交和绑定"></a>5.2 材质数据提交和绑定</h2><p>所有的渲染Pass都必须使用材质，渲染物体的Pass需要切换材质，后处理Pass则是使用一个材质。材质数据的使用也是需要有时机的。材质数据实际上会覆盖Pass级别的数据的设置，如果有重复的话；不过，按照filament的定义，这两部分数据是不会互相影响的，因为使用的是不同的DescriptorSetLayout。实际上，filament定义pipeline里面已经对PerView和PerMaterial的DescriptorSetLayout做了区分。PerView的layout就是前面所说的渲染Pass级别的数据。代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">struct PipelineLayout {</span><br><span class="line">    using SetLayout = std::array&lt;Handle&lt;HwDescriptorSetLayout&gt;, MAX_DESCRIPTOR_SET_COUNT&gt;;</span><br><span class="line">    SetLayout setLayout;      // 16</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct PipelineState {</span><br><span class="line">    Handle&lt;HwProgram&gt; program;                                              //  4</span><br><span class="line">    Handle&lt;HwVertexBufferInfo&gt; vertexBufferInfo;                            //  4</span><br><span class="line">    PipelineLayout pipelineLayout;                                          // 16</span><br><span class="line">    RasterState rasterState;                                                //  4</span><br><span class="line">    StencilState stencilState;                                              // 12</span><br><span class="line">    PolygonOffset polygonOffset;                                            //  8</span><br><span class="line">    PrimitiveType primitiveType = PrimitiveType::TRIANGLES;                 //  1</span><br><span class="line">    uint8_t padding[3] = {};                                                //  3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">static constexpr size_t MAX_DESCRIPTOR_SET_COUNT    = 4;    // This is guaranteed by Vulkan.</span><br><span class="line"></span><br><span class="line">enum class DescriptorSetBindingPoints : uint8_t {</span><br><span class="line">    PER_VIEW        = 0,</span><br><span class="line">    PER_RENDERABLE  = 1,</span><br><span class="line">    PER_MATERIAL    = 2,</span><br><span class="line">};</span><br><span class="line">在RenderPass执行时候渲染Command时候，给pipepline同时绑定PER_VIEW和PER_MATERIAL的layout。</span><br><span class="line">// Each material has its own version of the per-view descriptor-set layout,</span><br><span class="line">// because it depends on the material features (e.g. lit/unlit)</span><br><span class="line">pipeline.pipelineLayout.setLayout[+DescriptorSetBindingPoints::PER_VIEW] =</span><br><span class="line">        ma-&gt;getPerViewDescriptorSetLayout(info.materialVariant).getHandle();</span><br><span class="line"></span><br><span class="line">// Each material has a per-material descriptor-set layout which encodes the</span><br><span class="line">// material's parameters (ubo and samplers)</span><br><span class="line">pipeline.pipelineLayout.setLayout[+DescriptorSetBindingPoints::PER_MATERIAL] =</span><br><span class="line">        ma-&gt;getDescriptorSetLayout().getHandle();</span><br><span class="line">5.2.1 材质commit数据</span><br><span class="line">void FEngine::prepare() {</span><br><span class="line">    FEngine::DriverApi&amp; driver = getDriverApi();</span><br><span class="line"></span><br><span class="line">    for (auto&amp; materialInstanceList: mMaterialInstances) {</span><br><span class="line">        materialInstanceList.second.forEach([&amp;driver](FMaterialInstance* item) {</span><br><span class="line">            item-&gt;commit(driver);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void PostProcessManager::commitAndRenderFullScreenQuad(backend::DriverApi&amp; driver,</span><br><span class="line">        FrameGraphResources::RenderPassInfo const&amp; out, FMaterialInstance const* mi,</span><br><span class="line">        PostProcessVariant variant) const noexcept {</span><br><span class="line">    mi-&gt;commit(driver);</span><br><span class="line">    mi-&gt;use(driver);</span><br><span class="line">    FMaterial const* const ma = mi-&gt;getMaterial();</span><br><span class="line">    PipelineState const pipeline = getPipelineState(ma, variant);</span><br><span class="line"></span><br><span class="line">    assert_invariant(</span><br><span class="line">            ((out.params.readOnlyDepthStencil &amp; RenderPassParams::READONLY_DEPTH)</span><br><span class="line">             &amp;&amp; !pipeline.rasterState.depthWrite)</span><br><span class="line">            || !(out.params.readOnlyDepthStencil &amp; RenderPassParams::READONLY_DEPTH));</span><br><span class="line"></span><br><span class="line">    driver.beginRenderPass(out.target, out.params);</span><br><span class="line">    driver.draw(pipeline, mFullScreenQuadRph, 0, 3, 1);</span><br><span class="line">    driver.endRenderPass();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void FMaterialInstance::commit(DriverApi&amp; driver) const {</span><br><span class="line">    // update uniforms if needed</span><br><span class="line">    if (mUniforms.isDirty()) {</span><br><span class="line">        driver.updateBufferObject(mUbHandle, mUniforms.toBufferDescriptor(driver), 0);</span><br><span class="line">    }</span><br><span class="line">    // Commit descriptors if needed (e.g. when textures are updated,or the first time)</span><br><span class="line">    mDescriptorSet.commit(mMaterial-&gt;getDescriptorSetLayout(), driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>prepare是在FRenderer::beginFrame里面调用的，即每帧开始时候会提交所有的材质实例数据，实际上这里主要是非处理材质，后处理材质是在commitAndRenderFullScreenQuad内提交的。commit内做了两件事情，一个是更新UBO数据，一个是通过DescriptorSet进行commit。</p>
<h3 id="5-2-2-材质绑定数据"><a href="#5-2-2-材质绑定数据" class="headerlink" title="5.2.2 材质绑定数据"></a>5.2.2 材质绑定数据</h3><p>绑定材质数据是通过调用材质实例的use函数。材质绑定数据要在调用drawcall函数之前，比如renderpass里面就必须在执行每个command的drawcall前绑定，后处理这种Pass则需要在最终执行渲染drawcall之前绑定数据，可以参考commitAndRenderFullScreenQuad函数代码。下面代码段是RenderPass内绑定材质数据的代码：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (UTILS_UNLIKELY(mi != info.mi)) {</span><br><span class="line">    // this is always taken the first time</span><br><span class="line">    assert_invariant(info.mi);</span><br><span class="line"></span><br><span class="line">    mi = info.mi;</span><br><span class="line">    ...</span><br><span class="line">    // Each MaterialInstance has its own descriptor set. This binds it.</span><br><span class="line">    mi-&gt;use(driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>上述代码在RenderPass::Executor::execute内执行command的一段，可以看到在材质实例变化时候，会调用材质实例的use函数绑定不同的材质级别数据。</p>
<h2 id="5-3-Renderable数据提交和绑定"><a href="#5-3-Renderable数据提交和绑定" class="headerlink" title="5.3 Renderable数据提交和绑定"></a>5.3 Renderable数据提交和绑定</h2><p>同一个渲染Pass的Command，可以包括多个材质实例；同一个材质实例，可以渲染多个物体。因此，物体级别的数据优先级别是最高的。</p>
<h3 id="5-3-1-初始化Renderble数据"><a href="#5-3-1-初始化Renderble数据" class="headerlink" title="5.3.1 初始化Renderble数据"></a>5.3.1 初始化Renderble数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct PrimitiveInfo { // 56 bytes</span><br><span class="line">    union {</span><br><span class="line">        FMaterialInstance const* mi;</span><br><span class="line">        uint64_t padding; // make this field 64 bits on all platforms</span><br><span class="line">    };</span><br><span class="line">    backend::RenderPrimitiveHandle rph;                 // 4 bytes</span><br><span class="line">    backend::VertexBufferInfoHandle vbih;               // 4 bytes</span><br><span class="line">    backend::DescriptorSetHandle dsh;                   // 4 bytes</span><br><span class="line">    uint32_t indexOffset;                               // 4 bytes</span><br><span class="line">    uint32_t indexCount;                                // 4 bytes</span><br><span class="line">    uint32_t index = 0;                                 // 4 bytes</span><br><span class="line">    uint32_t skinningOffset = 0;                        // 4 bytes</span><br><span class="line">    uint32_t morphingOffset = 0;                        // 4 bytes</span><br><span class="line"></span><br><span class="line">    backend::RasterState rasterState;                   // 4 bytes</span><br><span class="line"></span><br><span class="line">    uint16_t instanceCount;                             // 2 bytes [MSb: user]</span><br><span class="line">    Variant materialVariant;                            // 1 byte</span><br><span class="line">    backend::PrimitiveType type : 3;                    // 1 byte       3 bits</span><br><span class="line">    bool hasSkinning : 1;                               //              1 bit</span><br><span class="line">    bool hasMorphing : 1;                               //              1 bit</span><br><span class="line">    bool hasHybridInstancing : 1;                       //              1 bit</span><br><span class="line"></span><br><span class="line">    uint32_t rfu[2];                                    // 16 bytes</span><br><span class="line">};</span><br><span class="line">static_assert(sizeof(PrimitiveInfo) == 56);</span><br><span class="line"></span><br><span class="line">struct alignas(8) Command {     // 64 bytes</span><br><span class="line">    CommandKey key = 0;         //  8 bytes</span><br><span class="line">    PrimitiveInfo info;    // 56 bytes</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如上代码，RenderPass内的Command定义内有一个图元信息结构PrimitiveInfo。该结构内有一个backend::DescriptorSetHandle成员dsh。dsh表示的就是Renderable级别的渲染数据。dsh是在RenderPass::generateCommandsImpl内通过场景数据FScene::RenderableSoa内的FScene::DESCRIPTOR_SET_HANDLE数据初始化的。</p>
<h3 id="5-3-2-绑定Renderble数据"><a href="#5-3-2-绑定Renderble数据" class="headerlink" title="5.3.2 绑定Renderble数据"></a>5.3.2 绑定Renderble数据</h3><p>在执行每个command的drawcall之前，会调用driver.bindDescriptorSet绑定Renderable级别的数据。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.bindDescriptorSet(info.dsh,</span><br><span class="line">        +DescriptorSetBindingPoints::PER_RENDERABLE,</span><br><span class="line">        {{ offset, info.skinningOffset }, driver});</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-4-其它数据"><a href="#5-4-其它数据" class="headerlink" title="5.4 其它数据"></a>5.4 其它数据</h2><h3 id="5-4-1-SpecializationConstants"><a href="#5-4-1-SpecializationConstants" class="headerlink" title="5.4.1 SpecializationConstants"></a>5.4.1 SpecializationConstants</h3><p>这部分之前提过，filament是通过切换变体时候，将材质内保存的constants设置数据传递给gpu program，也提到过这部分在实现上有一定的不合理。</p>
<h3 id="5-4-2-PushConstant"><a href="#5-4-2-PushConstant" class="headerlink" title="5.4.2 PushConstant"></a>5.4.2 PushConstant</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (UTILS_UNLIKELY(info.hasMorphing)) {</span><br><span class="line">    driver.setPushConstant(ShaderStage::VERTEX,</span><br><span class="line">            +PushConstantIds::MORPHING_BUFFER_OFFSET, int32_t(info.morphingOffset));</span><br><span class="line">}</span><br><span class="line">driver.draw2(info.indexOffset, info.indexCount, info.instanceCount);</span><br></pre></td></tr></tbody></table></figure>
<p>pushConstant数据则是在调用drawcall之前通过driver.setPushConstant传入driver。目前，filament只支持固定的pushConstants数据。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2024/06/20/%E6%B0%B4%E4%BD%93%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/20/%E6%B0%B4%E4%BD%93%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">水体效果模拟</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-20 15:20:22" itemprop="dateCreated datePublished" datetime="2024-06-20T15:20:22+08:00">2024-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2024/06/20/%E6%B0%B4%E4%BD%93%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" class="post-meta-item leancloud_visitors" data-flag-title="水体效果模拟" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/06/20/%E6%B0%B4%E4%BD%93%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/06/20/%E6%B0%B4%E4%BD%93%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="水体效果简介"><a href="#水体效果简介" class="headerlink" title="水体效果简介"></a>水体效果简介</h1><p>这里讲的是模拟水体效果的一系列技术点。主要包括，着色模型、水体颜色、法线模拟水面流动、FlowMap控制水面流动、深度、折射、反射、焦散、泡沫、假SSS模拟等。下面具体说明。</p>
<h1 id="着色模型"><a href="#着色模型" class="headerlink" title="着色模型"></a>着色模型</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterSurfaceOptions.png"><br>LightingMode有PBR、BlingPhong、None三种选项。默认使用PBR着色，可以为了极致的性能选择BlingPhong，甚至不着色直接输出albedo。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if defined(_PBR)</span><br><span class="line">        half4 color = UniversalFragmentPBR(inputData, surfaceData);</span><br><span class="line">#elif defined(_BLING_PHONG)</span><br><span class="line">        surfaceData.specular = lerp(_BlingPhongSpecColor.rgb, surfaceData.albedo, surfaceData.metallic);</span><br><span class="line">        half4 color = UniversalFragmentBlinnPhong(inputData, surfaceData);</span><br><span class="line">#else</span><br><span class="line">        half4 color = half4(surfaceData.albedo * surfaceData.occlusion, surfaceData.alpha);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到PBR的结果更加细腻，最明显的区别就是高光。PBR可能看到金黄色的高光，但是BlingPhong的高光需要调整。因此，使用了一个trick，额外提供了一个BlingPhong的高光颜色来近似，同时用金属度在高光颜色和albedo之间进行插值。<br>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水着色模型.gif"></p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>output内有两个选项，第一个是在最终渲染结果的a通道上叠加一个透明度，用于整体调整透明度；一个是缩放最终的着色结果，用于整体调亮调暗。<br>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水output.gif"></p>
<h1 id="水体颜色"><a href="#水体颜色" class="headerlink" title="水体颜色"></a>水体颜色</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterSurfaceInputs.png"><br>水体分为浅水颜色和深水颜色。浅水区域即靠近岸边的区域，深水区域即其它区域。那么怎么区分，浅水区域和深水区域了？使用水深，即使用水的深度差。这个深度差是使用水底的深度和水面的深度相减得到，具体实现在深度部分会具体讲述。<br>那么，最终的颜色即使用浅水颜色和深水颜色插值得到，过渡算法即是使用深度差进行smoothstep。具体代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half4 baseColor = lerp(_ShallowBaseColor, _DeepBaseColor, smoothstep(_WaterDepthAdd, _ShallowDepthCutOff + _WaterDepthAdd, _WaterDepthMultiple * sceneDeltaDepth));</span><br></pre></td></tr></tbody></table></figure>
<p>ShallowDepthCutOff用于控制浅水的范围。至于WaterDepthAdd、WaterDepthMultiple是额外提供的调整水深度范围的参数。<br>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水颜色.gif"><br>可以看到调整ShallowDepthCutOff可以扩大或者缩小浅水区域的范围。</p>
<h2 id="水体透明度"><a href="#水体透明度" class="headerlink" title="水体透明度"></a>水体透明度</h2><p>除去output对透明度的修改外，还有水体颜色的a通道对透明度的控制，比如浅水透明度更高，深水透明度更低，然后使用深度进行过渡。<br>更重要的是实现水体边缘的平滑过渡，否则水体边缘是硬边，无法做到与岸边的平滑融合。具体实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color.a *= max(0.0, smoothstep(-0.001, _TransparentDepthCutOff, sceneDeltaDepth) - _TransparentAdd);</span><br></pre></td></tr></tbody></table></figure>
<p>算法原理类似水体颜色过渡，使用深度差在-0.001（略小于0）和TransparentDepthCutOff之间进行smoothstep插值，然后乘到原始的透明度上。<br>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水边缘平滑.gif"></p>
<h1 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterDepthOptions.png"></p>
<h2 id="水面深度"><a href="#水面深度" class="headerlink" title="水面深度"></a>水面深度</h2><p>水面深度指的是当前着色的像素点深度，这里我们要计算从摄像机开始的线性深度，具体代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline float GetRealtimeWaterEyeDepth(float4 projection)</span><br><span class="line">{</span><br><span class="line">    float depth = projection.z / projection.w;</span><br><span class="line">    #if !UNITY_REVERSED_Z</span><br><span class="line">        depth = depth * 0.5 + 0.5;</span><br><span class="line">    #endif</span><br><span class="line">    return LinearEyeDepth(depth, _ZBufferParams);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">float waterDepth = GetRealtimeWaterEyeDepth(input.screenPos);</span><br></pre></td></tr></tbody></table></figure>
<p>对于性能敏感的场景，我们也可以使用一张离线的深度图。这种情况下可以假设使用正交模型，从顶往下离线渲染一张RT保存了深度图。如OfflineDepth的设置所示，需要一个摄像机原点和一个正交投影范围，根据这些信息，那么还原离线线性深度的代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline float GetOfflineWaterEyeDepth(float3 positionWS)</span><br><span class="line">{</span><br><span class="line">    float eyeDepth = _OfflineTextureWorldOrgin.y - positionWS.y;//离线相机从上往下拍摄</span><br><span class="line">    float n = _OfflineTextureCameraSettings.y;</span><br><span class="line">    float f =  _OfflineTextureCameraSettings.z;</span><br><span class="line"></span><br><span class="line">    eyeDepth = clamp(eyeDepth, n, f);</span><br><span class="line">    return eyeDepth;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">float waterDepth = GetOfflineWaterEyeDepth(input.positionWS);</span><br></pre></td></tr></tbody></table></figure>
<p>该函数实际上就是计算距离离线深度图相机的线性距离。</p>
<h2 id="水底深度"><a href="#水底深度" class="headerlink" title="水底深度"></a>水底深度</h2><p>同样分为实时和离线两种情况，实时深度需要从实时深度图读取深度再转换为线性深度；离线深度则是从离线深度图内读取深度，再根据正交投影信息转换为线性深度。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">inline float2 GetOfflineWorldUV(float3 positionWS)</span><br><span class="line">{</span><br><span class="line">    return (positionWS.xz - (_OfflineTextureWorldOrgin.xz - _OfflineTextureCameraSettings.xx)) / (2 * _OfflineTextureCameraSettings.xx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">inline float GetSceneEyeDepth(float2 uv)</span><br><span class="line">{</span><br><span class="line">#if _REALTIME_DEPTH_MAP</span><br><span class="line">    float depth = SampleSceneDepth(uv);</span><br><span class="line">    depth = LinearEyeDepth(depth, _ZBufferParams);</span><br><span class="line">#else</span><br><span class="line">    float depth = SAMPLE_TEXTURE2D_X(_OfflineDepthMap, sampler_OfflineDepthMap, uv).r;//offline tool has fixed UNITY_REVERSED_Z</span><br><span class="line">    float n = _OfflineTextureCameraSettings.y;</span><br><span class="line">    float f = _OfflineTextureCameraSettings.z;</span><br><span class="line">    depth = n + (f - n) * depth;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return depth;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#if _REALTIME_DEPTH_MAP</span><br><span class="line">	float sceneDepth = GetSceneEyeDepth(screenUV);</span><br><span class="line">#else</span><br><span class="line">	float sceneDepth = GetSceneEyeDepth(offlineWorldUV);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<p>当然，实时深度必须开启<strong>渲染管线的深度图</strong>设置。</p>
<h2 id="归一化深度差"><a href="#归一化深度差" class="headerlink" title="归一化深度差"></a>归一化深度差</h2><p>上面2个步骤的水底深度减去水面深度，得到的就是深度差，然后用这个深度除以最大深度差得到的就是归一化的深度差。具体代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float sceneDeltaDepth = max((sceneDepth - waterDepth) / _MaxWaterDepthDiff, 0.0);</span><br></pre></td></tr></tbody></table></figure>
<p>注意，MaxWaterDepthDiff是一个可调节的参数，用户可以方便控制最大的水深（可以超过或者小于实际的最大水深），这样可以整体调整整个水体的深度。</p>
<h2 id="归一化深度差的用途"><a href="#归一化深度差的用途" class="headerlink" title="归一化深度差的用途"></a>归一化深度差的用途</h2><p>比如，前面说到的浅水区域和深水区域定义和过渡、水体边缘平滑过渡等。以及后续的焦散、泡沫等效果，也可以用深度差控制显示范围。</p>
<h1 id="法线模拟水面流动"><a href="#法线模拟水面流动" class="headerlink" title="法线模拟水面流动"></a>法线模拟水面流动</h1><p>我们知道水面是流动的，要模拟流动主要有两种方式，一种是顶点动画，一种是在片元内移动法线。顶点动画比较适合模拟海浪，性能消耗比较大。这里，我们使用的是法线来模拟水面的流动。<br>SurfaceInputs内有一张法线输入，以及2个法线的ScaleSpeed；按照不同的移动速度采用出2个法线值，然后进行BlendNormal，作为最终的法线。<br>具体代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float2 baseNormalUV = TRANSFORM_TEX(uv, _NormalMap);</span><br><span class="line">UVPanner1 = _Time.y * 0.1f * _NormalScaleSpeed1.yz;</span><br><span class="line">UVPanner2 = _Time.y * 0.1f * _NormalScaleSpeed2.yz;</span><br><span class="line"></span><br><span class="line">half4 normalColor1 = SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, baseNormalUV + UVPanner1);</span><br><span class="line">half4 normalColor2 = SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, baseNormalUV + UVPanner2);</span><br><span class="line"></span><br><span class="line">half3 normalTS1 = UnpackNormalScale(normalColor1, _NormalScaleSpeed1.x);</span><br><span class="line">half3 normalTS2 = UnpackNormalScale(normalColor2, _NormalScaleSpeed2.x);</span><br><span class="line"></span><br><span class="line">outSurfaceData.normalTS = BlendNormal(normalTS1, normalTS2);</span><br></pre></td></tr></tbody></table></figure>
<p>至于BlendNormal的实现，CommonMaterial.hlsl内具体代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// assume compositing in tangent space</span><br><span class="line">real3 BlendNormal(real3 n1, real3 n2)</span><br><span class="line">{</span><br><span class="line">    return normalize(real3(n1.xy * n2.z + n2.xy * n1.z, n1.z * n2.z));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以参考文章：<a href="https://zhuanlan.zhihu.com/p/364821684">Normal Blend方法总结</a>的Partial Derivative Blending部分。</p>
<h1 id="FlowMap控制水面流动"><a href="#FlowMap控制水面流动" class="headerlink" title="FlowMap控制水面流动"></a>FlowMap控制水面流动</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterFlowMapOptions.png"><br>上面我们实现了水面流动的模拟，但是有时候我们需要用贴图来控制水面的整体流动方向，这个时候就需要一种叫做FlowMap的技术。FlowMap实际上是一张记录了2D向量场的纹理，我们可以从这张图里面读取1个flowDir表示UV的移动方向；另外需要计算一个phase，用于表示当前的相位，结合flowDir可以获得2个UV；最后，用这个2个UV采用法线贴图，再进行插值即可。注意，插值算法也要依赖phase。详细的解释和FlowMap的应用可以参考文章：<a href="https://zhuanlan.zhihu.com/p/660311527">FlowMap技术介绍 和 案例展示</a>。</p>
<p>具体代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float2 baseNormalUV = TRANSFORM_TEX(uv, _NormalMap);</span><br><span class="line"></span><br><span class="line">float2 flowDir = (SAMPLE_TEXTURE2D(_FlowMap, sampler_FlowMap, uv).rg * 2.0f - 1.0f) * (-_FlowDirSpeed);</span><br><span class="line">float phase0 = frac(_Time.y * _FlowTimeSpeed);</span><br><span class="line">float phase1 = frac(_Time.y * _FlowTimeSpeed + 0.5f);</span><br><span class="line">UVPanner1 = flowDir * phase0;</span><br><span class="line">UVPanner2 = flowDir * phase1;</span><br><span class="line"></span><br><span class="line">half4 normalColor1 = SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, baseNormalUV + UVPanner1);</span><br><span class="line">half4 normalColor2 = SAMPLE_TEXTURE2D(_NormalMap, sampler_NormalMap, baseNormalUV + UVPanner2);</span><br><span class="line"></span><br><span class="line">flowLerp = abs(phase0 - 0.5f) / 0.5f;</span><br><span class="line">half4 normalColor = lerp(normalColor1, normalColor2, flowLerp);</span><br><span class="line">outSurfaceData.normalTS = UnpackNormalScale(normalColor, _FlowNormalScale);</span><br></pre></td></tr></tbody></table></figure>
<p>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水flowmap.gif"><br>可以看到激活FlowMap后，水体流向会按照这张2D向量场贴图的方向流动。</p>
<h1 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterRefractionOptions.png"><br>类似于深度的计算，同样有实时折射和离线折射两种方式。实时折射需要渲染管线开启颜色贴图，而离线折射则需要使用工具预先生成一张颜色贴图，类似于离线深度，这里同样使用自顶向下的离线相机拍摄一张离线颜色贴图。<br>具体代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline half3 GetRefractionColor(float2 uv, float2 noise, float sceneDeltaDepth)</span><br><span class="line">{</span><br><span class="line">    half weight = saturate(1 - smoothstep(_WaterDepthAdd, _RefractionDepthCutOff + _WaterDepthAdd, sceneDeltaDepth));</span><br><span class="line">    uv += noise * _RefractionNoiseIntensity * 0.1;</span><br><span class="line"></span><br><span class="line">#if _REALTIME_REFRACTION</span><br><span class="line">    half3 sceneColor = SampleSceneColor(uv).rgb;</span><br><span class="line">#else</span><br><span class="line">    half3 sceneColor = SAMPLE_TEXTURE2D_LOD(_OfflineRefractionMap, sampler_OfflineRefractionMap, uv, sceneDeltaDepth * 10 * _OfflineRefractionLodMultiple).rgb;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return weight * sceneColor * _RefractionColor * _RefractionIntensity;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#if _REALTIME_REFRACTION</span><br><span class="line">	refractColor = GetRefractionColor(screenUV, inputData.normalWS.xz, sceneDeltaDepth);</span><br><span class="line">#elif _OFFLINE_REFRACTION</span><br><span class="line">	refractColor = GetRefractionColor(offlineWorldUV, inputData.normalWS.xz, sceneDeltaDepth);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实时折射"><a href="#实时折射" class="headerlink" title="实时折射"></a>实时折射</h2><p>从上述代码可以看到，实时折射需要调用SampleSceneColor采样实时的颜色贴图，采样左边是屏幕空间uv。</p>
<h2 id="离线折射"><a href="#离线折射" class="headerlink" title="离线折射"></a>离线折射</h2><p>而离线折射，从一张OfflineRefractionMap内采样颜色信息，同时提供了贴图LOD控制。</p>
<h2 id="叠加折射"><a href="#叠加折射" class="headerlink" title="叠加折射"></a>叠加折射</h2><p>折射颜色与反射颜色是通过菲涅尔算法插值后，再叠加到最终的着色结果上。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline half CalculateFresnelTerm(half3 normalWS, half3 viewDirectionWS)</span><br><span class="line">{</span><br><span class="line">    return 1.0 - dot(normalWS, viewDirectionWS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">half fresnelTerm = CalculateFresnelTerm(inputData.normalWS, inputData.viewDirectionWS);</span><br><span class="line"></span><br><span class="line">color.rgb += lerp(refractColor, reflectColor, fresnelTerm);</span><br></pre></td></tr></tbody></table></figure>
<p>这里的Fresnel使用了最简单的计算法线与视线夹角的实现。</p>
<h2 id="具体效果"><a href="#具体效果" class="headerlink" title="具体效果"></a>具体效果</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水折射.gif"><br>由于水是半透明的，不开启折射也能一定程度上看到水底的效果。因此，默认情况下，不开启折射以节省性能。切换到离线折射时候，由于没有设置贴图，默认是白色贴图会导致整体变凉。实时折射情况下，调整折射噪声的强度可以看到一定程度的水底扭曲。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterReflectionOptions.png"><br>反射通常指的是反射周围环境的效果，由于一般水体面积很大，不需要精准反应反射物体的位置，因此不需要实时镜面反射。比较合适的方式是使用Cubemap或者反射探针反射。</p>
<h2 id="Cubemap反射"><a href="#Cubemap反射" class="headerlink" title="Cubemap反射"></a>Cubemap反射</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline half3 GetCubemapReflection(half3 reflectVector)</span><br><span class="line">{</span><br><span class="line">#if _CUBEMAP_REFLECTION</span><br><span class="line">    return SAMPLE_TEXTURECUBE_LOD(_ReflectionCubeMap, sampler_ReflectionCubeMap, reflectVector, _ReflectionCubemapLod).rgb * _ReflectionCubemapColor * _ReflectionCubemapIntensity;</span><br><span class="line">#else</span><br><span class="line">    return half3(0, 0, 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Cubemap即显式指定一张固定的Cubemap，从这张图采样作为反射信息，同时支持指定贴图LOD。</p>
<h2 id="Probe反射"><a href="#Probe反射" class="headerlink" title="Probe反射"></a>Probe反射</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline half3 GetProbeReflection(half3 reflectVector, float3 positionWS, half smoothness, half occlusion)</span><br><span class="line">{</span><br><span class="line">#if _PROBE_REFLECTION</span><br><span class="line">    reflectVector = BoxProjectedCubemapDirection(reflectVector, positionWS, unity_SpecCube0_ProbePosition, unity_SpecCube0_BoxMin, unity_SpecCube0_BoxMax);</span><br><span class="line">    half mip = PerceptualRoughnessToMipmapLevel(PerceptualSmoothnessToPerceptualRoughness(smoothness));</span><br><span class="line">    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);</span><br><span class="line"></span><br><span class="line">#if defined(UNITY_USE_NATIVE_HDR)</span><br><span class="line">    half3 irradiance = encodedIrradiance.rgb;</span><br><span class="line">#else</span><br><span class="line">    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return irradiance * occlusion * _ProbeReflectionColor * _ProbeReflectionIntensity;</span><br><span class="line">#else</span><br><span class="line">    return _GlossyEnvironmentColor.rgb * occlusion;</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>该函数实际上还是采样一个引擎内置的Cubemap：unity_SpecCube0。同时，新增了BoxProjectedCubemapDirection支持，该函数使用世界空间位置和Cubemap的位置、范围对反射方向进行了校正，该算法同样可以迁移到普通的Cubemap上。urp管线内BoxProjectedCubemapDirection的实现如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">half3 BoxProjectedCubemapDirection(half3 reflectionWS, float3 positionWS, float4 cubemapPositionWS, float4 boxMin, float4 boxMax)</span><br><span class="line">{</span><br><span class="line">    // Is this probe using box projection?</span><br><span class="line">    if (cubemapPositionWS.w &gt; 0.0f)</span><br><span class="line">    {</span><br><span class="line">        float3 boxMinMax = (reflectionWS &gt; 0.0f) ? boxMax.xyz : boxMin.xyz;</span><br><span class="line">        half3 rbMinMax = half3(boxMinMax - positionWS) / reflectionWS;</span><br><span class="line"></span><br><span class="line">        half fa = half(min(min(rbMinMax.x, rbMinMax.y), rbMinMax.z));</span><br><span class="line"></span><br><span class="line">        half3 worldPos = half3(positionWS - cubemapPositionWS.xyz);</span><br><span class="line"></span><br><span class="line">        half3 result = worldPos + reflectionWS * fa;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        return reflectionWS;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>具体算法描述可以参考文章：<a href="https://blog.csdn.net/zengjunjie59/article/details/111884969">BoxProjectedCubemapDirection—镜面反射中的盒型投影函数</a>。</p>
<h2 id="具体效果-1"><a href="#具体效果-1" class="headerlink" title="具体效果"></a>具体效果</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水反射.gif"><br>可以看到切换到实时反射后，水面能够显示出天空盒的颜色。</p>
<h1 id="焦散"><a href="#焦散" class="headerlink" title="焦散"></a>焦散</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterCausticsOptions.png"><br>焦散用于模拟水底的焦散现象。实现焦散效果需要一张焦散模式的贴图，采样这张贴图的结果和折射效果进行结合。<br>实现的难点在于如何让焦散看起来在水底，而不是漂浮在水面。这可以使用水底的世界坐标xz分量去采样焦散贴图，这样焦散的效果与水底的世界空间位置就强关联，看起来与水面就会分离。<br>另外，焦散贴图采样时候需要往相反方向采样两次，再取两次采样的最大值作为焦散强度。这样做是为了实现焦散的来回抖动效果，如果只采样一次就是规律性移动。<br>具体代码：<br></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">inline half3 <span class="title class_">GetCausticColor</span>(float2 uv, float sceneDeltaDepth)</span><br><span class="line">{</span><br><span class="line">#<span class="keyword">if</span> _CAUSTICS</span><br><span class="line">    uv = <span class="title function_">TRANSFORM_TEX</span>(uv, _CausticsMaskMap);</span><br><span class="line">    half weight = <span class="title function_">saturate</span>(<span class="number">1</span> - <span class="title function_">smoothstep</span>(_WaterDepthAdd, _CausticsDepthCutOff + _WaterDepthAdd, sceneDeltaDepth));</span><br><span class="line">    half3 causticsMask1 = <span class="title function_">SAMPLE_TEXTURE2D</span>(_CausticsMaskMap, sampler_CausticsMaskMap, uv + _Time.<span class="property">y</span> * _CausticsSpeed * <span class="number">0.1</span>).<span class="property">rgb</span>;</span><br><span class="line">    half3 causticsMask2 = <span class="title function_">SAMPLE_TEXTURE2D</span>(_CausticsMaskMap, sampler_CausticsMaskMap, uv - _Time.<span class="property">y</span> * _CausticsSpeed * <span class="number">0.1</span>).<span class="property">rgb</span>;</span><br><span class="line">    <span class="keyword">return</span> weight * _CausticsColor * _CausticsIntensity * <span class="title function_">min</span>(causticsMask1, causticsMask2) * <span class="number">10</span>;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">half3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> _CAUSTICS</span><br><span class="line">	float2 causticsUV = input.<span class="property">uvAndFogAtten</span>.<span class="property">xy</span>;</span><br><span class="line">	#<span class="keyword">if</span> _REALTIME_DEPTH_MAP</span><br><span class="line">		#<span class="keyword">if</span> <span class="variable constant_">UNITY_REVERSED_Z</span></span><br><span class="line">			float deviceDepth = <span class="title function_">SAMPLE_TEXTURE2D_X</span>(_CameraDepthTexture, sampler_PointClamp, screenUV + inputData.<span class="property">normalWS</span>.<span class="property">xz</span> * <span class="number">0.01</span>).<span class="property">r</span>;</span><br><span class="line">	#<span class="keyword">else</span></span><br><span class="line">		float deviceDepth = <span class="title function_">SAMPLE_TEXTURE2D_X</span>(_CameraDepthTexture, sampler_PointClamp, screenUV + inputData.<span class="property">normalWS</span>.<span class="property">xz</span> * <span class="number">0.01</span>).<span class="property">r</span>;</span><br><span class="line">		deviceDepth = deviceDepth * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">	#endif</span><br><span class="line">		causticsUV = <span class="title class_">ComputeWorldSpacePosition</span>(screenUV + inputData.<span class="property">normalWS</span>.<span class="property">xz</span> * <span class="number">0.01</span>, deviceDepth, unity_MatrixInvVP).<span class="property">xz</span>;</span><br><span class="line">	#endif</span><br><span class="line">	refractColor += <span class="title function_">lerp</span>(<span class="number">1</span>, refractColor, _CausticsRefractWeight) * <span class="title class_">GetCausticColor</span>(causticsUV, sceneDeltaDepth);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure><br>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水焦散.gif"><p></p>
<h1 id="泡沫"><a href="#泡沫" class="headerlink" title="泡沫"></a>泡沫</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/FoamOptions.png"><br>这个效果是模拟水面的边缘部分的泡沫流动现象。主要包括泡沫的着色以及泡沫的流动，因此需要一张表示泡沫的贴图。比如下面这张贴图的g通道。<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/Foam1.png"><br>实现泡沫的流动类似云阴影的实现，泡沫本身的流动以及泡沫的边缘流动，方法是按照不同的速率采样泡沫贴图两次，然后使用PS的线性加深模式进行叠加即可。<br>具体代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inline half3 GetFoamColor(float2 uv, float2 UVPanner1, float2 UVPanner2, float flowLerp, float sceneDeltaDepth)</span><br><span class="line">{</span><br><span class="line">#if _FOAM</span><br><span class="line">    uv = TRANSFORM_TEX(uv, _FoamMap);</span><br><span class="line">    half weight = 1 - smoothstep(_WaterDepthAdd, _FoamDepthCutOff + _WaterDepthAdd, sceneDeltaDepth);</span><br><span class="line">    half foamWeight1 = SAMPLE_TEXTURE2D(_FoamMap, sampler_FoamMap, uv + UVPanner1 * _FoamSpeed1).g;</span><br><span class="line">    half foamWeight2 = SAMPLE_TEXTURE2D(_FoamMap, sampler_FoamMap, uv + UVPanner2 * _FoamSpeed2).g;</span><br><span class="line">    half foamWeight = saturate(2 * foamWeight1 + foamWeight2 - 1);</span><br><span class="line"></span><br><span class="line">    return _FoamColor * weight * foamWeight * _FoamIntensity;</span><br><span class="line">#else</span><br><span class="line">    return half3(0, 0, 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#if _FOAM</span><br><span class="line">	color.rgb += GetFoamColor(input.uvAndFogAtten.xy, UVPanner1, UVPanner2, flowLerp, sceneDeltaDepth);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<p>最后将泡沫颜色叠加到渲染结果上即可。<br>具体效果：</p>
<h1 id="假SSS模拟"><a href="#假SSS模拟" class="headerlink" title="假SSS模拟"></a>假SSS模拟</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/WaterSSSOptions.png"><br>这个是对SSS的简单模拟。实现算法比较简单，根据光照方向做一定偏移作为SSS的方向，然后计算SSS方向与视线方向的夹角，以这个夹角作为因子来计算额外的SSS光强度，叠加到最终的渲染上。<br>具体代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline half3 GetSSSColor(Light light, half3 viewDirectionWS, half3 normalWS, float sceneDeltaDepth)</span><br><span class="line">{</span><br><span class="line">#if _SSS</span><br><span class="line">    half3 sssLightDirection = normalize(light.direction + normalWS * _SSSLightDistortion);</span><br><span class="line">    half sss = pow(saturate(dot(viewDirectionWS, sssLightDirection)), _SSSLightPower) * _SSSLightIntensity;</span><br><span class="line">    half weight = 1 - smoothstep(_WaterDepthAdd, _SSSLighDepthCutOff + _WaterDepthAdd, sceneDeltaDepth);</span><br><span class="line"></span><br><span class="line">    return _SSSColor * light.color * sss * weight;</span><br><span class="line">#else</span><br><span class="line">    return half3(0, 0, 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#if _SSS</span><br><span class="line">	color.rgb += GetSSSColor(GetMainLight(), inputData.viewDirectionWS, inputData.normalWS, sceneDeltaDepth);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<p>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水SSS.gif"></p>
<h1 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/水整体效果.gif"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/364821684">Normal Blend方法总结</a><br><a href="https://zhuanlan.zhihu.com/p/660311527">FlowMap技术介绍 和 案例展示</a><br><a href="https://blog.csdn.net/zengjunjie59/article/details/111884969">BoxProjectedCubemapDirection—镜面反射中的盒型投影函数</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2023/05/24/%E5%81%87%E4%BA%91%E9%98%B4%E5%BD%B1%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/24/%E5%81%87%E4%BA%91%E9%98%B4%E5%BD%B1%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">假云阴影模拟</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-24 16:20:22" itemprop="dateCreated datePublished" datetime="2023-05-24T16:20:22+08:00">2023-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2023/05/24/%E5%81%87%E4%BA%91%E9%98%B4%E5%BD%B1%E6%A8%A1%E6%8B%9F/" class="post-meta-item leancloud_visitors" data-flag-title="假云阴影模拟" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/05/24/%E5%81%87%E4%BA%91%E9%98%B4%E5%BD%B1%E6%A8%A1%E6%8B%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/05/24/%E5%81%87%E4%BA%91%E9%98%B4%E5%BD%B1%E6%A8%A1%E6%8B%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="云阴影效果简介"><a href="#云阴影效果简介" class="headerlink" title="云阴影效果简介"></a>云阴影效果简介</h1><p>这里说的云阴影，是使用噪声图或者特定规律的随机图模拟的假云阴影。效果类似于大片云投影在大地上，同时阴影按照一定速度移动和随机流动变化，并且支持双层阴影叠加。效果如下：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/云阴影.gif"></p>
<h1 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/云阴影参数.png"></p>
<h2 id="全局云阴影开关"><a href="#全局云阴影开关" class="headerlink" title="全局云阴影开关"></a>全局云阴影开关</h2><p>可以看到，有一个是否启用（Enable）的全局开关控制是否开启全局云阴影。这可以使用全局变体实现，由于全局变体无法剔除，容易引入变体爆炸问题。因此，最好使用材质局部变体替代。</p>
<h2 id="云阴影颜色"><a href="#云阴影颜色" class="headerlink" title="云阴影颜色"></a>云阴影颜色</h2><p>有一个全局的云阴影颜色用于调整整体的云阴影颜色，比如可以调出红色等特殊颜色的云阴影，默认是黑色。</p>
<h2 id="云阴影参数"><a href="#云阴影参数" class="headerlink" title="云阴影参数"></a>云阴影参数</h2><p>从参数设置可以看到，云阴影分为两层。每层有大小、强度、方向、速度以及噪声的强度、速度、tiling。噪声是为了模拟云阴影边缘的快速变化抖动效果。同时，需要一张云阴影贴图来控制这两层的参数；规定贴图的R、G通道是第一层阴影的强度和噪声的强度，B、A通道是第二层阴影的强度和噪声的强度。</p>
<h1 id="Shader或者材质参数"><a href="#Shader或者材质参数" class="headerlink" title="Shader或者材质参数"></a>Shader或者材质参数</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/云阴影材质参数.png"></p>
<h2 id="材质云阴影开关"><a href="#材质云阴影开关" class="headerlink" title="材质云阴影开关"></a>材质云阴影开关</h2><p>Shader上有专门的变体开关控制是否激活云阴影。这里针对的是当前材质的开关，使用local变体即可满足据要求。</p>
<h2 id="材质云阴影强度"><a href="#材质云阴影强度" class="headerlink" title="材质云阴影强度"></a>材质云阴影强度</h2><p>同时，有一个强度滑块控制该材质的云阴影强度。这样，可以定制不同材质接收到云阴影强度。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="修改albedo"><a href="#修改albedo" class="headerlink" title="修改albedo"></a>修改albedo</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#if _GLOBAL_CLOUD_SHADOW</span><br><span class="line">		surfaceData.albedo = ApplyGlobalCloudShadow修改(surfaceData.albedo, input.positionWS, _CloudShadowIntensity);</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<p>从上述代码可以看到，在开启变体_GLOBAL_CLOUD_SHADOW时候，使用函数ApplyGlobalCloudShadow修改albedo。</p>
<h2 id="计算CloudShadow"><a href="#计算CloudShadow" class="headerlink" title="计算CloudShadow"></a>计算CloudShadow</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inline half3 ApplyGlobalCloudShadow(half3 albedo, float3 positionWS, half intensity = 1.0f)</span><br><span class="line">{</span><br><span class="line">    half firstCloudShadowIntensity = GetFirstGlobalCloudShadowIntensity(positionWS);</span><br><span class="line">    half secondCloudShadowIntensity = GetSecondGlobalCloudShadowIntensity(positionWS);</span><br><span class="line"></span><br><span class="line">    albedo *= lerp(half3(1, 1, 1), _CloudShadowColor, intensity * max(firstCloudShadowIntensity, secondCloudShadowIntensity));</span><br><span class="line">    return albedo;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>函数ApplyGlobalCloudShadow首先计算两层云阴影强度，再使用max获得两层的最大强度（两层阴影叠加的位置取最大值）作为云阴影强度。</li>
<li>然后使用这个云阴影强度在白色与云阴影颜色之间进行插值获得最终的云阴影颜色。</li>
<li>最终，将该云阴影颜色乘到albedo上。</li>
</ol>
<h2 id="计算单层CloudShadow强度"><a href="#计算单层CloudShadow强度" class="headerlink" title="计算单层CloudShadow强度"></a>计算单层CloudShadow强度</h2><p>该函数代码比较关键，不再直接提供源码，有需要的可以理解后再自行实现。</p>
<ol>
<li>使用传入的positionWS计算出worldUV。</li>
<li>使用worldUV结合云阴影的大小、速度计算出云阴影的位置（cloudUV），然后使用cloudUV采用贴图的R通道获得云阴影强度。</li>
<li>使用worldUV结合云阴影噪声的速度、tiling计算出云阴影噪声的位置（cloudNoiseUV），然后使用cloudNoiseUV采用贴图的B通道获得云阴影噪声强度。</li>
<li>将云阴影强度和云阴影噪声强度进行叠加获得整体的云阴影强度。注意：叠加算法很关键，需要使用PS的线性加深模式。</li>
</ol>
<h1 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/云阴影整体.gif"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">玻璃效果和窗户室内效果模拟</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-18 14:20:22" itemprop="dateCreated datePublished" datetime="2023-03-18T14:20:22+08:00">2023-03-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" class="post-meta-item leancloud_visitors" data-flag-title="玻璃效果和窗户室内效果模拟" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、玻璃效果"><a href="#一、玻璃效果" class="headerlink" title="一、玻璃效果"></a>一、玻璃效果</h1><p>首先来讲如何模拟玻璃效果。玻璃的渲染包括三部分，普通场景物体的渲染、反射和折射模拟、毛玻璃模拟。作为场景物体，那么类似其它场景物体Shader一样，可以使用PBR、BlingPhong或者Matcap，甚至三阶色卡通渲染都可以。玻璃比较特殊的地方是模拟对环境的反射和折射，以及模拟玻璃污渍效果。<br>对于场景物体的基础着色部分不再赘述，下面来介绍环境反射和折射、玻璃污渍模拟部分。</p>
<h2 id="1-1-环境反射和折射"><a href="#1-1-环境反射和折射" class="headerlink" title="1.1 环境反射和折射"></a>1.1 环境反射和折射</h2><p>对于不要求实时反映环境变化的效果，那么采样静态贴图进行模拟，是一种性能和效果都更优的方式。从效果上来说，美术可以自由定制贴图，那么可以方便控制效果；从性能上来说，不要求实时blit出当前的colorbuffer，性能远超实时反射和折射。</p>
<h3 id="1-1-1-静态Cubemap模拟"><a href="#1-1-1-静态Cubemap模拟" class="headerlink" title="1.1.1 静态Cubemap模拟"></a>1.1.1 静态Cubemap模拟</h3><p>最常见的方式是使用Cubemap来模拟环境的反射和折射。</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ol>
<li>计算当前着色像素的反射方向。</li>
<li>使用反射方向去从Cubemap中采样出反射颜色</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 reflectVector = reflect(-inputData.viewDirectionWS, inputData.normalWS);</span><br><span class="line">half3 reflectColor = SAMPLE_TEXTURECUBE_LOD(_EnvironmentCubeMap, sampler_EnvironmentCubeMap, reflectVector, _EnvironmentCubemapLod).rgb * _EnvironmentReflectionColor * _EnvironmentReflectionIntensity;</span><br></pre></td></tr></tbody></table></figure>
<p>如上述代码，使用内置函数reflect即可计算视线到当前像素的反射方向，然后用该方向去采样Cubemap即可。具体相关数学原理，比较简单，不再赘述。</p>
<h4 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h4><ol>
<li>计算当前着色像素的折射方向。</li>
<li>使用折射方向去从Cubemap中采样出折射颜色。</li>
</ol>
<p><strong>如何计算折射方向？</strong></p>
<ol>
<li>-viewDirectionWS。最简单的方式是假定折射方向没有发生偏转，那么简单使用相机到该像素点的方向即可，即-inputData.viewDirectionWS。由于，这本来就是一种近似效果，因此简单使用视线方向得到的结果也能差强人意。</li>
<li>refract。即使用折射定律来计算折射方向，直接调用refract函数即可，需要提供参数来调整折射率。</li>
<li>Refraction Model。生活中真正的玻璃，光线是先折射进入玻璃，然后再折射出来到空气中，我们需要的是最终的方向，而不是到玻璃内的折射方向。要模拟真实的折射方向，可以使用简化的模拟来模拟，比如假设折射是通过一定厚度的球体或者立方体。相关内容和代码，在HDRP内已经使用，参考文档：<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@8.0/manual/Refraction-in-HDRP.html">Refraction in the High Definition Render Pipeline</a>的Refraction Model部分。代码在com.unity.render-pipelines.core内，因此urp也可以使用。如果需要使用该折射模型，搜索RefractionModelBox或者RefractionModelSphere即可。</li>
</ol>
<h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p> 使用fresnel定律，将反射和折射颜色叠加起来作为最终的环境颜色。这部分的关键在于正确计算出反射和折射的贡献比例，并不一定需要严格计算fresnel定律，只需要接近该定律的现象即可。<br> fresnel定律的基本意思是：视线方向与法线的角度越大，反射越明显。对于基本只剩下反射的区域，也可以叫做掠角。<br>因此，最终结果可以使用下述代码叠加起来。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float fresnel = pow(saturate(1 - dot(inputData.viewDirectionWS, inputData.normalWS)), 5.0);</span><br><span class="line">half3 color = reflectColor * fresnel + refractColor * (1 - fresnel);</span><br></pre></td></tr></tbody></table></figure>
<p>最终效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassEnv.png"></p>
<h3 id="1-1-2-Matcap模拟"><a href="#1-1-2-Matcap模拟" class="headerlink" title="1.1.2 Matcap模拟"></a>1.1.2 Matcap模拟</h3><p>使用Matcap来模拟的话，思路与Cubemap类似。问题转换成如何从2D的Matcap贴图中计算反射颜色和折射颜色。</p>
<h4 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h4><p>反射其实可以理解为高光，那么可以参考Matcap如何实现高光的模拟部分：<a href="https://xiaopengcheng.top/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">Matcap模拟高光</a>。</p>
<h4 id="折射-1"><a href="#折射-1" class="headerlink" title="折射"></a>折射</h4><p>折射更像一个扭曲的过程，因为折射后方向发生了改变。那么，可以直接对uv进行扭曲，比如采样噪声图对uv进行叠加，再去采样一张折射matcap。</p>
<h4 id="最终结果-1"><a href="#最终结果-1" class="headerlink" title="最终结果"></a>最终结果</h4><p>与使用Cubemap类似，都需要使用计算fresnel定律计算折射和反射的混合比例。</p>
<h3 id="1-1-3-实时反射和折射模拟"><a href="#1-1-3-实时反射和折射模拟" class="headerlink" title="1.1.3 实时反射和折射模拟"></a>1.1.3 实时反射和折射模拟</h3><p>实时反射和折射，与前面两个算法的区别，是用反射和折射方向去采样当前的渲染结果，作为反射和折射的计算结果。</p>
<h3 id="获得ColorBuffer"><a href="#获得ColorBuffer" class="headerlink" title="获得ColorBuffer"></a>获得ColorBuffer</h3><p>需要在管线内插入一个Pass，将ColorBuffer进行Blit到一个低分辨率的RT上，然后对该RT进行采样。对于URP渲染管线，我们只要设置请求OpaqueTexture后，既可以在Shader对_CameraOpaqueTexture进行采样。</p>
<h3 id="反射-2"><a href="#反射-2" class="headerlink" title="反射"></a>反射</h3><p>由于OpaqueTexture是屏幕空间纹理，那么需要在屏幕空间内计算反射方向，可以参考文章<a href="https://xiaopengcheng.top/2021/08/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/">反射效果的实现总结</a>的屏幕空间反射部分。<br>或者更直接参考GitHub上的开源项目：<a href="https://github.com/ColinLeung-NiloCat/UnityURP-MobileScreenSpacePlanarReflection">UnityURP-MobileScreenSpacePlanarReflection</a>。在屏幕空间计算反射，算法部分比较复杂，不再赘述，请参考相关资料。</p>
<h3 id="折射-2"><a href="#折射-2" class="headerlink" title="折射"></a>折射</h3><p>由于反射要求方向精确，但是折射就没有这种要求，因此最简单的方式是计算出当前像素的屏幕空间位置后，然后对该位置进行扭曲，再采样OpaqueTexture即可获得折射结果。<br>当然如果要计算精确的折射方向，类似屏幕空间反射，都需要在屏幕空间内使用类似算法进行精确的方向计算， 然后再去采样屏幕空间RT。</p>
<h4 id="最终结果-2"><a href="#最终结果-2" class="headerlink" title="最终结果"></a>最终结果</h4><p>与使用Cubemap类似，都需要使用计算fresnel定律计算折射和反射的混合比例。</p>
<h2 id="1-2-玻璃污渍模拟"><a href="#1-2-玻璃污渍模拟" class="headerlink" title="1.2 玻璃污渍模拟"></a>1.2 玻璃污渍模拟</h2><p>该效果是对玻璃角落通常会出现污渍现象的模拟。通过观察，玻璃或者窗户一般是四个角落积累污渍。因此，可以计算与角落或者中心的距离，以这个距离归一化为默认的污渍强度。再结合一个污渍掩码贴图和污渍强度噪声贴图就可以让美术精细控制污渍了，当然不提供任何贴图也有默认的角落污渍。<br>具体功能，参考下图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassFrost.png"></p>
<h3 id="1-2-1-角落污渍"><a href="#1-2-1-角落污渍" class="headerlink" title="1.2.1 角落污渍"></a>1.2.1 角落污渍</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float uDis = min(abs(_FrostCenter.x - uv.x), abs(1 - _FrostCenter.x - uv.x));</span><br><span class="line">float vDis = min(abs(_FrostCenter.y - uv.y), abs(1 - _FrostCenter.y - uv.y));</span><br><span class="line">float dis = length(float2(uDis, vDis)) / 0.707;//斜边距离，然后归一化</span><br><span class="line">dis = _FrostReverse * (1 - dis) + (1 - _FrostReverse) * dis;//反转距离</span><br></pre></td></tr></tbody></table></figure>
<p>如上述代码，_FrostCenter定义的是污渍的中心，这个通常是（0.5,0.5)，即UV的中心。然后，计算当前uv到中心的归一化距离，用该距离作为污渍强度。</p>
<h3 id="1-2-2-污渍强度Noise"><a href="#1-2-2-污渍强度Noise" class="headerlink" title="1.2.2 污渍强度Noise"></a>1.2.2 污渍强度Noise</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half noiseDistance = SAMPLE_TEXTURE2D(_FrostNoiseMap, sampler_FrostNoiseMap, TRANSFORM_TEX(uv, _FrostNoiseMap)).r * _FrostNoiseIntensity;</span><br><span class="line">dis *= smoothstep(0, _FrostNoiseMax, noiseDistance);</span><br></pre></td></tr></tbody></table></figure>
<p>从贴图内读取噪声强度，然后对强度进行smoothstep归一化，再乘以到原来的强度距离上。</p>
<h3 id="1-2-3-污渍Mask"><a href="#1-2-3-污渍Mask" class="headerlink" title="1.2.3 污渍Mask"></a>1.2.3 污渍Mask</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 frostMask = SAMPLE_TEXTURE2D(_FrostMaskMap, sampler_FrostMaskMap, TRANSFORM_TEX(uv, _FrostMaskMap));</span><br><span class="line">dis *= lerp(1, lerp(frostMask.x, 1 - frostMask.x, _FrostMaskReverse),  _FrostBlendFactor);//blend with mask</span><br></pre></td></tr></tbody></table></figure>
<p>从贴图内读取mask，然后将mask乘到原有的强度上。至于_FrostMaskReverse则是强度反转控制，_FrostBlendFactor是mask比例控制。</p>
<h3 id="1-2-4-将距离转化为污渍颜色"><a href="#1-2-4-将距离转化为污渍颜色" class="headerlink" title="1.2.4 将距离转化为污渍颜色"></a>1.2.4 将距离转化为污渍颜色</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float weight = smoothstep(0, _FrostDistance / 0.707, dis);</span><br><span class="line">color.rgb += weight * _FrostColor * _FrostIntensity;</span><br></pre></td></tr></tbody></table></figure>
<p>_FrostDistance/0.707是归一化的最大距离。然后对dis进行smoothstep后就可以得到污渍强度。最后，将<br>污渍强度与污渍颜色、污渍整体强度相乘后叠加到最终颜色上即可。当然，也可以有其它的应用方式，比如用污渍weight来改变法线等。<br>最终效果如图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassFrostDemo.png"></p>
<h1 id="二、窗户室内模拟"><a href="#二、窗户室内模拟" class="headerlink" title="二、窗户室内模拟"></a>二、窗户室内模拟</h1><p>这是另外一种窗户模拟效果，跟玻璃效果差距较大，但是也可以作为通用Shader的一部分整合进来，因此放在一起讲述。详细的效果和算法可以参考文章：<a href="https://zhuanlan.zhihu.com/p/376762518">案例学习——Interior Mapping 室内映射（假室内效果）</a>。<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassInterior.png"><br>该算法的整体思想，是计算当前视线与室内的交点，然后从室内环境Cubemap获取交点的颜色作为最终颜色。计算交点有两种方式，一种是在模型空间计算，一种是在切线空间计算。在模型空间计算，依赖模型空间坐标系的具体范围，更通用的方式是在切线空间计算。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="property">interiorViewDir</span>.<span class="property">z</span> *= <span class="number">1</span> / (<span class="number">1</span> - _InteriorDepthScale) - <span class="number">1</span>;</span><br><span class="line">   half3 revseseViewDir = <span class="title class_">SafeNormalize</span>(-input.<span class="property">interiorViewDir</span>);</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> _INTERIOR_TANGENT</span><br><span class="line">	float2 interiorUV = <span class="title function_">frac</span>(<span class="title function_">TRANSFORM_TEX</span>(uv, _InteriorCubemap) + <span class="number">0.0001</span>);</span><br><span class="line">	<span class="comment">// raytrace box from tangent view dir</span></span><br><span class="line">	float3 pos = <span class="title function_">float3</span>(interiorUV * <span class="number">2.0</span> - <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">	float3 pos = <span class="title function_">frac</span>(input.<span class="property">positionOS</span> * _InteriorCubemap_ST.<span class="property">xyx</span> + _InteriorCubemap_ST.<span class="property">zwz</span> + <span class="number">0.0001</span>);</span><br><span class="line">           <span class="comment">// raytrace box from object view dir</span></span><br><span class="line">           <span class="comment">// transform object space uvw( min max corner = (0,0,0) &amp; (+1,+1,+1))  </span></span><br><span class="line">           <span class="comment">// to normalized box space(min max corner = (-1,-1,-1) &amp; (+1,+1,+1))</span></span><br><span class="line">           pos = pos * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">float3 id = <span class="number">1.0</span> / revseseViewDir;</span><br><span class="line">float3 k = <span class="title function_">abs</span>(id) - pos * id;</span><br><span class="line">float kMin = <span class="title function_">min</span>(<span class="title function_">min</span>(k.<span class="property">x</span>, k.<span class="property">y</span>), k.<span class="property">z</span>);</span><br><span class="line">pos += kMin * revseseViewDir;</span><br><span class="line"></span><br><span class="line">refractColor += <span class="title function_">SAMPLE_TEXTURECUBE</span>(_InteriorCubemap, sampler_InteriorCubemap, pos.<span class="property">xyz</span>).<span class="property">rgb</span> * _InteriorIntensity;</span><br></pre></td></tr></tbody></table></figure>
<p>_InteriorDepthScale表示室内的深度，对室内进行远近拉伸，默认是0.5，表示没有拉伸。详细的推导算法请参考上述文章。<br>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassInteriorDemo.png"><br>外表凹凸不平的是玻璃本身的颜色贴图和法线贴图效果，内部是室内模拟效果。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@8.0/manual/Refraction-in-HDRP.html">Refraction in the High Definition Render Pipeline</a><br><a href="https://xiaopengcheng.top/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">Matcap模拟高光</a><br><a href="https://xiaopengcheng.top/2021/08/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/">反射效果的实现总结</a><br><a href="https://github.com/ColinLeung-NiloCat/UnityURP-MobileScreenSpacePlanarReflection">UnityURP-MobileScreenSpacePlanarReflection</a><br><a href="https://zhuanlan.zhihu.com/p/376762518">案例学习——Interior Mapping 室内映射（假室内效果）</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/" class="post-title-link" itemprop="url">多层融合地形Shader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-18 16:02:00" itemprop="dateCreated datePublished" datetime="2023-01-18T16:02:00+08:00">2023-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/" class="post-meta-item leancloud_visitors" data-flag-title="多层融合地形Shader" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、多层融合地形Shader介绍"><a href="#一、多层融合地形Shader介绍" class="headerlink" title="一、多层融合地形Shader介绍"></a>一、多层融合地形Shader介绍</h1><p>所谓多层融合地形Shader，即多层地形效果过渡融合的Shader，比如黄色的土地上，融合淡绿色的草地，然后再点缀红色的花，这样就是三层效果融合。虽然，该效果常用在地形上，但是并不局限于地形，普通的场景模型等照样可以使用这样方式融合多层效果，比如静态的雪地，就可以使用该技术达到很精细的效果。<br>对于单独的一层效果，可以是PBR也可以是BlingPhong，甚至可以是Matcap。关键在于，如何将多层效果比较自然得融合起来。<br>类似下面的地形Shader效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainOptions.png"><br>可以看出该Shader，支持权重混合和高度混合，同时支持四层融合。</p>
<h1 id="二、多层融合效果的基本实现思路"><a href="#二、多层融合效果的基本实现思路" class="headerlink" title="二、多层融合效果的基本实现思路"></a>二、多层融合效果的基本实现思路</h1><p>概况的说，一句话可以总结：<strong>对着色模型或者说光照模型的输入进行多层混合</strong>。比如，PBR的基本输入是基础色、法线、金属度、粗糙度、AO；BlingPhong的基本输入是基础色、法线、AO。其它的着色模型也是类似的思路，同样可以对Matcap和卡通渲染进行多层融合。</p>
<h1 id="二、权重融合"><a href="#二、权重融合" class="headerlink" title="二、权重融合"></a>二、权重融合</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainWeight.png"><br>权重融合的实现方式比较简单，用一个权重贴图控制四层的权重，同时提供数值缩放。这样，第一层的权重就是权重贴图的R通道乘以第一层的缩放（First Layer Weight），以此类推。然后，用得到的四个权重，应用到四层的基本输入上做加权平均，得到最终的输入。</p>
<h1 id="三、高度融合"><a href="#三、高度融合" class="headerlink" title="三、高度融合"></a>三、高度融合</h1><p>权重融合的缺点是边界过渡比较生硬，无法实现平滑的过渡。而高度融合是解决过渡生硬的一个好的方式。效果和思路可以参考文章：<a href="https://zhuanlan.zhihu.com/p/26383778">基于高度的纹理混合shader</a><br>基本思路：</p>
<ol>
<li>求四层最大高度。</li>
<li>用最大权重减去过渡因子作为开始高度。</li>
<li>每一层的高度减去开始高度作为该层权重。</li>
<li>然后进行四层加权混合。<br>具体代码可以参考下面函数：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">half LayerHeightBlend(half4 height, half input1, half input2, half input3, half input4)</span><br><span class="line">{</span><br><span class="line">	half heightStart = max(max(height.r, height.g), max(height.b, height.a)) - _HeightBlendFactor;</span><br><span class="line">	half b1 = max(height.r - heightStart, 0);</span><br><span class="line">	half b2 = max(height.g - heightStart, 0);</span><br><span class="line">	half b3 = max(height.b - heightStart, 0);</span><br><span class="line">	half b4 = max(height.a - heightStart, 0);</span><br><span class="line">	return max((input1 * b1 + input2 * b2 + input3 * b3 + input4 * b4) / (b1 + b2 + b3 + b4), 0.0001);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
效果对比：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainWeightDemo.png"><br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainHeightDemo.png"></li>
</ol>
<p>第二个效果与第一个效果对比，有明显的过渡区域，而且过渡区域是有明显融合的，而单纯的权重融合只是效果的加权平均。</p>
<h1 id="四、融合控制贴图编辑工具"><a href="#四、融合控制贴图编辑工具" class="headerlink" title="四、融合控制贴图编辑工具"></a>四、融合控制贴图编辑工具</h1><p>为了方便美术所见即所得的编辑和预览最终的混合效果，那么实现一个编辑器工具，方便美术用笔刷实时来修改效果，同时在Unity编辑器内预览最终效果是非常有意义的，可以显著提高生产效率。<br>类似如下工具：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainPaint.png"><br>该工具的功能并不复杂，读取地形材质的设置，比如控制贴图信息和四层的贴图信息，提供笔刷功能，在Scene窗口去刷模型，壁画操作的结果再写回控制贴图。由于当前模型使用的正是笔刷引用的地形材质和控制贴图，因此就可以实时预览最终的渲染效果。<br>网上应该也有类似的插件或者开源代码。这里只是抛砖引玉，具体代码不会提供。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/" class="post-title-link" itemprop="url">通用特效Shader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-22 15:10:00" itemprop="dateCreated datePublished" datetime="2022-11-22T15:10:00+08:00">2022-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/" class="post-meta-item leancloud_visitors" data-flag-title="通用特效Shader" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、通用特效Shader介绍"><a href="#一、通用特效Shader介绍" class="headerlink" title="一、通用特效Shader介绍"></a>一、通用特效Shader介绍</h1><h2 id="1-1-什么是通用特效材质"><a href="#1-1-什么是通用特效材质" class="headerlink" title="1.1 什么是通用特效材质"></a>1.1 什么是通用特效材质</h2><p>Unity支持SRP Batcher后，使用UberShader的优势非常明显。所谓，UberShader，即一个超级Shader，覆盖一类功能，而不是多个分散的小Shader，比如一个通用特效Shader，整个项目内的所有特效都使用该Shader来制作所有的粒子特效或者模型特效，其它需求也类似，比如物体、地形等。</p>
<h2 id="1-2-通用特效材质的意义"><a href="#1-2-通用特效材质的意义" class="headerlink" title="1.2 通用特效材质的意义"></a>1.2 通用特效材质的意义</h2><h3 id="1-2-1-方便使用和沟通"><a href="#1-2-1-方便使用和沟通" class="headerlink" title="1.2.1 方便使用和沟通"></a>1.2.1 方便使用和沟通</h3><p>整个项目只有一个特效Shader的情况下，美术很容易熟悉该Shader有哪些功能，能够尽可能复用该通用Shader的多个功能制作复杂特效；同时，避免美术与技术美术或者技术重复沟通类似的功能。</p>
<h3 id="1-2-2-方便维护"><a href="#1-2-2-方便维护" class="headerlink" title="1.2.2 方便维护"></a>1.2.2 方便维护</h3><p>对于技术美术或者开发同学来说，维护一个Shader的成本比维护多个的成本低很多。对于重复功能不需要再重复开发，优化性能时候也不用满世界扫描美术到底用的是什么Shader，只需要优化这一个Shader性能即可。</p>
<h3 id="1-2-3-批次更低"><a href="#1-2-3-批次更低" class="headerlink" title="1.2.3 批次更低"></a>1.2.3 批次更低</h3><p>由于支持SRP Batcher，Unity使用的是最终的变体级别合批。与多个分散小Shader相比，一个Shader质制作的特效更可能被SRP Batcher，因为使用的同一个变体的概率很高，而不同的Shader天然就是不同的变体，不可能被SRP Batcher。因此，只要复用率越高，被合并的批次越多。</p>
<h2 id="1-2-通用特效材质主要模块"><a href="#1-2-通用特效材质主要模块" class="headerlink" title="1.2 通用特效材质主要模块"></a>1.2 通用特效材质主要模块</h2><p>主要包括基础功能、Mask、Distortion（扭曲）、Dissolve（溶解）、Emission（自发光）、Reflection（反射）、其它等。每个大的模块都有变体开关，部分消耗大的小功能也需要有变体开关。这里只是列出本人项目中用到过的一些功能，基本上覆盖了常见的特效功能，但是不同项目会有不同的需求，因此除了常见的扭曲、溶解等还会有不少定制功能。这篇文章的目的，不在于介绍这些功能的实现细节，而是说明一个超级特效Shader在项目中使用的意义。</p>
<h1 id="二、通用特效具体模块"><a href="#二、通用特效具体模块" class="headerlink" title="二、通用特效具体模块"></a>二、通用特效具体模块</h1><h2 id="2-1-Surface-Options（基础设置）"><a href="#2-1-Surface-Options（基础设置）" class="headerlink" title="2.1 Surface Options（基础设置）"></a>2.1 Surface Options（基础设置）</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsSurfaceOptions.png"><br>Surface Type：不透明或者半透明<br>Render Face：Front（剔除背面）、Back（剔除前面）、Both（不剔除）<br>Custom ZWrite：是否覆盖深度写入<br>ZTest：深度测试<br>ColorMask：输出颜色通道<br>Alpha Clipping：Alpha裁剪<br>Enable Billboard：是否作为Billboard渲染（朝向相机）</p>
<h2 id="2-2-Surface-Inputs-（基础输入）"><a href="#2-2-Surface-Inputs-（基础输入）" class="headerlink" title="2.2 Surface Inputs （基础输入）"></a>2.2 Surface Inputs （基础输入）</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsSurfaceInputs.png"><br>Base Map：基础颜色贴图<br>Base Color：基础颜色<br>Enable BackFace Base Color：开启该选项，可以给背面单独制定基础颜色<br>Apply Vertex Color：开启该选项，顶点颜色应用到基础色上<br>BaseMap UvType：该设置有UV、ScreenUV、ReflectionUV三种类型。UV模式是使用模型UV0，ScreenUV是使用屏幕空间位置作为UV，ReflectionUV使用反射向量的两个分量比如xz作为UV。ScreenUV和ReflectionUV可以实现一些特殊效果。<br>BaseMap Rotation：UV模式下，对模型UV0旋转。<br>BaseMap U Speed：UV的U移动速度。<br>BaseMap V Speed：UV的V移动速度。<br>BaseMap Custom Speed (CustomData1.xy, UV0.zw)：该功能是使用Unity粒子的CustomData1.xy来作为UV。如下所示的CustomData1.xy是曲线：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/EffectsCustomData.png"><br>Normal Map：法线贴图，只在需要使用法线方向时候有意义，比如反射、Matcap等<br>Normal Scale：法线强度缩放<br>Normal U Speed：法线的U移动速度。<br>Normal V Speed：法线的V移动速度。</p>
<h2 id="2-3-Mask-Options"><a href="#2-3-Mask-Options" class="headerlink" title="2.3 Mask Options"></a>2.3 Mask Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsMask.png"><br>Mask贴图的作用是修改透明度，在半透明模式下可以只显示通过Mask的区域。</p>
<p>Mask Map (R)：Mask贴图，默认使用R通道。<br>Mask Channel Mask (Default R)：Mask贴图的通道掩码。<br>Mask Rotation：Mask贴图的UV旋转。<br>Mask U Speed：Mask贴图的U移动速度。<br>Mask V Speed：Mask贴图的V移动毒素。<br>Mask Custom Speed (CustomData1.zw, UV1.xy):使用Unity粒子的CustomData1.zw来作为Mask的UV。<br>Mask Intensity:  Mask的强度缩放。<br>Mask Min：Mask的强度最小值。<br>Mask Max：Mask的强度最大值。最终的Mask强度会在该范围内SmoothStep。<br>下面是使用Mask的效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsMaskTest.gif"></p>
<h2 id="2-4-Distortion-Options"><a href="#2-4-Distortion-Options" class="headerlink" title="2.4 Distortion Options"></a>2.4 Distortion Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDistortion.png"><br>Distortion的功能就是扭曲其它模块的采样UV，比如基础色、自发光、溶解等。<br>Distortion Map (RG) Mask(A)：扭曲贴图，RG通道是扭曲强度，A通道是扭曲Mask。<br>Distortion Rotation：扭曲的UV旋转。<br>Distortion U Speed：扭曲的U移动速度。<br>Distortion V Speed：扭曲的V移动速度。<br>Distortion Intensity：扭曲的强度缩放。<br>下面是使用扭曲的效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDistortionTest.gif"></p>
<h2 id="2-5-Dissolve-Options"><a href="#2-5-Dissolve-Options" class="headerlink" title="2.5 Dissolve Options"></a>2.5 Dissolve Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDissolveOptions.png"><br>Dissolve Map (R)：溶解贴图，默认使用R通道。<br>Dissolve Channel Mask (Default R)：溶解贴图的通道掩码。<br>Dissolve Rotation：溶解贴图的UV旋转。<br>Dissolve U Speed：溶解贴图的U移动速度。<br>Dissolve V Speed：溶解贴图的V移动速度。<br>Dissolve Intensity：溶解强度，注意不是溶解贴图的输入强度缩放。<br>Dissolve Width：溶解宽度。<br>Dissolve Edge Color：溶解边缘颜色。<br>Dissolve Edge Intensity：溶解边缘颜色强度缩放。<br>Dissolve Hard Edge：是否硬边溶解。<br>Dissolve Custom Intensity (CustomData2.x, UV1.z)：使用粒子系统的CustomData2.x作为溶解强度。<br>Dissolve Custom Width (CustomData2.y, UV1.w)：使用粒子系统的CustomData2.y作为溶解宽度。<br>溶解的功能比较复杂，最基本的思想是用一张贴图作为溶解强度输入，然后通过在溶解强度和宽度之间计算出溶解阈值，用这个阈值去修改透明度；溶解的边缘颜色则是将溶解阈值应用到单独是边缘颜色上再叠加到输出颜色上；至于硬边溶解是直接将溶解阈值取sign。<br>有兴趣还原的可以参考下面代码：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">half disslove = dot(SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv3.xy + distortion), _DissolveChannelMask);</span><br><span class="line">half dissloveIntensity = input.uv3.z;</span><br><span class="line">half dissolveWidth = input.uv3.w;</span><br><span class="line">half dissolveWithParticle = (dissloveIntensity * (1 + dissolveWidth) - dissolveWidth);</span><br><span class="line">half dissolveAlpha = saturate(smoothstep(dissolveWithParticle, (dissolveWithParticle + dissolveWidth), disslove));</span><br><span class="line">color.a *= _DissolveHardEdge ? sign(dissolveAlpha) : dissolveAlpha;</span><br><span class="line">color.rgb += _DissolveEdgeColor.rgb * _DissolveEdgeColor.a * _DissolveEdgeIntensity * (_DissolveHardEdge ? sign(1 - dissolveAlpha) : (1 - dissolveAlpha));</span><br></pre></td></tr></tbody></table></figure><br>下面是使用溶解的效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDissolveTest.gif"><p></p>
<h2 id="2-6-Emission-Options"><a href="#2-6-Emission-Options" class="headerlink" title="2.6 Emission Options"></a>2.6 Emission Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsEmissionOptions.png"><br>Emission Map：自发光贴图。<br>EmissionColor：自发光颜色。<br>Use WorldPos As UV：特殊需求，使用世界空间位置作为UV采样自发光贴图。<br>Emission U Speed：自发光的U移动速度。<br>Emission V Speed：自发光的V移动速度。<br>Emission Intensity：自发光的强度缩放。<br>自发光的原理比较简单，采样一张额外的自发光贴图叠加颜色，不再赘述。</p>
<h2 id="2-7-RimLight-Options"><a href="#2-7-RimLight-Options" class="headerlink" title="2.7 RimLight Options"></a>2.7 RimLight Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsRimLightOptions.png"><br>RimLight Color：边缘光颜色。<br>RimLight Width：边缘光宽度。<br>RimLight Smoothness：边缘光光滑度。<br>RimLight Intensity：边缘光强度缩放。<br>RimLight Min：边缘光最小强度。<br>RimLight Max：边缘光最大强度。<br>RimLight Reverse：是否反转强度。<br>边缘光是实际上是计算法线与视线的夹角来判断边缘，当夹角越大边缘光越强，最终将边缘光叠加回输出颜色上。具体代码如下：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half cosTheta = dot(normalWS, viewDirWS);</span><br><span class="line">half rimLightStrength = pow(saturate(1 - 1 / _RimLightWidth * cosTheta), _RimLightSmoothness);</span><br><span class="line">rimLightStrength = (_RimLightReverse ? 1 - rimLightStrength : rimLightStrength) * _RimLightIntensity;</span><br><span class="line">rimLightStrength = smoothstep(_RimLightMinValue, _RimLightMaxValue, rimLightStrength);</span><br><span class="line">color.rgb += _RimLightColor * rimLightStrength;</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="2-8-Light-Options"><a href="#2-8-Light-Options" class="headerlink" title="2.8 Light Options"></a>2.8 Light Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsLightOptions.png"><br>Real Time Light Strength：实时光强度<br>Real Time Shadow Strength：实时光阴影强度<br>Real Time Shadow Color：实时光阴影颜色<br>Real Time Shadow Color Strength：实时光阴影颜色强度<br>强调一下：这里不是让特效Shader走完整的光照计算，而只是用光源的信息去修改最终的输出颜色。这样性能高效，看起来也在接受光源阴影。</p>
<h2 id="2-9-其它功能"><a href="#2-9-其它功能" class="headerlink" title="2.9 其它功能"></a>2.9 其它功能</h2><h3 id="2-9-1-Depth-Bias"><a href="#2-9-1-Depth-Bias" class="headerlink" title="2.9.1 Depth Bias"></a>2.9.1 Depth Bias</h3><p>深度偏移，特效有时候需要偏移深度来强制放在某些物体之前，这个功能比较有效果。</p>
<h3 id="2-9-2-Reflection-Options"><a href="#2-9-2-Reflection-Options" class="headerlink" title="2.9.2 Reflection Options"></a>2.9.2 Reflection Options</h3><p>使用反射方向采样Cubemap，将结果叠加到输出颜色上即可。</p>
<h3 id="2-9-2-Matcap"><a href="#2-9-2-Matcap" class="headerlink" title="2.9.2 Matcap"></a>2.9.2 Matcap</h3><p>参考上一篇文章的Matcap，对于特效的matcap可以简单实现即可。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">Matcap的原理和应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-19 17:15:51" itemprop="dateCreated datePublished" datetime="2022-09-19T17:15:51+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">图形学</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-meta-item leancloud_visitors" data-flag-title="Matcap的原理和应用" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、概念和原理"><a href="#一、概念和原理" class="headerlink" title="一、概念和原理"></a>一、概念和原理</h1><h2 id="1-1-什么是Matcap"><a href="#1-1-什么是Matcap" class="headerlink" title="1.1 什么是Matcap"></a>1.1 什么是Matcap</h2><p>  什么是Matcap？Matcap实际上是Material Capture的缩写，即材质捕捉。实际上，这是一种离线渲染方案。类似光照烘焙，将光照或者其它更复杂环境下的渲染数据存储到一张2D贴图上， 再从这张2D贴图进行采样进行实时渲染。</p>
<p><a href="https://help.sketchfab.com/hc/en-us/articles/115003065883-Materials-MatCap-">Materials (MatCap)</a>这篇文章对Matcap的定义是：<br>MatCap (Material Capture) shaders are complete materials, including lighting and reflections. They work by defining a color for every vertex normal direction relative to the camera. </p>
<h2 id="1-2-如何理解Matcap"><a href="#1-2-如何理解Matcap" class="headerlink" title="1.2 如何理解Matcap"></a>1.2 如何理解Matcap</h2><p>Matcap是一种在视线空间下使用单位法线采样单位球的离线渲染算法。</p>
<ul>
<li>为什么是视线空间？因为视线空间下，相机变化就可以看到不同的渲染结果。</li>
<li>为什么使用法线去采样了？法线是描述表面朝向的向量，与渲染结果强相关，法线跟物体的曲率强相关等，因此这种算法经常用于 sculpting上。</li>
</ul>
<h2 id="1-3-Matcap的特点"><a href="#1-3-Matcap的特点" class="headerlink" title="1.3 Matcap的特点"></a>1.3 Matcap的特点</h2><p>Matcap的特点总结如下：</p>
<ul>
<li>使用视线空间下的法线向量采样2D贴图，作为光照和反射结果。</li>
<li>在缺乏光照烘焙的环境下，可以一定程度上替代或者模拟光图。</li>
<li>但是，Matcap代表的2D贴图不局限于光照信息，也可以理解为某种环境下的最终渲染结果。</li>
<li>由于是离线方案，因此计算非常廉价，很适合低端机器或者特定场合下使用。</li>
</ul>
<h1 id="二、如何实现Matcap"><a href="#二、如何实现Matcap" class="headerlink" title="二、如何实现Matcap"></a>二、如何实现Matcap</h1><h2 id="2-1-如何获得Matcap贴图"><a href="#2-1-如何获得Matcap贴图" class="headerlink" title="2.1 如何获得Matcap贴图"></a>2.1 如何获得Matcap贴图</h2><p>按照定义，matcap贴图是一张2D贴图，内部包含一个单位球，表示光照信息。如何获得这样的贴图了？</p>
<ul>
<li>从网上的材质库下载<br>比如，<a href="https://github.com/nidorx/matcaps">matcaps</a></li>
<li>引擎预览材质球然后截图。<br><img alt="材质预览matcap" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/材质预览matcap.png"><br>如上图，可以把右边的预览结果紧贴着球体进行截图。<br>当然，如果严格按照定义，Matcap表示的是光照信息，不是所有材质预览的结果都可以当作Matcap贴图。</li>
</ul>
<h2 id="2-2-如何采样Matcap贴图"><a href="#2-2-如何采样Matcap贴图" class="headerlink" title="2.2 如何采样Matcap贴图"></a>2.2 如何采样Matcap贴图</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------</span><br><span class="line">// Vertex</span><br><span class="line">// -------------------------------</span><br><span class="line">VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);</span><br><span class="line">output.normalWS = normalInput.normalWS;</span><br><span class="line"></span><br><span class="line">// -------------------------------</span><br><span class="line">// Fragment</span><br><span class="line">// -------------------------------</span><br><span class="line">float3 viewNormal = mul((float3x3)GetWorldToViewMatrix(), normalWS);</span><br><span class="line">float2 matCapUV = viewNormal.xy * 0.5 + 0.5;</span><br><span class="line">half3 matcapColor = SAMPLE_TEXTURE2D(_Matcap, sampler_Matcap, matCapUV).rgb;</span><br></pre></td></tr></tbody></table></figure>
<p>从上述glsl代码可以看出，需要把法线转换到视线空间，然后再将法线偏移到[0,1]的范围内，然后取xy分量作为uv，对matcap纹理进行采样。</p>
<h1 id="三、Matcap的问题"><a href="#三、Matcap的问题" class="headerlink" title="三、Matcap的问题"></a>三、Matcap的问题</h1><h2 id="3-1-边缘瑕疵"><a href="#3-1-边缘瑕疵" class="headerlink" title="3.1 边缘瑕疵"></a>3.1 边缘瑕疵</h2><p>有时候使用Matcap渲染，模型上会出现一条线或者缝隙。可能的原因是采样到了贴图的边缘部分，而有些matcap贴图制作上不太好，边缘区域过大。<br><img alt="matcap边缘瑕疵" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap边缘瑕疵.png"><br>如上图所示：左边的matcap贴图就是一个非常不规范的matcap贴图，球没有紧贴边缘，而是出现大量空白部分，导致兔子的边缘出现大量的灰色边缘。<br>解决方式有两种，一种是强制采样内部的像素；另一种方式是修改采样算法，使得更合理避免出现边缘区域。</p>
<h2 id="3-2-单点采样"><a href="#3-2-单点采样" class="headerlink" title="3.2 单点采样"></a>3.2 单点采样</h2><p>对于平面来说，其法线朝着同一个方向的，因此会出现整个平面获得的matcap颜色都是同一个像素点，与正常的光照结果相差很大。我们希望的是，即使是一个平面，不同的像素点也是有不同的光照结果。</p>
<h2 id="3-3-解决办法"><a href="#3-3-解决办法" class="headerlink" title="3.3 解决办法"></a>3.3 解决办法</h2><h3 id="3-1-1-缩放uv"><a href="#3-1-1-缩放uv" class="headerlink" title="3.1.1 缩放uv"></a>3.1.1 缩放uv</h3><p>第一种方式是对matcapUV进行缩放，比如缩小uv可以使得避免采样边缘区域。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float2 matCapUV = viewNormal.xy * <span class="number">0.5</span> * _MatcapUVScale + <span class="number">0.5</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这种方式可以简单的解决边缘瑕疵问题，但是无法解决单点采样。</p>
<h3 id="3-1-2-使用视线空间下单位球的法线"><a href="#3-1-2-使用视线空间下单位球的法线" class="headerlink" title="3.1.2 使用视线空间下单位球的法线"></a>3.1.2 使用视线空间下单位球的法线</h3><p><img alt="matcap优化" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap优化.png"><br>如上图所示，在Matcap的定义中，我们处于视线空间内，视线方向始终是（0，0，1）。我们最终要使用的是单位球的N方向。假设反射方向是R，可以计算得到N是(Rx，Ry，Rz+1)。那么问题转化为求反射向量R。我们可以用视线空间的顶点和法线求得视线空间下的R，然后用视线空间的R去代替单位球上的反射向量R即可，即使两个方向向量不能等价，也可以得到相应正确的结果。<br>这种算法可以显著优化平面的单点采样问题。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if _MATCAP_FIX_EDGE_FLAW</span><br><span class="line">	float3 r = reflect(input.positionVS, viewNormal);</span><br><span class="line">	r = normalize(r);</span><br><span class="line">	float m = 2.82842712474619 * sqrt(r.z + 1.0); </span><br><span class="line">	float2 matCapUV = r.xy / m * _MatcapUVScale + 0.5;</span><br><span class="line">#else</span><br><span class="line">	float2 matCapUV = viewNormal.xy * 0.5 * _MatcapUVScale + 0.5;</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<p><img alt="matcap优化对比" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap优化对比.png"><br>从上图可以看出，对于平面来说，两种算法的效果差异非常明显。</p>
<h1 id="四、Matcap与其它效果的结合"><a href="#四、Matcap与其它效果的结合" class="headerlink" title="四、Matcap与其它效果的结合"></a>四、Matcap与其它效果的结合</h1><p>下面的测试均以如下Matcap贴图为例。<br><img alt="matcap输入" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap输入.png"></p>
<h2 id="4-1-基础颜色"><a href="#4-1-基础颜色" class="headerlink" title="4.1 基础颜色"></a>4.1 基础颜色</h2><p>如果把Matcap当作光照的结果，那么可以额外提供基础颜色来控制最终结果。比如，提供基础颜色贴图和基础颜色，乘以到matcap上作为最终输出。<br><img alt="matcap基础色" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap基础色.png"></p>
<h2 id="4-2-法线贴图"><a href="#4-2-法线贴图" class="headerlink" title="4.2 法线贴图"></a>4.2 法线贴图</h2><p>既然matcap需要用到法线，那么可以额外提供法线贴图去修改像素的法线。<br><img alt="matcap法线" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap法线.png"><br>从上图可以看出，法线对最终的渲染结果影响显著。</p>
<h2 id="4-3-自发光"><a href="#4-3-自发光" class="headerlink" title="4.3 自发光"></a>4.3 自发光</h2><p>类似正常的光照计算，可以在matcap的结果之上，再叠加自发光。</p>
<h2 id="4-4-模拟高光"><a href="#4-4-模拟高光" class="headerlink" title="4.4 模拟高光"></a>4.4 模拟高光</h2><p>matcap本身已经是光照计算的结果，因此理论上贴图内带有了漫反射、高光、反射的信息。但是，通常情况下，matcap主要包括的还是漫反射信息，或者说表现不出明显的高光信息。<br>有一种简单模拟高光的方式，提供一个高光阈值，使用matcap减去该颜色阈值，然后除以1-阈值。最终结果再用原matcap颜色相乘避免过曝。<br><img alt="matcap高光" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap高光.png"></p>
<h2 id="4-5-Cubemap反射"><a href="#4-5-Cubemap反射" class="headerlink" title="4.5 Cubemap反射"></a>4.5 Cubemap反射</h2><p>同时，可以额外利用cubemap计算静态反射结果叠加到最终着色上。<br><img alt="matcap反射" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap反射.png"></p>
<h2 id="4-6-模拟边缘光"><a href="#4-6-模拟边缘光" class="headerlink" title="4.6 模拟边缘光"></a>4.6 模拟边缘光</h2><p>利用dot(normalWS, viewDirWS)计算出边缘光的强度，再将边缘光颜色与强度相乘叠加到最终着色结果上即可。</p>
<h2 id="4-7-模拟折射"><a href="#4-7-模拟折射" class="headerlink" title="4.7 模拟折射"></a>4.7 模拟折射</h2><p>折射一种扭曲的效果，因此我们可以通过扭曲matcap的采样位置和反射的采样位置来模拟折射。同时，可以乘以边缘光的强度来模拟菲尼尔效应，也就是边缘光强的地方折射更强。然后，利用这个扭曲强度去偏移matcap的uv和反射向量，即可在一定程度上模拟折射的效果。<br><img alt="matcap折射" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap折射.png"><br>如上图所示，边缘的红色是边缘光；同时，噪声贴图作为折射扭曲强度贴图让边缘光看起来比较细碎，用来模拟折射效果。</p>
<h2 id="4-8-光照强度"><a href="#4-8-光照强度" class="headerlink" title="4.8 光照强度"></a>4.8 光照强度</h2><p>同时，也可以计算出真实的光照强度，将光照强度乘以matcap颜色，让matcap的着色结果受到灯光影响。不过，这跟matcap的初衷不太一致。</p>
<h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote>
<p><a href="[Matcap的原理和应用](xsjapp://doc/b62819d2-d505-4107-8b34-5a176c25bc82#xsj_1702740535139">Materials (MatCap)</a>)<br><a href="https://github.com/nidorx/matcaps">https://github.com/nidorx/matcaps</a><br><a href="https://zhuanlan.zhihu.com/p/79040521">MatCap Shader 改进：解决平面渲染和环境反射问题</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">角色妆容的实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 11:10:00" itemprop="dateCreated datePublished" datetime="2022-07-30T11:10:00+08:00">2022-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">图形学</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-meta-item leancloud_visitors" data-flag-title="角色妆容的实现" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><p>前段时间做了下角色妆容的实现，想写个文章记录一下这个事情。妆容看起来很复杂，实际上整理实现思路很简单，主要是两个方面的内容，改变基础色和改变高光（金粉效果）。<br>先贴一个妆容效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容效果1.jpg"></p>
<p>没有开启妆容的情况下，基础色就是从颜色贴图和基础颜色中获得；开启妆容后，要根据各个状态模块的模板和比例来插值妆容颜色和基本颜色；金粉则是改变特定区域的高光，金粉的浓淡可以用滑块控制，最好同时结合妆容色的浓淡；额外可能需要改变特定妆容区域的光滑度，比如唇彩。</p>
<h1 id="妆容界面"><a href="#妆容界面" class="headerlink" title="妆容界面"></a>妆容界面</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容0.png"><br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容1.png"></p>
<h2 id="妆容开关"><a href="#妆容开关" class="headerlink" title="妆容开关"></a>妆容开关</h2><p>最上面有一个Toggle来开关妆容模块，可以使用shader_feature_local的关键字，比如_MAKEUP来区分。</p>
<h2 id="妆容金粉"><a href="#妆容金粉" class="headerlink" title="妆容金粉"></a>妆容金粉</h2><p>最上面的界面是指定金粉贴图贴图和相应的缩放，使用同样的UV缩放和位移的好处是避免重复读取金粉贴图，提高性能，避免每个妆容模块都要去读一次贴图。毕竟贴图是存储在内存中，要读取到GPU内的话，如果没有Cache中，则速度相比一个计算来说要慢一个数量级的可能。</p>
<h2 id="妆容模块"><a href="#妆容模块" class="headerlink" title="妆容模块"></a>妆容模块</h2><p>接下来是具体的妆容模块，虽然模块比较多，实际上大同小异。功能都是通过通道贴图去改变指定位置的基础颜色，有些通道贴图还有图案的作用。有一些模块有额外的功能，比如唇彩的光滑度滑块、面纹的UV变化。</p>
<h1 id="妆容的实现原理"><a href="#妆容的实现原理" class="headerlink" title="妆容的实现原理"></a>妆容的实现原理</h1><p>下面介绍妆容的具体实现原理。</p>
<h2 id="妆容颜色"><a href="#妆容颜色" class="headerlink" title="妆容颜色"></a>妆容颜色</h2><p>这里的妆容颜色实际上对应的就是界面上具体的妆容模块。以第一个腮红为例子来说明，参考如下代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half3 makeup = baseColor;</span><br><span class="line">half4 blush = SAMPLE_TEXTURE2D(_BlushMap, sampler_BlushMap, uv0);</span><br><span class="line">makeup = lerp(makeup, blush.rgb * _BlushColor, blush.a * _BlusIntensity);</span><br></pre></td></tr></tbody></table></figure>
<p>从代码可以看到妆容色makeup是基础颜色和妆容颜色的插值结果。妆容颜色是从通道贴图读取的rgb和腮红颜色的结合，同样插值比例是通道贴图的a和腮红比例的结合。不过大部分妆容模块的妆容颜色不需要通道贴图的rgb，这种通道贴图实际上可以做合并处理。</p>
<h3 id="妆容模块的结合"><a href="#妆容模块的结合" class="headerlink" title="妆容模块的结合"></a>妆容模块的结合</h3><p>妆容模块有一定的叠加顺序，最底部的是基础色，然后是按照顺序叠加的妆容模块，比如界面上的妆容模块顺序。那么，计算的时候，首先也是一个个按照顺序插值过来，比如先插值基础颜色和腮红，然后用插值结果继续和下一个妆容模块做插值，这样得到的最终妆容颜色就是多个妆容模块的结合。</p>
<h2 id="妆容金粉-1"><a href="#妆容金粉-1" class="headerlink" title="妆容金粉"></a>妆容金粉</h2><p>金粉实际上改变的是高光。没有金粉的话，高光就是默认的情况，比如pbr的金属流高光或者Bling-Phong的高光。有金粉的话，根据金粉计算出一个高光，同时与默认高光进行插值，插值的因子同具体妆容模块的颜色计算。<br>可以参考以下代码实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half3 golddustUV0 = SAMPLE_TEXTURE2D(_GolddustMap, sampler_GolddustMap, _GolddustUVTile * uv0 + _GolddustUVSpeed * _Time.x).rgb;</span><br><span class="line">half4 blush = SAMPLE_TEXTURE2D(_BlushMap, sampler_BlushMap, uv0);</span><br><span class="line">half3 specular = lerp((half3)0, _BlusGolddustColor * golddustUV0 * _BlusGolddustIntensity, blush.a * _BlusIntensity);</span><br></pre></td></tr></tbody></table></figure>
<p>对于Pbr的金属流，默认的高光是0，所以金粉是为了增加额外的高光。关键的一句是在默认的高光和金粉高光之间做插值，插值比例是金粉浓度和妆容的比例。金粉高光是从金粉贴图读取出来同时应用金粉颜色和强度。</p>
<h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><p>比如唇彩模块可以改变光滑度，这个改变的前提是唇彩的通道贴图a通道是大于0的；另外还有面纹的一些UV变化，实际上这个是简单模仿贴花的功能。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>下面介绍一些妆容性能相关的优化策略。</p>
<h2 id="妆容通道贴图采样器的合并"><a href="#妆容通道贴图采样器的合并" class="headerlink" title="妆容通道贴图采样器的合并"></a>妆容通道贴图采样器的合并</h2><p>上述界面的妆容模块过多，如果每个妆容通道贴图一个采样器，肯定会超过限制。方式是所有妆容模块共用一个或者几个采样器。不过，理解上来说，一个贴图采样器对应一个贴图设置，所以去改变贴图的设置会不会有一些影响这个待验证。</p>
<h2 id="妆容通道贴图合并"><a href="#妆容通道贴图合并" class="headerlink" title="妆容通道贴图合并"></a>妆容通道贴图合并</h2><p>其实根本没必要一个妆容模块一个贴图，完全可以做贴图合并，比如不需要使用rgb的妆容模块，那么一个贴图可以对应四个妆容模块了。实际上，跟美术沟通后发现，妆容的效果主要是依赖妆容的通道掩码和妆容颜色，所以基本上不需要使用妆容贴图的rgb。</p>
<h2 id="妆容颜色渲染到基础贴图"><a href="#妆容颜色渲染到基础贴图" class="headerlink" title="妆容颜色渲染到基础贴图"></a>妆容颜色渲染到基础贴图</h2><p>这个理论上来说算是终极优化吧。妆容会暴露很多参数给美术或者用户，用户调整这些参数后会得到一个化妆后的效果。关键的地方是，调整完成之后，可以理解为妹子化妆完成后，效果已经固定了。那么实际上，我们不需要每次再去计算妆容颜色，而是可以将妆容颜色渲染到一张单独的贴图上或者直接覆盖原本的BaseMap。以后的渲染，就不需要使用妆容模块了。</p>
<h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><p>可以新建一个Pass，将妆容颜色的计算结果单独走一遍Pass，同时结合原本的BaseMap作为基础颜色，渲染目标是一个RT，比如是BaseMap。这个Pass的开关可以提供接口供业务代码控制，在化妆完成后调用来覆盖原本的BaseMap。</p>
<h1 id="妆容效果"><a href="#妆容效果" class="headerlink" title="妆容效果"></a>妆容效果</h1><p>最后上一点效果图吧，从美术大佬那边要来的图，凑合看看吧。<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容效果0.jpg"><br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容效果3.jpg"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="远行"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">远行</p>
  <div class="site-description" itemprop="description">远行的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">226</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xpc-yx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xpc-yx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiaopengcheng4912@qq.com" title="E-Mail → mailto:xiaopengcheng4912@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/sitemap.xml" title="sitemap → &#x2F;sitemap.xml"><i class="fa fa-fw fa-sitemap"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">远行</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">692k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:29</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'xqSndxWj2seRmSIR1WvYWOxI-gzGzoHsz',
    appKey: 'dWX3wyEMQ9djk8yiujbPp4pz',
    placeholder: "留下你的足迹 O(∩_∩)O~~",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
