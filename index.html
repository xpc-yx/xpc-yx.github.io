<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xiaopengcheng.top').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left"},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '420f506edca2c5290761c146d6bde3b2',
      indexName: 'xiaopengcheng.top',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="远行的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="远行&#39;s Blog">
<meta property="og:url" content="http://xiaopengcheng.top/index.html">
<meta property="og:site_name" content="远行&#39;s Blog">
<meta property="og:description" content="远行的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="远行">
<meta property="article:tag" content="UE4">
<meta property="article:tag" content="Unity3D">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xiaopengcheng.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>远行's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="远行's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">远行's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">STEP BY STEP</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/xpc-yx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>

  </li>
        <li class="menu-item menu-item-e-mail">

    <a href="mailto:xiaopengcheng4912@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>邮箱</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">基于Vulkan Specialization Constants的材质变体系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-24 12:28:30" itemprop="dateCreated datePublished" datetime="2025-04-24T12:28:30+08:00">2025-04-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="基于Vulkan Specialization Constants的材质变体系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="材质变体"><a href="#材质变体" class="headerlink" title="材质变体"></a>材质变体</h1><p>所谓材质变体，指的是一份材质代码文件，最终对应的是多份运行时gpu程序。比如，shader代码里面有开关或者选项，不同的组合对应不同的最终gpu program。那么，所有的这些组合对应的gpu program，可以统一理解为这个材质对应的所有变体。<br>比如下面shader代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">float4 color;</span><br><span class="line">float3 normal;</span><br><span class="line"></span><br><span class="line">void setColorAndNormal() {</span><br><span class="line">#if COLOR_RED</span><br><span class="line">	color = float4(1, 0, 0, 1);</span><br><span class="line">#else</span><br><span class="line">	color = float4(1, 1, 1, 1);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if NORMAL_POSITIVE</span><br><span class="line">	normal = float3(0, 1, 0);</span><br><span class="line">#else</span><br><span class="line">	normal = float3(0, -1, 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>有2个开关，COLOR_RED，NORMAL_POSITIVE。每个开关都有2种状态，开或者关。那么，可以组合出2*2=4种状态。<br>类似C语言，glsl或者hlsl也支持#define宏，因此也有大于2个状态的开关，比如COLOR_RED == 0、COLOR_RED == 1、COLOR_RED == 2。总的状态计算方式是所有开关的状态数相乘，也就是复杂度是指数级的。</p>
<h1 id="传统变体（静态编译变体）"><a href="#传统变体（静态编译变体）" class="headerlink" title="传统变体（静态编译变体）"></a>传统变体（静态编译变体）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>这里的传统变体指的是针对每一种组合状态都编译生成单独的着色器代码。实际上，目前绝大部分引擎实现的变体方案都是这种方式。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h3><p>算法基本思路很简单，遍历所有的状态组合，针对当前状态，#define相应的宏，然后编译当前代码。<br>比如，</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define COLOR_RED 1</span><br><span class="line">#define NORMAL_POSITIVE 0</span><br><span class="line"></span><br><span class="line">float4 color;</span><br><span class="line">float3 normal;</span><br><span class="line"></span><br><span class="line">void setColorAndNormal() {</span><br><span class="line">#if COLOR_RED</span><br><span class="line">	color = float4(1, 0, 0, 1);</span><br><span class="line">#else</span><br><span class="line">	color = float4(1, 1, 1, 1);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if NORMAL_POSITIVE</span><br><span class="line">	normal = float3(0, 1, 0);</span><br><span class="line">#else</span><br><span class="line">	normal = float3(0, -1, 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>对应的代码就是开关COLOR_RED打开、NORMAL_POSITIVE关闭的变体组合状态。<br>同时，将当前状态的激活关键字（变体开关）组合与编译后的代码做映射，保存在编译结果中。</p>
<h3 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h3><p>根据当前的变体开关选择，映射到具体的代码。这里的映射方式与编译期的算法类似。比如，在材质类里面有一个hashmap， 保持变体状态组合到具体gpu program的映射。如果，hashmap内不存在这个映射，那么从编译期生成的代码内加载具体的编译后shader code，然后创建gpu program。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于需要在编译期就决定所有的状态组合，那么很可能会出现包体和内存爆炸的情况。比如，有10个开关，每个开关有2种状态，那么就是1024个变体，对应1024份代码。假设，一份代码的尺寸是10kb，那么就是10mb，有10个这样的材质，那么包体占用就是100mb，内存占用会更大。这就是游戏项目中常说的变体爆炸问题。</p>
<h1 id="动态变体"><a href="#动态变体" class="headerlink" title="动态变体"></a>动态变体</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p> 相比于传统变体，动态变体的最大优势是不会出现变体爆炸问题。在编译期间的编译结果，只有一份代码，同时保存变体定义信息。在运行时，二次编译生成真正的中间代码（spir-v）或者gpu上的汇编代码。</p>
<h2 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="编译期-1"><a href="#编译期-1" class="headerlink" title="编译期"></a>编译期</h3><p>不需要复杂的遍历算法，直接编译shader代码即可。但是，需要工具链或者图形API支持。比如，使用vulkan支持的Specialization Constants实现变体，那么可以在编译期保存Specialization Constants定义信息的同时，使用spirv-tools编译生成一份spir-v中间代码。</p>
<h3 id="运行时-1"><a href="#运行时-1" class="headerlink" title="运行时"></a>运行时</h3><p>加载这份编译后的代码，比如spir-v中间代码。针对，当前的变体设置，对spir-v进一步处理成指定的变体状态或者将变体设置提交给vulkan，让驱动去编译。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>这种方式会有一定的局限性，无法优化所有的情况。比如驱动可能有bug，无法优化掉一些复杂变体组合的情况或者一些复杂的代码，导致真正运行的代码有多余的指令，引起性能大幅度下降。</p>
<h1 id="Vulkan-Specialization-Constants变体"><a href="#Vulkan-Specialization-Constants变体" class="headerlink" title="Vulkan Specialization Constants变体"></a>Vulkan Specialization Constants变体</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>不同的图形API对动态变体的支持情况不一样，比如OpenGL不支持，Vulkan支持Specialization Constants，metal支持Function Constants。<br>这里专门指代基于Vulkan Specialization Constants实现的变体系统。</p>
<h2 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="使用Specialization-Constants实现材质代码"><a href="#使用Specialization-Constants实现材质代码" class="headerlink" title="使用Specialization Constants实现材质代码"></a>使用Specialization Constants实现材质代码</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">layout(constant_id = 0) const bool COLOR_RED = true;</span><br><span class="line">layout(constant_id = 1) const bool NORMAL_POSITIVE = true;</span><br><span class="line"></span><br><span class="line">float4 color;</span><br><span class="line">float3 normal;</span><br><span class="line"></span><br><span class="line">void setColorAndNormal() {</span><br><span class="line">if (COLOR_RED) {</span><br><span class="line">	color = float4(1, 0, 0, 1);</span><br><span class="line">}</span><br><span class="line">else {</span><br><span class="line">	color = float4(1, 1, 1, 1);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">if (NORMAL_POSITIVE) {</span><br><span class="line">	normal = float3(0, 1, 0);</span><br><span class="line">}</span><br><span class="line">else {</span><br><span class="line">	normal = float3(0, -1, 0);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>比如上述代码，定义了2个Specialization Constants变量：COLOR_RED和NORMAL_POSITIVE 。同时在代码内使用了这2个变量作为开关进行分支选择，注意：从语法上，Specialization Constants是作为变量处理，而不是宏。</p>
<h3 id="使用spirv-tools编译带有Specialization-Constants信息的材质代码"><a href="#使用spirv-tools编译带有Specialization-Constants信息的材质代码" class="headerlink" title="使用spirv-tools编译带有Specialization Constants信息的材质代码"></a>使用spirv-tools编译带有Specialization Constants信息的材质代码</h3><p>这一步与传统变体的区别是不需要遍历所有的变体状态组合，直接编译代码即可。对于，vulkan来说，使用glslang库调用spirv-tools编译代码就可以获得带有Specialization Constants信息的spir-v中间代码。</p>
<h3 id="运行时决定Specialization-Constants"><a href="#运行时决定Specialization-Constants" class="headerlink" title="运行时决定Specialization Constants"></a>运行时决定Specialization Constants</h3><p>上一步得到的是一份带有Specialization Constants信息的spir-v中间代码，如果获得最终的运行时代码了？</p>
<h4 id="变体组合映射gpu-program"><a href="#变体组合映射gpu-program" class="headerlink" title="变体组合映射gpu program"></a>变体组合映射gpu program</h4><p>这部分类似传统变体方案，需要将变体组合状态映射到具体的Specialization Constants设置。</p>
<h4 id="设置Specialization-Constants"><a href="#设置Specialization-Constants" class="headerlink" title="设置Specialization Constants"></a>设置Specialization Constants</h4><p>有两种实现思路，各有优劣，下面具体说明。<br><strong>1. 使用vulkan的Specialization Constants接口</strong><br>使用vulkan的Specialization Constants，在在vulkan的pipeline中传递运行时的Specialization Constants设置信息。因为Specialization Constants是PSO的一部分，因此这种方式需要重新编译gpu program和PSO。由于，不需要完整编译gpu program，因此与切换gpu program的方案（传统变体）这个方案会编译更快。</p>
<p><strong>2. 使用spirv-optimizer剔除分支</strong><br>第二种方式是使用spir-optimizer里面的pass处理spir-v中间代码，比如设置Specialization Constants的值后，剔除dead code和Specialization Constants信息等，直接获得最终不带Specialization Constants信息的spir-v。这个spir-v就可以直接传递vulkan创建gpu program。</p>
<p><strong>3. 两个方案对比</strong></p>
<ul>
<li>vulkan的Specialization Constants依赖驱动的JIT编译结果，如果驱动实现有问题，那么实际上Specialization Constants无法精准剔除代码，导致性能达不到预期。</li>
<li>spirv-optimizer剔除代码的方式，可以避免驱动的问题，在不同的驱动上表现一致；而且方便调试，比如可以在RenderDoc上抓取最终运行代码，或者mali offline compiler离线查看，确定最终运行的变体状态，但是这个方案依赖这个中间处理工具的能力。</li>
</ul>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><ul>
<li>依赖高级特性，在传统图形API上不支持。只能针对运行Vulkan的平台做优化。</li>
<li>一些复杂的情况无法兼容，比如高通驱动无法优化比较复杂的使用Specialization Constants的代码等，会出现明显性能下降；spirv-optimizer对于将Specialization Constants作为变量传递的代码无法识别等。</li>
<li>使用vulkan的Specialization Constants接口在驱动上进行JIT编译的方案，运行结果依赖具体硬件的驱动实现，结果不稳定。</li>
<li>使用spirv-optimizer剔除分支的方案需要额外的运行时处理时间，会引起切换变体卡顿，引擎需要妥善处理，比如异步调用spirv-optimizer，同时对优化后的spir-v缓存。</li>
</ul>
<h1 id="动态变体与传统变体的对比"><a href="#动态变体与传统变体的对比" class="headerlink" title="动态变体与传统变体的对比"></a>动态变体与传统变体的对比</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul>
<li>可以解决变体爆炸问题。</li>
<li>可能更快的编译PSO。</li>
</ul>
<h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><ul>
<li>跨平台差，需要高级图形API特性。</li>
<li>可能依赖硬件驱动实现。</li>
<li>可能引入运行时卡顿。</li>
</ul>
<h1 id="其它问题探讨"><a href="#其它问题探讨" class="headerlink" title="其它问题探讨"></a>其它问题探讨</h1><h2 id="变体收集"><a href="#变体收集" class="headerlink" title="变体收集"></a>变体收集</h2><p>变体收集是另一个经常讨论的问题。一般需要引擎支持才能实现完整的变体收集。下面讲一个之前实现过的方案。</p>
<ul>
<li>引擎runtime<br>引擎内有一个统一的ShaderProgramManger。该管理器内有2层hash，保存了所有材质和材质变体组合对应的gpu program。引擎内所有切换变体的操作最终都通过该类来查找gpu program。因此，该类完整收集了当前引擎运行状态下所有的变体组合。那么，可以在该类里面实现dump接口，遍历所有缓存的材质变体组合，输出文件作为变体集合文件。<br>实际项目中，可以用自动化系统运行常见的场景，在合适的时机调用dump接口进行收集。</li>
<li>变体集合编译<br>假如使用spirv-optimizer的方案实现动态变体，那么可以针对变体集合文件内的收集到的变体状态组合，提前编译出最终的spir-v。在ShaderProgramManger查找变体时候，判断有提前预编译的情况，可以直接加载，而不是去调用spirv-optimizer处理。</li>
</ul>
<h2 id="变体预热"><a href="#变体预热" class="headerlink" title="变体预热"></a>变体预热</h2><ul>
<li><p>变体切换<br>对于传统变体来说，就是根据变体设置查找相应的着色器代码；对于动态变体来说，可能需要对spir-v代码进行预处理。</p>
</li>
<li><p>编译PSO<br>对于使用vulkan的Specialization Constants接口的方案来说，gpu program已经确定，需要设置Specialization Constants，再重新编译PSO。这个过程实际上是对gpu program重新编译获得最终的版本，由于有之前的编译信息，会比编译完整的gpu program更快。<br>对于其它方案，实际上是编译完整的gpu program，与使用vulkan的Specialization Constants接口的方案对比，速度更慢。</p>
</li>
<li><p>实现思路<br>比如引擎可以加载变体集合文件，根据变体集合文件的描述，提前编译对应变体的代码以及PSO。</p>
</li>
</ul>
<h2 id="动态变体无法解决PSO编译的问题"><a href="#动态变体无法解决PSO编译的问题" class="headerlink" title="动态变体无法解决PSO编译的问题"></a>动态变体无法解决PSO编译的问题</h2><p>网上也有讨论Specialization Constants的文章，比如：<a href="https://zhuanlan.zhihu.com/p/678177922">【笔记】Shader变体大杀器：specialization constants</a>。该文章的评论里面提到Specialization Constants无法解决PSO的预热问题，从而对Specialization Constants进行了否定。实际上，这个是概念上的混淆。无论如何，PSO是需要重新编译的，因为最终的渲染状态数目是没有改变的；动态变体只是将确定最终gpu program的过程延迟到运行时决定，从而避免变体爆炸，并没有减少材质变体的状态总数。期望通过<br>Specialization Constants减少PSO数目或者加快PSO预热是方向上的错误。正确的思路是从PSO的收集缓存等方面来考虑，避免第一次切换到该PSO的卡顿。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">filament的材质系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-28 12:28:30" itemprop="dateCreated datePublished" datetime="2024-12-28T12:28:30+08:00">2024-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="filament的材质系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><p><a href="https://github.com/google/filament">filament</a>是Google开源的一个跨平台实时pbr渲染引擎。注意，这是一个渲染引擎，不是一个完整的游戏引擎。<br>filament的材质系统文档：<a href="https://google.github.io/filament/Materials.html">Filament Materials Guide</a>，pbr算法文档：<a href="https://google.github.io/filament/Filament.html">Physically Based Rendering in Filament</a>。这些文档只是从使用层面简单介绍材质系统和使用的PBR算法等，并没有深入介绍材质的整体流程和一些关键技术细节。因此，本文打算深入介绍材质系统相关的整体流程以及材质渲染相关的关键技术细节。</p>
<h1 id="一-材质编写"><a href="#一-材质编写" class="headerlink" title="一. 材质编写"></a>一. 材质编写</h1><p>这部分大概介绍下材质相关的语法。以下面的材质示例代码来说明：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">material {    </span><br><span class="line">    name : "Textured material",</span><br><span class="line">    requires : [ uv0, color ],    </span><br><span class="line">    shadingModel : lit,</span><br><span class="line">    blending : opaque,</span><br><span class="line">    parameters : [       </span><br><span class="line">        {    type : sampler2d,       name : baseColor        },    </span><br><span class="line">        {    type : float,           name : metallic       },     </span><br><span class="line">        {    type : float,           name : roughness      }</span><br><span class="line">    ],</span><br><span class="line">    constants : [</span><br><span class="line">        {</span><br><span class="line">           name : overrideAlpha,</span><br><span class="line">           type : bool</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">           name : customAlpha,</span><br><span class="line">           type : float,</span><br><span class="line">           default : 0.5</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">vertex {    </span><br><span class="line">    void materialVertex(inout MaterialVertexInputs material) { </span><br><span class="line">        material.color *= sin(getUserTime().x); </span><br><span class="line">        material.uv0 *= sin(getUserTime().x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fragment {  </span><br><span class="line">    void material(inout MaterialInputs material) { </span><br><span class="line">        prepareMaterial(material);</span><br><span class="line">        material.baseColor = texture(materialParams_baseColor, getUV0()); </span><br><span class="line">        material.metallic = materialParams.metallic;</span><br><span class="line">        material.roughness = materialParams.roughness;</span><br><span class="line">                </span><br><span class="line">                if (materialConstants_overrideAlpha) {</span><br><span class="line">            material.baseColor.a = materialConstants_customAlpha;</span><br><span class="line">            material.baseColor.rgb *= material.baseColor.a;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上述示例代码来看，一个材质分开三块：material、vertex、fragment。其中，material是材质熟悉块，vertex是顶点代码块，fragment是片元代码块。如果是一个compute材质，那么只有一个compute代码块。</p>
<h2 id="1-1-材质属性块"><a href="#1-1-材质属性块" class="headerlink" title="1.1 材质属性块"></a>1.1 材质属性块</h2><p>这部分包括所有的材质设置，比如渲染状态设置、材质的uniform参数以及各种其它设置。举例说明，blending是混合模式，是渲染状态设置；shadingModel是光照模型，类似一个材质变体设置；parameters则是uniform参数，比如float最终是存放在材质的uniform buffer内，而sampler2d是生成uniform sampler。</p>
<h2 id="1-2-代码块"><a href="#1-2-代码块" class="headerlink" title="1.2 代码块"></a>1.2 代码块</h2><p>filament的材质是一种surface材质。surface材质是一种受限制的材质，意思是一种只开放表面属性修改的材质，这种材质书写方式入门比较简单，但是功能比较受限制。unity的默认管线也支持surface材质，具体可以参考<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html">Introduction to surface shaders in the Built-In Render Pipeline</a>。</p>
<h3 id="1-2-1-顶点代码"><a href="#1-2-1-顶点代码" class="headerlink" title="1.2.1 顶点代码"></a>1.2.1 顶点代码</h3><p>vertex下的入口函数是materialVertex，只能在该函数内修改inout的MaterialVertexInputs参数material来定制顶点着色器。MaterialVertexInputs是顶点的输入定义结构体，定义如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct MaterialVertexInputs {</span><br><span class="line">#ifdef HAS_ATTRIBUTE_COLOR</span><br><span class="line">    vec4 color;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_UV0</span><br><span class="line">    vec2 uv0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_UV1</span><br><span class="line">    vec2 uv1;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM0</span><br><span class="line">    vec4 VARIABLE_CUSTOM0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM1</span><br><span class="line">    vec4 VARIABLE_CUSTOM1;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM2</span><br><span class="line">    vec4 VARIABLE_CUSTOM2;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM3</span><br><span class="line">    vec4 VARIABLE_CUSTOM3;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_TANGENTS</span><br><span class="line">    vec3 worldNormal;</span><br><span class="line">#endif</span><br><span class="line">    vec4 worldPosition;</span><br><span class="line">#ifdef VERTEX_DOMAIN_DEVICE</span><br><span class="line">#ifdef MATERIAL_HAS_CLIP_SPACE_TRANSFORM</span><br><span class="line">    mat4 clipSpaceTransform;</span><br><span class="line">#endif // MATERIAL_HAS_CLIP_SPACE_TRANSFORM</span><br><span class="line">#endif // VERTEX_DOMAIN_DEVICE</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>比如，color、uv0、uv1都是顶点属性。</p>
<h3 id="1-2-2-片元代码"><a href="#1-2-2-片元代码" class="headerlink" title="1.2.2 片元代码"></a>1.2.2 片元代码</h3><p>fragment也是类似的逻辑，入口函数是material，只能通过修改inout的MaterialInputs参数material来定制片元着色器。MaterialInputs结构体是pbr或者更复杂的渲染模型的属性，定义如下。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">struct MaterialInputs {</span><br><span class="line">    vec4  baseColor;</span><br><span class="line">#if !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">#if !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    float roughness;</span><br><span class="line">#endif</span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    float metallic;</span><br><span class="line">    float reflectance;</span><br><span class="line">#endif</span><br><span class="line">    float ambientOcclusion;</span><br><span class="line">#endif</span><br><span class="line">    vec4  emissive;</span><br><span class="line"></span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SUBSURFACE) &amp;&amp; !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">    vec3 sheenColor;</span><br><span class="line">    float sheenRoughness;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    float clearCoat;</span><br><span class="line">    float clearCoatRoughness;</span><br><span class="line"></span><br><span class="line">    float anisotropy;</span><br><span class="line">    vec3  anisotropyDirection;</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_SUBSURFACE) || defined(MATERIAL_HAS_REFRACTION)</span><br><span class="line">    float thickness;</span><br><span class="line">#endif</span><br><span class="line">#if defined(SHADING_MODEL_SUBSURFACE)</span><br><span class="line">    float subsurfacePower;</span><br><span class="line">    vec3  subsurfaceColor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_CLOTH)</span><br><span class="line">    vec3  sheenColor;</span><br><span class="line">#if defined(MATERIAL_HAS_SUBSURFACE_COLOR)</span><br><span class="line">    vec3  subsurfaceColor;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    vec3  specularColor;</span><br><span class="line">    float glossiness;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_NORMAL)</span><br><span class="line">    vec3  normal;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_BENT_NORMAL)</span><br><span class="line">    vec3  bentNormal;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_CLEAR_COAT) &amp;&amp; defined(MATERIAL_HAS_CLEAR_COAT_NORMAL)</span><br><span class="line">    vec3  clearCoatNormal;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_POST_LIGHTING_COLOR)</span><br><span class="line">    vec4  postLightingColor;</span><br><span class="line">    float postLightingMixFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SUBSURFACE) &amp;&amp; !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">#if defined(MATERIAL_HAS_REFRACTION)</span><br><span class="line">#if defined(MATERIAL_HAS_ABSORPTION)</span><br><span class="line">    vec3 absorption;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_TRANSMISSION)</span><br><span class="line">    float transmission;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_IOR)</span><br><span class="line">    float ior;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_MICRO_THICKNESS) &amp;&amp; (REFRACTION_TYPE == REFRACTION_TYPE_THIN)</span><br><span class="line">    float microThickness;</span><br><span class="line">#endif</span><br><span class="line">#elif !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">#if defined(MATERIAL_HAS_IOR)</span><br><span class="line">    float ior;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_SPECULAR_FACTOR)</span><br><span class="line">    float specularFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_SPECULAR_COLOR_FACTOR)</span><br><span class="line">    vec3 specularColorFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>因此，只需要简单的在入口函数内修改属性，就可以便捷的实现材质效果。</p>
<h3 id="1-2-3-compute代码块"><a href="#1-2-3-compute代码块" class="headerlink" title="1.2.3 compute代码块"></a>1.2.3 compute代码块</h3><p>如果使用的是compute材质，那么代码块是compute代码块。示例如下：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">material {</span><br><span class="line">    name: testCompute,</span><br><span class="line">    domain: compute,</span><br><span class="line">    groupSize: [32, 32, 1],</span><br><span class="line">    parameters: [</span><br><span class="line">        {type : sampler2d, name : color}</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">compute {</span><br><span class="line">    void compute() {</span><br><span class="line">        int3 id = int3(getGlobalInvocationID());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="二-材质编译"><a href="#二-材质编译" class="headerlink" title="二. 材质编译"></a>二. 材质编译</h1><p>filament有一个专门的材质编译工具matc。该工具主要做了两件事情：一个是解析material材质属性块，根据材质属性块生成代码，需要序列化的材质属性写入材质属性数据块中；一个是编译材质代码，将编译后的所有的变体代码写入到代码数据块中。<br>整体流程图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/filament材质编译流程.png"></p>
<h2 id="2-1-材质属性编译"><a href="#2-1-材质属性编译" class="headerlink" title="2.1 材质属性编译"></a>2.1 材质属性编译</h2><p>材质属性，指定是material块内的定义。材质属性主要包括两类，生成代码的属性和其它属性。生成代码的属性包括parameters和constants属性，parameters和constants属性会生成代码定义，同时也会进行序列化；而其它类型的材质属性会在解析后进行序列化。</p>
<h3 id="2-1-1-parameters属性"><a href="#2-1-1-parameters属性" class="headerlink" title="2.1.1 parameters属性"></a>2.1.1 parameters属性</h3><p>parameters块内定义的属性，type指定类型，主要是两类：数值类型和采样器类型。最终，所有的数值类型会存放到一个着材质实例的uniform buffer内。而每个采样器类型的参数，都会生成一个着材质实例的uniform sampler。</p>
<h3 id="2-1-2-其它属性"><a href="#2-1-2-其它属性" class="headerlink" title="2.1.2 其它属性"></a>2.1.2 其它属性</h3><p>这部分属性包括，材质渲染状态设置、光照模型相关等。对于编译器来说，这部分设置解析出来后再序列化就行。</p>
<h2 id="2-2-材质代码编译"><a href="#2-2-材质代码编译" class="headerlink" title="2.2 材质代码编译"></a>2.2 材质代码编译</h2><h3 id="2-2-1-生成材质属性定义"><a href="#2-2-1-生成材质属性定义" class="headerlink" title="2.2.1 生成材质属性定义"></a>2.2.1 生成材质属性定义</h3><p>示例代码的parameters生成的ubo定义可能如下：</p>
<ol>
<li><strong>Uniform Buffer生成</strong></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout(binding = 10, std140, set = 1) uniform MaterialParams {</span><br><span class="line">    float metallic;</span><br><span class="line">    float roughness;</span><br><span class="line">} materialParams;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>Uniform Sampler生成</strong><br>示例代码的parameters生成的uniform sampler定义可能如下：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout(binding = 10, set = 2) uniform lowp sampler2D materialParams_baseColor;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>Specialization Constants生成</strong><br>示例代码的constants生成的specialization constants定义可能如下</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout (constant_id = 8) const bool materialConstants_overrideAlpha = false;</span><br><span class="line">layout (constant_id = 9) const float materialConstants_customAlpha = 0.500000;</span><br></pre></td></tr></tbody></table></figure>
<p>至于什么是<strong>specialization constants</strong>，请参考文档：<a href="https://docs.vulkan.org/samples/latest/samples/performance/specialization_constants/README.htm">Utilizing Specialization Constants</a>。简而言之，这是一种将编译器的预处理阶段的宏延迟到gpu编译阶段的手段。</p>
<h1 id="三-材质加载和材质实例创建"><a href="#三-材质加载和材质实例创建" class="headerlink" title="三. 材质加载和材质实例创建"></a>三. 材质加载和材质实例创建</h1><h2 id="3-1-整体介绍"><a href="#3-1-整体介绍" class="headerlink" title="3.1 整体介绍"></a>3.1 整体介绍</h2><p>这部分主要涉及三个类，材质类Material、材质示例类MaterialInstance、材质解析类MaterialParser。Material类对应的是Unity的Shader类，MaterialInstance类对应的是Unity的Material类。整体流程如下：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/filament材质加载和材质实例创建.png"></p>
<h2 id="3-2-材质创建"><a href="#3-2-材质创建" class="headerlink" title="3.2 材质创建"></a>3.2 材质创建</h2><h3 id="3-2-1-数据解析"><a href="#3-2-1-数据解析" class="headerlink" title="3.2.1 数据解析"></a>3.2.1 数据解析</h3><ol>
<li><strong>MaterialParser</strong><br>材质创建的第一步是解析二进制的材质数据，即材质编译阶段序列化各种数据块，包括材质属性数据块以及材质代码数据块。该类的parse函数会遍历解析出所有的数据Chunk，保存起来作为后续真正的数据解析使用。</li>
<li><strong>兼容检测</strong><br>将所有的数据块全部加载到内存中后，再做一些基本的检测，比如材质版本号匹配、shaderModel（平台）匹配等，如果通过才真正去创建材质。<h3 id="3-2-2-创建材质对象"><a href="#3-2-2-创建材质对象" class="headerlink" title="3.2.2 创建材质对象"></a>3.2.2 创建材质对象</h3>材质数据加载后，并且通过兼容性检测后，会调用engine的createMaterial函数去创建材质对象。filament的所有gpu相关对象最终都是通过engine类来创建管理的。<h3 id="3-2-3-初始化材质属性"><a href="#3-2-3-初始化材质属性" class="headerlink" title="3.2.3 初始化材质属性"></a>3.2.3 初始化材质属性</h3>在FMaterial类的构造函数内，会通过调用MaterialParser的具体解析函数，将所有材质数据属性解析出来，然后做好相应的运行时状态初始化。</li>
<li><strong>描述集Layout</strong><br>材质内有两个DescriptorSetLayout，一个是材质本身的DescriptorSetLayout，一个是PerView的DescriptorSetLayout。这两个layout是用于提交材质级别和PerView级别的数据。材质本身的DescriptorSetLayout用于后续初始化材质实例的DescriptorSet；材质实例的DescriptorSet用于提交材质数据。</li>
<li><strong>SpecializationConstants</strong><br>specializationConstants是一种新的动态变体技术，具体在生成材质属性定义里面有介绍。在材质解析阶段，需要解析出材质的specializationConstants设置，然后在切换材质变体时候通过传递给对应的gpu program进行切换。<br>filament的specializationConstants变体问题<br>filament将specializationConstants数据保存在材质内，会导致设置时候引起该材质所有的材质实例变化。这并不喝了，因为变体从使用上是材质实例级别的，不同的材质实例需要保存不同的变体设置，所以应该通过材质实例来保存和设置变体数据。</li>
<li><strong>pushConstants</strong><br>关于什么是pushConstants ，参考文档：Push Constants。简单理解，即这是一块区分于UBO的小数据块，相比UBO有一定的性能优势，但是大小受限制。<br>实际上，当前版本的filament只是用pushConstants处理了引擎morphing数据，并没有开放材质级别的写法。如下代码，<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">utils::FixedCapacityVector&lt;filament::MaterialPushConstant&gt; const PUSH_CONSTANTS = {</span><br><span class="line">    {</span><br><span class="line">        "morphingBufferOffset",</span><br><span class="line">        filament::backend::ConstantType::INT,</span><br><span class="line">        filament::backend::ShaderStage::VERTEX,</span><br><span class="line">    },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
材质文件固定序列化上述代码的pushConstants。</li>
<li><strong>其它属性</strong><br>其它属性涉及范围比较广，比如渲染状态的设置，包括深度测试/写入、混合、模板测试等，也包括材质相关的设置，比如材质效果相关的设置等。这些属性都会序列化为数据块，然后在材质创建时候，通过MaterialParser解析出来保存在材质内。<h2 id="3-3-材质实例创建"><a href="#3-3-材质实例创建" class="headerlink" title="3.3 材质实例创建"></a>3.3 材质实例创建</h2>创建材质实例有两种路径，但是初始化流程是一致的，都是初始化描述集和其它材质属性。</li>
<li><strong>初始化描述集</strong><br>材质实例的DescriptorSet通过材质的DescriptorSetLayout进行初始化。材质实例使用该DescriptorSet进行数据的提交和绑定，包括Sampler和Uniform Buffer。因此，需要在初始化阶段将材质Uniform Buffer的通过调用setBuffer设置给DescriptorSet。</li>
<li><strong>初始化其它材质属性</strong><br>其它材质属性，基本是通过从材质或者其它材质实例内拷贝的方式设置的。这些存储在材质实例内的材质属性，通常与渲染状态或者渲染效果相关，比如混合、深度测试/写入等。</li>
</ol>
<h1 id="四-材质变体"><a href="#四-材质变体" class="headerlink" title="四. 材质变体"></a>四. 材质变体</h1><p>filament支持基于宏的传统变体，即每一个变体是一个gpu program。在编译材质时候，根据不同的宏定义组合编译出不同的gpu program；在运行阶段，根据stage和变体匹配到对应的gpu program。</p>
<h2 id="4-1-变体定义"><a href="#4-1-变体定义" class="headerlink" title="4.1 变体定义"></a>4.1 变体定义</h2><h3 id="4-1-1-Surface材质变体"><a href="#4-1-1-Surface材质变体" class="headerlink" title="4.1.1 Surface材质变体"></a>4.1.1 Surface材质变体</h3><p>filament有一个Variant类，里面定义了Surface材质可以使用的变体。如下摘自其变体注释代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// DIR: Directional Lighting</span><br><span class="line">// DYN: Dynamic Lighting</span><br><span class="line">// SRE: Shadow Receiver</span><br><span class="line">// SKN: Skinning</span><br><span class="line">// DEP: Depth only</span><br><span class="line">// FOG: Fog</span><br><span class="line">// PCK: Picking (depth variant only)</span><br><span class="line">// VSM: Variance shadow maps</span><br><span class="line">// STE: Instanced stereo rendering</span><br><span class="line">//</span><br><span class="line">//   X: either 1 or 0</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">// Variant              | STE | VSM | FOG | DEP | SKN | SRE | DYN | DIR |   256</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                                    PCK</span><br><span class="line">//</span><br><span class="line">// Standard variants:</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                      | STE | VSM | FOG |  0  | SKN | SRE | DYN | DIR |    128 - 44 = 84</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//      Vertex shader      X     0     0     0     X     X     X     X</span><br><span class="line">//    Fragment shader      0     X     X     0     0     X     X     X</span><br><span class="line">//       Fragment SSR      0     1     0     0     0     1     0     0</span><br><span class="line">//           Reserved      X     1     1     0     X     1     0     0      [ -4]</span><br><span class="line">//           Reserved      X     0     X     0     X     1     0     0      [ -8]</span><br><span class="line">//           Reserved      X     1     X     0     X     0     X     X      [-32]</span><br><span class="line">//</span><br><span class="line">// Depth variants:</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                      | STE | VSM | PCK |  1  | SKN |  0  |  0  |  0  |   16 - 4 = 12</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//       Vertex depth      X     X     0     1     X     0     0     0</span><br><span class="line">//     Fragment depth      0     X     X     1     0     0     0     0</span><br><span class="line">//           Reserved      X     1     1     1     X     0     0     0     [  -4]</span><br><span class="line">//</span><br><span class="line">// 96 variants used, 160 reserved (256 - 96)</span><br><span class="line">//</span><br><span class="line">// note: a valid variant can be neither a valid vertex nor a valid fragment variant</span><br><span class="line">//       (e.g.: FOG|SKN variants), the proper bits are filtered appropriately,</span><br><span class="line">//       see filterVariantVertex(), filterVariantFragment().</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>8位变体</li>
<li>顶点和片元的变体是分开的</li>
<li>X表示该变体位可以切换，1或者0表示只能设置为固定值。</li>
<li>Reserved是无效的变体组合。<h3 id="4-1-2-PostProcess材质变体"><a href="#4-1-2-PostProcess材质变体" class="headerlink" title="4.1.2 PostProcess材质变体"></a>4.1.2 PostProcess材质变体</h3></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static constexpr size_t POST_PROCESS_VARIANT_BITS = 1;</span><br><span class="line">static constexpr size_t POST_PROCESS_VARIANT_COUNT = (1u &lt;&lt; POST_PROCESS_VARIANT_BITS);</span><br><span class="line">static constexpr size_t POST_PROCESS_VARIANT_MASK = POST_PROCESS_VARIANT_COUNT - 1;</span><br><span class="line"></span><br><span class="line">enum class PostProcessVariant : uint8_t {</span><br><span class="line">    OPAQUE,</span><br><span class="line">    TRANSLUCENT</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>根据上述定义，后处理材质支持2个变体。</p>
<h3 id="4-1-3-Compute材质变体"><a href="#4-1-3-Compute材质变体" class="headerlink" title="4.1.3 Compute材质变体"></a>4.1.3 Compute材质变体</h3><p>compute材质不支持变体切换。</p>
<h2 id="4-2-变体编译"><a href="#4-2-变体编译" class="headerlink" title="4.2 变体编译"></a>4.2 变体编译</h2><ol>
<li><strong>计算所有有效变体组合</strong></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Generate all shaders and write the shader chunks.</span><br><span class="line"></span><br><span class="line">std::vector&lt;Variant&gt; variants;</span><br><span class="line">switch (mMaterialDomain) {</span><br><span class="line">    case MaterialDomain::SURFACE:</span><br><span class="line">        variants = determineSurfaceVariants(mVariantFilter, isLit(), mShadowMultiplier);</span><br><span class="line">        break;</span><br><span class="line">    case MaterialDomain::POST_PROCESS:</span><br><span class="line">        variants = determinePostProcessVariants();</span><br><span class="line">        break;</span><br><span class="line">    case MaterialDomain::COMPUTE:</span><br><span class="line">        variants = determineComputeVariants();</span><br><span class="line">        break;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>determineSurfaceVariants函数是跟Variant类的定义，遍历出所有有效的顶点变体和片元变体。determinePostProcessVariants则是返回2个固定的顶点和片元变体。determineComputeVariants返回默认的一个0变体。</p>
<ol>
<li><strong>根据变体组合生成宏定义</strong><br>材质编译工具的代码生成类ShaderGenerator里面有一个generateSurfaceMaterialVariantDefines函数，该函数会根据变体组合variant来生成对应的宏定义。其部分代码如下：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void ShaderGenerator::generateSurfaceMaterialVariantDefines(utils::io::sstream&amp; out,</span><br><span class="line">        ShaderStage stage, MaterialBuilder::FeatureLevel featureLevel,</span><br><span class="line">        MaterialInfo const&amp; material, filament::Variant variant) noexcept {</span><br><span class="line"></span><br><span class="line">    bool const litVariants = material.isLit || material.hasShadowMultiplier;</span><br><span class="line"></span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_DIRECTIONAL_LIGHTING",</span><br><span class="line">            litVariants &amp;&amp; variant.hasDirectionalLighting());</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_DYNAMIC_LIGHTING",</span><br><span class="line">            litVariants &amp;&amp; variant.hasDynamicLighting());</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_SHADOWING",</span><br><span class="line">            litVariants &amp;&amp; filament::Variant::isShadowReceiverVariant(variant));</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_VSM",</span><br><span class="line">            filament::Variant::isVSMVariant(variant));</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_STEREO",</span><br><span class="line">            hasStereo(variant, featureLevel));</span><br><span class="line"></span><br><span class="line">    switch (stage) {</span><br><span class="line">        case ShaderStage::VERTEX:</span><br><span class="line">        CodeGenerator::generateDefine(out, "VARIANT_HAS_SKINNING_OR_MORPHING",</span><br><span class="line">                hasSkinningOrMorphing(variant, featureLevel));</span><br><span class="line">            break;</span><br><span class="line">        case ShaderStage::FRAGMENT:</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_FOG",</span><br><span class="line">                    filament::Variant::isFogVariant(variant));</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_PICKING",</span><br><span class="line">                    filament::Variant::isPickingVariant(variant));</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_SSR",</span><br><span class="line">                    filament::Variant::isSSRVariant(variant));</span><br><span class="line">            break;</span><br><span class="line">        case ShaderStage::COMPUTE:</span><br><span class="line">            break;</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>所有的宏定义组合就对应一个变体组合的program。</p>
<h2 id="4-3-变体切换"><a href="#4-3-变体切换" class="headerlink" title="4.3 变体切换"></a>4.3 变体切换</h2><p>变体编译阶段是根据材质类型、Stage（顶点/片元）、变体组合来生成对应的program的。因此，变体切换阶段，也是根据这些信息查找出对应的program代码。然后，使用这个代码（比如SPIR-V中间代码）来创建gpu program。<br>部分关键代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void FMaterial::prepareProgramSlow(Variant variant,</span><br><span class="line">        backend::CompilerPriorityQueue priorityQueue) const noexcept {</span><br><span class="line">    assert_invariant(mEngine.hasFeatureLevel(mFeatureLevel));</span><br><span class="line">    switch (getMaterialDomain()) {</span><br><span class="line">        case MaterialDomain::SURFACE:</span><br><span class="line">            getSurfaceProgramSlow(variant, priorityQueue);</span><br><span class="line">            break;</span><br><span class="line">        case MaterialDomain::POST_PROCESS:</span><br><span class="line">            getPostProcessProgramSlow(variant, priorityQueue);</span><br><span class="line">            break;</span><br><span class="line">        case MaterialDomain::COMPUTE:</span><br><span class="line">            // TODO: implement MaterialDomain::COMPUTE</span><br><span class="line">            break;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool MaterialChunk::getBinaryShader(BlobDictionary const&amp; dictionary,</span><br><span class="line">        ShaderContent&amp; shaderContent, ShaderModel shaderModel, filament::Variant variant, ShaderStage shaderStage) {</span><br><span class="line"></span><br><span class="line">    if (mBase == nullptr) {</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    uint32_t key = makeKey(shaderModel, variant, shaderStage);</span><br><span class="line">    auto pos = mOffsets.find(key);</span><br><span class="line">    if (pos == mOffsets.end()) {</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shaderContent = dictionary[pos-&gt;second];</span><br><span class="line">    return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>getSurfaceProgramSlow最终会调用到MaterialChunk::getBinaryShader从二进制材质数据中查找出指定变体的二进制代码。makeKey函数的参数是shaderModel（平台）、variant、shaderStage，这个key就是变体查找的键值。</p>
<h2 id="4-4-变体使用"><a href="#4-4-变体使用" class="headerlink" title="4.4 变体使用"></a>4.4 变体使用</h2><p>filament的变体使用方式分为三步：</p>
<ol>
<li><strong>计算变体组合</strong><br>这一步通常是渲染管线或者渲染Pass在计算。比如，ColorPass或者DepthPass、PickingPass等。</li>
<li><strong>prepareProgram</strong><br>使用第一步计算出的变体调用材质函数的prepareProgram以准备变体。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void prepareProgram(Variant variant,</span><br><span class="line">        backend::CompilerPriorityQueue priorityQueue = CompilerPriorityQueue::HIGH) const noexcept {</span><br><span class="line">    if (UTILS_UNLIKELY(!isCached(variant))) {</span><br><span class="line">        prepareProgramSlow(variant, priorityQueue);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>getProgram</strong><br>使用第一步计算出的变体调用材质函数的getProgram获得对应变体的program的handle。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backend::Handle&lt;backend::HwProgram&gt; getProgram(Variant variant) const noexcept {</span><br><span class="line">    assert_invariant(mCachedPrograms[variant.key]);</span><br><span class="line">    return mCachedPrograms[variant.key];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pipeline.program = ma-&gt;getProgram(info.materialVariant);</span><br></pre></td></tr></tbody></table></figure>
<p>然后将获得的program赋值给pipeline的program。</p>
<h2 id="4-5-再谈SpecializationConstants变体"><a href="#4-5-再谈SpecializationConstants变体" class="headerlink" title="4.5 再谈SpecializationConstants变体"></a>4.5 再谈SpecializationConstants变体</h2><h3 id="4-5-1-filament变体的问题"><a href="#4-5-1-filament变体的问题" class="headerlink" title="4.5.1 filament变体的问题"></a>4.5.1 filament变体的问题</h3><p>根据前述变体使用的步骤，在使用filament的变体时候并不方便。</p>
<pre><code>1. 首先，变体设置是需要在外部计算的。
2. 其次，变体设置并没有保存在材质实例内，反而需要外部代码保存。
3.从使用角度上来说，应该在材质实例内保存其对应的variant，然后一个材质实例对应一个program才更方便理解。
</code></pre><h3 id="4-5-2-filament的SpecializationConstants变体问题"><a href="#4-5-2-filament的SpecializationConstants变体问题" class="headerlink" title="4.5.2 filament的SpecializationConstants变体问题"></a>4.5.2 filament的SpecializationConstants变体问题</h3><p>filament的specializationConstants变体也存在类似的问题。specializationConstants变体是通过传入设置数据给gpu program对象来生效的，而且specializationConstants变体的设置还存在在材质内。</p>
<h3 id="4-5-3-优化思路"><a href="#4-5-3-优化思路" class="headerlink" title="4.5.3 优化思路"></a>4.5.3 优化思路</h3><p>因此，比较好的优化方向是将variant和specializationConstants的状态都保存在材质实例内；然后，通过材质实例来从材质中获得不同的program和设置不同的specializationConstants数据。</p>
<h1 id="五-渲染数据的提交和绑定"><a href="#五-渲染数据的提交和绑定" class="headerlink" title="五. 渲染数据的提交和绑定"></a>五. 渲染数据的提交和绑定</h1><p>最后再来讲一讲渲染使用的数据提交和绑定。渲染数据一般指定是Buffer和Sampler，也包括其它一些特殊数据，比如SpecializationConstants和pushConstants。从作用范围上来区分，渲染数据一般能分为三个级别，渲染当前pass要使用的全局数据、当前使用材质的数据、当前drawcall对应的物体的数据。<br>DescriptorSet<br>首先，需要明确filament提交和绑定Buffer和Sampler数据的封装类DescriptorSet。filament通过该类提交和绑定Buffer和Sampler。因此，后续三个级别的数据提交都是通过对该类的封装进行。</p>
<h2 id="5-1-渲染Pass数据提交和绑定"><a href="#5-1-渲染Pass数据提交和绑定" class="headerlink" title="5.1 渲染Pass数据提交和绑定"></a>5.1 渲染Pass数据提交和绑定</h2><p>通常是封装一个Pass级别的数据提交类，比如ColorPassDescriptorSet、PostProcessDescriptorSet、SsrPassDescriptorSet。这些类里面有一个DescriptorSet对象用于真正的数据提交和绑定。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class PostProcessDescriptorSet {</span><br><span class="line">public:</span><br><span class="line">    explicit PostProcessDescriptorSet() noexcept;</span><br><span class="line"></span><br><span class="line">    void init(FEngine&amp; engine) noexcept;</span><br><span class="line"></span><br><span class="line">    void terminate(HwDescriptorSetLayoutFactory&amp; factory, backend::DriverApi&amp; driver);</span><br><span class="line"></span><br><span class="line">    void setFrameUniforms(backend::DriverApi&amp; driver,</span><br><span class="line">            TypedUniformBuffer&lt;PerViewUib&gt;&amp; uniforms) noexcept;</span><br><span class="line"></span><br><span class="line">    void bind(backend::DriverApi&amp; driver) noexcept;</span><br><span class="line"></span><br><span class="line">    DescriptorSetLayout const&amp; getLayout() const noexcept {</span><br><span class="line">        return mDescriptorSetLayout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DescriptorSetLayout mDescriptorSetLayout;</span><br><span class="line">    DescriptorSet mDescriptorSet;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void PostProcessManager::setFrameUniforms(backend::DriverApi&amp; driver,</span><br><span class="line">        TypedUniformBuffer&lt;PerViewUib&gt;&amp; uniforms) noexcept {</span><br><span class="line">    mPostProcessDescriptorSet.setFrameUniforms(driver, uniforms);</span><br><span class="line">    mSsrPassDescriptorSet.setFrameUniforms(uniforms);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void PostProcessManager::bindPostProcessDescriptorSet(backend::DriverApi&amp; driver) const noexcept {</span><br><span class="line">    mPostProcessDescriptorSet.bind(driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>后处理Pass会在适当的时候调用相关函数进行数据提交和绑定，一般是在Pass的最开始进行设置。<br>实际上，一些数据是全局的，可以一次设置后不用改变。所以，Pass级别的数据不一定完全遵守Pass级别的作用域。比如，PostProcessDescriptorSet的setFrameUniforms实际上是在renderJob一开始就调用了，如下代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void FRenderer::renderJob(RootArenaScope&amp; rootArenaScope, FView&amp; view) {</span><br><span class="line">    FEngine&amp; engine = mEngine;</span><br><span class="line">    JobSystem&amp; js = engine.getJobSystem();</span><br><span class="line">    FEngine::DriverApi&amp; driver = engine.getDriverApi();</span><br><span class="line">    PostProcessManager&amp; ppm = engine.getPostProcessManager();</span><br><span class="line">    ppm.setFrameUniforms(driver, view.getFrameUniforms());</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-2-材质数据提交和绑定"><a href="#5-2-材质数据提交和绑定" class="headerlink" title="5.2 材质数据提交和绑定"></a>5.2 材质数据提交和绑定</h2><p>所有的渲染Pass都必须使用材质，渲染物体的Pass需要切换材质，后处理Pass则是使用一个材质。材质数据的使用也是需要有时机的。材质数据实际上会覆盖Pass级别的数据的设置，如果有重复的话；不过，按照filament的定义，这两部分数据是不会互相影响的，因为使用的是不同的DescriptorSetLayout。实际上，filament定义pipeline里面已经对PerView和PerMaterial的DescriptorSetLayout做了区分。PerView的layout就是前面所说的渲染Pass级别的数据。代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">struct PipelineLayout {</span><br><span class="line">    using SetLayout = std::array&lt;Handle&lt;HwDescriptorSetLayout&gt;, MAX_DESCRIPTOR_SET_COUNT&gt;;</span><br><span class="line">    SetLayout setLayout;      // 16</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct PipelineState {</span><br><span class="line">    Handle&lt;HwProgram&gt; program;                                              //  4</span><br><span class="line">    Handle&lt;HwVertexBufferInfo&gt; vertexBufferInfo;                            //  4</span><br><span class="line">    PipelineLayout pipelineLayout;                                          // 16</span><br><span class="line">    RasterState rasterState;                                                //  4</span><br><span class="line">    StencilState stencilState;                                              // 12</span><br><span class="line">    PolygonOffset polygonOffset;                                            //  8</span><br><span class="line">    PrimitiveType primitiveType = PrimitiveType::TRIANGLES;                 //  1</span><br><span class="line">    uint8_t padding[3] = {};                                                //  3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">static constexpr size_t MAX_DESCRIPTOR_SET_COUNT    = 4;    // This is guaranteed by Vulkan.</span><br><span class="line"></span><br><span class="line">enum class DescriptorSetBindingPoints : uint8_t {</span><br><span class="line">    PER_VIEW        = 0,</span><br><span class="line">    PER_RENDERABLE  = 1,</span><br><span class="line">    PER_MATERIAL    = 2,</span><br><span class="line">};</span><br><span class="line">在RenderPass执行时候渲染Command时候，给pipepline同时绑定PER_VIEW和PER_MATERIAL的layout。</span><br><span class="line">// Each material has its own version of the per-view descriptor-set layout,</span><br><span class="line">// because it depends on the material features (e.g. lit/unlit)</span><br><span class="line">pipeline.pipelineLayout.setLayout[+DescriptorSetBindingPoints::PER_VIEW] =</span><br><span class="line">        ma-&gt;getPerViewDescriptorSetLayout(info.materialVariant).getHandle();</span><br><span class="line"></span><br><span class="line">// Each material has a per-material descriptor-set layout which encodes the</span><br><span class="line">// material's parameters (ubo and samplers)</span><br><span class="line">pipeline.pipelineLayout.setLayout[+DescriptorSetBindingPoints::PER_MATERIAL] =</span><br><span class="line">        ma-&gt;getDescriptorSetLayout().getHandle();</span><br><span class="line">5.2.1 材质commit数据</span><br><span class="line">void FEngine::prepare() {</span><br><span class="line">    FEngine::DriverApi&amp; driver = getDriverApi();</span><br><span class="line"></span><br><span class="line">    for (auto&amp; materialInstanceList: mMaterialInstances) {</span><br><span class="line">        materialInstanceList.second.forEach([&amp;driver](FMaterialInstance* item) {</span><br><span class="line">            item-&gt;commit(driver);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void PostProcessManager::commitAndRenderFullScreenQuad(backend::DriverApi&amp; driver,</span><br><span class="line">        FrameGraphResources::RenderPassInfo const&amp; out, FMaterialInstance const* mi,</span><br><span class="line">        PostProcessVariant variant) const noexcept {</span><br><span class="line">    mi-&gt;commit(driver);</span><br><span class="line">    mi-&gt;use(driver);</span><br><span class="line">    FMaterial const* const ma = mi-&gt;getMaterial();</span><br><span class="line">    PipelineState const pipeline = getPipelineState(ma, variant);</span><br><span class="line"></span><br><span class="line">    assert_invariant(</span><br><span class="line">            ((out.params.readOnlyDepthStencil &amp; RenderPassParams::READONLY_DEPTH)</span><br><span class="line">             &amp;&amp; !pipeline.rasterState.depthWrite)</span><br><span class="line">            || !(out.params.readOnlyDepthStencil &amp; RenderPassParams::READONLY_DEPTH));</span><br><span class="line"></span><br><span class="line">    driver.beginRenderPass(out.target, out.params);</span><br><span class="line">    driver.draw(pipeline, mFullScreenQuadRph, 0, 3, 1);</span><br><span class="line">    driver.endRenderPass();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void FMaterialInstance::commit(DriverApi&amp; driver) const {</span><br><span class="line">    // update uniforms if needed</span><br><span class="line">    if (mUniforms.isDirty()) {</span><br><span class="line">        driver.updateBufferObject(mUbHandle, mUniforms.toBufferDescriptor(driver), 0);</span><br><span class="line">    }</span><br><span class="line">    // Commit descriptors if needed (e.g. when textures are updated,or the first time)</span><br><span class="line">    mDescriptorSet.commit(mMaterial-&gt;getDescriptorSetLayout(), driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>prepare是在FRenderer::beginFrame里面调用的，即每帧开始时候会提交所有的材质实例数据，实际上这里主要是非处理材质，后处理材质是在commitAndRenderFullScreenQuad内提交的。commit内做了两件事情，一个是更新UBO数据，一个是通过DescriptorSet进行commit。</p>
<h3 id="5-2-2-材质绑定数据"><a href="#5-2-2-材质绑定数据" class="headerlink" title="5.2.2 材质绑定数据"></a>5.2.2 材质绑定数据</h3><p>绑定材质数据是通过调用材质实例的use函数。材质绑定数据要在调用drawcall函数之前，比如renderpass里面就必须在执行每个command的drawcall前绑定，后处理这种Pass则需要在最终执行渲染drawcall之前绑定数据，可以参考commitAndRenderFullScreenQuad函数代码。下面代码段是RenderPass内绑定材质数据的代码：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (UTILS_UNLIKELY(mi != info.mi)) {</span><br><span class="line">    // this is always taken the first time</span><br><span class="line">    assert_invariant(info.mi);</span><br><span class="line"></span><br><span class="line">    mi = info.mi;</span><br><span class="line">    ...</span><br><span class="line">    // Each MaterialInstance has its own descriptor set. This binds it.</span><br><span class="line">    mi-&gt;use(driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>上述代码在RenderPass::Executor::execute内执行command的一段，可以看到在材质实例变化时候，会调用材质实例的use函数绑定不同的材质级别数据。</p>
<h2 id="5-3-Renderable数据提交和绑定"><a href="#5-3-Renderable数据提交和绑定" class="headerlink" title="5.3 Renderable数据提交和绑定"></a>5.3 Renderable数据提交和绑定</h2><p>同一个渲染Pass的Command，可以包括多个材质实例；同一个材质实例，可以渲染多个物体。因此，物体级别的数据优先级别是最高的。</p>
<h3 id="5-3-1-初始化Renderble数据"><a href="#5-3-1-初始化Renderble数据" class="headerlink" title="5.3.1 初始化Renderble数据"></a>5.3.1 初始化Renderble数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct PrimitiveInfo { // 56 bytes</span><br><span class="line">    union {</span><br><span class="line">        FMaterialInstance const* mi;</span><br><span class="line">        uint64_t padding; // make this field 64 bits on all platforms</span><br><span class="line">    };</span><br><span class="line">    backend::RenderPrimitiveHandle rph;                 // 4 bytes</span><br><span class="line">    backend::VertexBufferInfoHandle vbih;               // 4 bytes</span><br><span class="line">    backend::DescriptorSetHandle dsh;                   // 4 bytes</span><br><span class="line">    uint32_t indexOffset;                               // 4 bytes</span><br><span class="line">    uint32_t indexCount;                                // 4 bytes</span><br><span class="line">    uint32_t index = 0;                                 // 4 bytes</span><br><span class="line">    uint32_t skinningOffset = 0;                        // 4 bytes</span><br><span class="line">    uint32_t morphingOffset = 0;                        // 4 bytes</span><br><span class="line"></span><br><span class="line">    backend::RasterState rasterState;                   // 4 bytes</span><br><span class="line"></span><br><span class="line">    uint16_t instanceCount;                             // 2 bytes [MSb: user]</span><br><span class="line">    Variant materialVariant;                            // 1 byte</span><br><span class="line">    backend::PrimitiveType type : 3;                    // 1 byte       3 bits</span><br><span class="line">    bool hasSkinning : 1;                               //              1 bit</span><br><span class="line">    bool hasMorphing : 1;                               //              1 bit</span><br><span class="line">    bool hasHybridInstancing : 1;                       //              1 bit</span><br><span class="line"></span><br><span class="line">    uint32_t rfu[2];                                    // 16 bytes</span><br><span class="line">};</span><br><span class="line">static_assert(sizeof(PrimitiveInfo) == 56);</span><br><span class="line"></span><br><span class="line">struct alignas(8) Command {     // 64 bytes</span><br><span class="line">    CommandKey key = 0;         //  8 bytes</span><br><span class="line">    PrimitiveInfo info;    // 56 bytes</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如上代码，RenderPass内的Command定义内有一个图元信息结构PrimitiveInfo。该结构内有一个backend::DescriptorSetHandle成员dsh。dsh表示的就是Renderable级别的渲染数据。dsh是在RenderPass::generateCommandsImpl内通过场景数据FScene::RenderableSoa内的FScene::DESCRIPTOR_SET_HANDLE数据初始化的。</p>
<h3 id="5-3-2-绑定Renderble数据"><a href="#5-3-2-绑定Renderble数据" class="headerlink" title="5.3.2 绑定Renderble数据"></a>5.3.2 绑定Renderble数据</h3><p>在执行每个command的drawcall之前，会调用driver.bindDescriptorSet绑定Renderable级别的数据。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.bindDescriptorSet(info.dsh,</span><br><span class="line">        +DescriptorSetBindingPoints::PER_RENDERABLE,</span><br><span class="line">        {{ offset, info.skinningOffset }, driver});</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-4-其它数据"><a href="#5-4-其它数据" class="headerlink" title="5.4 其它数据"></a>5.4 其它数据</h2><h3 id="5-4-1-SpecializationConstants"><a href="#5-4-1-SpecializationConstants" class="headerlink" title="5.4.1 SpecializationConstants"></a>5.4.1 SpecializationConstants</h3><p>这部分之前提过，filament是通过切换变体时候，将材质内保存的constants设置数据传递给gpu program，也提到过这部分在实现上有一定的不合理。</p>
<h3 id="5-4-2-PushConstant"><a href="#5-4-2-PushConstant" class="headerlink" title="5.4.2 PushConstant"></a>5.4.2 PushConstant</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (UTILS_UNLIKELY(info.hasMorphing)) {</span><br><span class="line">    driver.setPushConstant(ShaderStage::VERTEX,</span><br><span class="line">            +PushConstantIds::MORPHING_BUFFER_OFFSET, int32_t(info.morphingOffset));</span><br><span class="line">}</span><br><span class="line">driver.draw2(info.indexOffset, info.indexCount, info.instanceCount);</span><br></pre></td></tr></tbody></table></figure>
<p>pushConstant数据则是在调用drawcall之前通过driver.setPushConstant传入driver。目前，filament只支持固定的pushConstants数据。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">玻璃效果和窗户室内效果模拟</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-18 14:20:22" itemprop="dateCreated datePublished" datetime="2023-03-18T14:20:22+08:00">2023-03-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" class="post-meta-item leancloud_visitors" data-flag-title="玻璃效果和窗户室内效果模拟" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、玻璃效果"><a href="#一、玻璃效果" class="headerlink" title="一、玻璃效果"></a>一、玻璃效果</h1><p>首先来讲如何模拟玻璃效果。玻璃的渲染包括三部分，普通场景物体的渲染、反射和折射模拟、毛玻璃模拟。作为场景物体，那么类似其它场景物体Shader一样，可以使用PBR、BlingPhong或者Matcap，甚至三阶色卡通渲染都可以。玻璃比较特殊的地方是模拟对环境的反射和折射，以及模拟玻璃污渍效果。<br>对于场景物体的基础着色部分不再赘述，下面来介绍环境反射和折射、玻璃污渍模拟部分。</p>
<h2 id="1-1-环境反射和折射"><a href="#1-1-环境反射和折射" class="headerlink" title="1.1 环境反射和折射"></a>1.1 环境反射和折射</h2><p>对于不要求实时反映环境变化的效果，那么采样静态贴图进行模拟，是一种性能和效果都更优的方式。从效果上来说，美术可以自由定制贴图，那么可以方便控制效果；从性能上来说，不要求实时blit出当前的colorbuffer，性能远超实时反射和折射。</p>
<h3 id="1-1-1-静态Cubemap模拟"><a href="#1-1-1-静态Cubemap模拟" class="headerlink" title="1.1.1 静态Cubemap模拟"></a>1.1.1 静态Cubemap模拟</h3><p>最常见的方式是使用Cubemap来模拟环境的反射和折射。</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ol>
<li>计算当前着色像素的反射方向。</li>
<li>使用反射方向去从Cubemap中采样出反射颜色</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 reflectVector = reflect(-inputData.viewDirectionWS, inputData.normalWS);</span><br><span class="line">half3 reflectColor = SAMPLE_TEXTURECUBE_LOD(_EnvironmentCubeMap, sampler_EnvironmentCubeMap, reflectVector, _EnvironmentCubemapLod).rgb * _EnvironmentReflectionColor * _EnvironmentReflectionIntensity;</span><br></pre></td></tr></tbody></table></figure>
<p>如上述代码，使用内置函数reflect即可计算视线到当前像素的反射方向，然后用该方向去采样Cubemap即可。具体相关数学原理，比较简单，不再赘述。</p>
<h4 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h4><ol>
<li>计算当前着色像素的折射方向。</li>
<li>使用折射方向去从Cubemap中采样出折射颜色。</li>
</ol>
<p><strong>如何计算折射方向？</strong></p>
<ol>
<li>-viewDirectionWS。最简单的方式是假定折射方向没有发生偏转，那么简单使用相机到该像素点的方向即可，即-inputData.viewDirectionWS。由于，这本来就是一种近似效果，因此简单使用视线方向得到的结果也能差强人意。</li>
<li>refract。即使用折射定律来计算折射方向，直接调用refract函数即可，需要提供参数来调整折射率。</li>
<li>Refraction Model。生活中真正的玻璃，光线是先折射进入玻璃，然后再折射出来到空气中，我们需要的是最终的方向，而不是到玻璃内的折射方向。要模拟真实的折射方向，可以使用简化的模拟来模拟，比如假设折射是通过一定厚度的球体或者立方体。相关内容和代码，在HDRP内已经使用，参考文档：<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@8.0/manual/Refraction-in-HDRP.html">Refraction in the High Definition Render Pipeline</a>的Refraction Model部分。代码在com.unity.render-pipelines.core内，因此urp也可以使用。如果需要使用该折射模型，搜索RefractionModelBox或者RefractionModelSphere即可。</li>
</ol>
<h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p> 使用fresnel定律，将反射和折射颜色叠加起来作为最终的环境颜色。这部分的关键在于正确计算出反射和折射的贡献比例，并不一定需要严格计算fresnel定律，只需要接近该定律的现象即可。<br> fresnel定律的基本意思是：视线方向与法线的角度越大，反射越明显。对于基本只剩下反射的区域，也可以叫做掠角。<br>因此，最终结果可以使用下述代码叠加起来。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float fresnel = pow(saturate(1 - dot(inputData.viewDirectionWS, inputData.normalWS)), 5.0);</span><br><span class="line">half3 color = reflectColor * fresnel + refractColor * (1 - fresnel);</span><br></pre></td></tr></tbody></table></figure>
<p>最终效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassEnv.png"></p>
<h3 id="1-1-2-Matcap模拟"><a href="#1-1-2-Matcap模拟" class="headerlink" title="1.1.2 Matcap模拟"></a>1.1.2 Matcap模拟</h3><p>使用Matcap来模拟的话，思路与Cubemap类似。问题转换成如何从2D的Matcap贴图中计算反射颜色和折射颜色。</p>
<h4 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h4><p>反射其实可以理解为高光，那么可以参考Matcap如何实现高光的模拟部分：<a href="https://xiaopengcheng.top/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">Matcap模拟高光</a>。</p>
<h4 id="折射-1"><a href="#折射-1" class="headerlink" title="折射"></a>折射</h4><p>折射更像一个扭曲的过程，因为折射后方向发生了改变。那么，可以直接对uv进行扭曲，比如采样噪声图对uv进行叠加，再去采样一张折射matcap。</p>
<h4 id="最终结果-1"><a href="#最终结果-1" class="headerlink" title="最终结果"></a>最终结果</h4><p>与使用Cubemap类似，都需要使用计算fresnel定律计算折射和反射的混合比例。</p>
<h3 id="1-1-3-实时反射和折射模拟"><a href="#1-1-3-实时反射和折射模拟" class="headerlink" title="1.1.3 实时反射和折射模拟"></a>1.1.3 实时反射和折射模拟</h3><p>实时反射和折射，与前面两个算法的区别，是用反射和折射方向去采样当前的渲染结果，作为反射和折射的计算结果。</p>
<h3 id="获得ColorBuffer"><a href="#获得ColorBuffer" class="headerlink" title="获得ColorBuffer"></a>获得ColorBuffer</h3><p>需要在管线内插入一个Pass，将ColorBuffer进行Blit到一个低分辨率的RT上，然后对该RT进行采样。对于URP渲染管线，我们只要设置请求OpaqueTexture后，既可以在Shader对_CameraOpaqueTexture进行采样。</p>
<h3 id="反射-2"><a href="#反射-2" class="headerlink" title="反射"></a>反射</h3><p>由于OpaqueTexture是屏幕空间纹理，那么需要在屏幕空间内计算反射方向，可以参考文章<a href="https://xiaopengcheng.top/2021/08/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/">反射效果的实现总结</a>的屏幕空间反射部分。<br>或者更直接参考GitHub上的开源项目：<a href="https://github.com/ColinLeung-NiloCat/UnityURP-MobileScreenSpacePlanarReflection">UnityURP-MobileScreenSpacePlanarReflection</a>。在屏幕空间计算反射，算法部分比较复杂，不再赘述，请参考相关资料。</p>
<h3 id="折射-2"><a href="#折射-2" class="headerlink" title="折射"></a>折射</h3><p>由于反射要求方向精确，但是折射就没有这种要求，因此最简单的方式是计算出当前像素的屏幕空间位置后，然后对该位置进行扭曲，再采样OpaqueTexture即可获得折射结果。<br>当然如果要计算精确的折射方向，类似屏幕空间反射，都需要在屏幕空间内使用类似算法进行精确的方向计算， 然后再去采样屏幕空间RT。</p>
<h4 id="最终结果-2"><a href="#最终结果-2" class="headerlink" title="最终结果"></a>最终结果</h4><p>与使用Cubemap类似，都需要使用计算fresnel定律计算折射和反射的混合比例。</p>
<h2 id="1-2-玻璃污渍模拟"><a href="#1-2-玻璃污渍模拟" class="headerlink" title="1.2 玻璃污渍模拟"></a>1.2 玻璃污渍模拟</h2><p>该效果是对玻璃角落通常会出现污渍现象的模拟。通过观察，玻璃或者窗户一般是四个角落积累污渍。因此，可以计算与角落或者中心的距离，以这个距离归一化为默认的污渍强度。再结合一个污渍掩码贴图和污渍强度噪声贴图就可以让美术精细控制污渍了，当然不提供任何贴图也有默认的角落污渍。<br>具体功能，参考下图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassFrost.png"></p>
<h3 id="1-2-1-角落污渍"><a href="#1-2-1-角落污渍" class="headerlink" title="1.2.1 角落污渍"></a>1.2.1 角落污渍</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float uDis = min(abs(_FrostCenter.x - uv.x), abs(1 - _FrostCenter.x - uv.x));</span><br><span class="line">float vDis = min(abs(_FrostCenter.y - uv.y), abs(1 - _FrostCenter.y - uv.y));</span><br><span class="line">float dis = length(float2(uDis, vDis)) / 0.707;//斜边距离，然后归一化</span><br><span class="line">dis = _FrostReverse * (1 - dis) + (1 - _FrostReverse) * dis;//反转距离</span><br></pre></td></tr></tbody></table></figure>
<p>如上述代码，_FrostCenter定义的是污渍的中心，这个通常是（0.5,0.5)，即UV的中心。然后，计算当前uv到中心的归一化距离，用该距离作为污渍强度。</p>
<h3 id="1-2-2-污渍强度Noise"><a href="#1-2-2-污渍强度Noise" class="headerlink" title="1.2.2 污渍强度Noise"></a>1.2.2 污渍强度Noise</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half noiseDistance = SAMPLE_TEXTURE2D(_FrostNoiseMap, sampler_FrostNoiseMap, TRANSFORM_TEX(uv, _FrostNoiseMap)).r * _FrostNoiseIntensity;</span><br><span class="line">dis *= smoothstep(0, _FrostNoiseMax, noiseDistance);</span><br></pre></td></tr></tbody></table></figure>
<p>从贴图内读取噪声强度，然后对强度进行smoothstep归一化，再乘以到原来的强度距离上。</p>
<h3 id="1-2-3-污渍Mask"><a href="#1-2-3-污渍Mask" class="headerlink" title="1.2.3 污渍Mask"></a>1.2.3 污渍Mask</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 frostMask = SAMPLE_TEXTURE2D(_FrostMaskMap, sampler_FrostMaskMap, TRANSFORM_TEX(uv, _FrostMaskMap));</span><br><span class="line">dis *= lerp(1, lerp(frostMask.x, 1 - frostMask.x, _FrostMaskReverse),  _FrostBlendFactor);//blend with mask</span><br></pre></td></tr></tbody></table></figure>
<p>从贴图内读取mask，然后将mask乘到原有的强度上。至于_FrostMaskReverse则是强度反转控制，_FrostBlendFactor是mask比例控制。</p>
<h3 id="1-2-4-将距离转化为污渍颜色"><a href="#1-2-4-将距离转化为污渍颜色" class="headerlink" title="1.2.4 将距离转化为污渍颜色"></a>1.2.4 将距离转化为污渍颜色</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float weight = smoothstep(0, _FrostDistance / 0.707, dis);</span><br><span class="line">color.rgb += weight * _FrostColor * _FrostIntensity;</span><br></pre></td></tr></tbody></table></figure>
<p>_FrostDistance/0.707是归一化的最大距离。然后对dis进行smoothstep后就可以得到污渍强度。最后，将<br>污渍强度与污渍颜色、污渍整体强度相乘后叠加到最终颜色上即可。当然，也可以有其它的应用方式，比如用污渍weight来改变法线等。<br>最终效果如图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassFrostDemo.png"></p>
<h1 id="二、窗户室内模拟"><a href="#二、窗户室内模拟" class="headerlink" title="二、窗户室内模拟"></a>二、窗户室内模拟</h1><p>这是另外一种窗户模拟效果，跟玻璃效果差距较大，但是也可以作为通用Shader的一部分整合进来，因此放在一起讲述。详细的效果和算法可以参考文章：<a href="https://zhuanlan.zhihu.com/p/376762518">案例学习——Interior Mapping 室内映射（假室内效果）</a>。<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassInterior.png"><br>该算法的整体思想，是计算当前视线与室内的交点，然后从室内环境Cubemap获取交点的颜色作为最终颜色。计算交点有两种方式，一种是在模型空间计算，一种是在切线空间计算。在模型空间计算，依赖模型空间坐标系的具体范围，更通用的方式是在切线空间计算。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="property">interiorViewDir</span>.<span class="property">z</span> *= <span class="number">1</span> / (<span class="number">1</span> - _InteriorDepthScale) - <span class="number">1</span>;</span><br><span class="line">   half3 revseseViewDir = <span class="title class_">SafeNormalize</span>(-input.<span class="property">interiorViewDir</span>);</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> _INTERIOR_TANGENT</span><br><span class="line">	float2 interiorUV = <span class="title function_">frac</span>(<span class="title function_">TRANSFORM_TEX</span>(uv, _InteriorCubemap) + <span class="number">0.0001</span>);</span><br><span class="line">	<span class="comment">// raytrace box from tangent view dir</span></span><br><span class="line">	float3 pos = <span class="title function_">float3</span>(interiorUV * <span class="number">2.0</span> - <span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">	float3 pos = <span class="title function_">frac</span>(input.<span class="property">positionOS</span> * _InteriorCubemap_ST.<span class="property">xyx</span> + _InteriorCubemap_ST.<span class="property">zwz</span> + <span class="number">0.0001</span>);</span><br><span class="line">           <span class="comment">// raytrace box from object view dir</span></span><br><span class="line">           <span class="comment">// transform object space uvw( min max corner = (0,0,0) &amp; (+1,+1,+1))  </span></span><br><span class="line">           <span class="comment">// to normalized box space(min max corner = (-1,-1,-1) &amp; (+1,+1,+1))</span></span><br><span class="line">           pos = pos * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">float3 id = <span class="number">1.0</span> / revseseViewDir;</span><br><span class="line">float3 k = <span class="title function_">abs</span>(id) - pos * id;</span><br><span class="line">float kMin = <span class="title function_">min</span>(<span class="title function_">min</span>(k.<span class="property">x</span>, k.<span class="property">y</span>), k.<span class="property">z</span>);</span><br><span class="line">pos += kMin * revseseViewDir;</span><br><span class="line"></span><br><span class="line">refractColor += <span class="title function_">SAMPLE_TEXTURECUBE</span>(_InteriorCubemap, sampler_InteriorCubemap, pos.<span class="property">xyz</span>).<span class="property">rgb</span> * _InteriorIntensity;</span><br></pre></td></tr></tbody></table></figure>
<p>_InteriorDepthScale表示室内的深度，对室内进行远近拉伸，默认是0.5，表示没有拉伸。详细的推导算法请参考上述文章。<br>具体效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/GlassInteriorDemo.png"><br>外表凹凸不平的是玻璃本身的颜色贴图和法线贴图效果，内部是室内模拟效果。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@8.0/manual/Refraction-in-HDRP.html">Refraction in the High Definition Render Pipeline</a><br><a href="https://xiaopengcheng.top/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">Matcap模拟高光</a><br><a href="https://xiaopengcheng.top/2021/08/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/">反射效果的实现总结</a><br><a href="https://github.com/ColinLeung-NiloCat/UnityURP-MobileScreenSpacePlanarReflection">UnityURP-MobileScreenSpacePlanarReflection</a><br><a href="https://zhuanlan.zhihu.com/p/376762518">案例学习——Interior Mapping 室内映射（假室内效果）</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/" class="post-title-link" itemprop="url">多层融合地形Shader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-18 16:02:00" itemprop="dateCreated datePublished" datetime="2023-01-18T16:02:00+08:00">2023-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/" class="post-meta-item leancloud_visitors" data-flag-title="多层融合地形Shader" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/01/18/%E5%A4%9A%E5%B1%82%E8%9E%8D%E5%90%88%E5%9C%B0%E5%BD%A2Shader/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、多层融合地形Shader介绍"><a href="#一、多层融合地形Shader介绍" class="headerlink" title="一、多层融合地形Shader介绍"></a>一、多层融合地形Shader介绍</h1><p>所谓多层融合地形Shader，即多层地形效果过渡融合的Shader，比如黄色的土地上，融合淡绿色的草地，然后再点缀红色的花，这样就是三层效果融合。虽然，该效果常用在地形上，但是并不局限于地形，普通的场景模型等照样可以使用这样方式融合多层效果，比如静态的雪地，就可以使用该技术达到很精细的效果。<br>对于单独的一层效果，可以是PBR也可以是BlingPhong，甚至可以是Matcap。关键在于，如何将多层效果比较自然得融合起来。<br>类似下面的地形Shader效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainOptions.png"><br>可以看出该Shader，支持权重混合和高度混合，同时支持四层融合。</p>
<h1 id="二、多层融合效果的基本实现思路"><a href="#二、多层融合效果的基本实现思路" class="headerlink" title="二、多层融合效果的基本实现思路"></a>二、多层融合效果的基本实现思路</h1><p>概况的说，一句话可以总结：<strong>对着色模型或者说光照模型的输入进行多层混合</strong>。比如，PBR的基本输入是基础色、法线、金属度、粗糙度、AO；BlingPhong的基本输入是基础色、法线、AO。其它的着色模型也是类似的思路，同样可以对Matcap和卡通渲染进行多层融合。</p>
<h1 id="二、权重融合"><a href="#二、权重融合" class="headerlink" title="二、权重融合"></a>二、权重融合</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainWeight.png"><br>权重融合的实现方式比较简单，用一个权重贴图控制四层的权重，同时提供数值缩放。这样，第一层的权重就是权重贴图的R通道乘以第一层的缩放（First Layer Weight），以此类推。然后，用得到的四个权重，应用到四层的基本输入上做加权平均，得到最终的输入。</p>
<h1 id="三、高度融合"><a href="#三、高度融合" class="headerlink" title="三、高度融合"></a>三、高度融合</h1><p>权重融合的缺点是边界过渡比较生硬，无法实现平滑的过渡。而高度融合是解决过渡生硬的一个好的方式。效果和思路可以参考文章：<a href="https://zhuanlan.zhihu.com/p/26383778">基于高度的纹理混合shader</a><br>基本思路：</p>
<ol>
<li>求四层最大高度。</li>
<li>用最大权重减去过渡因子作为开始高度。</li>
<li>每一层的高度减去开始高度作为该层权重。</li>
<li>然后进行四层加权混合。<br>具体代码可以参考下面函数：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">half LayerHeightBlend(half4 height, half input1, half input2, half input3, half input4)</span><br><span class="line">{</span><br><span class="line">	half heightStart = max(max(height.r, height.g), max(height.b, height.a)) - _HeightBlendFactor;</span><br><span class="line">	half b1 = max(height.r - heightStart, 0);</span><br><span class="line">	half b2 = max(height.g - heightStart, 0);</span><br><span class="line">	half b3 = max(height.b - heightStart, 0);</span><br><span class="line">	half b4 = max(height.a - heightStart, 0);</span><br><span class="line">	return max((input1 * b1 + input2 * b2 + input3 * b3 + input4 * b4) / (b1 + b2 + b3 + b4), 0.0001);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
效果对比：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainWeightDemo.png"><br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainHeightDemo.png"></li>
</ol>
<p>第二个效果与第一个效果对比，有明显的过渡区域，而且过渡区域是有明显融合的，而单纯的权重融合只是效果的加权平均。</p>
<h1 id="四、融合控制贴图编辑工具"><a href="#四、融合控制贴图编辑工具" class="headerlink" title="四、融合控制贴图编辑工具"></a>四、融合控制贴图编辑工具</h1><p>为了方便美术所见即所得的编辑和预览最终的混合效果，那么实现一个编辑器工具，方便美术用笔刷实时来修改效果，同时在Unity编辑器内预览最终效果是非常有意义的，可以显著提高生产效率。<br>类似如下工具：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/TerrainPaint.png"><br>该工具的功能并不复杂，读取地形材质的设置，比如控制贴图信息和四层的贴图信息，提供笔刷功能，在Scene窗口去刷模型，壁画操作的结果再写回控制贴图。由于当前模型使用的正是笔刷引用的地形材质和控制贴图，因此就可以实时预览最终的渲染效果。<br>网上应该也有类似的插件或者开源代码。这里只是抛砖引玉，具体代码不会提供。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/" class="post-title-link" itemprop="url">通用特效Shader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-22 15:10:00" itemprop="dateCreated datePublished" datetime="2022-11-22T15:10:00+08:00">2022-11-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/" class="post-meta-item leancloud_visitors" data-flag-title="通用特效Shader" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/11/22/%E9%80%9A%E7%94%A8%E7%89%B9%E6%95%88Shader/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、通用特效Shader介绍"><a href="#一、通用特效Shader介绍" class="headerlink" title="一、通用特效Shader介绍"></a>一、通用特效Shader介绍</h1><h2 id="1-1-什么是通用特效材质"><a href="#1-1-什么是通用特效材质" class="headerlink" title="1.1 什么是通用特效材质"></a>1.1 什么是通用特效材质</h2><p>Unity支持SRP Batcher后，使用UberShader的优势非常明显。所谓，UberShader，即一个超级Shader，覆盖一类功能，而不是多个分散的小Shader，比如一个通用特效Shader，整个项目内的所有特效都使用该Shader来制作所有的粒子特效或者模型特效，其它需求也类似，比如物体、地形等。</p>
<h2 id="1-2-通用特效材质的意义"><a href="#1-2-通用特效材质的意义" class="headerlink" title="1.2 通用特效材质的意义"></a>1.2 通用特效材质的意义</h2><h3 id="1-2-1-方便使用和沟通"><a href="#1-2-1-方便使用和沟通" class="headerlink" title="1.2.1 方便使用和沟通"></a>1.2.1 方便使用和沟通</h3><p>整个项目只有一个特效Shader的情况下，美术很容易熟悉该Shader有哪些功能，能够尽可能复用该通用Shader的多个功能制作复杂特效；同时，避免美术与技术美术或者技术重复沟通类似的功能。</p>
<h3 id="1-2-2-方便维护"><a href="#1-2-2-方便维护" class="headerlink" title="1.2.2 方便维护"></a>1.2.2 方便维护</h3><p>对于技术美术或者开发同学来说，维护一个Shader的成本比维护多个的成本低很多。对于重复功能不需要再重复开发，优化性能时候也不用满世界扫描美术到底用的是什么Shader，只需要优化这一个Shader性能即可。</p>
<h3 id="1-2-3-批次更低"><a href="#1-2-3-批次更低" class="headerlink" title="1.2.3 批次更低"></a>1.2.3 批次更低</h3><p>由于支持SRP Batcher，Unity使用的是最终的变体级别合批。与多个分散小Shader相比，一个Shader质制作的特效更可能被SRP Batcher，因为使用的同一个变体的概率很高，而不同的Shader天然就是不同的变体，不可能被SRP Batcher。因此，只要复用率越高，被合并的批次越多。</p>
<h2 id="1-2-通用特效材质主要模块"><a href="#1-2-通用特效材质主要模块" class="headerlink" title="1.2 通用特效材质主要模块"></a>1.2 通用特效材质主要模块</h2><p>主要包括基础功能、Mask、Distortion（扭曲）、Dissolve（溶解）、Emission（自发光）、Reflection（反射）、其它等。每个大的模块都有变体开关，部分消耗大的小功能也需要有变体开关。这里只是列出本人项目中用到过的一些功能，基本上覆盖了常见的特效功能，但是不同项目会有不同的需求，因此除了常见的扭曲、溶解等还会有不少定制功能。这篇文章的目的，不在于介绍这些功能的实现细节，而是说明一个超级特效Shader在项目中使用的意义。</p>
<h1 id="二、通用特效具体模块"><a href="#二、通用特效具体模块" class="headerlink" title="二、通用特效具体模块"></a>二、通用特效具体模块</h1><h2 id="2-1-Surface-Options（基础设置）"><a href="#2-1-Surface-Options（基础设置）" class="headerlink" title="2.1 Surface Options（基础设置）"></a>2.1 Surface Options（基础设置）</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsSurfaceOptions.png"><br>Surface Type：不透明或者半透明<br>Render Face：Front（剔除背面）、Back（剔除前面）、Both（不剔除）<br>Custom ZWrite：是否覆盖深度写入<br>ZTest：深度测试<br>ColorMask：输出颜色通道<br>Alpha Clipping：Alpha裁剪<br>Enable Billboard：是否作为Billboard渲染（朝向相机）</p>
<h2 id="2-2-Surface-Inputs-（基础输入）"><a href="#2-2-Surface-Inputs-（基础输入）" class="headerlink" title="2.2 Surface Inputs （基础输入）"></a>2.2 Surface Inputs （基础输入）</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsSurfaceInputs.png"><br>Base Map：基础颜色贴图<br>Base Color：基础颜色<br>Enable BackFace Base Color：开启该选项，可以给背面单独制定基础颜色<br>Apply Vertex Color：开启该选项，顶点颜色应用到基础色上<br>BaseMap UvType：该设置有UV、ScreenUV、ReflectionUV三种类型。UV模式是使用模型UV0，ScreenUV是使用屏幕空间位置作为UV，ReflectionUV使用反射向量的两个分量比如xz作为UV。ScreenUV和ReflectionUV可以实现一些特殊效果。<br>BaseMap Rotation：UV模式下，对模型UV0旋转。<br>BaseMap U Speed：UV的U移动速度。<br>BaseMap V Speed：UV的V移动速度。<br>BaseMap Custom Speed (CustomData1.xy, UV0.zw)：该功能是使用Unity粒子的CustomData1.xy来作为UV。如下所示的CustomData1.xy是曲线：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/EffectsCustomData.png"><br>Normal Map：法线贴图，只在需要使用法线方向时候有意义，比如反射、Matcap等<br>Normal Scale：法线强度缩放<br>Normal U Speed：法线的U移动速度。<br>Normal V Speed：法线的V移动速度。</p>
<h2 id="2-3-Mask-Options"><a href="#2-3-Mask-Options" class="headerlink" title="2.3 Mask Options"></a>2.3 Mask Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsMask.png"><br>Mask贴图的作用是修改透明度，在半透明模式下可以只显示通过Mask的区域。</p>
<p>Mask Map (R)：Mask贴图，默认使用R通道。<br>Mask Channel Mask (Default R)：Mask贴图的通道掩码。<br>Mask Rotation：Mask贴图的UV旋转。<br>Mask U Speed：Mask贴图的U移动速度。<br>Mask V Speed：Mask贴图的V移动毒素。<br>Mask Custom Speed (CustomData1.zw, UV1.xy):使用Unity粒子的CustomData1.zw来作为Mask的UV。<br>Mask Intensity:  Mask的强度缩放。<br>Mask Min：Mask的强度最小值。<br>Mask Max：Mask的强度最大值。最终的Mask强度会在该范围内SmoothStep。<br>下面是使用Mask的效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsMaskTest.gif"></p>
<h2 id="2-4-Distortion-Options"><a href="#2-4-Distortion-Options" class="headerlink" title="2.4 Distortion Options"></a>2.4 Distortion Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDistortion.png"><br>Distortion的功能就是扭曲其它模块的采样UV，比如基础色、自发光、溶解等。<br>Distortion Map (RG) Mask(A)：扭曲贴图，RG通道是扭曲强度，A通道是扭曲Mask。<br>Distortion Rotation：扭曲的UV旋转。<br>Distortion U Speed：扭曲的U移动速度。<br>Distortion V Speed：扭曲的V移动速度。<br>Distortion Intensity：扭曲的强度缩放。<br>下面是使用扭曲的效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDistortionTest.gif"></p>
<h2 id="2-5-Dissolve-Options"><a href="#2-5-Dissolve-Options" class="headerlink" title="2.5 Dissolve Options"></a>2.5 Dissolve Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDissolveOptions.png"><br>Dissolve Map (R)：溶解贴图，默认使用R通道。<br>Dissolve Channel Mask (Default R)：溶解贴图的通道掩码。<br>Dissolve Rotation：溶解贴图的UV旋转。<br>Dissolve U Speed：溶解贴图的U移动速度。<br>Dissolve V Speed：溶解贴图的V移动速度。<br>Dissolve Intensity：溶解强度，注意不是溶解贴图的输入强度缩放。<br>Dissolve Width：溶解宽度。<br>Dissolve Edge Color：溶解边缘颜色。<br>Dissolve Edge Intensity：溶解边缘颜色强度缩放。<br>Dissolve Hard Edge：是否硬边溶解。<br>Dissolve Custom Intensity (CustomData2.x, UV1.z)：使用粒子系统的CustomData2.x作为溶解强度。<br>Dissolve Custom Width (CustomData2.y, UV1.w)：使用粒子系统的CustomData2.y作为溶解宽度。<br>溶解的功能比较复杂，最基本的思想是用一张贴图作为溶解强度输入，然后通过在溶解强度和宽度之间计算出溶解阈值，用这个阈值去修改透明度；溶解的边缘颜色则是将溶解阈值应用到单独是边缘颜色上再叠加到输出颜色上；至于硬边溶解是直接将溶解阈值取sign。<br>有兴趣还原的可以参考下面代码：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">half disslove = dot(SAMPLE_TEXTURE2D(_DissolveMap, sampler_DissolveMap, input.uv3.xy + distortion), _DissolveChannelMask);</span><br><span class="line">half dissloveIntensity = input.uv3.z;</span><br><span class="line">half dissolveWidth = input.uv3.w;</span><br><span class="line">half dissolveWithParticle = (dissloveIntensity * (1 + dissolveWidth) - dissolveWidth);</span><br><span class="line">half dissolveAlpha = saturate(smoothstep(dissolveWithParticle, (dissolveWithParticle + dissolveWidth), disslove));</span><br><span class="line">color.a *= _DissolveHardEdge ? sign(dissolveAlpha) : dissolveAlpha;</span><br><span class="line">color.rgb += _DissolveEdgeColor.rgb * _DissolveEdgeColor.a * _DissolveEdgeIntensity * (_DissolveHardEdge ? sign(1 - dissolveAlpha) : (1 - dissolveAlpha));</span><br></pre></td></tr></tbody></table></figure><br>下面是使用溶解的效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsDissolveTest.gif"><p></p>
<h2 id="2-6-Emission-Options"><a href="#2-6-Emission-Options" class="headerlink" title="2.6 Emission Options"></a>2.6 Emission Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsEmissionOptions.png"><br>Emission Map：自发光贴图。<br>EmissionColor：自发光颜色。<br>Use WorldPos As UV：特殊需求，使用世界空间位置作为UV采样自发光贴图。<br>Emission U Speed：自发光的U移动速度。<br>Emission V Speed：自发光的V移动速度。<br>Emission Intensity：自发光的强度缩放。<br>自发光的原理比较简单，采样一张额外的自发光贴图叠加颜色，不再赘述。</p>
<h2 id="2-7-RimLight-Options"><a href="#2-7-RimLight-Options" class="headerlink" title="2.7 RimLight Options"></a>2.7 RimLight Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsRimLightOptions.png"><br>RimLight Color：边缘光颜色。<br>RimLight Width：边缘光宽度。<br>RimLight Smoothness：边缘光光滑度。<br>RimLight Intensity：边缘光强度缩放。<br>RimLight Min：边缘光最小强度。<br>RimLight Max：边缘光最大强度。<br>RimLight Reverse：是否反转强度。<br>边缘光是实际上是计算法线与视线的夹角来判断边缘，当夹角越大边缘光越强，最终将边缘光叠加回输出颜色上。具体代码如下：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half cosTheta = dot(normalWS, viewDirWS);</span><br><span class="line">half rimLightStrength = pow(saturate(1 - 1 / _RimLightWidth * cosTheta), _RimLightSmoothness);</span><br><span class="line">rimLightStrength = (_RimLightReverse ? 1 - rimLightStrength : rimLightStrength) * _RimLightIntensity;</span><br><span class="line">rimLightStrength = smoothstep(_RimLightMinValue, _RimLightMaxValue, rimLightStrength);</span><br><span class="line">color.rgb += _RimLightColor * rimLightStrength;</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="2-8-Light-Options"><a href="#2-8-Light-Options" class="headerlink" title="2.8 Light Options"></a>2.8 Light Options</h2><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/UberEffectsLightOptions.png"><br>Real Time Light Strength：实时光强度<br>Real Time Shadow Strength：实时光阴影强度<br>Real Time Shadow Color：实时光阴影颜色<br>Real Time Shadow Color Strength：实时光阴影颜色强度<br>强调一下：这里不是让特效Shader走完整的光照计算，而只是用光源的信息去修改最终的输出颜色。这样性能高效，看起来也在接受光源阴影。</p>
<h2 id="2-9-其它功能"><a href="#2-9-其它功能" class="headerlink" title="2.9 其它功能"></a>2.9 其它功能</h2><h3 id="2-9-1-Depth-Bias"><a href="#2-9-1-Depth-Bias" class="headerlink" title="2.9.1 Depth Bias"></a>2.9.1 Depth Bias</h3><p>深度偏移，特效有时候需要偏移深度来强制放在某些物体之前，这个功能比较有效果。</p>
<h3 id="2-9-2-Reflection-Options"><a href="#2-9-2-Reflection-Options" class="headerlink" title="2.9.2 Reflection Options"></a>2.9.2 Reflection Options</h3><p>使用反射方向采样Cubemap，将结果叠加到输出颜色上即可。</p>
<h3 id="2-9-2-Matcap"><a href="#2-9-2-Matcap" class="headerlink" title="2.9.2 Matcap"></a>2.9.2 Matcap</h3><p>参考上一篇文章的Matcap，对于特效的matcap可以简单实现即可。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">Matcap的原理和应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-19 17:15:51" itemprop="dateCreated datePublished" datetime="2022-09-19T17:15:51+08:00">2022-09-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">图形学</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" class="post-meta-item leancloud_visitors" data-flag-title="Matcap的原理和应用" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/19/Matcap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、概念和原理"><a href="#一、概念和原理" class="headerlink" title="一、概念和原理"></a>一、概念和原理</h1><h2 id="1-1-什么是Matcap"><a href="#1-1-什么是Matcap" class="headerlink" title="1.1 什么是Matcap"></a>1.1 什么是Matcap</h2><p>  什么是Matcap？Matcap实际上是Material Capture的缩写，即材质捕捉。实际上，这是一种离线渲染方案。类似光照烘焙，将光照或者其它更复杂环境下的渲染数据存储到一张2D贴图上， 再从这张2D贴图进行采样进行实时渲染。</p>
<p><a href="https://help.sketchfab.com/hc/en-us/articles/115003065883-Materials-MatCap-">Materials (MatCap)</a>这篇文章对Matcap的定义是：<br>MatCap (Material Capture) shaders are complete materials, including lighting and reflections. They work by defining a color for every vertex normal direction relative to the camera. </p>
<h2 id="1-2-如何理解Matcap"><a href="#1-2-如何理解Matcap" class="headerlink" title="1.2 如何理解Matcap"></a>1.2 如何理解Matcap</h2><p>Matcap是一种在视线空间下使用单位法线采样单位球的离线渲染算法。</p>
<ul>
<li>为什么是视线空间？因为视线空间下，相机变化就可以看到不同的渲染结果。</li>
<li>为什么使用法线去采样了？法线是描述表面朝向的向量，与渲染结果强相关，法线跟物体的曲率强相关等，因此这种算法经常用于 sculpting上。</li>
</ul>
<h2 id="1-3-Matcap的特点"><a href="#1-3-Matcap的特点" class="headerlink" title="1.3 Matcap的特点"></a>1.3 Matcap的特点</h2><p>Matcap的特点总结如下：</p>
<ul>
<li>使用视线空间下的法线向量采样2D贴图，作为光照和反射结果。</li>
<li>在缺乏光照烘焙的环境下，可以一定程度上替代或者模拟光图。</li>
<li>但是，Matcap代表的2D贴图不局限于光照信息，也可以理解为某种环境下的最终渲染结果。</li>
<li>由于是离线方案，因此计算非常廉价，很适合低端机器或者特定场合下使用。</li>
</ul>
<h1 id="二、如何实现Matcap"><a href="#二、如何实现Matcap" class="headerlink" title="二、如何实现Matcap"></a>二、如何实现Matcap</h1><h2 id="2-1-如何获得Matcap贴图"><a href="#2-1-如何获得Matcap贴图" class="headerlink" title="2.1 如何获得Matcap贴图"></a>2.1 如何获得Matcap贴图</h2><p>按照定义，matcap贴图是一张2D贴图，内部包含一个单位球，表示光照信息。如何获得这样的贴图了？</p>
<ul>
<li>从网上的材质库下载<br>比如，<a href="https://github.com/nidorx/matcaps">matcaps</a></li>
<li>引擎预览材质球然后截图。<br><img alt="材质预览matcap" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/材质预览matcap.png"><br>如上图，可以把右边的预览结果紧贴着球体进行截图。<br>当然，如果严格按照定义，Matcap表示的是光照信息，不是所有材质预览的结果都可以当作Matcap贴图。</li>
</ul>
<h2 id="2-2-如何采样Matcap贴图"><a href="#2-2-如何采样Matcap贴图" class="headerlink" title="2.2 如何采样Matcap贴图"></a>2.2 如何采样Matcap贴图</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------</span><br><span class="line">// Vertex</span><br><span class="line">// -------------------------------</span><br><span class="line">VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);</span><br><span class="line">output.normalWS = normalInput.normalWS;</span><br><span class="line"></span><br><span class="line">// -------------------------------</span><br><span class="line">// Fragment</span><br><span class="line">// -------------------------------</span><br><span class="line">float3 viewNormal = mul((float3x3)GetWorldToViewMatrix(), normalWS);</span><br><span class="line">float2 matCapUV = viewNormal.xy * 0.5 + 0.5;</span><br><span class="line">half3 matcapColor = SAMPLE_TEXTURE2D(_Matcap, sampler_Matcap, matCapUV).rgb;</span><br></pre></td></tr></tbody></table></figure>
<p>从上述glsl代码可以看出，需要把法线转换到视线空间，然后再将法线偏移到[0,1]的范围内，然后取xy分量作为uv，对matcap纹理进行采样。</p>
<h1 id="三、Matcap的问题"><a href="#三、Matcap的问题" class="headerlink" title="三、Matcap的问题"></a>三、Matcap的问题</h1><h2 id="3-1-边缘瑕疵"><a href="#3-1-边缘瑕疵" class="headerlink" title="3.1 边缘瑕疵"></a>3.1 边缘瑕疵</h2><p>有时候使用Matcap渲染，模型上会出现一条线或者缝隙。可能的原因是采样到了贴图的边缘部分，而有些matcap贴图制作上不太好，边缘区域过大。<br><img alt="matcap边缘瑕疵" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap边缘瑕疵.png"><br>如上图所示：左边的matcap贴图就是一个非常不规范的matcap贴图，球没有紧贴边缘，而是出现大量空白部分，导致兔子的边缘出现大量的灰色边缘。<br>解决方式有两种，一种是强制采样内部的像素；另一种方式是修改采样算法，使得更合理避免出现边缘区域。</p>
<h2 id="3-2-单点采样"><a href="#3-2-单点采样" class="headerlink" title="3.2 单点采样"></a>3.2 单点采样</h2><p>对于平面来说，其法线朝着同一个方向的，因此会出现整个平面获得的matcap颜色都是同一个像素点，与正常的光照结果相差很大。我们希望的是，即使是一个平面，不同的像素点也是有不同的光照结果。</p>
<h2 id="3-3-解决办法"><a href="#3-3-解决办法" class="headerlink" title="3.3 解决办法"></a>3.3 解决办法</h2><h3 id="3-1-1-缩放uv"><a href="#3-1-1-缩放uv" class="headerlink" title="3.1.1 缩放uv"></a>3.1.1 缩放uv</h3><p>第一种方式是对matcapUV进行缩放，比如缩小uv可以使得避免采样边缘区域。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float2 matCapUV = viewNormal.xy * <span class="number">0.5</span> * _MatcapUVScale + <span class="number">0.5</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这种方式可以简单的解决边缘瑕疵问题，但是无法解决单点采样。</p>
<h3 id="3-1-2-使用视线空间下单位球的法线"><a href="#3-1-2-使用视线空间下单位球的法线" class="headerlink" title="3.1.2 使用视线空间下单位球的法线"></a>3.1.2 使用视线空间下单位球的法线</h3><p><img alt="matcap优化" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap优化.png"><br>如上图所示，在Matcap的定义中，我们处于视线空间内，视线方向始终是（0，0，1）。我们最终要使用的是单位球的N方向。假设反射方向是R，可以计算得到N是(Rx，Ry，Rz+1)。那么问题转化为求反射向量R。我们可以用视线空间的顶点和法线求得视线空间下的R，然后用视线空间的R去代替单位球上的反射向量R即可，即使两个方向向量不能等价，也可以得到相应正确的结果。<br>这种算法可以显著优化平面的单点采样问题。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#if _MATCAP_FIX_EDGE_FLAW</span><br><span class="line">	float3 r = reflect(input.positionVS, viewNormal);</span><br><span class="line">	r = normalize(r);</span><br><span class="line">	float m = 2.82842712474619 * sqrt(r.z + 1.0); </span><br><span class="line">	float2 matCapUV = r.xy / m * _MatcapUVScale + 0.5;</span><br><span class="line">#else</span><br><span class="line">	float2 matCapUV = viewNormal.xy * 0.5 * _MatcapUVScale + 0.5;</span><br><span class="line">#endif</span><br></pre></td></tr></tbody></table></figure>
<p><img alt="matcap优化对比" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap优化对比.png"><br>从上图可以看出，对于平面来说，两种算法的效果差异非常明显。</p>
<h1 id="四、Matcap与其它效果的结合"><a href="#四、Matcap与其它效果的结合" class="headerlink" title="四、Matcap与其它效果的结合"></a>四、Matcap与其它效果的结合</h1><p>下面的测试均以如下Matcap贴图为例。<br><img alt="matcap输入" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap输入.png"></p>
<h2 id="4-1-基础颜色"><a href="#4-1-基础颜色" class="headerlink" title="4.1 基础颜色"></a>4.1 基础颜色</h2><p>如果把Matcap当作光照的结果，那么可以额外提供基础颜色来控制最终结果。比如，提供基础颜色贴图和基础颜色，乘以到matcap上作为最终输出。<br><img alt="matcap基础色" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap基础色.png"></p>
<h2 id="4-2-法线贴图"><a href="#4-2-法线贴图" class="headerlink" title="4.2 法线贴图"></a>4.2 法线贴图</h2><p>既然matcap需要用到法线，那么可以额外提供法线贴图去修改像素的法线。<br><img alt="matcap法线" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap法线.png"><br>从上图可以看出，法线对最终的渲染结果影响显著。</p>
<h2 id="4-3-自发光"><a href="#4-3-自发光" class="headerlink" title="4.3 自发光"></a>4.3 自发光</h2><p>类似正常的光照计算，可以在matcap的结果之上，再叠加自发光。</p>
<h2 id="4-4-模拟高光"><a href="#4-4-模拟高光" class="headerlink" title="4.4 模拟高光"></a>4.4 模拟高光</h2><p>matcap本身已经是光照计算的结果，因此理论上贴图内带有了漫反射、高光、反射的信息。但是，通常情况下，matcap主要包括的还是漫反射信息，或者说表现不出明显的高光信息。<br>有一种简单模拟高光的方式，提供一个高光阈值，使用matcap减去该颜色阈值，然后除以1-阈值。最终结果再用原matcap颜色相乘避免过曝。<br><img alt="matcap高光" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap高光.png"></p>
<h2 id="4-5-Cubemap反射"><a href="#4-5-Cubemap反射" class="headerlink" title="4.5 Cubemap反射"></a>4.5 Cubemap反射</h2><p>同时，可以额外利用cubemap计算静态反射结果叠加到最终着色上。<br><img alt="matcap反射" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap反射.png"></p>
<h2 id="4-6-模拟边缘光"><a href="#4-6-模拟边缘光" class="headerlink" title="4.6 模拟边缘光"></a>4.6 模拟边缘光</h2><p>利用dot(normalWS, viewDirWS)计算出边缘光的强度，再将边缘光颜色与强度相乘叠加到最终着色结果上即可。</p>
<h2 id="4-7-模拟折射"><a href="#4-7-模拟折射" class="headerlink" title="4.7 模拟折射"></a>4.7 模拟折射</h2><p>折射一种扭曲的效果，因此我们可以通过扭曲matcap的采样位置和反射的采样位置来模拟折射。同时，可以乘以边缘光的强度来模拟菲尼尔效应，也就是边缘光强的地方折射更强。然后，利用这个扭曲强度去偏移matcap的uv和反射向量，即可在一定程度上模拟折射的效果。<br><img alt="matcap折射" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/matcap折射.png"><br>如上图所示，边缘的红色是边缘光；同时，噪声贴图作为折射扭曲强度贴图让边缘光看起来比较细碎，用来模拟折射效果。</p>
<h2 id="4-8-光照强度"><a href="#4-8-光照强度" class="headerlink" title="4.8 光照强度"></a>4.8 光照强度</h2><p>同时，也可以计算出真实的光照强度，将光照强度乘以matcap颜色，让matcap的着色结果受到灯光影响。不过，这跟matcap的初衷不太一致。</p>
<h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote>
<p><a href="[Matcap的原理和应用](xsjapp://doc/b62819d2-d505-4107-8b34-5a176c25bc82#xsj_1702740535139">Materials (MatCap)</a>)<br><a href="https://github.com/nidorx/matcaps">https://github.com/nidorx/matcaps</a><br><a href="https://zhuanlan.zhihu.com/p/79040521">MatCap Shader 改进：解决平面渲染和环境反射问题</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">角色妆容的实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 11:10:00" itemprop="dateCreated datePublished" datetime="2022-07-30T11:10:00+08:00">2022-07-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">图形学</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-meta-item leancloud_visitors" data-flag-title="角色妆容的实现" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/30/%E8%A7%92%E8%89%B2%E5%A6%86%E5%AE%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><p>前段时间做了下角色妆容的实现，想写个文章记录一下这个事情。妆容看起来很复杂，实际上整理实现思路很简单，主要是两个方面的内容，改变基础色和改变高光（金粉效果）。<br>先贴一个妆容效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容效果1.jpg"></p>
<p>没有开启妆容的情况下，基础色就是从颜色贴图和基础颜色中获得；开启妆容后，要根据各个状态模块的模板和比例来插值妆容颜色和基本颜色；金粉则是改变特定区域的高光，金粉的浓淡可以用滑块控制，最好同时结合妆容色的浓淡；额外可能需要改变特定妆容区域的光滑度，比如唇彩。</p>
<h1 id="妆容界面"><a href="#妆容界面" class="headerlink" title="妆容界面"></a>妆容界面</h1><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容0.png"><br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容1.png"></p>
<h2 id="妆容开关"><a href="#妆容开关" class="headerlink" title="妆容开关"></a>妆容开关</h2><p>最上面有一个Toggle来开关妆容模块，可以使用shader_feature_local的关键字，比如_MAKEUP来区分。</p>
<h2 id="妆容金粉"><a href="#妆容金粉" class="headerlink" title="妆容金粉"></a>妆容金粉</h2><p>最上面的界面是指定金粉贴图贴图和相应的缩放，使用同样的UV缩放和位移的好处是避免重复读取金粉贴图，提高性能，避免每个妆容模块都要去读一次贴图。毕竟贴图是存储在内存中，要读取到GPU内的话，如果没有Cache中，则速度相比一个计算来说要慢一个数量级的可能。</p>
<h2 id="妆容模块"><a href="#妆容模块" class="headerlink" title="妆容模块"></a>妆容模块</h2><p>接下来是具体的妆容模块，虽然模块比较多，实际上大同小异。功能都是通过通道贴图去改变指定位置的基础颜色，有些通道贴图还有图案的作用。有一些模块有额外的功能，比如唇彩的光滑度滑块、面纹的UV变化。</p>
<h1 id="妆容的实现原理"><a href="#妆容的实现原理" class="headerlink" title="妆容的实现原理"></a>妆容的实现原理</h1><p>下面介绍妆容的具体实现原理。</p>
<h2 id="妆容颜色"><a href="#妆容颜色" class="headerlink" title="妆容颜色"></a>妆容颜色</h2><p>这里的妆容颜色实际上对应的就是界面上具体的妆容模块。以第一个腮红为例子来说明，参考如下代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half3 makeup = baseColor;</span><br><span class="line">half4 blush = SAMPLE_TEXTURE2D(_BlushMap, sampler_BlushMap, uv0);</span><br><span class="line">makeup = lerp(makeup, blush.rgb * _BlushColor, blush.a * _BlusIntensity);</span><br></pre></td></tr></tbody></table></figure>
<p>从代码可以看到妆容色makeup是基础颜色和妆容颜色的插值结果。妆容颜色是从通道贴图读取的rgb和腮红颜色的结合，同样插值比例是通道贴图的a和腮红比例的结合。不过大部分妆容模块的妆容颜色不需要通道贴图的rgb，这种通道贴图实际上可以做合并处理。</p>
<h3 id="妆容模块的结合"><a href="#妆容模块的结合" class="headerlink" title="妆容模块的结合"></a>妆容模块的结合</h3><p>妆容模块有一定的叠加顺序，最底部的是基础色，然后是按照顺序叠加的妆容模块，比如界面上的妆容模块顺序。那么，计算的时候，首先也是一个个按照顺序插值过来，比如先插值基础颜色和腮红，然后用插值结果继续和下一个妆容模块做插值，这样得到的最终妆容颜色就是多个妆容模块的结合。</p>
<h2 id="妆容金粉-1"><a href="#妆容金粉-1" class="headerlink" title="妆容金粉"></a>妆容金粉</h2><p>金粉实际上改变的是高光。没有金粉的话，高光就是默认的情况，比如pbr的金属流高光或者Bling-Phong的高光。有金粉的话，根据金粉计算出一个高光，同时与默认高光进行插值，插值的因子同具体妆容模块的颜色计算。<br>可以参考以下代码实现：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half3 golddustUV0 = SAMPLE_TEXTURE2D(_GolddustMap, sampler_GolddustMap, _GolddustUVTile * uv0 + _GolddustUVSpeed * _Time.x).rgb;</span><br><span class="line">half4 blush = SAMPLE_TEXTURE2D(_BlushMap, sampler_BlushMap, uv0);</span><br><span class="line">half3 specular = lerp((half3)0, _BlusGolddustColor * golddustUV0 * _BlusGolddustIntensity, blush.a * _BlusIntensity);</span><br></pre></td></tr></tbody></table></figure>
<p>对于Pbr的金属流，默认的高光是0，所以金粉是为了增加额外的高光。关键的一句是在默认的高光和金粉高光之间做插值，插值比例是金粉浓度和妆容的比例。金粉高光是从金粉贴图读取出来同时应用金粉颜色和强度。</p>
<h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><p>比如唇彩模块可以改变光滑度，这个改变的前提是唇彩的通道贴图a通道是大于0的；另外还有面纹的一些UV变化，实际上这个是简单模仿贴花的功能。</p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>下面介绍一些妆容性能相关的优化策略。</p>
<h2 id="妆容通道贴图采样器的合并"><a href="#妆容通道贴图采样器的合并" class="headerlink" title="妆容通道贴图采样器的合并"></a>妆容通道贴图采样器的合并</h2><p>上述界面的妆容模块过多，如果每个妆容通道贴图一个采样器，肯定会超过限制。方式是所有妆容模块共用一个或者几个采样器。不过，理解上来说，一个贴图采样器对应一个贴图设置，所以去改变贴图的设置会不会有一些影响这个待验证。</p>
<h2 id="妆容通道贴图合并"><a href="#妆容通道贴图合并" class="headerlink" title="妆容通道贴图合并"></a>妆容通道贴图合并</h2><p>其实根本没必要一个妆容模块一个贴图，完全可以做贴图合并，比如不需要使用rgb的妆容模块，那么一个贴图可以对应四个妆容模块了。实际上，跟美术沟通后发现，妆容的效果主要是依赖妆容的通道掩码和妆容颜色，所以基本上不需要使用妆容贴图的rgb。</p>
<h2 id="妆容颜色渲染到基础贴图"><a href="#妆容颜色渲染到基础贴图" class="headerlink" title="妆容颜色渲染到基础贴图"></a>妆容颜色渲染到基础贴图</h2><p>这个理论上来说算是终极优化吧。妆容会暴露很多参数给美术或者用户，用户调整这些参数后会得到一个化妆后的效果。关键的地方是，调整完成之后，可以理解为妹子化妆完成后，效果已经固定了。那么实际上，我们不需要每次再去计算妆容颜色，而是可以将妆容颜色渲染到一张单独的贴图上或者直接覆盖原本的BaseMap。以后的渲染，就不需要使用妆容模块了。</p>
<h3 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h3><p>可以新建一个Pass，将妆容颜色的计算结果单独走一遍Pass，同时结合原本的BaseMap作为基础颜色，渲染目标是一个RT，比如是BaseMap。这个Pass的开关可以提供接口供业务代码控制，在化妆完成后调用来覆盖原本的BaseMap。</p>
<h1 id="妆容效果"><a href="#妆容效果" class="headerlink" title="妆容效果"></a>妆容效果</h1><p>最后上一点效果图吧，从美术大佬那边要来的图，凑合看看吧。<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容效果0.jpg"><br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/妆容效果3.jpg"></p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/05/18/Unity%E6%89%8B%E6%B8%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/18/Unity%E6%89%8B%E6%B8%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Unity手游性能优化的经验总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-18 11:10:00" itemprop="dateCreated datePublished" datetime="2022-05-18T11:10:00+08:00">2022-05-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index">
                    <span itemprop="name">游戏开发</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/" itemprop="url" rel="index">
                    <span itemprop="name">Unity</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/05/18/Unity%E6%89%8B%E6%B8%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="Unity手游性能优化的经验总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/18/Unity%E6%89%8B%E6%B8%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/18/Unity%E6%89%8B%E6%B8%B8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、定位游戏性能瓶颈"><a href="#一、定位游戏性能瓶颈" class="headerlink" title="一、定位游戏性能瓶颈"></a>一、定位游戏性能瓶颈</h1><h2 id="1-1-游戏循环"><a href="#1-1-游戏循环" class="headerlink" title="1.1 游戏循环"></a>1.1 游戏循环</h2><p>基本循环：游戏逻辑-渲染提交-等待渲染完成（注意：游戏逻辑指的是除去渲染之外所有的CPU运算）。<br>基本的游戏循环可以理解为先执行游戏逻辑，比如获得输入，然后更新玩家位置，播放动画，物理碰撞等，然后渲染引擎会将要渲染的游戏画面信息提交到GPU，CPU则等待GPU完成该一帧的渲染结果。</p>
<h3 id="1-1-1-单线程渲染"><a href="#1-1-1-单线程渲染" class="headerlink" title="1.1.1 单线程渲染"></a>1.1.1 单线程渲染</h3><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/singlethreaded_rendering_0.png"><br>上图可以看到主线程直接提交渲染命令GCMD给渲染设备。主线程需要等待图形设备渲染完成。</p>
<h3 id="1-1-2-多线程渲染"><a href="#1-1-2-多线程渲染" class="headerlink" title="1.1.2 多线程渲染"></a>1.1.2 多线程渲染</h3><p><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/multithreaded_rendering_0.png"><br>主线程：游戏逻辑-提交渲染到渲染线程-等待渲染完成。<br>渲染线程：提交渲染命令给GPU-等待渲染完成。<br>GPU：等待渲染命令-执行渲染。</p>
<p>从上图可以看到，主线程将渲染命令封装后提交给渲染线程，渲染再提交给图形设备渲染画面。因此，渲染线程会比主线程延迟一帧。虽然新增了渲染线程来减少CPU等待渲染完成的时间，但是每一帧主线程还是会等待渲染线程完成上一帧的渲染。因此，还是可以按照基本的游戏循环来分析每一帧的运行过程。</p>
<h2 id="1-2-利用工具确定执行时间"><a href="#1-2-利用工具确定执行时间" class="headerlink" title="1.2 利用工具确定执行时间"></a>1.2 利用工具确定执行时间</h2><p>我们需要使用工具，比如UWA分析报告或者Unity的Profile等来确定主线程的游戏逻辑、渲染提交、渲染等待，这三个部分的整体执行时间。</p>
<ol>
<li>或者利用工具获得GPU每帧耗时是多少，是否超过帧率的要求，比如30帧的话，那么一帧是33.3ms，GPU的每帧耗时就不能就不能超过33.3ms，或者不能比CPU的耗时多，否则就是GPU的性能瓶颈。</li>
<li>如果GPU不存在瓶颈，那么问题就在CPU上，这个时候要进一步分析CPU的瓶颈是游戏逻辑还是渲染提交上，这个UWA的性能分析报告和Unity的Profile都可以查看。</li>
<li>如果渲染等待时间过长，说明渲染指令过多，这个时候就需要减少渲染指令的提交，一般就是采样各种合批策略，比如SRP合批、静态合批等，或者是合并网格、减少摄像机距离或者层级Culling等。</li>
<li>如果渲染等待时间比较小，而游戏逻辑占用时间过长，那么要去分析CPU的耗时，具体是哪一块耗时过多，比如物理、动作、逻辑等。</li>
</ol>
<h1 id="二、GPU性能优化"><a href="#二、GPU性能优化" class="headerlink" title="二、GPU性能优化"></a>二、GPU性能优化</h1><p>当GPU遇到性能瓶颈时候就要着重进行GPU的性能优化，下面介绍一些常用的优化策略。</p>
<h2 id="2-1-降低分辨率"><a href="#2-1-降低分辨率" class="headerlink" title="2.1 降低分辨率"></a>2.1 降低分辨率</h2><p>很多手机的显示器分辨率过高，GPU性能却跟不上。因此，降低分辨率或者对分辨率做限制也是常见的优化手段。比如，最高档设置可以限制1080屏幕高度，依次递减，最低档的设备720就可以。</p>
<h2 id="2-2-减少OverDraw"><a href="#2-2-减少OverDraw" class="headerlink" title="2.2 减少OverDraw"></a>2.2 减少OverDraw</h2><p>OverDraw的意思是一个像素被重复绘制的次数，也就是该像素位置重复执行像素着色器(片元着色器)的次数。我们可以利用工具，比如固定管线的Unity编辑器是可以显示场景的OverDraw的，Urp的需要做一些扩展支持，来可视化游戏的OverDraw。对OverDraw特别高的部分要想办法优化，下面介绍一些Urp管线下的优化策略。</p>
<h3 id="2-2-1-自定义渲染Pass"><a href="#2-2-1-自定义渲染Pass" class="headerlink" title="2.2.1 自定义渲染Pass"></a>2.2.1 自定义渲染Pass</h3><p>Urp的渲染Pass是渲染顺序中优先级最高的，因此同一个Pass对应的物体都会在一起按照一定的顺序渲染。那么，为了减少OverDraw或者提高合批的命中，要合理的设计相关的渲染Pass。比如，天空盒是最远的物体，会一直被遮挡，这种就没必要在场景或者角色之前渲染，否则会有没必要的OverDraw。那么，就可以对天空盒单独一个Pass，在场景和角色之后执行。同理，如果角色一直靠近摄像机，也可以强制角色在场景之前的Pass渲染。</p>
<h3 id="2-2-2-渲染队列"><a href="#2-2-2-渲染队列" class="headerlink" title="2.2.2 渲染队列"></a>2.2.2 渲染队列</h3><p>渲染队列是在Shader中设置的，属于同一个Pass内的渲染顺序微调。同样的，还可以设置Render的sortingOrder等。类似的，在默认管线下，通常会调整天空盒的渲染队列为不透明物体之后来避免OverDraw。</p>
<h3 id="2-2-3-合理的渲染顺序"><a href="#2-2-3-合理的渲染顺序" class="headerlink" title="2.2.3 合理的渲染顺序"></a>2.2.3 合理的渲染顺序</h3><p>Urp渲染管线对不透明物体会按照从前到后渲染（不支持GPU隐藏面消除），透明物体按照从后到前渲染。Shader的RenderType定义是半透明还是不透明物体。另外前述的渲染Pass和渲染队列等也会影响渲染顺序。合理的渲染顺序能够提高Early-Z的命中率，减少OverDraw。</p>
<h3 id="2-2-4-减少大范围或者全屏特效"><a href="#2-2-4-减少大范围或者全屏特效" class="headerlink" title="2.2.4 减少大范围或者全屏特效"></a>2.2.4 减少大范围或者全屏特效</h3><p>大范围的特效是OverDraw的杀手，尤其特效反复重叠的情况，项目中最好从设计层面规避这种情况的出现，实在没办法的再想办法优化特效本身的执行效率，比如特效的粒子数或者面片数、Shader复杂度等。</p>
<h3 id="2-2-5-减少UI的重叠层数"><a href="#2-2-5-减少UI的重叠层数" class="headerlink" title="2.2.5 减少UI的重叠层数"></a>2.2.5 减少UI的重叠层数</h3><p>由于UI是按照半透明物体渲染的，因此要尽可能减少UI的重叠。下面的UI要隐藏而不是被覆盖。不过，这一点通常要在UI框架中做好解决，因为不仅仅是有OverDraw，UI的网格计算等CPU消耗也很大。</p>
<h2 id="2-3-提高Early-Z-Test的命中率"><a href="#2-3-提高Early-Z-Test的命中率" class="headerlink" title="2.3 提高Early-Z Test的命中率"></a>2.3 提高Early-Z Test的命中率</h2><p>理论上来说，从前到后渲染就是尽可能的提高Early-Z的命中率，从而降低OverDraw。所以，这一项优化通常是和优化OverDraw是一起进行的。</p>
<h3 id="2-3-1-减少Alpha测试"><a href="#2-3-1-减少Alpha测试" class="headerlink" title="2.3.1 减少Alpha测试"></a>2.3.1 减少Alpha测试</h3><p>但是Alpha-Test，也就是在Shader中丢弃像素，即在片元着色器中执行Discard指令，可能会破坏Early-Z Test，因为硬件不执行片元着色器就无法预测最终的深度。因此，要尽量避免大范围的Early-Z Test，除非特殊的渲染要求，比如溶解、植物、头发等，不要使用Alpha-Test。</p>
<h2 id="2-4-减少半透明物体"><a href="#2-4-减少半透明物体" class="headerlink" title="2.4 减少半透明物体"></a>2.4 减少半透明物体</h2><p>半透明物体一个是渲染顺序必须从后到前，因此OverDraw严重，性能肯定比不上不透明物体。<a href="https://docs.unrealengine.com/4.27/zh-CN/TestingAndOptimization/PerformanceAndProfiling/Guidelines/">按照虚幻的官方文档</a>，不透明最快，蒙版（Alpha测试）其次，半透明最慢(OverDraw严重)。</p>
<h2 id="2-5-降低GPU带宽"><a href="#2-5-降低GPU带宽" class="headerlink" title="2.5 降低GPU带宽"></a>2.5 降低GPU带宽</h2><h3 id="2-5-1-压缩纹理"><a href="#2-5-1-压缩纹理" class="headerlink" title="2.5.1 压缩纹理"></a>2.5.1 压缩纹理</h3><ol>
<li>纹理压缩格式：比如现今基本都支持ASTC纹理压缩，通过合理设置不同资源的压缩率，尽可能压缩纹理大小。</li>
<li>纹理大小：一些贴图根本不需要过大的尺寸，但是美术导入的原始资源通常过大，因此可以在资源导入脚本中强制压缩到一定的尺寸或者写工具扫描压缩一遍。</li>
<li>去除不必要的纹理通道：比如Alpha通道或者灰度图改成单通道</li>
</ol>
<h3 id="2-5-2-减少纹理采样次数"><a href="#2-5-2-减少纹理采样次数" class="headerlink" title="2.5.2 减少纹理采样次数"></a>2.5.2 减少纹理采样次数</h3><ol>
<li>尽可能关闭各向异性纹理</li>
<li>降低纹理质量</li>
<li>UI或者角色展示场景关闭Mipmap</li>
</ol>
<p>其中1和2都可以在工程设置的Quality中选择，可以根据不同的设备等级来选择不同的设置。3的话需要在贴图中设置，可以通过贴图导入脚本来设置。</p>
<h3 id="2-5-3-提高纹理缓存命中率"><a href="#2-5-3-提高纹理缓存命中率" class="headerlink" title="2.5.3 提高纹理缓存命中率"></a>2.5.3 提高纹理缓存命中率</h3><ol>
<li>减少贴图尺寸</li>
<li>开启Mipmap<br>GPU的片内缓冲大小是有限的，因此尽可能小的贴图或者Mipmap才更可能被缓存命中。纹理被缓存命中，那么读取速度会比从内存中读取快一个数量级。</li>
</ol>
<h3 id="2-5-4-压缩网格"><a href="#2-5-4-压缩网格" class="headerlink" title="2.5.4 压缩网格"></a>2.5.4 压缩网格</h3><ol>
<li>尽可能减少网格大小：比如限制面数、顶点数</li>
<li>开启顶点压缩<br>网格的大小也会影响带宽，但是更多的是会影响渲染面数，从而增大GPU的负担。</li>
</ol>
<h3 id="2-5-5-减少全屏Blit"><a href="#2-5-5-减少全屏Blit" class="headerlink" title="2.5.5 减少全屏Blit"></a>2.5.5 减少全屏Blit</h3><p>尽可能减少全屏特效，或者合并全屏特效的计算，减少全屏Blit的次数。</p>
<h2 id="2-6-Shader优化"><a href="#2-6-Shader优化" class="headerlink" title="2.6 Shader优化"></a>2.6 Shader优化</h2><h3 id="2-6-1-降低Shader中的数值精度"><a href="#2-6-1-降低Shader中的数值精度" class="headerlink" title="2.6.1 降低Shader中的数值精度"></a>2.6.1 降低Shader中的数值精度</h3><p>现在版本的Shader中已经不需要使用fixed类型，实际上Urp的Shader中也会编译失败。尽可能使用half类型，减少float类型的使用，float类型主要是用在postion和uv上，对应颜色等属性值尽量都用half。精度更大的话，计算时间就更多。</p>
<h3 id="2-6-2-减少Shader中的分支和循环"><a href="#2-6-2-减少Shader中的分支和循环" class="headerlink" title="2.6.2 减少Shader中的分支和循环"></a>2.6.2 减少Shader中的分支和循环</h3><p>尽可能避免分支出现，尽量不要使用循环。分支会破坏Shader的并行，严重影响Shader的执行效率。尽可能用其它方式替换，比如条件操作符、乘法等。</p>
<h3 id="2-6-3-降低Shader的计算复杂度"><a href="#2-6-3-降低Shader的计算复杂度" class="headerlink" title="2.6.3 降低Shader的计算复杂度"></a>2.6.3 降低Shader的计算复杂度</h3><p>分析一些OverDraw高或者屏幕占比高的Shader，尽可能或者根据项目要求来简化其计算复杂度，或者利用Shader LOD，写几个简化版本的Shader来对应中低端机器。</p>
<h3 id="2-6-4-减少纹理的读取次数"><a href="#2-6-4-减少纹理的读取次数" class="headerlink" title="2.6.4 减少纹理的读取次数"></a>2.6.4 减少纹理的读取次数</h3><p>在Shader中尽量减少纹理的读取次数，比如控制贴图对应的纹元可以一次性读取到变量中，不要反复读取。</p>
<h3 id="2-6-5-Shader-LOD"><a href="#2-6-5-Shader-LOD" class="headerlink" title="2.6.5 Shader LOD"></a>2.6.5 Shader LOD</h3><p>Unity的Shader支持LOD，可以针对中低端机器编写简化版本的SubShader，然后针对性的运行时切换到简化Shader运行。</p>
<h2 id="2-7-尽可能剔除不必要的物体渲染"><a href="#2-7-尽可能剔除不必要的物体渲染" class="headerlink" title="2.7 尽可能剔除不必要的物体渲染"></a>2.7 尽可能剔除不必要的物体渲染</h2><ol>
<li>合理设置摄像机远平面距离，不渲染远处的物体</li>
<li>给物体设置不同的Layer，给不同的Layer设置不同的摄像机裁剪距离</li>
<li>使用Unity自带的遮挡剔除（要烘焙数据，占用额外的包体和内存，可能占用额外的CPU，一般不建议使用）</li>
<li>自定义的剔除算法，比如检测到物体超过摄像机多远，不渲染或者只渲染部分效果（可以参考项目内的WorldCullingManager，这个是利用Unity自带的CullingGroup来检测角色的距离变化，从而缩放角色的渲染效果）。</li>
</ol>
<h2 id="2-8-LOD"><a href="#2-8-LOD" class="headerlink" title="2.8 LOD"></a>2.8 LOD</h2><h3 id="2-8-1-模型LOD"><a href="#2-8-1-模型LOD" class="headerlink" title="2.8.1 模型LOD"></a>2.8.1 模型LOD</h3><p>模型也可以使用Lod，默认情况下是随着摄像机距离变大切换到更简单的Lod。不过，也可以根据任意条件来切换Lod，比如机型匹配，帧率下降等。</p>
<h3 id="2-8-2-动画LOD"><a href="#2-8-2-动画LOD" class="headerlink" title="2.8.2 动画LOD"></a>2.8.2 动画LOD</h3><p>可以在切换模型LOD时候，选择更简单的动画状态机，这个Unity是支持分层动画和Mask的，具体参考相关文档。</p>
<h3 id="2-8-3-渲染LOD"><a href="#2-8-3-渲染LOD" class="headerlink" title="2.8.3 渲染LOD"></a>2.8.3 渲染LOD</h3><ol>
<li>不同的距离开启不一样的渲染效果，类似模型LOD，远处的物体采用更简单的渲染方式。</li>
<li>不同档次设置采用不同级别的渲染效果，比如切换Shader Lod，关闭一些Pass等。</li>
<li>不同重要度的物体，比如小怪等，可以关闭一些渲染特性或者效果，或者使用更低的Shader Lod等</li>
<li>同理，类似的其它一些缩放方式。</li>
</ol>
<h2 id="2-9-Fake渲染"><a href="#2-9-Fake渲染" class="headerlink" title="2.9 Fake渲染"></a>2.9 Fake渲染</h2><h3 id="2-9-1-假阴影"><a href="#2-9-1-假阴影" class="headerlink" title="2.9.1 假阴影"></a>2.9.1 假阴影</h3><p>比如角色下面的影子是一个黑色面片，或者使用平面阴影（Planar Shadow）。</p>
<h3 id="2-9-2-公告板"><a href="#2-9-2-公告板" class="headerlink" title="2.9.2 公告板"></a>2.9.2 公告板</h3><p>比如公告板技术实现的远处面片树木、面片房子等</p>
<h1 id="三、CPU性能优化"><a href="#三、CPU性能优化" class="headerlink" title="三、CPU性能优化"></a>三、CPU性能优化</h1><p>按照第一节的游戏循环的说法，CPU的性能优化主要包括：游戏逻辑和渲染提交。或者更准确的说，应该把CPU性能优化分为渲染优化和其它的优化；其它的优化，主要指的是游戏逻辑相关的优化，具体包括：物体、动画、粒子、UI、资源加载、游戏逻辑（游戏层脚本）、GC等。下面，我们来一个个的做一些经验介绍。</p>
<h2 id="3-1-渲染优化"><a href="#3-1-渲染优化" class="headerlink" title="3.1 渲染优化"></a>3.1 渲染优化</h2><p>CPU上的渲染主要包括两个部分，一个是计算需要渲染的物体，另一个是提交渲染和等待渲染完成。</p>
<h3 id="3-1-1-Culling优化"><a href="#3-1-1-Culling优化" class="headerlink" title="3.1.1 Culling优化"></a>3.1.1 Culling优化</h3><p>Culling也可以叫做裁剪，实质上裁剪有很多种算法或者方式。从现今的游戏引擎来说，一般是使用层次包围盒(Bounding Volume Hierarchy)，来粗略的和摄像机的可视范围做交集来进行裁剪。这一部分通常是在游戏引擎内的，因此我们不能控制。但是，SRP渲染管线提供了一些可能性来做优化。</p>
<ol>
<li>隔帧Culling：如果游戏场景更新不频繁，那么可以隔帧或者过几帧才计算一次Culling。</li>
<li>修改Urp的Renderer中的SetupCullingParameters：该函数控制渲染引擎的裁剪参数，可以尝试修改该函数以提高特定项目的裁剪效率。</li>
<li>在主线程中自定义Culling逻辑：和2.6的第四点意思一样。</li>
</ol>
<h3 id="3-1-2-渲染批次优化"><a href="#3-1-2-渲染批次优化" class="headerlink" title="3.1.2 渲染批次优化"></a>3.1.2 渲染批次优化</h3><p>本质上是优化主线程提交给渲染线程的指令数目，从而减少渲染线程提交给图形接口的渲染指令数目。对应到Unity上则是各种合批策略的体现。</p>
<ol>
<li>自定义Pass：对于要合批的物体，尤其是动态物体，比如特效，最好是定义一个专门的Pass，就不会被其它不相干物体打断动态合批（对于SRP Batcher没发现这种限制）。</li>
<li>SRP Batcher：尽可能所有的Shader兼容SRP Batcher，除非特别低端的机器，这种合批方式对性能的提高很大。</li>
<li>静态合批：静态合批通常用于场景（SRP Batcher实际上也兼容静态合批），不过静态合批需要打开网格读写，静态合批只合并材质一样的物体，因此静态合批需要美术那边尽量提高材质的重用度后使用的意义才大；同时因为静态合批会合并网格（比如，同样的网格和材质出现多次，会将网格复制多次合并成一个更大的网格）可能会导致包体和内存显著增长；因此，静态合批最适合材质重复度高，网格重复很少的场景。</li>
<li>动态合批：静态合批的运行时版本，因为有运行时的CPU消耗，类似静态合批也可能会增大内存消耗；有限制，比如要求顶点属性之和不超过900等；适合于动态的小物体的合批，比如粒子特效、小道具等。</li>
<li>Draw Instancing：也叫实例化渲染，适合的场景是网格重复多次（只是朝向、缩放等不一样），材质一样（或者材质属性基本一致的）的情况，比如大规模渲染树木和草地。</li>
<li>手动合并网格和材质：用软件来离线合并场景内的模型和材质；理论上来说，最自由但是最繁琐，如果场景小的话可以这样试试；合理控制的话，不会显著增大内存和包体，也没有运行时消耗，美术乐意的话，何乐而不为？</li>
</ol>
<h2 id="3-2-物理优化"><a href="#3-2-物理优化" class="headerlink" title="3.2 物理优化"></a>3.2 物理优化</h2><h3 id="3-2-1-降低Unity的物理更新频率"><a href="#3-2-1-降低Unity的物理更新频率" class="headerlink" title="3.2.1 降低Unity的物理更新频率"></a>3.2.1 降低Unity的物理更新频率</h3><p>可以在工程设置的Physics选项中关闭Auto Simulation，然后选择在框架更新的时候降低频率（比如2倍的Fixed Timestep）来调用Physics.Simulate来更新物理。同样可以直接设置Fixed Timestep来降低更新频率。</p>
<h3 id="3-2-2-少用或者不用MeshCollider"><a href="#3-2-2-少用或者不用MeshCollider" class="headerlink" title="3.2.2 少用或者不用MeshCollider"></a>3.2.2 少用或者不用MeshCollider</h3><h3 id="3-2-3-减少频繁射线检测的使用"><a href="#3-2-3-减少频繁射线检测的使用" class="headerlink" title="3.2.3 减少频繁射线检测的使用"></a>3.2.3 减少频繁射线检测的使用</h3><p>可以缓存计算结果或者用更快速的检测方式替代，比如boxcast。</p>
<h3 id="3-2-4-关闭碰撞矩阵中没必要的部分"><a href="#3-2-4-关闭碰撞矩阵中没必要的部分" class="headerlink" title="3.2.4 关闭碰撞矩阵中没必要的部分"></a>3.2.4 关闭碰撞矩阵中没必要的部分</h3><h2 id="3-3-动画优化"><a href="#3-3-动画优化" class="headerlink" title="3.3 动画优化"></a>3.3 动画优化</h2><h3 id="3-3-1-限制骨骼数目"><a href="#3-3-1-限制骨骼数目" class="headerlink" title="3.3.1 限制骨骼数目"></a>3.3.1 限制骨骼数目</h3><p>要求美术制作时候在规定的骨骼数目范围内，骨骼数目会影响动画大小也会影响执行效率。通常80-100已经非常足够了。</p>
<h3 id="3-3-3-动画的CPU性能优化"><a href="#3-3-3-动画的CPU性能优化" class="headerlink" title="3.3.3 动画的CPU性能优化"></a>3.3.3 动画的CPU性能优化</h3><p>参考UWA的文章：<a href="https://zhuanlan.zhihu.com/p/382656748">Unity性能优化 — 动画模块</a><br>参考Unity文档：<a href="https://docs.unity3d.com/cn/current/Manual/MecanimPeformanceandOptimization.html">性能和优化</a></p>
<h2 id="3-4-粒子优化"><a href="#3-4-粒子优化" class="headerlink" title="3.4 粒子优化"></a>3.4 粒子优化</h2><p>可以参考UWA的文章：<a href="https://blog.uwa4d.com/archives/UWA_ReportModule3.html">粒子系统优化——如何优化你的技能特效</a><br>特效的优化一般在项目的中后期，快上线的时候，针对性的对战斗这种特效集中度很高的场景进行测试和优化。</p>
<h3 id="3-4-1-限制特效的最大粒子数"><a href="#3-4-1-限制特效的最大粒子数" class="headerlink" title="3.4.1 限制特效的最大粒子数"></a>3.4.1 限制特效的最大粒子数</h3><p>通常会限制普通特效只能有5-10个粒子或者更小。</p>
<h3 id="3-4-2-限制特效的批次"><a href="#3-4-2-限制特效的批次" class="headerlink" title="3.4.2 限制特效的批次"></a>3.4.2 限制特效的批次</h3><p>最好是一个特效能在几个批次或者1个批次内渲染完成。</p>
<h3 id="3-4-3-限制特效使用的贴图尺寸"><a href="#3-4-3-限制特效使用的贴图尺寸" class="headerlink" title="3.4.3 限制特效使用的贴图尺寸"></a>3.4.3 限制特效使用的贴图尺寸</h3><p>特效尽量使用小贴图，比如不超256或者512的，尽量都是128或者更细的贴图或者贴图合集。</p>
<h3 id="3-4-3-限制特效的重叠层数和范围"><a href="#3-4-3-限制特效的重叠层数和范围" class="headerlink" title="3.4.3 限制特效的重叠层数和范围"></a>3.4.3 限制特效的重叠层数和范围</h3><p>这一部分应该算GPU的优化，可以减少OverDraw和GPU的计算。</p>
<h2 id="3-5-UI优化"><a href="#3-5-UI优化" class="headerlink" title="3.5 UI优化"></a>3.5 UI优化</h2><p>参考UWA的文章：<a href="https://blog.uwa4d.com/archives/UWA_ReportModule8.html">Unity性能优化 — UI模块</a><br>优化UI的基本原则是：</p>
<ol>
<li>减少UI变化重新生成网格：因为UI本质上也是网格加贴图绘制出来的，因此要避免各种操作或者设置到UI频繁变化导致网格重复生成。</li>
<li>减少UI的射线检测</li>
<li>UI的图集控制：比如一个界面最多2个图集等</li>
<li>战斗这种3D场景可以不使用UGUI来绘制3D的UI，而是直接用3D网格来绘制，避免UGUI的各种性能消耗。</li>
</ol>
<h2 id="3-6-资源加载优化"><a href="#3-6-资源加载优化" class="headerlink" title="3.6 资源加载优化"></a>3.6 资源加载优化</h2><p>参考UWA的文章：<a href="https://blog.uwa4d.com/archives/UWA_ReportModule2.html">Unity性能优化系列—加载与资源管理</a></p>
<h3 id="3-6-1-Shader变体的预热"><a href="#3-6-1-Shader变体的预热" class="headerlink" title="3.6.1 Shader变体的预热"></a>3.6.1 Shader变体的预热</h3><p>Shader变体的预热比较耗时，可能需要拆分处理。Shader需要优化关键字数目，尤其是全局关键字数目，这个会显著影响Shader的包体和加载进来的内存。</p>
<h3 id="3-6-2-游戏对象池"><a href="#3-6-2-游戏对象池" class="headerlink" title="3.6.2 游戏对象池"></a>3.6.2 游戏对象池</h3><p>尽量使用对象池，对象池回收时候可以隐藏GO，也可以选择移动到远处（关闭组件）。</p>
<h3 id="3-6-3-资源管理方案推荐YooAsset"><a href="#3-6-3-资源管理方案推荐YooAsset" class="headerlink" title="3.6.3 资源管理方案推荐YooAsset"></a>3.6.3 资源管理方案推荐YooAsset</h3><h2 id="3-7-游戏脚本优化"><a href="#3-7-游戏脚本优化" class="headerlink" title="3.7 游戏脚本优化"></a>3.7 游戏脚本优化</h2><p>这里主要讲的是游戏框架和游戏逻辑的代码优化，包括C#和Lua。</p>
<h3 id="3-7-1-游戏框架优化"><a href="#3-7-1-游戏框架优化" class="headerlink" title="3.7.1 游戏框架优化"></a>3.7.1 游戏框架优化</h3><p>框架应该尽可能优化，尽可能减少对使用者（游戏逻辑层）带来的性能损耗。</p>
<ol>
<li>框架代码尽量不要有GC</li>
<li>框架代码尽量不要占用额外的大内存</li>
<li>框架代码尽量不要消耗过多的CPU，使用者不用担心性能消耗<h3 id="3-7-2-游戏逻辑优化"><a href="#3-7-2-游戏逻辑优化" class="headerlink" title="3.7.2 游戏逻辑优化"></a>3.7.2 游戏逻辑优化</h3>具体的游戏逻辑优化，跟实际的游戏类型有关，需要针对性优化。</li>
</ol>
<h3 id="3-7-3-常见的脚本优化策略"><a href="#3-7-3-常见的脚本优化策略" class="headerlink" title="3.7.3 常见的脚本优化策略"></a>3.7.3 常见的脚本优化策略</h3><ol>
<li>缓存计算结果：中间结果或者初始参数尽量预计算好</li>
<li>不产生GC：任何引用类型的对象都尽量使用缓存池内的</li>
<li>对缓存友好的存储方式：比如尽量使用小数组存储数据，而不用链表或者字典</li>
<li>限帧法：限制部分逻辑的更新频率，比如2-3帧更新一次</li>
<li>多线程：部分独立性很强的逻辑，可以考虑多线程处理</li>
<li>主次法：比如非关键的角色或者物体，使用更少的计算逻辑</li>
<li>减少项目的MonoBehavior的更新函数入口，游戏逻辑尽量保持一个更新入口。</li>
</ol>
<h3 id="3-7-4-Lua代码优化"><a href="#3-7-4-Lua代码优化" class="headerlink" title="3.7.4 Lua代码优化"></a>3.7.4 Lua代码优化</h3><p>参考UWA的文章：<a href="https://blog.uwa4d.com/archives/UWA_ReportModule4.html">Unity性能优化系列—Lua代码优化</a></p>
<h2 id="3-8-GC优化"><a href="#3-8-GC优化" class="headerlink" title="3.8 GC优化"></a>3.8 GC优化</h2><p>由于Unity的Mono堆在超过最大值或者一定数值后会自动扩容，而且扩容后无法往回缩，因此必须非常关注Mono堆的峰值。</p>
<ol>
<li>降低Mono堆的峰值：这样可以避免Mono堆一直增长或者过大</li>
<li>降低GC的频率：减少不必要的CPU消耗，尽量使用缓存池中的引用对象</li>
</ol>
<h1 id="四、资源优化"><a href="#四、资源优化" class="headerlink" title="四、资源优化"></a>四、资源优化</h1><h2 id="4-1-纹理优化"><a href="#4-1-纹理优化" class="headerlink" title="4.1 纹理优化"></a>4.1 纹理优化</h2><p>这个在优化GPU代码有提到。</p>
<ol>
<li>合理降低纹理大小</li>
<li>尽量使用更高的压缩格式（ASTC更高压缩率）</li>
<li>UI或立绘关闭Mipmap</li>
<li>减少纹理通道</li>
<li>提高纹理复用（单色图复用，重复图案复用）</li>
</ol>
<h2 id="4-2-网格优化"><a href="#4-2-网格优化" class="headerlink" title="4.2 网格优化"></a>4.2 网格优化</h2><ol>
<li>关闭网格读写：除了特效外的网格关闭读写</li>
<li>开启项目的顶点压缩：会降低内存和GPU消耗，应该不会影响资源大小</li>
<li>MeshCompression：开启据说会降低网格的资源占用，但是不影响内存占用</li>
<li>尽量减少面数和顶点数：和美术制作规范，正式资源要符合要求</li>
</ol>
<h2 id="4-3-动画优化"><a href="#4-3-动画优化" class="headerlink" title="4.3 动画优化"></a>4.3 动画优化</h2><ol>
<li>压缩方式选择Optimal：官方推荐的方式</li>
<li>如果没有缩放，去除Scale曲线。</li>
<li>网上的一些剔除动画原始数据的方法以实测为准，可能剔除后动画文件变小，包体变小了，但是内存中大小不变。</li>
</ol>
<h1 id="五、内存优化"><a href="#五、内存优化" class="headerlink" title="五、内存优化"></a>五、内存优化</h1><h2 id="5-1-优化资源"><a href="#5-1-优化资源" class="headerlink" title="5.1 优化资源"></a>5.1 优化资源</h2><p>资源本身都会加载进入内存，因此优化资源本身大小对优化内存大小非常关键，第四节已经讲到。</p>
<h2 id="5-2-优化打包和资源管理"><a href="#5-2-优化打包和资源管理" class="headerlink" title="5.2 优化打包和资源管理"></a>5.2 优化打包和资源管理</h2><p>减少打AB包时候的重复，以及智能的资源加载管理方案，可以减少AB包加载后的内存占用，以及去除没必要的资源常驻现象，同时也可以优化资源加载的CPU消耗。</p>
<h2 id="5-3-优化Mono堆"><a href="#5-3-优化Mono堆" class="headerlink" title="5.3 优化Mono堆"></a>5.3 优化Mono堆</h2><p>前述已经提到Mono堆只增不涨，因此优化C#的Mono堆内存非常必要。</p>
<h2 id="5-4-优化Native内存"><a href="#5-4-优化Native内存" class="headerlink" title="5.4 优化Native内存"></a>5.4 优化Native内存</h2><p>一些插件包括引擎都会占用Native的内存，因此合理使用插件或者检测插件占用的Native内存在某些时候也有意义。如果插件造成的Native内存占用过多，是否可以考虑更换插件？比如音频插件等。</p>
<h2 id="5-5-优化Lua内存"><a href="#5-5-优化Lua内存" class="headerlink" title="5.5 优化Lua内存"></a>5.5 优化Lua内存</h2><p>Lua同样有虚拟机有自己管理的堆内存，同样是不能无限增长的。因此，Lua代码也要避免频繁创建新的对象造成GC严重或者导致堆内存一直上升。<br>UWA和UPR都有检测Lua内存的选项，可以试试。</p>
<h2 id="5-6-减少包体二进制大小"><a href="#5-6-减少包体二进制大小" class="headerlink" title="5.6 减少包体二进制大小"></a>5.6 减少包体二进制大小</h2><p>应用都会加载到内存中才会运行，因此更小的二进制包体自然会占用更小的内存。可以尝试剔除一些没有使用的代码（引擎代码或者C#脚本代码），这个Unity打包时候有相关设置。</p>
<h2 id="5-7-配置优化"><a href="#5-7-配置优化" class="headerlink" title="5.7 配置优化"></a>5.7 配置优化</h2><p>游戏项目到中后期配置可能会增大非常严重，如果一次性加载可能会造成加载时间过长，同时造成Mono内存增长过大。</p>
<ol>
<li>避免一次性加载全部配置到C#中</li>
<li>如果内存占用过高，考虑其它压缩存储方式，比如二进制存储，不要使用Json</li>
<li>Lua加载配置速度更快，但是配置过大同样内存占用高</li>
<li>实在占用过高，可以考虑小型数据库存储配置</li>
<li>是不是该让策划清理或者使用工具清理重复配置，配置本身是否严重冗余？</li>
</ol>
<h1 id="六、二进制包体优化"><a href="#六、二进制包体优化" class="headerlink" title="六、二进制包体优化"></a>六、二进制包体优化</h1><h2 id="6-1-代码裁剪"><a href="#6-1-代码裁剪" class="headerlink" title="6.1 代码裁剪"></a>6.1 代码裁剪</h2><p>Unity可以设置裁剪引擎代码，和脚本层代码。经过测试开启引擎代码裁剪问题不大，但是脚本层代码裁剪设置过高可能引起代码丢失问题，可能可以通过link.xml中的设置解决。</p>
<h2 id="6-2-安卓架构"><a href="#6-2-安卓架构" class="headerlink" title="6.2 安卓架构"></a>6.2 安卓架构</h2><p>通常ARMv7和ARM64只需要打一个架构，当前ARM64的性能更好但是兼容性不够，关闭一个架构能减少包体。</p>
<h2 id="6-3-其它跟App打包相关的方法"><a href="#6-3-其它跟App打包相关的方法" class="headerlink" title="6.3 其它跟App打包相关的方法"></a>6.3 其它跟App打包相关的方法</h2><p>具体请查阅相关文档，参考并且实验是否有效。</p>
<h1 id="七、其它"><a href="#七、其它" class="headerlink" title="七、其它"></a>七、其它</h1><p>性能优化是一个迭代的长期工作，关键是底子打好，后期优化压力就小很多；或者明白优化的思路，能够快速定位关键的性能瓶颈。</p>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/05/04/Urp%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8B%E7%9A%84%E5%8D%A1%E9%80%9A%E5%86%B0%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/04/Urp%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8B%E7%9A%84%E5%8D%A1%E9%80%9A%E5%86%B0%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Urp渲染管线下的卡通冰效果实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-04 17:10:00" itemprop="dateCreated datePublished" datetime="2022-05-04T17:10:00+08:00">2022-05-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">图形学</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/05/04/Urp%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8B%E7%9A%84%E5%8D%A1%E9%80%9A%E5%86%B0%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" class="post-meta-item leancloud_visitors" data-flag-title="Urp渲染管线下的卡通冰效果实现" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/05/04/Urp%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8B%E7%9A%84%E5%8D%A1%E9%80%9A%E5%86%B0%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/05/04/Urp%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%8B%E7%9A%84%E5%8D%A1%E9%80%9A%E5%86%B0%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><h1 id="一、卡通冰的效果"><a href="#一、卡通冰的效果" class="headerlink" title="一、卡通冰的效果"></a>一、卡通冰的效果</h1><p>先看最终实现的卡通冰材质效果吧，如下所示：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通冰.png"><br>也可以调出类似玻璃的效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通冰-玻璃.png"><br>如果对一个球应用卡通冰材质，然后打开各种选项，可以得到如下效果：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通冰-球.png"><br>凹凸不平的地方是因为应用了法线贴图。</p>
<h1 id="二、脚本和最终的材质界面"><a href="#二、脚本和最终的材质界面" class="headerlink" title="二、脚本和最终的材质界面"></a>二、脚本和最终的材质界面</h1><p>最终的材质界面，如下图所示：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通冰材质.png"><br>通过材质界面可以清晰看出卡通冰效果的各个模块。<br>另外为了获得屏幕颜色需要挂上一个脚本（PostProcessEffect）表示当前管线需要执行CopyColorPass。</p>
<h1 id="三、折射"><a href="#三、折射" class="headerlink" title="三、折射"></a>三、折射</h1><p>冰效果最关键的部分是折射，注意是折射而不是半透明。折射是透光冰看过去，后面的背景会发生一定的扭曲；而半透明混合是冰本身的颜色和背景做一定的混合，无法背景实现扭曲的效果。这里的实现思路参考之前的屏幕扭曲特效的实现方式，具体可以参考文章：<a href="https://xiaopengcheng.top/2021/10/22/Urp%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%95%88%E7%AE%A1%E7%BA%BF%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/">Urp下自定义特效管线和后处理特效实现</a>。<br>关于如何取得屏幕颜色贴图的方法不再赘述，另外为了优化性能，最终是判断是否需要获取屏幕颜色贴图（比如是否挂了屏幕特效脚本等）来决定是否执行CopyColorPass。</p>
<h1 id="3-1-折射屏幕扭曲"><a href="#3-1-折射屏幕扭曲" class="headerlink" title="3.1 折射屏幕扭曲"></a>3.1 折射屏幕扭曲</h1><p>获得屏幕颜色贴图后，只需要在屏幕空间下采样就能获得背景的颜色信息，至于扭曲的方式是通过一张扭曲贴图来采样当前位置的扭曲程度，这个扭曲程度加到屏幕空间UV上即可。一定程度的扭曲，能够模仿透过冰这种介质发生光线扭曲的这种效果。</p>
<h1 id="3-2-折射强度控制"><a href="#3-2-折射强度控制" class="headerlink" title="3.2 折射强度控制"></a>3.2 折射强度控制</h1><p>折射强度主要是通过NDotV来控制，另外提供了折射强度和控制贴图来调节。折射越强，越能透光冰看到后面的场景。至于为什么要使用NDotV，主要是为了贴近菲尼尔效应。根据菲涅尔效应，视线垂直于法线的情况下，反射越强，相应的折射越弱，NDotV越小。</p>
<h1 id="四、卡通着色"><a href="#四、卡通着色" class="headerlink" title="四、卡通着色"></a>四、卡通着色</h1><p>这里的卡通着色就是一个二阶色的卡通着色，计算halfLambert，然后映射到2个颜色（暗色、亮色），中间的过渡用smoothstep插值。可以参考文章：<a href="https://xiaopengcheng.top/2022/01/22/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E7%9D%80%E8%89%B2%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/">Unity下的日式卡通渲染实现-着色篇（一）</a>中的卡通着色部分。<br>那么卡通着色如何跟折射效果结合了？<br>可以使用折射强度去插值基础颜色和折射颜色，然后再用得到的基础色去计算卡通着色。</p>
<h1 id="五、高光"><a href="#五、高光" class="headerlink" title="五、高光"></a>五、高光</h1><p>高光就是Blinn-Phong的高光部分，计算NDotH，然后用pow(NDotH, 高光指数)来得到高光结果。比较简单，不再赘述。</p>
<h1 id="六、边缘光"><a href="#六、边缘光" class="headerlink" title="六、边缘光"></a>六、边缘光</h1><p>边缘光也是通过NDotV来判断边缘光程度，方法是判断NDotV是否小于边缘光宽度。这样不仅可以通过NDotV简单的模仿物体边缘判断，而且可以通过边缘光宽度来调整边缘光的大小。<br>高光和边缘光是叠加在卡通着色基础之上的，叠加比例是1-折射强度。</p>
<h1 id="七、描边"><a href="#七、描边" class="headerlink" title="七、描边"></a>七、描边</h1><p>描边就是使用沿着法线外扩的卡通渲染描边，可以参考文章：<a href="https://xiaopengcheng.top/2022/03/12/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E6%8F%8F%E8%BE%B9%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/">Unity下的日式卡通渲染实现-描边篇（三）</a>。</p>
<h1 id="八、溶解"><a href="#八、溶解" class="headerlink" title="八、溶解"></a>八、溶解</h1><p>为了满足特效那边的冰消融的需求，额外添加了一个溶解部分。材质设置如下图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通冰-溶解材质.png"><br>溶解的实现很简单，提供一个溶解阈值，使用颜色贴图或者控制贴图的Alpha通道，来做AlphaTest。当然具体实现是用clip函数丢弃像素。</p>
<h2 id="8-1-溶解颜色"><a href="#8-1-溶解颜色" class="headerlink" title="8.1 溶解颜色"></a>8.1 溶解颜色</h2><p>为了模仿消融的效果，提供了一个溶解颜色来表示消融的过渡色，过渡色和本来的颜色通过smoothstep来插值，插值参数是溶解程度，溶解程度即是alpha减去溶解阈值。<br>效果如下图所示：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通冰-溶解.png"><br>可以看到溶解的边缘有一个溶解过渡颜色。</p>
<h1 id="九、控制贴图"><a href="#九、控制贴图" class="headerlink" title="九、控制贴图"></a>九、控制贴图</h1><p>为了方便美术控制效果，额外提供了一张控制贴图，四个通道分别控制：高光强度、边缘光强度、折射强度、溶解Alpha值。</p>
<h1 id="十、参考资料"><a href="#十、参考资料" class="headerlink" title="十、参考资料"></a>十、参考资料</h1><blockquote>
<p><a href="https://xiaopengcheng.top/2021/10/22/Urp%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%95%88%E7%AE%A1%E7%BA%BF%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/">Urp下自定义特效管线和后处理特效实现</a><br><a href="https://xiaopengcheng.top/2022/01/22/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E7%9D%80%E8%89%B2%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/">Unity下的日式卡通渲染实现-着色篇（一）</a><br><a href="https://xiaopengcheng.top/2022/03/12/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E6%8F%8F%E8%BE%B9%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/">Unity下的日式卡通渲染实现-描边篇（三）</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

			  
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2022/03/12/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E6%8F%8F%E8%BE%B9%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/12/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E6%8F%8F%E8%BE%B9%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">Unity下的日式卡通渲染实现-描边篇（三）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-12 20:18:30" itemprop="dateCreated datePublished" datetime="2022-03-12T20:18:30+08:00">2022-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">图形学</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2022/03/12/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E6%8F%8F%E8%BE%B9%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-meta-item leancloud_visitors" data-flag-title="Unity下的日式卡通渲染实现-描边篇（三）" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/03/12/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E6%8F%8F%E8%BE%B9%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/12/Unity%E4%B8%8B%E7%9A%84%E6%97%A5%E5%BC%8F%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E5%AE%9E%E7%8E%B0-%E6%8F%8F%E8%BE%B9%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <html><head></head><body><p>这边文章讲述的是项目中用到的一些卡通渲染描边相关技术。</p>
<h1 id="一、Back-Face外扩描边"><a href="#一、Back-Face外扩描边" class="headerlink" title="一、Back Face外扩描边"></a>一、Back Face外扩描边</h1><p>背面外扩描边和后处理描边是卡通渲染中主要应用到的描边方式。</p>
<h2 id="1-1-实现原理"><a href="#1-1-实现原理" class="headerlink" title="1.1 实现原理"></a>1.1 实现原理</h2><p>第一个Pass正常渲染物体。第二个Pass只渲染背面，同时顶点沿着法线方向偏移，开启深度测试。<br>第二个Pass开启深度测试的用处一个是重叠部分不会显示出来，另外可以利用Early-Z减少需要处理的片元数量。</p>
<h2 id="1-2-描边的法线优化"><a href="#1-2-描边的法线优化" class="headerlink" title="1.2 描边的法线优化"></a>1.2 描边的法线优化</h2><p>由于我们是沿着法线偏移顶点，那么最终的描边结果对法线的依赖很大。如果法线分布有问题，可能造成描边断裂的情况。如下图所示：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通渲染描边断裂.png"></p>
<p>这是因为四个面的法线都是垂直于面的，在角的地方没有连续性。一种比较好的解决方式是计算平均法线存储在不使用的uv通道内，比如uv8，然后使用这个平均法线去计算描边。<br>何谓平均法线？即顶点周围面法线的平均或者加权平均。<br>如何计算这个平均法线了？这个可以编写外部工具对fbx直接离线修改；或者编写Unity的脚本修改uv8，不过在Unity内已经修改不了Fbx文件了，所以去修改Mesh的uv8数据，实际上这个修改是存储在工程的缓存数据内的，因此需要给Mesh新增一个Tag，如果有这个Tag导入Mesh的时候就需要就需要计算平滑法线。</p>
<h2 id="1-3-根据摄像机修正描边宽度"><a href="#1-3-根据摄像机修正描边宽度" class="headerlink" title="1.3 根据摄像机修正描边宽度"></a>1.3 根据摄像机修正描边宽度</h2><p>一个是距离摄像机的距离，理论上来说应该是距离摄像机越远描边应该越小，这个可以用摄像机空间的z值来表示。另外一个是Fov，Fov越大描边应该越小。<br>加入这2个修正因子后，描边的粗细会看起来自然很多。</p>
<h2 id="1-4-描边深度偏移控制消隐"><a href="#1-4-描边深度偏移控制消隐" class="headerlink" title="1.4 描边深度偏移控制消隐"></a>1.4 描边深度偏移控制消隐</h2><p>有些地方美术实际上不希望出现描边。比如，头发的中间部位，美术只希望头发的边缘能看到描边。但是，正对着角色的时候，头发的中间部分实际上也是外扩的边缘，同样会看到描边。<br>这种情况可以通过使用深度偏移来修改顶点着色器的裁剪坐标，从而消隐描边。实际上，就是把不需要看到的描边往里推，从而被角色本身覆盖，就看不到描边了。<br>那么，哪些描边需要消隐了？就是下面要说的顶点色。</p>
<h2 id="1-5-顶点色控制描边宽度和深度偏移"><a href="#1-5-顶点色控制描边宽度和深度偏移" class="headerlink" title="1.5 顶点色控制描边宽度和深度偏移"></a>1.5 顶点色控制描边宽度和深度偏移</h2><p>我们提供了顶点色的两个通道来分别控制描边的粗细和深度偏移。粗细很好理解，就是有些部位描边宽有些更窄。深度偏移就是上面说的消隐问题，有些地方的描边希望看不到就可以增加一定的深度偏移使其被角色挡住。<br>顶点色需要美术使用DCC工具去涂色，或者也可以在Unity中使用编辑器去涂，然后保存下来。还是类似的问题，在Unity中不能修改原始的Fbx文件，因此涂色后的网格数据只能保存为.asset。<br>当前项目中使用的是这篇文章：<a href="https://zhuanlan.zhihu.com/p/139318012">在Unity中写一个简单的顶点颜色编辑器</a>的顶点色工具，基本需求能够满足。</p>
<p>最终的描边效果如下所示：<br><img alt="卡通渲染外扩描边" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/卡通渲染外扩描边.jpg"><br>可以看到头顶的头发通过顶点色深度偏移控制了消隐，头发的描边粗细也是通过另一个顶点色通道控制的。</p>
<h1 id="二、-后处理描边"><a href="#二、-后处理描边" class="headerlink" title="二、 后处理描边"></a>二、 后处理描边</h1><p>后处理描边是在图像空间使用边缘检测因子得到边缘信息，通常是检测深度图或者法线图，比颜色图效果更好。因为，深度或者法线在角色边缘有明显的不连续性。但是，后处理描边的缺点是无法控制描边或者说很难像外扩描边一样精细的控制描边效果，同时还会把内描边也检测出来。<br>对于头发的描边，后处理描边这些缺点就是非常致命的，因为我们主要用的还是外扩描边。</p>
<h1 id="三、其它描边方式"><a href="#三、其它描边方式" class="headerlink" title="三、其它描边方式"></a>三、其它描边方式</h1><h2 id="3-1-NdotV"><a href="#3-1-NdotV" class="headerlink" title="3.1 NdotV"></a>3.1 NdotV</h2><p>类似简单的边缘光实现方式，也可以用来做描边，但是效果和控制力度肯定是达不到需求的。</p>
<h2 id="3-2-深度贴图描边"><a href="#3-2-深度贴图描边" class="headerlink" title="3.2 深度贴图描边"></a>3.2 深度贴图描边</h2><p>之前说的深度贴图边缘光和阴影同样可以用来做描边，也能使用顶点颜色提供一定的控制粒度，比如控制粗细，但是也无法做深度偏移消隐等。</p>
<h1 id="四、内描边"><a href="#四、内描边" class="headerlink" title="四、内描边"></a>四、内描边</h1><p>所谓内描边，指的是物体内部的描边，非物体边缘看到的描边。之前说的技术基本上都是针对外描边的。</p>
<h2 id="4-1-本村线"><a href="#4-1-本村线" class="headerlink" title="4.1 本村线"></a>4.1 本村线</h2><p>简单来说，是直接在贴图上画描边，同时这些描边基本是跟轴对齐的。不过工作量很大，而且很大细节需要控制，很少有美术愿意采用这种方式，因此不做过多的讨论。<br>如下图：<br>!](<a href="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/本村线描边.jpg">https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/本村线描边.jpg</a>)</p>
<h2 id="4-2-后处理内描边"><a href="#4-2-后处理内描边" class="headerlink" title="4.2 后处理内描边"></a>4.2 后处理内描边</h2><p>网上有文章提到二之国中的做法是在顶点属性通道中记录边缘程度，然后在后处理中来进行绘制内描边。<br>如下图所示：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/二之国后处理内描边.jpg"><br>猜测是类似于顶点色的方式，让美术使用工具在顶点色中涂色边缘程度，<br>然后需要一个Pass将顶点色上的边缘程度属性输出到一个RT上，最终在后处理Pass中检测这个RT对应像素的边缘程度完成内描边。<br>至于如何将边缘程度转换为描边，需要参考相关资料才能弄清楚了，这里的日文看不懂啊。</p>
<h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/109101851">【01】从零开始的卡通渲染-描边篇</a><br><a href="https://zhuanlan.zhihu.com/p/163791090">卡通渲染学习总结</a></p>
</blockquote>
</body></html>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="远行"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">远行</p>
  <div class="site-description" itemprop="description">远行的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">223</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xpc-yx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xpc-yx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiaopengcheng4912@qq.com" title="E-Mail → mailto:xiaopengcheng4912@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/sitemap.xml" title="sitemap → &#x2F;sitemap.xml"><i class="fa fa-fw fa-sitemap"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">远行</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">676k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'xqSndxWj2seRmSIR1WvYWOxI-gzGzoHsz',
    appKey: 'dWX3wyEMQ9djk8yiujbPp4pz',
    placeholder: "留下你的足迹 O(∩_∩)O~~",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
