<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>游戏引擎渲染管线的总结</title>
      <link href="/2021/12/22/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/22/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>需要注意的是，本文涉及的内容过多过杂，基本涉及到游戏渲染和图形管线的方方面面。内容是根据多方面的资料整理而成，比如本人的Unity和Unreal引擎相关的理解和认知，以及引擎相关官方文档等，以及DirectX和OpenGL相关官方文档等，以及网络上各种相关文章和资料等。可能有一些纰漏或者不足之处，或者有些阶段的资料来源较为单一，本人主要目的是从概念理解上对应整个游戏引擎的渲染管线，不一定和真实的游戏完全一一对应，比如应用程序阶段的知识对应到游戏引擎应该会有一些区别和取舍，几何阶段和光栅化阶段主要参考的是OpenGL和DirectX，Vulkan和Metal相关资料参考较少，可能不同的图形API会有一些出入。由于涉及内容过多，难免理解不到位，有发现比较明显错误的，请指出以尽早修正，避免造成误解。</p><h1 id="一、渲染管线的思维导图"><a href="#一、渲染管线的思维导图" class="headerlink" title="一、渲染管线的思维导图"></a>一、渲染管线的思维导图</h1><p>这是本文内容的思维导图，通过该图可以从整体上把握全文的内容，对渲染管线有整理的理解。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/渲染管线.png"></p><h1 id="二、应用程序阶段"><a href="#二、应用程序阶段" class="headerlink" title="二、应用程序阶段"></a>二、应用程序阶段</h1><h2 id="2-1-渲染数据加载"><a href="#2-1-渲染数据加载" class="headerlink" title="2.1 渲染数据加载"></a>2.1 渲染数据加载</h2><p>这个阶段指的是将渲染所需要的相关数据，比如模型、贴图、材质、Shader等加载到内存中，通常只发生一次，不需要每帧重复加载。比如，Unity游戏需要在运行时，将需要的场景或者人物从AssetBundle中加载出来，然后引擎才能显示加载的场景或者人物。</p><h2 id="2-2-物体级别的裁剪"><a href="#2-2-物体级别的裁剪" class="headerlink" title="2.2 物体级别的裁剪"></a>2.2 物体级别的裁剪</h2><p>以下描述的裁剪算法是按照粒度从粗到细的裁剪，相应复杂度和代价也是在递增。最简单的是基于距离的裁剪；然后是利用空间数据结构实现的视锥体裁剪；动态的入口裁剪是一种特殊情况，可以算在视口裁剪内也可以用于预计算；然后预计算数据的裁剪；接下来才是动态的遮挡剔除。</p><h3 id="2-2-1-基于距离的裁剪"><a href="#2-2-1-基于距离的裁剪" class="headerlink" title="2.2.1 基于距离的裁剪"></a>2.2.1 基于距离的裁剪</h3><p>思路是超过一定的视距即不渲染该物体，Unreal引擎支持这个特性，参考<a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/VisibilityCulling/CullDistanceVolume/" target="_blank" rel="noopener">Cull Distance Volumes</a>。对于Unity，可以使用<a href="https://docs.unity3d.com/Manual/CullingGroupAPI.html" target="_blank" rel="noopener">CullingGroup</a>实现类似的功能。即使引擎没有提供类似的支持，在游戏逻辑层面，先可以每帧或者隔帧判断物体跟摄像机的距离，来动态显示隐藏物体。</p><h3 id="2-2-2-视锥体裁剪"><a href="#2-2-2-视锥体裁剪" class="headerlink" title="2.2.2 视锥体裁剪"></a>2.2.2 视锥体裁剪</h3><p>用物体跟摄像机视锥体做相交测试，将完全没有相交的物体过滤掉。为了加快速度，使用的是物体的包围盒或者包围球跟视锥体做相交测试。游戏引擎内一般都会有空间数据结构来组织物体，比如BVH，那么可以直接使用BVH来搜索加速这个计算。具体过程是用视锥体和空间数据结构去做相交测试，如果当前节点没有相交，那么不需要继续，如果有相交则继续遍历子节点直到叶子节点或者没有相交，叶子节点中存储的物体即是需要渲染的物体。</p><h4 id="基于空间数据结构的裁剪"><a href="#基于空间数据结构的裁剪" class="headerlink" title="基于空间数据结构的裁剪"></a>基于空间数据结构的裁剪</h4><h5 id="四叉树和八叉树"><a href="#四叉树和八叉树" class="headerlink" title="四叉树和八叉树"></a>四叉树和八叉树</h5><p>四叉树对应的是二维空间，下面以八叉树为例来说明。八叉树是将三维空间平均划分为八个部分作为八个子节点，重复划分到一定的粒度为止，比如叶子节点内最多存储多少个物体，物体存储在叶子节点内。<br>优点：概念和实现简单。<br>缺点：无限空间不好划分；物体可能跨越分割面；物体分布不均匀会造成层次过深，搜索效率不高。<br>适用场景：四叉树适用于基于高度场的地形管理；八叉树室适用于室外分布均匀的三维场景（有高度）。</p><h5 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h5><p>针对八叉树这种不均匀划分，如果将物体均匀划分成两部分，那么就是Binary Space Partition Tree，可以避免树的层次过深。注意，BSP的每个节点存储的是划分平面，而不是物体，划分平面将场景分为前后2个部分，分别对应左右子树；由于需要BSP树针对的多边形，因此可以针对物体的AABB包围盒做划分。</p><p>优点：物体分布均匀，不会出现树层次过深；支持任意空间。<br>缺点：实现复杂，构造时间长，不适合动态场景。<br>适用场景：紧凑并且分布均匀的室内场景；静态场景；自带物体排序，方便实现画家算法。</p><h5 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h5><p>BSP全称是K-Dimensional Tree。这是一种特殊的BSP，在BSP上进一步将划分面限制跟坐标轴垂直，但是保持从物体分布的中间划分，以尽可能得到一个物体分布均匀的树。KD-Tree不仅仅可以用来做空间划分，在其它领域经常用来组织K维度的数据来做搜索，比如K维数据查询、近邻查询。<br>优点：物体分布均匀，不会出现树层次过深；数据可以组织为数组形式的完全二叉树，缓存友好等。<br>缺点：如何确定最优或者较优的划分面？<br>适用场景：紧凑并且分布均匀的室内场景；辅助其它数据结构进行邻域查询。</p><h5 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h5><p>全名是Bounding Volume Hierarchy，中文翻译层次包围盒。BSP和KD-Tree的节点代表的都是分割面，但是面有可能穿过物体。层次包围盒的思想是每个节点代表一个空间，空间计算其包含物体的最小包围盒，划分空间后重新计算子空间的包围盒。与BSP最大区别是节点代表的不再是分割平面而是包含最小包围盒的子空间。因此，这些子空间可能出现一定的重叠，但是不会出现物体出现在不同的划分里面。<br>优点：节点存储的是物体，方便碰撞检测等查询；构建快，动态更新方便。<br>缺点：如何确定最优的包围盒？<br>适用场景：视锥剔除；物体碰撞检测；射线检测；光线跟踪。</p><h5 id="空间数据结构的其它应用"><a href="#空间数据结构的其它应用" class="headerlink" title="空间数据结构的其它应用"></a>空间数据结构的其它应用</h5><p>除了视锥体裁剪外，空间数据结构还有很多其它应用，比如<br>1、Ray Casting （射线检测）<br>2、碰撞检测<br>3、邻近查询 （比如查询玩家周围敌人）<br>4、光线追踪</p><h4 id="Portal-Culling（入口裁剪）"><a href="#Portal-Culling（入口裁剪）" class="headerlink" title="Portal Culling（入口裁剪）"></a>Portal Culling（入口裁剪）</h4><p>适用于将场景划分为格子，格子之间可能存在入口的情形，如下图所示，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/portal-diagram.png"></p><p>从入口只能看到部分被墙壁遮挡住的物体，因此可以借助这个特性加速视锥体和格子的相交裁剪。Unity中的<a href="https://docs.unity3d.com/Manual/class-OcclusionPortal.html" target="_blank" rel="noopener">Occlusion Portal</a>即是这个特性。如果预计算出Protal Culling的结果，那么可以在运行时加快物体裁剪。</p><h3 id="2-2-3-预计算遮挡剔除"><a href="#2-2-3-预计算遮挡剔除" class="headerlink" title="2.2.3 预计算遮挡剔除"></a>2.2.3 预计算遮挡剔除</h3><p>这是一种空间换时间的算法，会增大内存占用，降低Cpu的裁剪消耗。所以是否需要预计算遮挡数据，还需要具体讨论。一般如果内存消耗不大，但是Cpu占用较高的话，可以尝试开启预计算遮挡数据。</p><h4 id="Precomputed-Visibility-UE4"><a href="#Precomputed-Visibility-UE4" class="headerlink" title="Precomputed Visibility (UE4)"></a>Precomputed Visibility (UE4)</h4><p>参考虚幻引擎的<a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/VisibilityCulling/PrecomputedVisibilityVolume/" target="_blank" rel="noopener">Precomputed Visibility</a>。思想是将场景划分为格子，计算每个格子内可以看到的可见物体集合相关的数据，用于运行时动态查询。</p><h4 id="预计算Occlusion-Culling-Unity"><a href="#预计算Occlusion-Culling-Unity" class="headerlink" title="预计算Occlusion Culling (Unity)"></a>预计算Occlusion Culling (Unity)</h4><p>参考Unity的<a href="https://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank" rel="noopener">Occlusion culling</a>。类似于UE4的Precomputed Visibility，不过Unity的Occlusion Culling也支持动态物体，但是动态物体只能occludee（被遮挡物体）。Unity的预计算Occlusion Culling应该是入口剔除的一种预计算实现。</p><h3 id="2-2-4-动态遮挡查询"><a href="#2-2-4-动态遮挡查询" class="headerlink" title="2.2.4 动态遮挡查询"></a>2.2.4 动态遮挡查询</h3><p>这里讲的是在CPU上或者GPU上实现的遮挡查询。图形API已经提供了遮挡查询相关的接口，比如OpenGL的<a href="https://www.khronos.org/opengl/wiki/Query_Object" target="_blank" rel="noopener">Query Object</a>或者DirectX的<a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/predication-queries" target="_blank" rel="noopener">Predication Queries</a>。但是不是所有的硬件都能够支持，因此可以在软件层面即在CPU上做软渲染实现遮挡查询。Hierarchical Z-Buffer Occlusion则是在普通的硬件遮挡查询上的进一步优化，使用了层次Z-Buffer来进一步加快速度。</p><h4 id="软件遮挡查询"><a href="#软件遮挡查询" class="headerlink" title="软件遮挡查询"></a>软件遮挡查询</h4><p>软光栅化模仿硬件遮挡查询，因此不受设备类型限制，只是需要额外消耗CPU。</p><h4 id="硬件遮挡查询"><a href="#硬件遮挡查询" class="headerlink" title="硬件遮挡查询"></a>硬件遮挡查询</h4><p>使用图形接口本身提供的遮挡查询接口。基本思想是用物体的包围盒去渲染Z-Buffer，统计通过深度测试的像素数目，如果有通过说明当前物体没有被完全挡住，保存结果用于下一帧查询。因此，硬件遮挡查询会存在两个问题：额外的渲染消耗和延迟一帧。</p><h4 id="Hierarchical-Z-Buffer-Occlusion"><a href="#Hierarchical-Z-Buffer-Occlusion" class="headerlink" title="Hierarchical Z-Buffer Occlusion"></a>Hierarchical Z-Buffer Occlusion</h4><p>类似硬件遮挡查询，不过使用Hierarchical Z-Buffer来加快查询速度。具体实现比较复杂，请参考相关文章。</p><h3 id="2-2-5-LOD切换"><a href="#2-2-5-LOD切换" class="headerlink" title="2.2.5 LOD切换"></a>2.2.5 LOD切换</h3><p>LOD指的是Level Of Details。如果物体通过了以上的裁剪，那么说明会提交给渲染线程进行处理。LOD切换指的是这些物体的细节层次切换，比如一些不重要的或者看不清楚的物体选择更简单的模型。</p><h4 id="基于距离的LOD切换"><a href="#基于距离的LOD切换" class="headerlink" title="基于距离的LOD切换"></a>基于距离的LOD切换</h4><p>最常见的方式是根据摄像机距离来进行LOD切换，越远的物体选择更简略的LOD，Unity和UE4默认是这种方式。</p><h4 id="基于渲染分级切换LOD"><a href="#基于渲染分级切换LOD" class="headerlink" title="基于渲染分级切换LOD"></a>基于渲染分级切换LOD</h4><p>但是我们也可以主动切换LOD，比如检测到当前硬件较差，需要切换到更低的画质，那么可以根据游戏设置的渲染品质分级来切换低的LOD。</p><h4 id="LOD过渡"><a href="#LOD过渡" class="headerlink" title="LOD过渡"></a>LOD过渡</h4><p>LOD的一个常见问题是LOD的过渡问题，可能在切换LOD时候会察觉到明显的过渡。常见的方式是在切换时候混合2个LOD，比如透明度逐渐从1变化到0或者从0变化到1，避免出现明显的过渡。</p><h2 id="2-3-物体级别的渲染排序"><a href="#2-3-物体级别的渲染排序" class="headerlink" title="2.3 物体级别的渲染排序"></a>2.3 物体级别的渲染排序</h2><p>为了减少OverDraw或者实现半透明效果，所有通过裁剪的物体会按照一定的次序进行渲染。下面列举几个常见的渲染次序。游戏引擎实际的渲染过程还会跟引擎渲染管线的Pass定义顺序相关，比如不透明和透明物体在不同的Pass内渲染的，而且是先在一个Pass内渲染透明物体，再在另外一个Pass渲染透明物体。</p><h3 id="从前到后渲染（不透明物体）"><a href="#从前到后渲染（不透明物体）" class="headerlink" title="从前到后渲染（不透明物体）"></a>从前到后渲染（不透明物体）</h3><p>从前到后渲染可以利用Early Z-Test过滤掉不必要的片元处理。因此，如果先渲染近处的物体，那么后面渲染的远处物体就不会通过Early Z-Test，就不会进入片段处理阶段。不过，不是所有的硬件都需要按照从前到后的物体顺序进行渲染，这毕竟需要额外的CPU消耗来排序物体，部分支持HSV（hidden surface removal）特性的GPU，比如PowerVR是不需要做这个排序的。Unity提高了静态变量SystemInfo.hasHiddenSurfaceRemovalOnGPU来查询GPU是否支持HSV，<br>Urp渲染管线会根据这个来判断是否需要跳过从前到后排序物体。</p><h3 id="从后到前渲染（半透明物体）"><a href="#从后到前渲染（半透明物体）" class="headerlink" title="从后到前渲染（半透明物体）"></a>从后到前渲染（半透明物体）</h3><p>由于半透明物体的渲染算法要求必须从后到前渲染物体，同时关闭深度测试 ，前面的物体与后面的物体进行颜色混合。那么这个排序过程是无法省掉的，类似从前到后渲染的排序，可以采样BSP来排序物体。</p><h3 id="渲染层级或渲染队列"><a href="#渲染层级或渲染队列" class="headerlink" title="渲染层级或渲染队列"></a>渲染层级或渲染队列</h3><p>Unity同时定义了这2种排序，不过SortingLayer的优先级更高，这个是定义在物体的Renderer组件上。RenderQueue是定义在Shader和材质上，优先级在渲染层级之后。理论上，就是对所有物体进行优先级排序。</p><h3 id="最少渲染状态切换"><a href="#最少渲染状态切换" class="headerlink" title="最少渲染状态切换"></a>最少渲染状态切换</h3><p>还有一种方式是尽可能在渲染物体的时候避免渲染状态切换，这样能够尽可能减少CPU消耗。那么可以在CPU计算出来一个最优的渲染顺序来尽可能减少渲染状态切换。</p><h2 id="2-4-渲染数据绑定和状态设置"><a href="#2-4-渲染数据绑定和状态设置" class="headerlink" title="2.4 渲染数据绑定和状态设置"></a>2.4 渲染数据绑定和状态设置</h2><p>这一个阶段讲的是在CPU上设置渲染相关数据和状态，以及为了减少渲染状态切换的渲染合批的思想。</p><h3 id="视口设置"><a href="#视口设置" class="headerlink" title="视口设置"></a>视口设置</h3><p>设置窗口的渲染区域，比如OpenGL的<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml" target="_blank" rel="noopener">glViewport</a>。通过这个设置，我们可以在一个窗口上渲染多个不同的视口，比如游戏的分屏。</p><h3 id="FrameBuffer设置"><a href="#FrameBuffer设置" class="headerlink" title="FrameBuffer设置"></a>FrameBuffer设置</h3><p>一般游戏引擎不会直接将物体渲染到默认的渲染缓冲上，单独的RenderTarget方便进行后处理，在后处理之后再Blit到默认缓冲上。一个FrameBuffer可以包含颜色、深度、模板三个附件，也可以将深度和模板组织成一个32位的RT。</p><h3 id="渲染合批"><a href="#渲染合批" class="headerlink" title="渲染合批"></a>渲染合批</h3><p>渲染合批指的是为了减少渲染状态切换的一种优化手段，Unity URP渲染管线的SRP技术可以大幅度优化渲染批次。这是一个在Shader变体层次的合批，与之前的材质层次的合批相比有很大的优化。</p><h3 id="顶点输入绑定"><a href="#顶点输入绑定" class="headerlink" title="顶点输入绑定"></a>顶点输入绑定</h3><p>对于OpenGL来说就是创建和绑定VAO（Vertex Array Object）。一个VAO中可以包含VBO（Vertex Buffer Object）、IBO（Index Buffer Object）。然后用glVertexAttribPointer和glEnableVertexAttribArray指定数据到Shader的输入变量。<br>顶点属性通常包括，位置、法线、切线、UV、顶点颜色等。</p><h3 id="Shader绑定"><a href="#Shader绑定" class="headerlink" title="Shader绑定"></a>Shader绑定</h3><p>渲染数据绑定好之后，需要指定当前使用的Shader，这包括Shader的编译链接和使用等（假设Shader代码已经加载进来）。</p><h4 id="Shader编译链接使用"><a href="#Shader编译链接使用" class="headerlink" title="Shader编译链接使用"></a>Shader编译链接使用</h4><p>类似于CPU上运行的程序，Shader也需要编译链接以及开始使用的过程，不过这个过程基本上是固定。<br>可以参考learnopengl的<a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/" target="_blank" rel="noopener">着色器</a>一节。</p><h4 id="Uniform变量绑定"><a href="#Uniform变量绑定" class="headerlink" title="Uniform变量绑定"></a>Uniform变量绑定</h4><p>Shader中通常会有很多全局变量，比如MVP、摄像机位置、光的信息等。这些都需要在CPU上传入Shader中。</p><h3 id="Output-Merger-Stage相关设置"><a href="#Output-Merger-Stage相关设置" class="headerlink" title="Output-Merger Stage相关设置"></a>Output-Merger Stage相关设置</h3><p>在渲染管线的最后（片元着色器之后），有一个Output-Merger阶段，也叫做Raster Operations。这是一个不可编程阶段，但是有很多选择可以设置。比如剪切测试、模板测试、深度测试、颜色混合因子和函数、sRGB转换等。这些都需要在应用程序阶段进行设置。</p><h2 id="2-5-DrawCall调用"><a href="#2-5-DrawCall调用" class="headerlink" title="2.5 DrawCall调用"></a>2.5 DrawCall调用</h2><p>终于到了应用程序的最后一步，即DrawCall的调用了。OpenGL对应的接口是<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" target="_blank" rel="noopener">glDrawArrays</a>或者<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml" target="_blank" rel="noopener">glDrawElements</a>。</p><h1 id="三、几何处理阶段"><a href="#三、几何处理阶段" class="headerlink" title="三、几何处理阶段"></a>三、几何处理阶段</h1><p>这是第二个大的阶段，当前阶段已经进行GPU中了。该阶段的起点和主要过程是顶点着色器。除了着色器之外，其余阶段都是硬件自动进行的，除了可选阶段之外，其余的都是固定的，应用程序无法根据配置来进行更改。</p><h2 id="3-1-顶点着色器"><a href="#3-1-顶点着色器" class="headerlink" title="3.1 顶点着色器"></a>3.1 顶点着色器</h2><p>顶点着色器的处理对象是应用程序阶段绑定的每个顶点，顶点着色器会获得顶点属性以及相应的Uniform变量。顶点着色器的输出是一个NDC Clip Space的顶点位置。NDC（Normalized device coordinates）是规范化设备坐标系的位置，OpenGL的范围[-1,1]，DirectX的范围是[0,1]。之所以说是Clip Space，因为该阶段得到的顶点数据是一个齐次坐标，还需要进行透视除法，即x、y、z除以w分量才能得到NDC坐标系下的位置。</p><h2 id="3-2-曲面细分着色器"><a href="#3-2-曲面细分着色器" class="headerlink" title="3.2 曲面细分着色器"></a>3.2 曲面细分着色器</h2><p>曲面细分着色器是一个可选阶段，用于将一个简单模型细分成复杂的模型。其实该阶段是2个着色器和一个固定阶段的组合。在DirectX中叫做Hull Shader stage、Tessellator stage、Domain Shader stage；在OpenGL的<a href="https://www.khronos.org/opengl/wiki/Tessellation" target="_blank" rel="noopener">Tessellation</a>中叫做Tessellation Control Shader、Tessellation Primitive eneration、Tessellation Evaluation Shader。具体的介绍和使用方式请参考相关资料。</p><h2 id="3-3-几何着色器"><a href="#3-3-几何着色器" class="headerlink" title="3.3 几何着色器"></a>3.3 几何着色器</h2><p>几何着色器也是一个可选阶段。几何着色器的输入是图元的顶点集合（比如三角形图元有三个顶点，点图元只有一个顶点），输出是一个新的图元，新的图元也要包含一个顶点集合。简单来说，几何着色器的输入和输出都是图元，输入的图元是在应用程序阶段指定的，输出的图元可以在顶点着色器中实现。</p><h2 id="3-4-Stream-Output-（Transform-Feedback）"><a href="#3-4-Stream-Output-（Transform-Feedback）" class="headerlink" title="3.4 Stream Output （Transform Feedback）"></a>3.4 Stream Output （Transform Feedback）</h2><p>这是一个可选的阶段。这个阶段在DirectX中叫做Stream Output ，在OpenGL找叫做Transform Feedback。如果该阶段开启，那么顶点数据流会输出到一个Buffer中，这个Buffer可以给顶点着色器使用也可以返回给CPU，当前渲染管线则不会进行接下来的处理。</p><h2 id="3-5-图元组装"><a href="#3-5-图元组装" class="headerlink" title="3.5 图元组装"></a>3.5 图元组装</h2><p>这一步是将之前得到的顶点数据组合成图元，比如顶点图元、线段图元、三角形图元。该阶段输出图元进行接下来的处理。</p><h2 id="3-6-透视除法和NDC裁剪"><a href="#3-6-透视除法和NDC裁剪" class="headerlink" title="3.6 透视除法和NDC裁剪"></a>3.6 透视除法和NDC裁剪</h2><p>该阶段的输入是组装好的图元，输出的是NDC裁剪之后的图元。首先对图元的顶点进行透视除法，这样得到的顶点数据都会位于NDC内，方便进行NDC裁剪。图元裁剪后可以会产生新的图元。</p><h2 id="3-7-屏幕空间映射"><a href="#3-7-屏幕空间映射" class="headerlink" title="3.7 屏幕空间映射"></a>3.7 屏幕空间映射</h2><p>该阶段是将NDC下的图元顶点坐标映射到屏幕空间。值得注意的是顶点坐标是一个齐次坐标，透视除法后得到的是NDC下的坐标；然后，通过一个缩放和平移变换将x和y映射到屏幕空间。</p><h2 id="3-8-面剔除-（Face-Culling）"><a href="#3-8-面剔除-（Face-Culling）" class="headerlink" title="3.8 面剔除 （Face Culling）"></a>3.8 面剔除 （Face Culling）</h2><p>这一个阶段指的是三角形的前后面剔除。前或者后的定义是根据正视三角形的时候定义三角形顶点的旋向，可以定义逆时针旋转或者顺时针旋转为前面。实际上，面剔除跟实际的摄像机位置没有关系，不管摄像机转到哪个地方，前后面不会改变，比如渲染立方体的时候，后面都是立方体内部看不到的面，无论摄像机如何旋转。因为，前后面的定义是固定视角正对三角形时候定义的。</p><h1 id="四、光栅化阶段"><a href="#四、光栅化阶段" class="headerlink" title="四、光栅化阶段"></a>四、光栅化阶段</h1><p>该大的阶段的输入是几何处理阶段输出的图元。该阶段主要分为四个部分，首先是光栅化图元得到片元（潜在的像素信息），然后进行Early Fragment Test，通过测试后再进行片元着色器，最终进行输出合并阶段的各种测试以及颜色混合等，再输出到颜色缓冲区。</p><h2 id="4-1-图元光栅化"><a href="#4-1-图元光栅化" class="headerlink" title="4.1 图元光栅化"></a>4.1 图元光栅化</h2><p>该阶段是将图元的顶点信息进行线性插值，然后生成片元数据。每个片元上有顶点信息线性插值而来的片元数据。需要注意的是，这个插值是线性的，如果有一些数据是非线性的，则不能在顶点着色器中计算然后输出到片元着色器，因为线性插值的结果和在片元着色器中计算的结果是不一致的。<br>这里需要特别说明的是，关于深度z’的生成。屏幕空间映射后的z’是关于摄像机空间z倒数的一个线性函数。之所以使用1/z而不是z，是为了在近处获得更好的深度缓冲精度，因为1/z在近处的变化更快，可以优化Z-Fighting这种现象。由于z’不是一个关于z的线性函数，因此z’应该是在光栅化后硬件自动根据1/z计算出来的，而不是先计算z’再光栅化。 </p><h2 id="4-2-Early-Fragment-Test"><a href="#4-2-Early-Fragment-Test" class="headerlink" title="4.2 Early Fragment Test"></a>4.2 Early Fragment Test</h2><p>参考OpenGL的<a href="https://www.khronos.org/opengl/wiki/Early_Fragment_Test" target="_blank" rel="noopener">Early Fragment Test</a>，可以看到不仅仅通常所说的Early Z-Test还有其它好几个阶段都可以进行EarlyTest，一共是四个测试（Pixel ownership test、Scissor test、<br> Stencil test、Depth test）和遮挡查询更新。根据文档，Pixel ownership test和Scissor test从OpenGL4.2起会总是在EarlyTest阶段进行。那么，如果这些测试没有在EarlyTest阶段进行，则会在最终的输出合并阶段进行；如果进行了，那么输出合并阶段也不会重复处理。</p><h3 id="4-3-Early-Z-Test的限制"><a href="#4-3-Early-Z-Test的限制" class="headerlink" title="4.3 Early Z-Test的限制"></a>4.3 Early Z-Test的限制</h3><p>不要在片元着色器中改变深度，比如glsl的gl_FragDepth；也不要discard片元，通常实现AlphaTest会根据Alphadiscard片元。因为这些操作会导致硬件无法预测最终的深度，从而无法进行提前深度测试。</p><h2 id="4-4-片段着色器"><a href="#4-4-片段着色器" class="headerlink" title="4.4 片段着色器"></a>4.4 片段着色器</h2><p>片段着色器的输入是光栅化来的各种顶点属性，输出是一个颜色值。该阶段是计算光照结果的主要阶段。通常片元着色器会有比较复杂的计算，通常的优化手段是将计算转移到顶点着色器甚至CPU（应用程序阶段，用Uniform传入）上。</p><h2 id="4-5-Output-Merger-Stage-Raster-Operations"><a href="#4-5-Output-Merger-Stage-Raster-Operations" class="headerlink" title="4.5 Output-Merger Stage(Raster Operations)"></a>4.5 Output-Merger Stage(Raster Operations)</h2><p>终于进入最后的输出合并阶段，该阶段的输入是一个个的片元。片元需要进行一些列的测试和转换，最终才会将颜色输出到缓冲区上。</p><h3 id="Pixel-ownership-test"><a href="#Pixel-ownership-test" class="headerlink" title="Pixel ownership test"></a>Pixel ownership test</h3><p>根据OpenGL的文档，该阶段只对默认缓冲区生效，用于测试像素是否被其它窗口遮挡的情形。对于自定义的FrameBuffer，不存在这个测试。</p><h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>需要特别说明的是，Alpha测试当前是已经被废弃了，从DirectX10和OpenGL3.1开始废弃，参考<a href="https://www.khronos.org/opengl/wiki/Transparency_Sorting" target="_blank" rel="noopener">Transparency Sorting</a>文档；当前需要在片元着色器用discard实现。列在这里主要是为了完整性。</p><h3 id="Scissor-test"><a href="#Scissor-test" class="headerlink" title="Scissor test"></a>Scissor test</h3><p>参考OpenGL的剪切测试文档，<a href="https://www.khronos.org/opengl/wiki/Scissor_Test" target="_blank" rel="noopener">Scissor Test</a>。通过在应用程序阶段设置，可以让片元只通过视口的一个小矩形区域。根据EarlyTest的文档，推测该阶段目前都在EarlyTest阶段进行了。</p><h3 id="Multisample-operations"><a href="#Multisample-operations" class="headerlink" title="Multisample operations"></a>Multisample operations</h3><p>如果启用了MSAA，那么需要进行resolve才能够输出到默认颜色缓冲中，进行屏幕显示。假如在默认缓冲中开了MSAA，那么从MSAA的后备缓冲交换到前向缓冲就需要进行resolve操作，因为前向缓冲是single-sample的。如果是自定义的FrameBuffer开启了MSAA，那么在Blit到默认缓冲区的时候也需要进行resolve操作。</p><h3 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h3><p>模板测试基本思想是用一个八位的模板缓冲，一个参考值，一个比较函数，一个掩码，用该参考值和片元对应的模板缓冲值使用比较进行比较（比较之前进行掩码），通过的则片元可以继续进行深度测试，否则丢弃。另外还可以定义模板成功和失败，以及深度测试成功和失败后模板缓冲如何变化。可以参考OpenGL的<a href="https://www.khronos.org/opengl/wiki/Stencil_Test" target="_blank" rel="noopener">Stencil Test</a>文档。<br>模板测试的一个常见的应用是描边或者在像素级别分类。</p><h3 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3><p>深度测试是根据当前片元的深度值与深度缓冲进行比较，比较函数可以设置，通过比较的片元才会进行接下来的处理，否则丢弃当前片元。</p><h3 id="遮挡查询更新"><a href="#遮挡查询更新" class="headerlink" title="遮挡查询更新"></a>遮挡查询更新</h3><p>参考OpenGL的遮挡查询文档<a href="https://www.khronos.org/opengl/wiki/Query_Object#Occlusion_queries" target="_blank" rel="noopener">Query Object</a>。<br>该阶段会更新遮挡查询的结果，因此遮挡查询的结果只能用于下一帧渲染。</p><h3 id="颜色混合"><a href="#颜色混合" class="headerlink" title="颜色混合"></a>颜色混合</h3><p>需要注意的是，容易误解半透明渲染才会有颜色混合，实际上颜色混合是管线的一个固定的阶段，不透明渲染也会有默认的混合方式。<br>理解颜色混合，首先要明白2个概念，source和dest，source指的是当前的片元，dest指的是要目标缓冲中对应的颜色。<br>颜色混合主要是需要设置2个函数，一个函数用于设置混合因子，一个函数用来设置混合函数。混合因子有四种，source rgb和dest rgb，source a和dest a，可以一起指定也可以分开指定。具体可以参考OpenGL的<a href="https://www.khronos.org/opengl/wiki/Blending" target="_blank" rel="noopener">Blending</a>文档。</p><h3 id="sRGB转换"><a href="#sRGB转换" class="headerlink" title="sRGB转换"></a>sRGB转换</h3><p>1、我们知道显示器或者颜色纹理的颜色空间是sRgb，sRGB空间就是Gamma校正的颜色空间，也就是已经Gamma校正过的颜色数据，这样子在显示器上才能正常显示。如果我们使用的线性工作流，也就是在线性空间中制作资源，编写Shader计算光照结果，那么片元着色器的输出需要转换到sRgb空间。这个转换部分硬件上是自动支持，对于不支持的硬件则需要在Shader里面转换。<br>2、如果要硬件自动转换，首先要创建的必须是srgb颜色空间的FrameBuffer，在OpenGL中可以使用glEnable(GL_FRAMEBUFFER_SRGB)开启；要保证片元输出的线性空间的颜色，也就是要采用线性工作流。<br>3、需要注意的是，避免将sRGB转换和ToneMaping混合起来，ToneMaping做的是将HDR映射到LDR。这只是一个带偏向性颜色范围映射，也就是算法倾向性的增强部分颜色。而sRGB转换才是将颜色从线性空间转换到sRGB空间。</p><h3 id="Dithering"><a href="#Dithering" class="headerlink" title="Dithering"></a>Dithering</h3><p>首先说明一下，颜色格式分为Float、Normalized Integer、Integer三种，默认缓冲区就是Normalized Integer格式的颜色。根据OpenGL的文档，当将一个Float颜色写入Normalized Integer缓冲区的时候，可以开启Dithering。Normalized Integer缓冲区是一个定点数缓冲来存储浮点值，比如通常我们的颜色是定义在[0,\1]的浮点值，但是颜色缓冲是[0,254]\的Int值，OpenGL会自动进行转换。</p><h3 id="Logic-operations"><a href="#Logic-operations" class="headerlink" title="Logic operations"></a>Logic operations</h3><p>根据OpenGL的文档，当将颜色写入Integer（Normalized Or Not）缓冲区的时候，可以开启Logic operations。这是一些Bool操作。具体可以参考文档<a href="https://www.khronos.org/opengl/wiki/Logical_Operation" target="_blank" rel="noopener">Logical Operation</a>。Logical Operations在sRGB颜色空间是禁止的。</p><h3 id="Write-mask"><a href="#Write-mask" class="headerlink" title="Write mask"></a>Write mask</h3><p>该阶段可以分别指定Color、Depth、Stencil的写入掩码。具体参考文档<a href="https://www.khronos.org/opengl/wiki/Write_Mask" target="_blank" rel="noopener">Write Mask</a>。</p><h1 id="五、RenderPass"><a href="#五、RenderPass" class="headerlink" title="五、RenderPass"></a>五、RenderPass</h1><h2 id="5-1-Renderer"><a href="#5-1-Renderer" class="headerlink" title="5.1 Renderer"></a>5.1 Renderer</h2><p>以上所有内容在游戏引擎只是一个RenderPass，实际情况下，每帧游戏引擎会按照一定的顺序渲染多个Pass。比如，深度Pass（或者深度法线Pass）、阴影Pass、不透明物体Pass、透明物体Pass、后处理Pass等；而且后面的Pass会利用前面的Pass渲染结果来处理，比如深度Pass渲染的深度纹理可以用在后续的Pass实现一些效果。<br>总而言之，真实的游戏引擎是每帧渲染多个Pass，每个Pass对应上述的内容。</p><h2 id="5-2-CameraStack"><a href="#5-2-CameraStack" class="headerlink" title="5.2 CameraStack"></a>5.2 CameraStack</h2><p>实际上，在Unity的Urp渲染管线中，更完整的过程是渲染相机堆栈-&gt;每个相机堆栈对应一个渲染器-&gt;每个渲染器包含多个Pass。不过，Urp里面每个相机堆栈只对应一个FrameBuffer，也就是所有的相机渲染输出都是这一个FrameBuffer，避免内存和带宽浪费。如果在场景内创建多个相机堆栈，那么其它的相机堆栈的输出应该是离屏RT。</p><h1 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h1><blockquote><p>1、<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/graphics-pipeline" target="_blank" rel="noopener">Graphics pipeline</a><br>2、<a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target="_blank" rel="noopener">Rendering Pipeline Overview</a><br>3、<a href="https://www.khronos.org/opengl/wiki/Per-Sample_Processing" target="_blank" rel="noopener">Per-Sample Processing</a><br>4、<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/output-merger-stage--om-" target="_blank" rel="noopener">Output Merger (OM) stage</a><br>5、<a href="https://blog.codingnow.com/2020/07/culling_space.html" target="_blank" rel="noopener">裁剪和空间管理</a><br>6、<a href="https://zhuanlan.zhihu.com/p/138295496" target="_blank" rel="noopener">[总结] 漫谈HDR和色彩管理（三）SDR和HDR</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染管线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射效果的实现总结</title>
      <link href="/2021/10/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、反射的实现原理分类"><a href="#一、反射的实现原理分类" class="headerlink" title="一、反射的实现原理分类"></a>一、反射的实现原理分类</h1><p>首先要说明下<strong>反射向量</strong>，指的是视线的镜面反射向量，如下图所示，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/视线反射方向.png"><br>实际上，人眼看向一个物体表面的时候，在该位置（上图O点）的反射信息，来自于视线的反射方向，因为光线会从该反射方向打到物体表面，最终进入人眼。一般情况下，我们假定反射角和入射角相等。以下所有涉及到的反射向量， 都是指的视线反射向量，不是光线反射向量。</p><h2 id="1-1-CubeMap"><a href="#1-1-CubeMap" class="headerlink" title="1.1 CubeMap"></a>1.1 CubeMap</h2><p>天空盒就是一个CubeMap，我们可以假定天空盒是一个环境反射来源，也可以指定另外的CubeMap，用反射向量采样这个CubeMap就能得到反射颜色。CubeMap虽然比较简单，但是也能出很好的效果，而且不需要实时计算反射信息，性能很好。<br>优点：实现简单，效率高，只需要额外的CubeMap存储反射信息；适用于多种情况，不仅仅限于平面反射。<br>缺点：反射信息固定，没有变化。</p><h2 id="1-2-反射探针"><a href="#1-2-反射探针" class="headerlink" title="1.2 反射探针"></a>1.2 反射探针</h2><p>这种方式需要在场景内布置反射探针，用来采集反射信息。渲染时候，在Shader内根据反射探针来获得反射信息。反射探针如果是实时的，性能就会很差，这个时候可以考虑降低反射探针的更新频率或者使用烘焙模式的反射探针。因为反射探针的输出就是CubeMap，因此烘焙模式的反射探针，本质上和CubeMap没有区别。<br>优点：直接利用引擎计算反射信息，不需要额外工作；适用于多种情况，不仅仅限于平面反射。<br>缺点：实时反射探针性能差，计算一次反射探针需要朝着6个方向渲染场景，Drawcall增加6倍，性能太差；烘焙反射探针无法变化。</p><h2 id="1-3-平面反射"><a href="#1-3-平面反射" class="headerlink" title="1.3 平面反射"></a>1.3 平面反射</h2><p>这种方式限制于只能在平面上做反射。如果要求在凹凸不平的表面上实现反射效果，则不太适合。基本思路是将场景根据平面对称镜像一次，具体实现上是将生成的反射矩阵乘以到原场景摄像机的世界到相机空间的矩阵，然后用新的相机再渲染一次场景生成RT。然后在屏幕空间内采样这个RT，得到的像素值作为反射信息。<br>其实，使用反射探针也能实现平面反射的效果，原理是将探针的位置放在摄像机在平面的对称位置。可以参考大佬的这篇文章，<a href="https://baddogzz.github.io/2020/04/22/Probe-Reflection/" target="_blank" rel="noopener">关于反射探头的实时反射</a>。实现难度相对平面反射低很多，不过实时探针比平面反射性能差6倍，优化起来难度太大。<br>优点：反射效果最好，最真实接近平面反射。<br>缺点：需要额外渲染一次场景，DrawCall翻倍。</p><h2 id="1-4-屏幕空间反射（SSR）"><a href="#1-4-屏幕空间反射（SSR）" class="headerlink" title="1.4 屏幕空间反射（SSR）"></a>1.4 屏幕空间反射（SSR）</h2><p>屏幕空间反射的基本原理比较简单，也就是在屏幕空间内通过深度法线纹理恢复世界空间坐标。然后，沿着反射向量方向做步进，也就是所谓的RayMarching，检查当前深度是否已经超过深度纹理对应的值，如果超过，表面已经碰到物体了，那么取当前步进到的颜色值作为反射结果即可。<br>优点：适用于多种情况，不仅仅限于平面反射；DrawCall不变。<br>缺点：需要额外的深度和法线纹理，在前向渲染中这不是免费的，需要多渲染一次场景得到深度和法线纹理；效果一般；无法反射屏幕之外的信息；实现比较复杂，移动平台下性能差（步进相交的计算量大），很可能跑不起来；带宽增加。</p><p>SSR应该是更适合于延迟渲染的一个反射效果实现方案，毕竟可以免费得到深度和法线纹理。</p><h2 id="1-5-屏幕空间平面反射"><a href="#1-5-屏幕空间平面反射" class="headerlink" title="1.5 屏幕空间平面反射"></a>1.5 屏幕空间平面反射</h2><p>这个是平面反射在屏幕空间下的一个实现。<br>SSPR大体的实现思路如下，<br>1、用当前屏幕UV从深度图重建当前世界坐标，将世界坐标以反射平面进行对称翻转<br>2、使用翻转后的世界坐标的计算屏幕UV<br>3、对当前屏幕纹理进行采样得到ReflectColor保存到一张新的ColorRT中，保存位置是翻转后的世界坐标的屏幕UV<br>4、在反射平面的Shader中用屏幕UV对ColorRT进行采样得到反射颜。<br>5、在反射平面的Shader中将反射颜色和着色结果进行组合得到最终颜色。</p><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/SSPR.jpg"><br>如上大佬的图能够基本说明SSPR的实现思路。UAV write即是3的输出。关键点和难点是要得到步骤三的ColorRT，并且要正确高效。网上有不少博客说的是如何正确高效实现前三步，基本上要使用Computer Shader，图形接口要求是vulkan/metal。具体实现比较复杂，不在此详细说明。</p><p>优点：效果较高；性能比SSR好；DrawCall不变。<br>缺点：对硬件要求高；需要额外的ColorRT，带宽和内存增加；只适用于平面反射。</p><h1 id="二、Unity对反射效果支持"><a href="#二、Unity对反射效果支持" class="headerlink" title="二、Unity对反射效果支持"></a>二、Unity对反射效果支持</h1><h2 id="2-1-CubeMap"><a href="#2-1-CubeMap" class="headerlink" title="2.1 CubeMap"></a>2.1 CubeMap</h2><p>Unity自带的Shader或许有支持，实现起来也很简单，关键代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 reflectVector = reflect(-viewDirectionWS, normalWS);</span><br><span class="line">half3 reflectColor = SAMPLE_TEXTURECUBE(_Cubemap, sampler_Cubemap, reflectVector).rgb;</span><br></pre></td></tr></table></figure><h2 id="2-2-反射探针"><a href="#2-2-反射探针" class="headerlink" title="2.2 反射探针"></a>2.2 反射探针</h2><p>目前，Unity内置管线和Urp支持<a href="https://docs.unity3d.com/cn/2019.4/Manual/class-ReflectionProbe.html" target="_blank" rel="noopener">反射探针</a>，HDRP管线还支持一种特殊的<a href="https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.high-definition@10.4/manual/Planar-Reflection-Probe.html" target="_blank" rel="noopener">平面反射探针</a>，平面反射探针猜测是针对平面反射这种特殊情况的一种优化手段。<br>场景内布置了反射探针后，Urp管线中反射信息是存储在叫做unity_SpecCube0的内置CubeMap中。Shader中需要采样该CubeMap获得反射信息，Urp代码中搜索函数GlossyEnvironmentReflection，可以得到如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">half3 <span class="title">GlossyEnvironmentReflection</span>(<span class="params">half3 reflectVector, half perceptualRoughness, half occlusion</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_ENVIRONMENTREFLECTIONS_OFF)</span></span><br><span class="line">    half mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);</span><br><span class="line">    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span>DOTS - we need to port probes to live in c# so we can manage this manually.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(UNITY_USE_NATIVE_HDR) || defined(UNITY_DOTS_INSTANCING_ENABLED)</span></span><br><span class="line">    half3 irradiance = encodedIrradiance.rgb;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> irradiance * occlusion;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> // GLOSSY_REFLECTIONS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _GlossyEnvironmentColor.rgb * occlusion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数三个关键点，根据粗糙度计算mipmap，采样光照探针，解析HDR贴图。我们重点关注的是mipmap计算，mipmap大家都知道，越远的地方，贴图采样率越低效果才好，看起来越模糊，没有锐利的毛刺感觉；同时粗糙度刚好可以表示这个概率，粗糙度越低越接近镜面，那么反射效果更接近光滑镜子的效果，粗糙度越高，反射效果越模糊。<br><strong>计算Mipmap的概念可以应用到所有的反射效果实现中，不仅仅反射探针</strong>。</p><h2 id="2-3-平面反射"><a href="#2-3-平面反射" class="headerlink" title="2.3 平面反射"></a>2.3 平面反射</h2><p>Unity没有发现支持，需要自己实现或者找第三方实现。后续会写文章介绍如何实现。</p><h2 id="2-4-屏幕空间反射"><a href="#2-4-屏幕空间反射" class="headerlink" title="2.4 屏幕空间反射"></a>2.4 屏幕空间反射</h2><p>Unity没有发现支持，需要自己实现或者找第三方实现。后续会写文章介绍如何实现。</p><h2 id="2-5-屏幕空间平面反射"><a href="#2-5-屏幕空间平面反射" class="headerlink" title="2.5 屏幕空间平面反射"></a>2.5 屏幕空间平面反射</h2><p>Unity没有发现支持，需要自己实现或者找第三方实现。后续会写文章介绍如何实现。</p><h1 id="三、UE4对反射效果支持"><a href="#三、UE4对反射效果支持" class="headerlink" title="三、UE4对反射效果支持"></a>三、UE4对反射效果支持</h1><h2 id="3-1-CubeMap"><a href="#3-1-CubeMap" class="headerlink" title="3.1 CubeMap"></a>3.1 CubeMap</h2><p>UE4的材质编辑器可以实现。</p><h2 id="3-2-反射探针"><a href="#3-2-反射探针" class="headerlink" title="3.2 反射探针"></a>3.2 反射探针</h2><p><a href="https://docs.unrealengine.com/4.27/zh-CN/BuildingWorlds/LightingAndShadows/ReflectionEnvironment/" target="_blank" rel="noopener">UE4有盒子和球形的反射探针</a>。</p><h2 id="3-3-平面反射"><a href="#3-3-平面反射" class="headerlink" title="3.3 平面反射"></a>3.3 平面反射</h2><p>UE4有<a href="https://docs.unrealengine.com/4.27/zh-CN/BuildingWorlds/LightingAndShadows/PlanarReflections/" target="_blank" rel="noopener">Planar Reflection Actor</a>，放入场景中即可。不过先要在工程设置中开启平面反射。</p><h2 id="3-4-屏幕空间反射"><a href="#3-4-屏幕空间反射" class="headerlink" title="3.4 屏幕空间反射"></a>3.4 屏幕空间反射</h2><p>UE4默认是启用<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/PostProcessEffects/ScreenSpaceReflection/" target="_blank" rel="noopener">屏幕空间反射</a>的。不过是可以在工程设置或者配置文件中关闭的。</p><h2 id="3-5-屏幕空间平面反射"><a href="#3-5-屏幕空间平面反射" class="headerlink" title="3.5 屏幕空间平面反射"></a>3.5 屏幕空间平面反射</h2><p>目前没有发现UE4支持这个特性。</p><h1 id="四、反射颜色与物体颜色的组合"><a href="#四、反射颜色与物体颜色的组合" class="headerlink" title="四、反射颜色与物体颜色的组合"></a>四、反射颜色与物体颜色的组合</h1><h2 id="4-1-Mipmap"><a href="#4-1-Mipmap" class="headerlink" title="4.1 Mipmap"></a>4.1 Mipmap</h2><p>计算Mipmap，模拟粗糙度的效果，这个在反射探针中已经有说明。</p><h2 id="4-2-菲涅尔效果"><a href="#4-2-菲涅尔效果" class="headerlink" title="4.2 菲涅尔效果"></a>4.2 菲涅尔效果</h2><p>获得反射颜色后，可以根据菲涅尔定律与物体本身的着色结果进行一定的组合即可。不过，不一定完全照搬菲涅尔效果的近似公式，比如Schlick菲涅耳近似等式。关键在于NdotV或者HdotV，也就是反射强弱基本是跟视线相关的。当NdotV为1的时候，说明视线垂直平面，为0的时候说明视线跟平面平行。因此，可以根据NdotV在反射颜色和物体颜色之间进行某种插值，来得到想要的效果。</p><p>以下是一个同时应用了粗糙度计算Mipmap和菲涅尔效果的反射平面，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/平面反射.jpg"></p><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote><p>1、<a href="https://blog.csdn.net/puppet_master/article/details/80808486" target="_blank" rel="noopener">Unity Shader-反射效果（CubeMap，Reflection Probe，Planar Reflection，Screen Space Reflection）</a><br>2、<a href="https://baddogzz.github.io/2020/04/22/Probe-Reflection/" target="_blank" rel="noopener">关于反射探头的实时反射</a><br>3、<a href="https://zhuanlan.zhihu.com/p/150890059" target="_blank" rel="noopener">Unity URP 移动平台的屏幕空间平面反射（SSPR）趟坑记</a><br>4、<a href="https://www.lfzxb.top/screen-space-plana-reflection-in-urp-study/" target="_blank" rel="noopener">URP下屏幕空间平面反射（ScreenSpacePlanarReflection）学习笔记</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射效果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Urp下自定义特效管线和后处理特效实现</title>
      <link href="/2021/08/10/Urp%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%95%88%E7%AE%A1%E7%BA%BF%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/08/10/Urp%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%95%88%E7%AE%A1%E7%BA%BF%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、如何获得颜色缓冲"><a href="#一、如何获得颜色缓冲" class="headerlink" title="一、如何获得颜色缓冲"></a>一、如何获得颜色缓冲</h1><p>网上搜索Unity的后处理或者获得屏幕缓冲，大部分会提到用grabpass到一张指定纹理上或者写一个后处理脚本挂在摄像机上。但是这种方式在Urp管线下已经不生效了。urp取消了默认管线抓取颜色缓冲的grabpass，同时也取消了<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnRenderImage.html" target="_blank" rel="noopener">MonoBehaviour.OnRenderImage</a>，需要使用<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/api/UnityEngine.Rendering.Universal.ScriptableRenderPass.html" target="_blank" rel="noopener">ScriptableRenderPass</a> 来完成类似的功能。ScriptableRenderPass是urp中的pass基类，urp预定义的pass都继承自该类，我们自定义的pass也需要继承自该类。</p><h2 id="1-1-Urp的渲染顺序"><a href="#1-1-Urp的渲染顺序" class="headerlink" title="1.1 Urp的渲染顺序"></a>1.1 Urp的渲染顺序</h2><p>urp中通过类型RenderPassEvent定义了一些列pass的渲染顺序或者说时机，大致的顺序是ShadowPass-&gt;PrePass(Depth Or DepthNormal)-&gt;Opaques-&gt;SkyBox-&gt;Transparents-&gt;PostProcessing，这个顺序也是Urp渲染管线的大致执行顺序。每个Pass或者说每个渲染事件都分Before和After，比如BeforePostProcessing和AfterPostProcessing分别表示后处理之前和后处理之后。<br>说了这么多，现在说结论，我们的特效Pass或者说特效管线就是要插入在BeforePostProcessing这个事件范围内。对了，同一个事件，比如BeforePostProcessing事件内的pass，最终的执行顺序是已加入管线的先后为准的。</p><h2 id="1-2-Urp内置的CameraOpaqueTexture"><a href="#1-2-Urp内置的CameraOpaqueTexture" class="headerlink" title="1.2 Urp内置的CameraOpaqueTexture"></a>1.2 Urp内置的CameraOpaqueTexture</h2><p>那么，我们是一定要自定义一个Pass才能获得颜色缓冲吗？不需要，其实Urp的ForwardRenderer内会在某种情况下给我生成一个颜色缓冲存储到贴图_CameraOpaqueTexture中，通过调用函数SampleSceneColor就得获得屏幕颜色。不过，这个贴图的生成时机是固定的，只会在渲染不透明物体之后，更准确的说是在渲染天空盒之后，通过CopyColorPass把摄像机的颜色缓冲Blit到_CameraOpaqueTexture。同时，需要摄像机或者Urp设置中有开启需要OpaqueTexture或者某个Pass的Input有要求ColorTexture。<br>假如，不需要颜色缓冲中有半透明物体的信息，那么这个_CameraOpaqueTexture就已经足够了。问题是，特效基本是半透明物体，部分场景物体也可能是半透明物体。所以，默认的_CameraOpaqueTexture大概率满足不了需求。<br>因此，需要在半透明物体渲染之后再获取一次颜色缓冲。这个可以通过在AfterTransparents或者BeforePostProcessing事件中插入一个CopyColorPass来实现。</p><h1 id="二、特效渲染管线"><a href="#二、特效渲染管线" class="headerlink" title="二、特效渲染管线"></a>二、特效渲染管线</h1><p>说实话，特效同学的要求有点多，要求部分特效受到全屏效果影响部分不受到影响。那么，特效要分成两部分渲染，一部分在全屏特效前，另外一部分在全屏特效后。那么，需要至少4个Pass，全屏特效前的特效Pass-&gt;CopyColorPass-&gt;全屏特效Pass-&gt;全屏特效后的特效Pass。<br>特效渲染管线如下：</p><ol><li>EffectPass</li><li>CopyColorPass</li><li>UberEffectPostRenderPass</li><li>EffectPass</li></ol><p>其中，中间2个Pass最好是能够根据是否有全屏特效来动态激活。</p><h2 id="2-1-EffectRenderFeature"><a href="#2-1-EffectRenderFeature" class="headerlink" title="2.1 EffectRenderFeature"></a>2.1 EffectRenderFeature</h2><p>Urp中需要定义RenderFeature来配置相应的Pass。因此，我们定义一个专门用于特效管线的Feature。在这个Feature中，我们按照上述的顺序加入这4个Pass，其中2和3根据全屏特效是否存在来判断是否加入渲染管线。</p><h2 id="2-2-兼容UI特效穿插UI的解决方案"><a href="#2-2-兼容UI特效穿插UI的解决方案" class="headerlink" title="2.2 兼容UI特效穿插UI的解决方案"></a>2.2 兼容UI特效穿插UI的解决方案</h2><p>由于发现自定义一个BeforeRenderingPostProcessing的特效Pass来专门渲染特效，会导致所有的特效都在半透明物体之后渲染，UI都是在半透明Pass渲染的，ShaderTag是UniversalForward，这样子会导致根据UI的Canvas来动态计算UI特效的sortingOrder以解决UI特效穿插UI的问题失效。因此，需要去除后处理特效前的特效pass，将这个Pass对应的特效改成默认的UniversalForward的ShaderTag。</p><p>关键代码如下，在这个Feature中还定义ColorRT的名字和采样方式、全屏后处理超级Shader的名字等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddRenderPasses</span>(<span class="params">ScriptableRenderer renderer, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderer.EnqueuePass(mEffectBeforePostProcessRenderPass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UberEffectPostRenderPass.IsPostProcessEnable())</span><br><span class="line">    &#123;</span><br><span class="line">        mCopyColorRenderTarget.Init(RenderTargetName);</span><br><span class="line">        mCopyColorPass.Setup(renderer.cameraColorTarget, mCopyColorRenderTarget, RenderTargetSampling);</span><br><span class="line">        renderer.EnqueuePass(mCopyColorPass);</span><br><span class="line">        renderer.EnqueuePass(mUberEffectPostRenderPass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer.EnqueuePass(mEffectAfterPostProcessRenderPass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后处理特效前的特效pass（UniversalForward就会在后处理之前，因此不需要定义专门的Pass，专门的Pass会造成SortingOrder排序失效，UI无法遮挡特效）</span></span><br><span class="line">    <span class="comment">//mEffectBeforePostProcessRenderPass = new EffectRenderPass(new ShaderTagId("EffectBeforePostProcess"));</span></span><br><span class="line"><span class="comment">//mEffectBeforePostProcessRenderPass.renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝颜色缓冲pass</span></span><br><span class="line">    mSamplingMaterial = CoreUtils.CreateEngineMaterial(Shader.Find(<span class="string">"Hidden/Universal Render Pipeline/Sampling"</span>));</span><br><span class="line">    mCopyColorMaterial = CoreUtils.CreateEngineMaterial(Shader.Find(<span class="string">"Hidden/Universal Render Pipeline/Blit"</span>));</span><br><span class="line">    mCopyColorPass = <span class="keyword">new</span> CopyColorPass(RenderPassEvent.BeforeRenderingPostProcessing, mSamplingMaterial, mCopyColorMaterial);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特效后处理超级Pass</span></span><br><span class="line">    mUberEffectPostRenderPass = <span class="keyword">new</span> UberEffectPostRenderPass();</span><br><span class="line">    mUberEffectPostRenderPass.renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后处理特效后的特效pass</span></span><br><span class="line">    mEffectAfterPostProcessRenderPass = <span class="keyword">new</span> EffectRenderPass(<span class="keyword">new</span> ShaderTagId(<span class="string">"EffectAfterPostProcess"</span>));</span><br><span class="line">    mEffectAfterPostProcessRenderPass.renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Urp的ForwardRender配置如图：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/EffectRenderFeature.jpg"></p><h2 id="2-3-EffectRenderPass"><a href="#2-3-EffectRenderPass" class="headerlink" title="2.3 EffectRenderPass"></a>2.3 EffectRenderPass</h2><p>特效渲染Pass用于渲染普通的特效，Pass跟Shader的对应方式是ShaderTag。关键代码如下，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DrawingSettings drawingSettings = CreateDrawingSettings(mShaderTag, <span class="keyword">ref</span> renderingData, SortingCriteria.CommonTransparent);</span><br><span class="line">    FilteringSettings filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line">    context.DrawRenderers(renderingData.cullResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个需要注意的地方是物体渲染的排序方式要用SortingCriteria.CommonTransparent，毕竟特效都是半透明物体。这个标志是Urp默认的渲染半透明物体的排序方式，理论上是从后到前的顺序渲染。</p><h2 id="2-4-UberEffectPostRenderPass"><a href="#2-4-UberEffectPostRenderPass" class="headerlink" title="2.4 UberEffectPostRenderPass"></a>2.4 UberEffectPostRenderPass</h2><p>后处理特效Pass为了兼容面片类型的扭曲特效和全屏类型的色散、黑白屏、径向模糊特效，调用了2次绘制函数。第一次是用context.DrawRenderers绘制普通的物体；第二次是用cmd.DrawMesh绘制一个全屏三角形。同时为了支持，场景中出现多个全屏特效，该Pass中保存了一个材质数组，同时根据优先级来排序，优先级高的先渲染，这样就可以实现多个全屏特效的叠加效果。<br>代码如下，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddMaterial</span>(<span class="params">Material mat, <span class="keyword">int</span> order = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> matOrder = mMaterialOrders.Find((temp) =&gt; temp.Mat == mat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matOrder == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        matOrder = <span class="keyword">new</span> MaterialOrder();</span><br><span class="line">        matOrder.Mat = mat;</span><br><span class="line">        mMaterialOrders.Add(matOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    matOrder.Order = order;</span><br><span class="line"></span><br><span class="line">    mMaterialOrders.Sort((a, b) =&gt; a.Order - b.Order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveMaterial</span>(<span class="params">Material mat</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mMaterialOrders.RemoveAll((temp) =&gt; temp.Mat == mat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DrawingSettings drawingSettings = CreateDrawingSettings(<span class="keyword">new</span> ShaderTagId(<span class="string">"UberEffectPost"</span>), <span class="keyword">ref</span> renderingData, SortingCriteria.RenderQueue | SortingCriteria.SortingLayer);</span><br><span class="line">    FilteringSettings filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line">    context.DrawRenderers(renderingData.cullResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMaterialOrders == <span class="literal">null</span> || mMaterialOrders.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CommandBuffer cmd = CommandBufferPool.Get();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, mProfilingSampler))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//set V,P to identity matrix so we can draw full screen quad (mesh's vertex position used as final NDC position)</span></span><br><span class="line">        cmd.SetViewProjectionMatrices(Matrix4x4.identity, Matrix4x4.identity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mMaterialOrders.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Material mat = mMaterialOrders[i] != <span class="literal">null</span> ? mMaterialOrders[i].Mat : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat != <span class="literal">null</span> &amp;&amp; mat.shader.name == mUberEffectPostShaderName)</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.DrawMesh(RenderingUtils.fullscreenMesh, Matrix4x4.identity, mat, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmd.SetViewProjectionMatrices(renderingData.cameraData.camera.worldToCameraMatrix, renderingData.cameraData.camera.projectionMatrix); <span class="comment">// restore</span></span><br><span class="line">    &#125;</span><br><span class="line">    context.ExecuteCommandBuffer(cmd);</span><br><span class="line">    CommandBufferPool.Release(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、后处理特效"><a href="#三、后处理特效" class="headerlink" title="三、后处理特效"></a>三、后处理特效</h1><h2 id="3-1-屏幕扭曲"><a href="#3-1-屏幕扭曲" class="headerlink" title="3.1 屏幕扭曲"></a>3.1 屏幕扭曲</h2><p>屏幕扭曲的效果最简单，只是偏移uv坐标即可。实现方式很多，基本上是采样噪声或者法线贴图来偏移uv坐标，核心代码大概如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half2 screenUV = input.screenPos.xy / input.screenPos.w;</span><br><span class="line">float2 uvDiffuse = input.uv + float2(_ScreenDistortionU, _ScreenDistortionV) * _Time.y;</span><br><span class="line">float4 diffuseTex = tex2D(_ScreenDistortionDiffuse, TRANSFORM_TEX(uvDiffuse, _ScreenDistortionDiffuse));</span><br><span class="line">half2 offset = float2(diffuseTex.r, diffuseTex.g) * _ScreenDistortStrength;</span><br><span class="line">screenUV = screenUV + offset; <span class="keyword">return</span> half4(SampleScreenColor(screenUV).rgb, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>以上代码计算了2次偏移，第一次偏移是计算噪声图的uv，第二次是计算颜色缓冲的uv，也就是屏幕uv。<br>效果如下，中间的部分放了一个扭曲面片特效。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/屏幕扭曲.jpg"></p><h2 id="3-2-色散"><a href="#3-2-色散" class="headerlink" title="3.2 色散"></a>3.2 色散</h2><p>色散的原理也很简单，计算一个偏移的uv，分别在两个方向上计算r和b，不偏移的位置计算g，合并起来作为完整的颜色输出。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   half2 deltaUv = half2(_ColorDispersionStrength * _ColorDispersionU, _ColorDispersionStrength * _ColorDispersionV);</span><br><span class="line">result.r = SampleScreenColor(screenUV + deltaUv).r;</span><br><span class="line">result.g = SampleScreenColor(screenUV).g;</span><br><span class="line">result.b = SampleScreenColor(screenUV - deltaUv).b;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/色散.jpg"></p><h2 id="3-3-黑白屏"><a href="#3-3-黑白屏" class="headerlink" title="3.3 黑白屏"></a>3.3 黑白屏</h2><p>黑白屏的关键实现代码也很短。但是想出来不太容易。网上大部分实现，就是简单的灰度化加上和屏幕颜色的插件。后面发现特效同学要的东西其实就是网上找了位特效大佬用ASE生成的shader效果，拿到代码后，过滤掉生成的冗余代码发现核心就是下面2个插值计算。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half luminosity = dot(screenColor.rgb, half3(<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>));</span><br><span class="line"><span class="keyword">float</span> smoothstepResult = smoothstep(_BlackWhiteThreshold, _BlackWhiteThreshold + _BlackWhiteWidth, luminosity.x);</span><br><span class="line">result = lerp(_BlackWhiteWhiteColor,_BlackWhiteBlackColor, smoothstepResult);</span><br></pre></td></tr></table></figure><p>关键代码是smoothstep，在阈值和阈值+阈值范围之间曲线插值，返回的值再用来插值白屏颜色色和黑屏颜色。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/黑白屏.png"></p><h2 id="3-4-径向模糊"><a href="#3-4-径向模糊" class="headerlink" title="3.4 径向模糊"></a>3.4 径向模糊</h2><p>径向模糊的思想是沿着到中点的方向采样几个点，然后平均。代码如下，这里假定是6次采样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   half2 dir = screenUV - half2(_RadialBlurHorizontalCenter, _RadialBlurVerticalCenter);</span><br><span class="line">half4 blur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">half2 uv = screenUV + _RadialBlurWidth * dir * i;</span><br><span class="line">blur += SampleScreenColor(uv);</span><br><span class="line">&#125;</span><br><span class="line">blur /= <span class="number">6</span>;</span><br><span class="line">   result = lerp(result, blur, saturate(_RadialBlurStrength));</span><br></pre></td></tr></table></figure><p>不过，以上代码不一定能满足美术的需求。比如dir是否需要归一化，lerp时候是否需要考虑距离中点的远近等都会影响最终的效果。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/径向模糊.jpg"></p><h2 id="3-5-色散和径向模糊"><a href="#3-5-色散和径向模糊" class="headerlink" title="3.5 色散和径向模糊"></a>3.5 色散和径向模糊</h2><p>  如果先计算色散的DeltaUv，再将取屏幕颜色替换为屏幕扭曲的话，就能得到一个色散和径向模糊结合的效果，关键代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half2 deltaUv = half2(_ColorDispersionStrength * _ColorDispersionU, _ColorDispersionStrength * _ColorDispersionV);</span><br><span class="line">result.r = RadialBlur(screenUV + deltaUv, screenColor).r;</span><br><span class="line">result.g = RadialBlur(screenUV, screenColor).g;</span><br><span class="line">result.b = RadialBlur(screenUV - deltaUv, screenColor).b;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/色散和径向模糊的结合.jpg"></p><h2 id="3-6-UberEffectPost超级Shader"><a href="#3-6-UberEffectPost超级Shader" class="headerlink" title="3.6 UberEffectPost超级Shader"></a>3.6 UberEffectPost超级Shader</h2><p>具体实现上，我是用一个超级shader将这些功能整合到一起（除了屏幕扭曲，特效的需求是面片）形成一个UberShader。不同的效果通过shader_feature_local的开关来控制，这样既不用增加额外的大小和内存，也更方便美术同学的使用，整合到一起也是美术提出来的。<br>材质界面如下，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/UberEffectPost.jpg"></p><h2 id="3-7-UberEffectPost脚本"><a href="#3-7-UberEffectPost脚本" class="headerlink" title="3.7 UberEffectPost脚本"></a>3.7 UberEffectPost脚本</h2><p>该脚本继承自MonoBehavior，用于判断是否存在全屏特效以及全屏特效材质、全屏特效优先级设置，并且在材质改变时候将后处理材质传入Pass等。<br>另外，美术同学要求加的后处理参数控制曲线也是在该脚本中，截图如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/UberEffectPostScript.jpg"></p><p>这些参数曲线相对于TimeLine来说，可以更快的生成动态变化的后处理效果，减少美术去编辑TimeLine的工作量，不过自由度会有所降低。</p><h1 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h1><blockquote><p>1、<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnRenderImage.html" target="_blank" rel="noopener">OnRenderImage</a><br>2、<a href="https://zhuanlan.zhihu.com/p/419814256" target="_blank" rel="noopener">仿.碧蓝幻想versus黑白闪后处理shader分享(build_in 与urp双版本)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> urp </tag>
            
            <tag> 特效 </tag>
            
            <tag> 后处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渲染管线中的坐标空间和相关变换</title>
      <link href="/2020/06/19/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8C%E7%9B%B8%E5%85%B3%E5%8F%98%E6%8D%A2/"/>
      <url>/2020/06/19/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8C%E7%9B%B8%E5%85%B3%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h1><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/坐标空间.png"></p><h1 id="二、模型空间"><a href="#二、模型空间" class="headerlink" title="二、模型空间"></a>二、模型空间</h1><p>这里的模型空间指的是建模出来的空间，也就是用建模软件输出的数据所在的坐标空间。比如，3D Max用的是右手系，输出的模型数据所在的空间就叫模型空间；由于Unity的模型空间是左手系，所以通常需要旋转90度才能对应上。</p><h1 id="三、切线空间"><a href="#三、切线空间" class="headerlink" title="三、切线空间"></a>三、切线空间</h1><p>切线空间又可以叫做纹理空间。假如纹理坐标uv构成一个二维空间，加上垂直于这个二维空间的法线，那么就是一个三维的切线空间。</p><h2 id="3-1-法线贴图的切线空间"><a href="#3-1-法线贴图的切线空间" class="headerlink" title="3.1 法线贴图的切线空间"></a>3.1 法线贴图的切线空间</h2><p>切线空间有什么应用了？我们在计算光照模型的时候，通常会有更精细表示法线的数据，比如法线贴图，法线贴图通常是建模软件用高模计算出来的。不过，法线贴图是原始切线空间下的数据。因此，法线贴图中的法线数据通常是(0,0,1)，所以法线贴图表现出大部分是蓝色。我们在读取这个法线数据后，需要将其变换到计算光照模型所在的空间，比如世界空间。</p><h2 id="3-2-模型空间下的切线空间"><a href="#3-2-模型空间下的切线空间" class="headerlink" title="3.2 模型空间下的切线空间"></a>3.2 模型空间下的切线空间</h2><p>顶点上除了位置数据外，还可以有法线、切线数据。注意，这些数据都是在模型空间的。因此，法线、切线、副切线（法线和切线叉积计算出来）自然可以构成一个模型空间下的切线空间。</p><h2 id="3-3-切线变换"><a href="#3-3-切线变换" class="headerlink" title="3.3 切线变换"></a>3.3 切线变换</h2><p>假如我们想将切线空间下的法线变换到世界空间，该如何做了？我们需要得到一个世界空间下的切线空间。首先将<strong>模型空间下的切线空间变换到世界空间</strong>，这样我们就得到了一个世界空间下的切线子空间，然后用这个切线子空间构成一个切线变换，再对切线空间下的法线数据应用这个切线变换就能变换到世界空间。<br>用公式来表示这个变换是，$NormalWS=TangentMatrix*NormalTS$。当然也可以将切线变换到其它的空间，比如摄像机空间，区别是构造不同的TangentMatrix。</p><h1 id="四、关节空间"><a href="#四、关节空间" class="headerlink" title="四、关节空间"></a>四、关节空间</h1><h2 id="4-1-关节空间"><a href="#4-1-关节空间" class="headerlink" title="4.1 关节空间"></a>4.1 关节空间</h2><p><strong>这里的关节空间，指的是带骨骼的模型中，骨骼或者关节所定义的局部空间。</strong><br>以人体手指为假设，手指会受到腕关节、肘关节、肩关节影响，对应三个骨骼。那么，手指会依次受到这三个关节的牵扯影响。我们知道，虚拟的根骨骼Root所在的是模型空间，同时每个关节也定义了自己的局部空间，比如腕关节是最终的局部空间，我们把这个关节定义的局部空间叫做关节空间。</p><h2 id="4-2-关节姿势"><a href="#4-2-关节姿势" class="headerlink" title="4.2 关节姿势"></a>4.2 关节姿势</h2><p>所谓关节姿势，存储的是子关节到父关节的变换，包括旋转、缩放、平移，这个也可以叫做局部关节姿势。全局关节姿势是，将所有的局部关节姿势结合起来。<br>比如公式，$P_{2\to M} = P_{2\to 1} P_{1\to 0} P_{0\to M}$表示的是将顶点从子关节2的局部空间变换到模型空间。全局关节姿势可以表示为$P_{j\to M} = \prod _{i=j}^{0} P_{i\to p(i)}$，其中p(i)是关节i的父关节。</p><h2 id="4-3-绑定关节姿势"><a href="#4-3-绑定关节姿势" class="headerlink" title="4.3 绑定关节姿势"></a>4.3 绑定关节姿势</h2><p>我们知道，默认情况下，蒙皮骨骼都有一个T-Pose，即绑定姿势，也可以理解为初始姿势。模型空间的顶点乘以绑定姿势的逆变换就能得到关节空间的顶点。</p><h2 id="4-4-蒙皮矩阵"><a href="#4-4-蒙皮矩阵" class="headerlink" title="4.4 蒙皮矩阵"></a>4.4 蒙皮矩阵</h2><p>模型空间的顶点乘以绑定姿势的逆变换就能得到关节空间的顶点。关键点来了，这个时候再乘以骨骼的当前全局姿势矩阵，就又变换回了模型空间。所谓的蒙皮矩阵，就是这两个变换的结合。可以用公式表示骨骼i的蒙皮矩阵，$K_{j} = (B_{j\to M})^{-1}  C_{j \to M}$，B代表绑定姿势，C代表当前姿势。多个蒙皮矩阵的加权，就能得到蒙皮动画。</p><h2 id="4-5-蒙皮动画"><a href="#4-5-蒙皮动画" class="headerlink" title="4.5 蒙皮动画"></a>4.5 蒙皮动画</h2><p>顶点会受到多个骨骼影响，这些骨骼的影响加权和为1，这个就是蒙皮动画。可以用公式来表示，$p’ = \sum_{i=1}^{n}W_i(p)K_ip$。其中，p是模型空间的顶点，Wi是骨骼i影响的权重，Ki是骨骼i的蒙皮矩阵。蒙皮矩阵的计算如上所示。</p><h2 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h2><p>根据以上五步的推导，蒙皮动画需要存储的数据是，</p><ul><li>绑定姿势下的的模型空间顶点</li><li>绑定关节姿势的逆矩阵</li><li>当前姿势数据（实时计算当前姿势矩阵）</li><li>蒙皮矩阵的权重</li></ul><h1 id="五、世界空间"><a href="#五、世界空间" class="headerlink" title="五、世界空间"></a>五、世界空间</h1><p>所谓世界空间，不需要解释了吧。放在游戏场景里面，指的是规定了场景坐标系的空间。模型空间，则指的是场景内的单个模型自身数据所在的空间。</p><h2 id="5-1-模型变换"><a href="#5-1-模型变换" class="headerlink" title="5.1 模型变换"></a>5.1 模型变换</h2><p>模型变换就是将模型空间的顶点数据变换到世界空间，通常包括对模型的平移、旋转和缩放。但是，一般要求的变换顺序是先缩放、再旋转、最后平移，如果反过来会造成平移受到前面的变换影响，与直观印象不符合。<br>所以，$ModelMatrix=TranslateMatrix*RotateMatrix*ScaleMatrix$。特别说明平移矩阵指的是，将模型从原点移动到其在世界空间的位置。</p><h1 id="六、摄像机空间"><a href="#六、摄像机空间" class="headerlink" title="六、摄像机空间"></a>六、摄像机空间</h1><p>摄像机空间也叫做观察空间。摄像机可以理解为世界空间的一个位置和朝向，比如在坐标(1,1,1)看向原点，那么射线的位置就是坐标(1,1,1)，前向就是看向的方向（-1，-1，-1）。这个时候再定义一个垂直于forward的Up方向，就可以根据叉积找到垂直forward和up方向的right方向。这三个方向就可以构成一个摄像机空间。</p><h2 id="6-1-观察变换"><a href="#6-1-观察变换" class="headerlink" title="6.1 观察变换"></a>6.1 观察变换</h2><p>观察变换是将顶点从世界空间变换到新的摄像机空间。首先，需要将顶点平移，比如上述情况下的原点在观察空间下是(-1，-1，-1)；然后，需要旋转顶点以匹配观察空间的坐标轴。由于观察空间的坐标轴是世界空间下的单位正交基，因此将三个轴放入矩阵即可得到旋转矩阵的逆矩阵（等于旋转矩阵的转置矩阵）。</p><h1 id="七、裁剪空间"><a href="#七、裁剪空间" class="headerlink" title="七、裁剪空间"></a>七、裁剪空间</h1><p>裁剪空间指的是观察空间下的顶点经过投影变换后所处的空间。我们知道，可视区域是摄像机前面的一个平截头体（透视投影）或者一个长方体（正交投影）。裁剪空间的用途是将可视区域外的物体裁剪，同时计算物体的二维坐标。</p><h2 id="7-1-投影变换"><a href="#7-1-投影变换" class="headerlink" title="7.1 投影变换"></a>7.1 投影变换</h2><p>投影分为透视投影和正交投影两种，透视投影会造成近大远小的效果，符合视觉效应，三维游戏一般使用透视投影，正交投影则远近一样大，通常只用于建模软件。</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/透视投影.jpg"><br>从图可以看出，透视投影后w是有值的，并不是1，结果还是一个平截头体。具体的矩阵推动，请参考相关资料。</p><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/正交投影.jpg"><br>从图可以看出，正交投影实际上就是缩放和平移的结合，得到的结果是一个-1到1范围的立方体。</p><h2 id="7-2-透视除法和图元裁剪"><a href="#7-2-透视除法和图元裁剪" class="headerlink" title="7.2 透视除法和图元裁剪"></a>7.2 透视除法和图元裁剪</h2><p>由于透视投影后齐次坐标的w非1，需要进行透视除法，这个是图形硬件自动进行的。如图所示：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/透视除法.jpg"><br>透视除法后，可以得到和正交投影结果一样的规范化立方体，也叫做NDC（规范化设备坐标系）。<br>到了NDC后，就可以方便的进行图元裁剪，毕竟坐标都是-1到1了（DirectX下Z坐标是0到1）。</p><h2 id="7-3-顶点着色器的输出"><a href="#7-3-顶点着色器的输出" class="headerlink" title="7.3 顶点着色器的输出"></a>7.3 顶点着色器的输出</h2><p>顶点着色器必须输出裁剪空间下的坐标。由于DirectX的NDC的Z范围是0到1，与OpenGL的-1到1有一定区别。因此，这2者的投影矩阵在Z坐标上有一定的平移和缩放区别。</p><h1 id="八、屏幕空间"><a href="#八、屏幕空间" class="headerlink" title="八、屏幕空间"></a>八、屏幕空间</h1><p>投影变换后得到的顶点范围是-1到1。现在还需要将NDC下的顶点映射到屏幕空间。屏幕空间也可以叫做窗口空间，即窗口定义的坐标空间。</p><h2 id="8-1-视口变换"><a href="#8-1-视口变换" class="headerlink" title="8.1 视口变换"></a>8.1 视口变换</h2><p>假设，窗口坐标原点在左下角（OpenGL的原点在左下角，但是DirectX的在左上角），窗口大小为Width和Height。视口变换就是把-1到1的x和y坐标范围映射到（0，width）和（0，height），对应DirectX的话，y还需要取反。这就是一个平移和缩放的过程。</p><p>实际上，透视除法和视口变换（屏幕空间映射）都是硬件自动进行的。</p><h1 id="九、参考资料"><a href="#九、参考资料" class="headerlink" title="九、参考资料"></a>九、参考资料</h1><blockquote><p><a href="https://book.douban.com/subject/26821639/" target="_blank" rel="noopener">Unity Shader入门精要</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 渲染 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渲染管线 </tag>
            
            <tag> 坐标空间 </tag>
            
            <tag> 坐标变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左右手坐标系和相关定则的总结</title>
      <link href="/2020/03/06/%E5%B7%A6%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E5%AE%9A%E5%88%99%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/06/%E5%B7%A6%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E5%AE%9A%E5%88%99%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>左手坐标系和右手坐标系是三维空间下两种不同的坐标系，而且无法通过旋转将左手坐标系转换到右手坐标系。与其相对应的，有左手定则和右手定则，主要是用来确定叉积的朝向或者说旋向。<br>首先，规定二维坐标，X轴朝右、Y轴朝上，推广到三维空间，需要确定的是Z轴是朝前还是朝后。</p><h1 id="一、左手坐标系"><a href="#一、左手坐标系" class="headerlink" title="一、左手坐标系"></a>一、左手坐标系</h1><p>所谓左手坐标系，指的是通过左手来确定的一个三维空间坐标系。</p><h2 id="1-1-确定左手坐标系的方式"><a href="#1-1-确定左手坐标系的方式" class="headerlink" title="1.1 确定左手坐标系的方式"></a>1.1 确定左手坐标系的方式</h2><p>下面总结了三种可以确定左手坐标系的方法。</p><h3 id="1-1-1-拇指、食指、中指相互垂直确定法"><a href="#1-1-1-拇指、食指、中指相互垂直确定法" class="headerlink" title="1.1.1 拇指、食指、中指相互垂直确定法"></a>1.1.1 拇指、食指、中指相互垂直确定法</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/左右手坐标系.png"><br>如图，伸出左手，拇指朝上代表Y轴、食指朝前代表Z轴、中指朝右代表X轴。注意，中指这个时候是只能往右边弯曲的。</p><h3 id="1-1-2-左手定则确定法"><a href="#1-1-2-左手定则确定法" class="headerlink" title="1.1.2 左手定则确定法"></a>1.1.2 左手定则确定法</h3><p>伸出左手，手指朝着右边X轴，握向Y轴，这个时候拇指指向的方向就是Z轴（朝前）。</p><h3 id="1-1-3-人站立的正面朝向确定法"><a href="#1-1-3-人站立的正面朝向确定法" class="headerlink" title="1.1.3 人站立的正面朝向确定法"></a>1.1.3 人站立的正面朝向确定法</h3><p>人朝前站立着，右手伸出的朝向是X轴，头顶的方向是Y轴，面向Z轴。</p><h2 id="1-2-左手定则"><a href="#1-2-左手定则" class="headerlink" title="1.2 左手定则"></a>1.2 左手定则</h2><p>假设，叉乘计算，C=A叉乘B。如何确定在C的朝向了？如果A和B都在左手坐标系下，那么使用左手定则来确定C的朝向。<br>类似1.1.2，伸出左手，手指朝着A，握向B，这个时候拇指指向的方向就是C。</p><h1 id="二、右手坐标系"><a href="#二、右手坐标系" class="headerlink" title="二、右手坐标系"></a>二、右手坐标系</h1><h2 id="2-1-确定右手坐标系的方式"><a href="#2-1-确定右手坐标系的方式" class="headerlink" title="2.1 确定右手坐标系的方式"></a>2.1 确定右手坐标系的方式</h2><h3 id="2-1-1-拇指、食指、中指相互垂直确定法"><a href="#2-1-1-拇指、食指、中指相互垂直确定法" class="headerlink" title="2.1.1 拇指、食指、中指相互垂直确定法"></a>2.1.1 拇指、食指、中指相互垂直确定法</h3><p>参考1.1.1，伸出右手，拇指朝上代表Y轴、食指朝前代表Z轴、中指朝左代表X轴。注意，中指这个时候是只能往左边弯曲的。<br>但是，我们一般假定X轴朝右，因此需要握着Z轴旋转180度。这个时候，拇指朝上代表Y轴、食指朝后代表Z轴、中指朝右代表X轴。注意，左右手坐标系旋转后不会改变。</p><h3 id="2-1-2-左手定则确定法"><a href="#2-1-2-左手定则确定法" class="headerlink" title="2.1.2 左手定则确定法"></a>2.1.2 左手定则确定法</h3><p>伸出右手，手指朝着右边X轴，握向Y轴，这个时候拇指指向的方向就是Z轴（朝后）。</p><h3 id="2-1-3-人站立的正面朝向确定法"><a href="#2-1-3-人站立的正面朝向确定法" class="headerlink" title="2.1.3 人站立的正面朝向确定法"></a>2.1.3 人站立的正面朝向确定法</h3><p>人朝前站立着，右手伸出的朝向是X轴，头顶的方向是Y轴，背后的是Z轴。</p><h2 id="2-2-右手定则"><a href="#2-2-右手定则" class="headerlink" title="2.2 右手定则"></a>2.2 右手定则</h2><p>类似1.1，如果A和B都在,右手坐标系下，那么使用右手定则来确定C的朝向。<br>类似1.1.2，伸出右手，手指朝着A，握向B，这个时候拇指指向的方向就是C。<br>因此，左手定则和右手定则的区别是使用左手还是右手。</p><h1 id="三、图形API的左右手坐标系"><a href="#三、图形API的左右手坐标系" class="headerlink" title="三、图形API的左右手坐标系"></a>三、图形API的左右手坐标系</h1><p>图形管线中，存在多个坐标系，每个坐标系都可以使用左手或者右手坐标系。下面按照，物体坐标系-&gt;世界坐标系-&gt;摄像机坐标系-&gt;裁剪坐标系-&gt;窗口坐标系来说明。</p><h2 id="3-1-OpenGL"><a href="#3-1-OpenGL" class="headerlink" title="3.1 OpenGL"></a>3.1 OpenGL</h2><p>OpenGL默认是右手坐标系。不过到了窗口坐标系，OpenGL使用的是左手坐标系。为什么了？<strong>因为OpenGL的深度范围是[0,1]，而且是摄像机越远，深度越大，这就是左手坐标系啦</strong>。<br>由于物体坐标系、世界坐标系、摄像机坐标系都是右手坐标系，但是窗口坐标系是左手坐标系，那么投影矩阵就需要乘以右手坐标系变换到左手坐标系这个变换，也就是Z变换成-Z。不过这个变换也可以放在摄像机坐标系，也就是MVP的V中。现在假定，都乘到P中了。<br>最终结论是：物体坐标系、世界坐标系、摄像机坐标系是右手坐标系；裁剪坐标系和窗口坐标系是左手坐标系，窗口坐标系实际上只是裁剪坐标系进行齐次除法后再平移缩放而已。</p><h2 id="3-2-DirectX"><a href="#3-2-DirectX" class="headerlink" title="3.2 DirectX"></a>3.2 DirectX</h2><p>DirectX默认是左手坐标系。<br>类似3.1，物体坐标系、世界坐标系、摄像机坐标系是左手坐标系。<strong>注意，DirectX的窗口坐标系是以左上角为原点的，深度是朝前的，那么跟OpenGL的反过来，是右手坐标系。</strong><br>因此，裁剪坐标系和窗口坐标系是右手手坐标系。投影变化同样要乘以，右手坐标系变换到左手坐标系这个变换，也就是Z变换成-Z。</p><h2 id="3-3-Vulkan"><a href="#3-3-Vulkan" class="headerlink" title="3.3 Vulkan"></a>3.3 Vulkan</h2><p>Vulkan的窗口坐标系和DirectX的一致，因此推测其余坐标系和DirectX的一致。</p><h2 id="3-4-Metal"><a href="#3-4-Metal" class="headerlink" title="3.4 Metal"></a>3.4 Metal</h2><p>Vulkan的窗口坐标系和DirectX的一致，因此推测其余坐标系和DirectX的一致。</p><p>看来只有，历史遗留的奇葩OpenGL的窗口坐标系，原点在左下角啊。原点在哪，这个跟纹理的v坐标是否需要取反也有关系。</p><h1 id="四、游戏引擎的左右手坐标系"><a href="#四、游戏引擎的左右手坐标系" class="headerlink" title="四、游戏引擎的左右手坐标系"></a>四、游戏引擎的左右手坐标系</h1><p>游戏引擎中，物体和世界坐标系是固定的，对于所有的图形API都会一样。</p><h2 id="4-1-Unity"><a href="#4-1-Unity" class="headerlink" title="4.1 Unity"></a>4.1 Unity</h2><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/Unity物体坐标系.jpg"><br>根据上图，Unity的物体和世界坐标系可以推测都是左手系。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/Unity坐标系旋向.jpg"><br>根据上图，出自Shader入门精要，Unity的窗口坐标系和OpenGL的一致，是左手系。但是摄像机空间变换到了右手系。那么，在V中需要乘以Z到-Z的变换。同时，P中再乘以-Z到Z的变换变回左手系。<br>为啥多次一举了，怀疑这个结论的正确性。下面做实验，用IMGizmos绘制坐标轴。代码如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace GYGame</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 出生点</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public class PlayerStart : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        public float GizmosHeight &#123; get; set; &#125; &#x3D; 2.0f;</span><br><span class="line"></span><br><span class="line">        void OnDrawGizmos()</span><br><span class="line">        &#123;</span><br><span class="line">            IMGizmos.Line3D(transform.position, transform.position + transform.up * GizmosHeight, Color.green);</span><br><span class="line">            IMGizmos.Line3D(transform.position, transform.position + transform.right * GizmosHeight, Color.red);</span><br><span class="line">            IMGizmos.Line3D(transform.position, transform.position + transform.forward * GizmosHeight, Color.blue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选中场景相机，可以得到下面结果，<br><img alt="Unity摄像机坐标系" data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/Unity摄像机坐标系.jpg"><br>可以看到右下角的场景相机画面里面有显示PlayerStart的Gizmos，Gizmos显示的坐标系是左手系，跟右上角显示的坐标系是一致的。同时，引擎自带的Gizmos显示的摄像机前向也是Z轴正向。<br>因此，推测我实验的Unity版本是2020，与UnityShader入门精要使用的Unity5.X版本，摄像机空间的旋向性已经发生了变化。</p><h2 id="4-2-UnrealEngine"><a href="#4-2-UnrealEngine" class="headerlink" title="4.2 UnrealEngine"></a>4.2 UnrealEngine</h2><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/虚幻坐标系.jpg"><br>虚幻和Unity一样也是采用左手坐标系，不过其是Z轴朝上，Y轴朝外。沿着X轴旋转90度，可以得到Z轴朝内，Y轴朝上，那么和Unity的是一致的。<br>推测，其余的空间的坐标系旋向和Unity的是一致。摄像机空间的旋向也可以用类似4.1的方式绘制Gizmos，然后选中摄像机，查看摄像机的绘制结果。</p><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote><p><a href="https://book.douban.com/subject/26821639/" target="_blank" rel="noopener">Shader入门精要</a><br><a href="https://zhuanlan.zhihu.com/p/269621383" target="_blank" rel="noopener">图形坐标系的跨平台适配</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> Rendering </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 左右手坐标系 </tag>
            
            <tag> 左右手定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3D代码规范</title>
      <link href="/2018/12/19/Unity3D%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2018/12/19/Unity3D%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="一、命名法"><a href="#一、命名法" class="headerlink" title="一、命名法"></a>一、命名法</h1><p>Pascal命名法：每个单词首字母大写。<br>Camel命名法：第一个单词首字母小写，其余单词首字母大写。<br>C++标准库命名法：全小写，单词用下划线分割。</p><h2 id="1-1-C"><a href="#1-1-C" class="headerlink" title="1.1 C"></a>1.1 C</h2><p>函数和类采用Pascal命名法，变量采用Camel命名法。<br>代码目录和文件采用Pascal命名法。</p><h2 id="1-2-Lua"><a href="#1-2-Lua" class="headerlink" title="1.2 Lua"></a>1.2 Lua</h2><p>类采用Pascal命名法，其余采用C++标准库命名法。<br>代码目录和文件采用C++标准库命名法。</p><h2 id="1-3-其它"><a href="#1-3-其它" class="headerlink" title="1.3 其它"></a>1.3 其它</h2><p>其它目录和文件采用Pascal命名法。</p><h1 id="二、C-代码规范"><a href="#二、C-代码规范" class="headerlink" title="二、C#代码规范"></a>二、C#代码规范</h1><h2 id="2-1-命名的基本约定"><a href="#2-1-命名的基本约定" class="headerlink" title="2.1 命名的基本约定"></a>2.1 命名的基本约定</h2><p>函数用动词命名，其它的用名词或者形容词命名。</p><h3 id="避免使用拼音"><a href="#避免使用拼音" class="headerlink" title="避免使用拼音"></a>避免使用拼音</h3><p>原则上避免使用拼音命名代码。</p><h3 id="尽量避免缩写"><a href="#尽量避免缩写" class="headerlink" title="尽量避免缩写"></a>尽量避免缩写</h3><p>尽量不要缩写名字，名字长没关系，尽可能描述清楚。</p><h3 id="类型前缀"><a href="#类型前缀" class="headerlink" title="类型前缀"></a>类型前缀</h3><p>类和变量前一般不要加前缀。模板类型加前缀T，接口加前缀I，枚举加前缀E。</p><h3 id="类型后缀"><a href="#类型后缀" class="headerlink" title="类型后缀"></a>类型后缀</h3><p>特殊类型可选加后缀。<br>List：可选加List后缀。<br>Dictionary：可选加Dict后缀。<br>delegate：加上后缀Event。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>使用Pascal命名法。<br>命名空间采用GY开头，比如GYEngine、GYGame。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用Pascal命名法。<br>类名要用名词。模板类开头用T。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>使用Pascal命名法。<br>接口开头用I。接口名要用名词或者形容词。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型采用Pascal命名法，需要加上前缀E，比如EMessageType。<br>枚举常量不需要加前缀，采用Pascal命名法，特殊情况下可以拆成两部分用下划线区分，比如Message_Start。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Enum EWeaponType</span><br><span class="line">&#123;</span><br><span class="line">Knife,</span><br><span class="line">Pistol,</span><br><span class="line">MachineGun,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Enum EMessageType</span><br><span class="line">&#123;</span><br><span class="line">Message_Start,</span><br><span class="line">Message_End,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>使用Pascal命名法。<br>函数名最好用动词开头。</p><h3 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h3><p>使用Pascal命名法。<br>使用动词短语命名，delegate类型的命名需要加上后缀Event。<br>event类型的实例需要加上On前缀，Event后缀。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">KillMonsterEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> KillMonsterEvent OnKillMonsterEvent = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>使用Pascal命名法。<br>属性是对Get和Set的语法封装，一般是public或者protected采有意义。</p><h3 id="特性-Attribute"><a href="#特性-Attribute" class="headerlink" title="特性(Attribute)"></a>特性(Attribute)</h3><p>使用Pascal命名法。<br>用名词或名词短语+Attribute方式命名特性。<br>比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObsoleteAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>采用Camel命名法。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>采用Camel命名法。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>类非公有非静态成员变量用m开头。比如mActorId。<br>类的公有成员变量大写开头，不需要加m前缀，尽量用属性代替公有变量。</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>类的静态成员变量用s开头。<br>函数内的静态变量用s开头。<br>比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Actor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mActorId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sActorNumInClass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> mActorClassId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> ActorName = <span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ActorId</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> mActorId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123; </span><br><span class="line">mActorId = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">KillMonsterEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">event</span> KillMonsterEvent OnKillMonsterEvent = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Actor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mActorId = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetActorNum</span>(<span class="params"><span class="keyword">bool</span> isFirstTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sActorNumInFun;</span><br><span class="line"><span class="keyword">int</span> addNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> sActorNumInFun = (isFirstTime ? <span class="number">0</span> : sActorNumInFun + addNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所有单词大写，多个单词之间用下划线隔开，比如public const int MAX_NUM = 10。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>原则上，尽量写可读性良好、自解释的代码，避免写冗余的注释。</p><h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><p>文件开头必须要有注释，如果是单个类的文件，可以将用类注释替代。</p><h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><p>单个类的文件，必须有类注释。<br>类注释说明该类是做什么的，可选包含怎么实现以及为什么这么实现的原因。</p><h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><p>简单函数不需要注释，难以使用的函数需要加注释，想想为什么难以使用，这个时候往往需要重构或者拆分函数代码了。</p><h3 id="语句注释"><a href="#语句注释" class="headerlink" title="语句注释"></a>语句注释</h3><p>关键难以理解的代码语句，需要加上注释说明。</p><h3 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h3><p>关键变量加上注释，普通的不需要加注释。</p><h2 id="2-2-代码风格"><a href="#2-2-代码风格" class="headerlink" title="2.2 代码风格"></a>2.2 代码风格</h2><h3 id="类成员排列顺序"><a href="#类成员排列顺序" class="headerlink" title="类成员排列顺序"></a>类成员排列顺序</h3><ol><li>属性：公有属性 、受保护属性 </li><li>字段：受保护字段、私有字段（公有字段当作属性对待）</li><li>事件：公有事件、受保护事件、私有事件</li><li>构造函数：参数数量最少的构造函数，参数数量中等的构造函数，参数数量最多的构造函数</li><li>方法：重载方法的排列顺序与构造函数相同，从参数数量最少往下至参数最多。方法按照功能分块，尽可能按照公有、保护、私有的访问级别来分布。</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li>一行只能声明一个变量，尽量避免用var定义变量类型，除非类型写起来很冗余。</li><li>尽量在声明的同时初始化。</li><li>变量定义在开头，比如类开头或者函数开头。除非是根据条件定义的块变量。</li></ol><p>比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mName = <span class="string">"PeopleName"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mAge = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeAge</span>(<span class="params"><span class="keyword">int</span> newAge, <span class="keyword">bool</span> needAddAge</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mAge = newAge;</span><br><span class="line"><span class="keyword">if</span> (needAddAge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tempAddAge = <span class="number">1</span>;</span><br><span class="line">mAge += tempAddAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><ol><li>一行只能有一条语句。</li><li><p>单行复合语句必须加大括号。原则上，即使只有一行语句，也需要加大括号包起来，防止后续修改代码破坏忘记语句范围。比如，</p></li><li><p>else if等必须新起一行。比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWorkday)</span><br><span class="line">&#123;</span><br><span class="line">Work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isHoliday)</span><br><span class="line">&#123;</span><br><span class="line">Rest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>代码缩进使用Tab键实现，最好不要使用空格，为保证在不同机器上使代码缩进保持一致，设置Tab键宽度为4个字符。</p><h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><ol><li>大括号需要占一行对齐，而不是将左大括号放在行尾。</li><li>Lambda函数可以将左大括号放在同一行，不需要另起一行。</li></ol><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ol><li>if、while、for、return等关键词后应有一个空格［eg. “if (a == b)”］。</li><li>运算符前后应各有一个空格［eg. “a = b + c;”］。</li><li>函数调用后不需要加空格。</li><li>左括号后面和右括号前面不需要加额外的空格。</li></ol><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ol><li>函数之间必须加空行。</li><li>较长函数的代码块直接用空行分割。</li><li>变量定义可以分块加空行分割。</li></ol><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>每一行代码的行长度，建议不要超过110个字符或者说不超过屏幕宽度。如果超过这个长度，可以按照以下规则换行：</p><ol><li>在逗号后换行。</li><li>在操作符前换行。</li><li>第一条优先于第二条。</li></ol><h3 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h3><p>建议单个函数长度不要超过80行。越简短越好。<br>超过80行，可以考虑拆分函数重用代码。</p><h3 id="类长度"><a href="#类长度" class="headerlink" title="类长度"></a>类长度</h3><p>单个类文件原则上不超过1000行。接近或者超过，考虑拆分类或者多个文件实现类。</p><h2 id="2-3-示例代码"><a href="#2-3-示例代码" class="headerlink" title="2.3 示例代码"></a>2.3 示例代码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YMGame</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> Enum EWeaponType</span><br><span class="line">&#123;</span><br><span class="line">Knife,</span><br><span class="line">Pistol,</span><br><span class="line">MachineGun,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Actor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mActorId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sActorNumInClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> mActorClassId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> ActorName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ActorId</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> mActorId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123; </span><br><span class="line">mActorId = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetActorNum</span>(<span class="params"><span class="keyword">bool</span> isFirstTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sActorNumInFun;</span><br><span class="line"><span class="keyword">int</span> addNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> sActorNumInFun = (isFirstTime ? <span class="number">0</span> : sActorNumInFun + addNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetActorId</span>(<span class="params"><span class="keyword">int</span> classId, <span class="keyword">int</span> actorId</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sNonClassIdActorNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mActorClassId = classId;</span><br><span class="line">mActorId = actorId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mActorClassId &lt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">sNonClassIdActorNum++;</span><br><span class="line"><span class="keyword">bool</span> isNonClassIdActor = <span class="literal">true</span>;</span><br><span class="line">actorId = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Lua代码规范"><a href="#三、Lua代码规范" class="headerlink" title="三、Lua代码规范"></a>三、Lua代码规范</h1><p>除了以下特殊提及到的，Lua的代码规范参照C#的代码规范。</p><h2 id="3-1-命名规则"><a href="#3-1-命名规则" class="headerlink" title="3.1 命名规则"></a>3.1 命名规则</h2><h3 id="文件（类）名"><a href="#文件（类）名" class="headerlink" title="文件（类）名"></a>文件（类）名</h3><p>采用Pascal命名法。</p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>采用Pascal命名法。</p><h3 id="文件的local变量"><a href="#文件的local变量" class="headerlink" title="文件的local变量"></a>文件的local变量</h3><p>下划线开头，采用Camel命名法。比如_classType。</p><h3 id="函数的local变量"><a href="#函数的local变量" class="headerlink" title="函数的local变量"></a>函数的local变量</h3><p>采用Camel命名法。</p><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><p>采用Camel命名法。</p><h3 id="C-代码导出到Lua"><a href="#C-代码导出到Lua" class="headerlink" title="C#代码导出到Lua"></a>C#代码导出到Lua</h3><p>必须增加Cs前缀以做区分，比如CsFileManager = CS.GYEngine.FileManager.Instance。</p><h3 id="双下划线"><a href="#双下划线" class="headerlink" title="双下划线"></a>双下划线</h3><p>双下划线用于一些特殊函数的前缀，比如类的初始化和销毁函数。</p><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>使用项目规定的log函数。比如使用log.l，可以通过个人logid来过滤其他人日志；警告使用log.w；错误使用log.e，避免使用默认的error。</p><h1 id="四、编程技巧"><a href="#四、编程技巧" class="headerlink" title="四、编程技巧"></a>四、编程技巧</h1><h2 id="避免使用魔数"><a href="#避免使用魔数" class="headerlink" title="避免使用魔数"></a>避免使用魔数</h2><p>代码里面不要出现魔法数字，用常量来替代。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span>(<span class="params"><span class="keyword">double</span> radius</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量替代魔法数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> final Double PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span>(<span class="params"><span class="keyword">double</span> radius</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释型变量"><a href="#解释型变量" class="headerlink" title="解释型变量"></a>解释型变量</h2><p>如下所示，用bool变量代替复杂的条件判断，bool变量的命名可以解释条件判断的意思。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入解释性变量后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">bool</span> isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line"><span class="keyword">if</span> (isSummer)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免函数参数过多"><a href="#避免函数参数过多" class="headerlink" title="避免函数参数过多"></a>避免函数参数过多</h2><p>参数过多时候，可以将参数组合成一个结构体传入，方便后续对参数的修改。</p><h3 id="避免函数参数控制函数内部逻辑"><a href="#避免函数参数控制函数内部逻辑" class="headerlink" title="避免函数参数控制函数内部逻辑"></a>避免函数参数控制函数内部逻辑</h3><p>可以考虑拆分成多个函数，保证函数职责单一。</p><h2 id="避免嵌套过深"><a href="#避免嵌套过深" class="headerlink" title="避免嵌套过深"></a>避免嵌套过深</h2><p><code>可以考虑使用</code>continue、break、return关键字，提前退出嵌套。</p><h2 id="分割代码和单一职责"><a href="#分割代码和单一职责" class="headerlink" title="分割代码和单一职责"></a>分割代码和单一职责</h2><p>如果函数或者类的代码过长，考虑拆分成多个函数或者类，保证职责单一。</p><h2 id="预计算和缓存"><a href="#预计算和缓存" class="headerlink" title="预计算和缓存"></a>预计算和缓存</h2><p>比如Component或者UI控件的获得等，可以在初始化的时候获取然后缓存引用，避免重复查询。</p><h2 id="避免频繁创建字符串"><a href="#避免频繁创建字符串" class="headerlink" title="避免频繁创建字符串"></a>避免频繁创建字符串</h2><p>由于C#中的string是独一无二的，无法修改，所以字符串操作会创建新的字符串，不像C++可以就地初始化或者重复利用对象，因此避免大量使用string的操作符构建字符串，改成使用StringBuilder。</p><h1 id="五、安全性编程"><a href="#五、安全性编程" class="headerlink" title="五、安全性编程"></a>五、安全性编程</h1><h2 id="5-1-安全性编程原则"><a href="#5-1-安全性编程原则" class="headerlink" title="5.1 安全性编程原则"></a>5.1 安全性编程原则</h2><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>C#中的对象都是引用，使用前需要判空，空引用会造成异常。这个是良好的编程习惯。可以用空值传播操作符等，简略代码。</p><h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>对传入的参数要进行安全性检查，比如空引用，索引范围等，非法情况提前返回，然后再进行正常的逻辑处理。</p><h3 id="尽可能使用错误处理而不是异常处理"><a href="#尽可能使用错误处理而不是异常处理" class="headerlink" title="尽可能使用错误处理而不是异常处理"></a>尽可能使用错误处理而不是异常处理</h3><p>异常有额外的性能消耗，加上异常会破坏调用链，应该尽可能用错误判断得方式处理各种可以预测的问题，而不是抛出异常。游戏引擎内一般不使用异常，比如UE4的源码内就禁用异常。</p><h2 id="5-2-示例代码"><a href="#5-2-示例代码" class="headerlink" title="5.2 示例代码"></a>5.2 示例代码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">SpawnObjectAsync</span>(<span class="params"><span class="keyword">string</span> assetPath, Vector3 position, Quaternion rotation, Vector3 scale, Transform parent = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">string</span> name = <span class="string">""</span>, Action&lt;GameObject&gt; onSpawnObjectDone = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(assetPath))</span><br><span class="line">    &#123;</span><br><span class="line">        GYLog.LogError(<span class="string">"GameObjectPool SpawnObjectAsync assetPath is IsNullOrEmpty"</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObjectPooledItemList pool = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAssetPathLookup.TryGetValue(assetPath, <span class="keyword">out</span> pool) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return <span class="title">WarmPoolAsync</span>(<span class="params">assetPath, <span class="number">1</span>, (tempPool</span>)</span> =&gt; pool = tempPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GYLog.LogError(<span class="string">"GameObjectPool SpawnObjectAsync Get GameObjectCollection return null"</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObject clone = pool.GetItem();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GYLog.LogError(<span class="string">"GameObjectPool SpawnObject Get GameObject from GameObjectCollection return null"</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clone.SetActiveEx(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clone.transform.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    clone.transform.position = position;</span><br><span class="line">    clone.transform.rotation = rotation;</span><br><span class="line">    clone.transform.localScale = scale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clone.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInstanceLookup.Add(clone.GetInstanceID(), pool);</span><br><span class="line">    mIsDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    onSpawnObjectDone?.Invoke(clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如示例代码，首先做了输入参数检查，然后在执行过程中做了条件检查，检查失败直接主动报错，马上返回。</p><h1 id="六、改动权限"><a href="#六、改动权限" class="headerlink" title="六、改动权限"></a>六、改动权限</h1><p>项目中可以通过SVN或者Git的权限限制，避免过多人改动底层或者关键代码。下面举例说明，</p><h2 id="C-的Engine代码"><a href="#C-的Engine代码" class="headerlink" title="C#的Engine代码"></a>C#的Engine代码</h2><p>原则上，Engine代码不做改动，主程或者指定的人有权限改动，其它人需要改动需要事先跟主程沟通后才能改动。</p><h2 id="C-的Game代码"><a href="#C-的Game代码" class="headerlink" title="C#的Game代码"></a>C#的Game代码</h2><p>在游戏发布之前，Game代码允许改动；在游戏发布之后，改动Game层的C#代码需要热更新二进制包或者打补丁更新，有改动需求需要事先跟主程沟通。</p><h2 id="Lua的框架代码"><a href="#Lua的框架代码" class="headerlink" title="Lua的框架代码"></a>Lua的框架代码</h2><p>框架代码改动之前需要考虑清楚，客户端程序都有改动权限，改动大的部分最好同步主程或者执行主程等，并且负责跟踪和修复改动后引入的问题</p><h2 id="Lua的业务代码"><a href="#Lua的业务代码" class="headerlink" title="Lua的业务代码"></a>Lua的业务代码</h2><p>客户端程序一直有改动权限，需要遵守代码规范。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类对象的内存布局</title>
      <link href="/2018/08/12/C++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
      <url>/2018/08/12/C++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一、内存对齐"><a href="#一、内存对齐" class="headerlink" title="一、内存对齐"></a>一、内存对齐</h1><p>C++的对象都会进行内存对齐，所谓内存对齐，指的是对象的地址和大小都会对齐到n的倍数上。比如按照4对齐，那么对象的地址会是4的倍数，对象的大小也是4的倍数。究其原因是，机器在内存对齐的地址上访问数据更快，可以一起取出数据；如果数据存在在不对齐的地址上，需要换成2次对齐地址上的取数据，再组合出原始数据；而且，部分机器根本没有取非对齐的数据。</p><h2 id="1-1-默认对齐"><a href="#1-1-默认对齐" class="headerlink" title="1.1 默认对齐"></a>1.1 默认对齐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassWithMemoryPack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line"></span><br><span class="line">    short shortB;</span><br><span class="line"></span><br><span class="line">    float floatC;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(int):&quot; &lt;&lt; sizeof(int) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(short):&quot; &lt;&lt; sizeof(short) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(float):&quot; &lt;&lt; sizeof(float) &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; &quot;sizeof(OrdinaryClassWithMemoryPack):&quot; &lt;&lt; sizeof(OrdinaryClassWithMemoryPack) &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; &quot;address of omp:&quot; &lt;&lt; &amp;omp &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="vs2019-x86的结果"><a href="#vs2019-x86的结果" class="headerlink" title="vs2019 x86的结果"></a>vs2019 x86的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x86.png"></p><h3 id="vs2019-x64的结果"><a href="#vs2019-x64的结果" class="headerlink" title="vs2019 x64的结果"></a>vs2019 x64的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x64.png"></p><p>可以看到，默认都是按照4字节对齐，int和float都是4个字节，short是2个字节，不过强制按照4字节对齐了。对象的地址都是4的倍数，不过64位程序的地址是64位了。</p><h2 id="1-2-Pack-n"><a href="#1-2-Pack-n" class="headerlink" title="1.2 Pack(n)"></a>1.2 Pack(n)</h2><p>假如我们用pack指令强制按照2字节对齐，那么输出结果如何了？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(push)</span><br><span class="line">#pragma pack(2)</span><br><span class="line">class OrdinaryClassWithMemoryPack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line"></span><br><span class="line">    float floatB;</span><br><span class="line"></span><br><span class="line">    short shortC;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack(pop)</span><br></pre></td></tr></table></figure></p><h3 id="vs2019-x86的结果-1"><a href="#vs2019-x86的结果-1" class="headerlink" title="vs2019 x86的结果"></a>vs2019 x86的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x86Pack2.png"></p><h3 id="vs2019-x64的结果-1"><a href="#vs2019-x64的结果-1" class="headerlink" title="vs2019 x64的结果"></a>vs2019 x64的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x64Pack2.png"></p><p>从输出结果可以看出，对象还是位于4对齐的地址上，只是对象本身的大小变成10了。short只占2个字节，那么接下来的float并没有强制在4字节的地址对齐，而是根据pack指令对齐在2字节的地址上了。</p><h2 id="1-3-实验环境"><a href="#1-3-实验环境" class="headerlink" title="1.3 实验环境"></a>1.3 实验环境</h2><p>未避免文章过于啰嗦，接下来的例子只说明vs2019 x86的输出结果。</p><h1 id="二、普通类的对象"><a href="#二、普通类的对象" class="headerlink" title="二、普通类的对象"></a>二、普通类的对象</h1><h2 id="2-1-基类的对象"><a href="#2-1-基类的对象" class="headerlink" title="2.1 基类的对象"></a>2.1 基类的对象</h2><p>接下来的讨论为避免内存对齐的干扰，忽略内存对齐。因此，类的成员变量只有一个int。定义基类如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-单继承子类的对象"><a href="#2-2-单继承子类的对象" class="headerlink" title="2.2 单继承子类的对象"></a>2.2 单继承子类的对象</h2><p>定义子类如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassAFirstSon : public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intAFirstSon;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="2-3-多继承子类的对象"><a href="#2-3-多继承子类的对象" class="headerlink" title="2.3 多继承子类的对象"></a>2.3 多继承子类的对象</h2><p>定义多继承的子类如下,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassASecondSon : public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intASecondSon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OrdinaryMultipleInheritClassE : public OrdinaryClassAFirstSon, public OrdinaryClassASecondSon</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intE;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassA):&quot; &lt;&lt; sizeof(OrdinaryClassA) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassAFirstSon):&quot; &lt;&lt; sizeof(OrdinaryClassAFirstSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryMultipleInheritClassE):&quot; &lt;&lt; sizeof(OrdinaryMultipleInheritClassE) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++普通对象多继承x86.png"><br>根据输出结果，可以看出：基类是4个字节；子类拥有基类的对象，加上自己的成员，一起是8个字节；多重继承的子类，拥有2个基类对象，加上自己的成员，总共是8+8+4=20个字节。<br>OrdinaryMultipleInheritClassE的两个基类都继承同一个类OrdinaryClassA，因此E的对象中会有2份A的实例。一般的编程范式中，都要求避免多继承，改用多接口继承。C++在针对这种情况，也有一种虚拟继承的方式来避免数据冗余。</p><h1 id="三、带虚函数的类对象"><a href="#三、带虚函数的类对象" class="headerlink" title="三、带虚函数的类对象"></a>三、带虚函数的类对象</h1><h2 id="3-1-带虚函数的基类的对象"><a href="#3-1-带虚函数的基类的对象" class="headerlink" title="3.1 带虚函数的基类的对象"></a>3.1 带虚函数的基类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-1-带虚函数的单继承子类的对象"><a href="#3-1-带虚函数的单继承子类的对象" class="headerlink" title="3.1 带虚函数的单继承子类的对象"></a>3.1 带虚函数的单继承子类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassAFirstSon : public VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intAFirstSon;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunAFirstSon()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VirtualFunClassA va;</span><br><span class="line">VirtualFunClassAFirstSon vason;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassA):&quot; &lt;&lt; sizeof(VirtualFunClassA) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassAFirstSon):&quot; &lt;&lt; sizeof(VirtualFunClassAFirstSon) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>用vs2019调试，自动窗口中显示的va和vason的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数类对象内存布局x86.png"><br>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数类对象大小x86.png"><br>可以看到，类对象内多了一个vfptr（虚函数指针），其中子类的虚函数指针是放在父对象内的。</p><h2 id="3-2-带虚函数的多继承子类的对象"><a href="#3-2-带虚函数的多继承子类的对象" class="headerlink" title="3.2 带虚函数的多继承子类的对象"></a>3.2 带虚函数的多继承子类的对象</h2><p>现在来考虑多继承的情况，假如多个基类都有虚函数，那么内存布局如何了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intB;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunB()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VirtualFunMultipleInheritClassC : public VirtualFunClassA, public VirtualFunClassB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intC;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunB() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunC()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VirtualFunMultipleInheritClassC vmc;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassA):&quot; &lt;&lt; sizeof(VirtualFunClassA) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassB):&quot; &lt;&lt; sizeof(VirtualFunClassB) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunMultipleInheritClassC):&quot; &lt;&lt; sizeof(VirtualFunMultipleInheritClassC) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>用vs2019调试，自动窗口中显示的vmc的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数多继承类对象内存布局x86.png"><br>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数多继承类对象内存大小x86.png"><br>可以得出结论：vmc中有2个基类的对象，大小分别是8，自身有一个大小为4的int，因此总共是20的大小；多继承的对象内会有多个虚函数指针，一个指针对应一个带虚函数的基类；子类如果也带非继承而来的虚函数，那么这个虚函数也会放在某个基类的虚函数表内。<br>因此，多重继承的子类对象，会有多个虚函数指针，对应多个虚函数表，自身虚函数会被合并到某个基类的虚函数表中，不会再多一个虚函数指针和虚函数表。对于多重继承子类的多个虚函数表，可能是分开存储，也可能是连续存储为一个表，只是虚函数指针有一定的偏移。</p><h1 id="四、虚拟继承的类对象"><a href="#四、虚拟继承的类对象" class="headerlink" title="四、虚拟继承的类对象"></a>四、虚拟继承的类对象</h1><p>下面来讨厌最变态的部分，虚拟继承的对象。</p><h2 id="4-1-虚多继承子类的对象"><a href="#4-1-虚多继承子类的对象" class="headerlink" title="4.1 虚多继承子类的对象"></a>4.1 虚多继承子类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassAVirtualFirstSon : virtual public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intAFirstSon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OrdinaryClassAVirtualSecondSon : virtual public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intASecondSon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OrdinayVirtualMultipleInheritClassF : public OrdinaryClassAVirtualFirstSon, public OrdinaryClassAVirtualSecondSon</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intF;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OrdinaryClassAVirtualFirstSon oavson;</span><br><span class="line">OrdinayVirtualMultipleInheritClassF ovmf;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassAVirtualFirstSon):&quot; &lt;&lt; sizeof(OrdinaryClassAVirtualFirstSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassAVirtualSecondSon):&quot; &lt;&lt; sizeof(OrdinaryClassAVirtualSecondSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinayVirtualMultipleInheritClassF):&quot; &lt;&lt; sizeof(OrdinayVirtualMultipleInheritClassF) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>用vs2019调试，自动窗口中显示的ovmf的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚多继承类对象内存布局x86.png"></p><p>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚多继承类对象内存大小x86.png"></p><p>可以看到2个基类的大小都是12，子类的大小是24。如果是普通继承的话，基类的大小是8，子类的大小是20，这个可以参考2.3。那么，虚继承的对象内肯定多了什么？具体是什么了。</p><h3 id="启用类内存布局分析"><a href="#启用类内存布局分析" class="headerlink" title="启用类内存布局分析"></a>启用类内存布局分析</h3><p>由于自动窗口无法显示虚拟继承的内存布局了，那么我们只能用其它方式来查看。<br>如下图，我们通过Project的属性窗口，找到C/C++ -&gt;命令行，添加新的选项 /d1 reportAllClassLayout。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/reportAllClassLayout.png"></p><h3 id="虚继承的基类内存布局"><a href="#虚继承的基类内存布局" class="headerlink" title="虚继承的基类内存布局"></a>虚继承的基类内存布局</h3><p>然后清理工程重新生成，在输出窗口会输出所有类的局部情况，然后搜索OrdinaryClassAVirtualFirstSon，如下图所示，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/虚继承的基类内存布局.png"><br>可以看到，对象内有三个成员，按照顺序分别是vbptr（虚表指针）、数据成员intAFirstSon、基类的数据成员intA。相比普通的继承，多了虚表指针。大小总和是4+4+4=12。</p><h3 id="虚继承的多重继承子类内存布局"><a href="#虚继承的多重继承子类内存布局" class="headerlink" title="虚继承的多重继承子类内存布局"></a>虚继承的多重继承子类内存布局</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/虚多重继承内存布局.png"><br>可以看到，对象的成员按照顺序分别是基类1对象、基类2对象、数据成员intF、虚继承的基类数据成员intA。<br>大小总和是8+8+4+4=24。基类1和基类2里面都是带1个虚表指针和1个数据成员。<br>相比普通的继承，多了2个虚表指针，但是减少了重复基类数据，总的大小变化是20+8-4=24。如果，重复的基类OrdinaryClassA有更多的数据成员，那么虚拟继承这种机制就更划算了。</p><h2 id="4-2-带虚函数的虚多继承子类的对象"><a href="#4-2-带虚函数的虚多继承子类的对象" class="headerlink" title="4.2 带虚函数的虚多继承子类的对象"></a>4.2 带虚函数的虚多继承子类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassASecondSon : virtual public VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intASecondSon;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunASecondSon()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VirtualFunClassAThirdSon : virtual public VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int AThirdSon;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunAThirdSon()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VirtualFunVirtualInheritClassG : public VirtualFunClassASecondSon, public VirtualFunClassAThirdSon</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intG;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunASecondSon() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunAThirdSon() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunE()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassASecondSon):&quot; &lt;&lt; sizeof(VirtualFunClassASecondSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassAThirdSon):&quot; &lt;&lt; sizeof(VirtualFunClassAThirdSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunVirtualInheritClassG):&quot; &lt;&lt; sizeof(VirtualFunVirtualInheritClassG) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚多继承对象大小.png"><br>发现基类的大小变成了20，多了8个字节。子类的从24变成了36，多了12个字节。猜测是多了虚函数指针。</p><h3 id="带虚函数的虚继承的基类内存布局"><a href="#带虚函数的虚继承的基类内存布局" class="headerlink" title="带虚函数的虚继承的基类内存布局"></a>带虚函数的虚继承的基类内存布局</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚继承的基类内存布局.png"><br>可以看到，内存布局是虚函数指针、虚表指针、数据成员、基类对象（基类的虚函数指针、基类数据成员）。相比不带虚函数的虚拟继承，是多了2个虚函数指针。相比，普通的继承，是多了1个虚表指针和1个虚函数指针。所以，最奇怪的地方是没有像普通继承那样将2个虚函数指针合并成一个。</p><p>如果注释掉当前类的虚函数VirtualFunASecondSon，得到的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚继承的基类内存布局1.png"><br>区别是少了当前类的虚函数指针，基类对象内的虚函数指针保留。</p><h3 id="带虚函数的虚继承的多重继承子类内存布局"><a href="#带虚函数的虚继承的多重继承子类内存布局" class="headerlink" title="带虚函数的虚继承的多重继承子类内存布局"></a>带虚函数的虚继承的多重继承子类内存布局</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚继承的多重继承子类内存布局.png"></p><p>这应该是已知的最复杂的类对象布局情况了。按照顺序是基类1、基类2、数据成员、虚拟基类。基类1和基类2内部都是虚函数指针、虚表指针、数据成员，大小都是12，那么总共是24。数据成员大小是4。虚拟基类的内部是虚函数指针、数据成员，大小是8。因此，总共的大小是12+12+4+8=36。<br>相比不带虚函数的虚拟继承，多了3个虚函数指针，总计12个字节。相比普通的继承，多了2个虚表指针和1个虚函数指针，但是减少了虚拟基类数据的重复，那么总大小是28+12-4=36。</p><h3 id="虚拟继承的最终结论"><a href="#虚拟继承的最终结论" class="headerlink" title="虚拟继承的最终结论"></a>虚拟继承的最终结论</h3><p>1、虚拟继承的对象内会多一个虚表指针。<br>2、带虚函数的虚继承，子类和基类的虚函数表不会合并，因此会多一个虚函数指针。<br>3、多重继承的基类，如果虚继承了共同的基类，那么其共同基类对象只会存在一份，包括数据成员和虚函数指针。</p><h3 id="疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？"><a href="#疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？" class="headerlink" title="疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？"></a>疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？</h3><p>猜测可能跟vs2019对应的vc++编译器实现有关。</p><h2 id="4-3-虚表指针的用途"><a href="#4-3-虚表指针的用途" class="headerlink" title="4.3 虚表指针的用途"></a>4.3 虚表指针的用途</h2><p>我们知道，虚函数指针指向的是虚函数表，虚函数表内存储的是虚函数的地址。对于采用指针或者引用来动态调用虚函数的情况，会在运行时才能确定真正的虚函数地址，这个就叫做延迟绑定。为了灵活性，失去了部分性能。<br>那么，虚表指针是用来做什么的？可以肯定的是用于找到共同的基类对象的。猜测虚表指针指向一张table，该table内部存储共同的基类数据在类对象内的偏移。</p><h2 id="4-4-虚拟继承实现的编译器差异"><a href="#4-4-虚拟继承实现的编译器差异" class="headerlink" title="4.4 虚拟继承实现的编译器差异"></a>4.4 虚拟继承实现的编译器差异</h2><p>根据深入探索C++对象模型的说明，虚拟继承在不同的编译器下有不同的实现，而且C++标准并未规定如何实现。因此，g++的内存布局跟vc++的内存布局可能会有显著差别。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGUI概述</title>
      <link href="/2017/01/12/NGUI%E6%A6%82%E8%BF%B0/"/>
      <url>/2017/01/12/NGUI%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="NGUI介绍"><a href="#NGUI介绍" class="headerlink" title="NGUI介绍"></a>NGUI介绍</h2><p>NGUI是Unity中最流行的UI插件，在UGUI出现前几乎是Unity唯一的UI解决方案。<br>NGUI是一个提供高效事件通知框架的强大UI系统。NGUI遵循<a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">Kiss准则</a>，其中类代码简洁，多数在200行以内。程序员可以方便的扩展其组件类代码以获得定制的功能。<br><a href="http://www.tasharen.com/?page_id=140" target="_blank" rel="noopener">NGUI官方网址</a><br><a href="http://www.tasharen.com/forum/index.php?board=12.0" target="_blank" rel="noopener">NGUI官方文档地址</a></p><h2 id="NGUI下载"><a href="#NGUI下载" class="headerlink" title="NGUI下载"></a>NGUI下载</h2><p>我们可以从unity商店购买NGUI，或者下载其免费版本。<br><a href="https://www.assetstore.Unity.com/cn/#!/content/2413" target="_blank" rel="noopener">NGUI的Unity商店</a><br>当然也可以下载网上其它人提供的版本学习研究。<br><a href="http://www.ceeger.com/forum/read.php?tid=20718fid=16" target="_blank" rel="noopener">NGUI 3.10.2</a></p><h2 id="NGUI导入"><a href="#NGUI导入" class="headerlink" title="NGUI导入"></a>NGUI导入</h2><p>下载NGUI后，我们得到的是一个.unitypackage文件，比如NGUI Next-Gen UI v3.6.8.unitypackage。<br>Unity编辑器中，打开菜单Assets-&gt;ImportPackage-&gt;CustomPackage，然后选择下载的.unitypackage文件导入编辑器。导入NGUI后，在工程的Assets目录下会出现一个NGUI文件夹，并且Unity编辑器中会多了一个NGUI主菜单。</p><h2 id="NGUI例子"><a href="#NGUI例子" class="headerlink" title="NGUI例子"></a>NGUI例子</h2><p>打开NGUI-&gt;Options-&gt;Reset Prefab ToolBar，会出现如下工具条：</p><p><img alt="NGUI例子" data-src="https://c1.staticflickr.com/1/782/31420422424_657c6cee61_o.png"><br>这里面有基本的NGUI控件例子，是我们学习参照的好材料。</p><h2 id="NGUI类图"><a href="#NGUI类图" class="headerlink" title="NGUI类图"></a>NGUI类图</h2><p>下面是我整理的NGUI类图：<br><img alt="NGUI类图" data-src="https://c1.staticflickr.com/1/363/32223724406_7e07b90f4b_o.png"></p><p>该类图中列出了NGUI中绝大部分的类。<br>类图中有两个最重要的分支，UIWidgetContainer分支和UIWidget分支。<br>NGUI中的大部分控件都继承自UIWidgetContainer，这说明在NGUI中，其实是把控件当作Sprite的容器而已。UIWidget的子类就是Sprite和Texture，表示NGUI中的控件都是图片化的，控件的表现都依赖图片。</p><h2 id="NGUI常用组件"><a href="#NGUI常用组件" class="headerlink" title="NGUI常用组件"></a>NGUI常用组件</h2><h3 id="UILabel-文本"><a href="#UILabel-文本" class="headerlink" title="UILabel 文本"></a>UILabel 文本</h3><h3 id="UIInput-输入框"><a href="#UIInput-输入框" class="headerlink" title="UIInput 输入框"></a>UIInput 输入框</h3><h3 id="UITextList-多文本显示框，类似聊天窗"><a href="#UITextList-多文本显示框，类似聊天窗" class="headerlink" title="UITextList 多文本显示框，类似聊天窗"></a>UITextList 多文本显示框，类似聊天窗</h3><h3 id="UISprite-图片精灵"><a href="#UISprite-图片精灵" class="headerlink" title="UISprite 图片精灵"></a>UISprite 图片精灵</h3><h3 id="UIBotton-按钮"><a href="#UIBotton-按钮" class="headerlink" title="UIBotton 按钮"></a>UIBotton 按钮</h3><h3 id="UIToggle-单选框-复选框"><a href="#UIToggle-单选框-复选框" class="headerlink" title="UIToggle 单选框/复选框"></a>UIToggle 单选框/复选框</h3><h3 id="UIScrollBar-滚动条"><a href="#UIScrollBar-滚动条" class="headerlink" title="UIScrollBar 滚动条"></a>UIScrollBar 滚动条</h3><h3 id="UISlider-滑动条-进度条"><a href="#UISlider-滑动条-进度条" class="headerlink" title="UISlider 滑动条/进度条"></a>UISlider 滑动条/进度条</h3><h3 id="UIProgressBar-进度条"><a href="#UIProgressBar-进度条" class="headerlink" title="UIProgressBar 进度条"></a>UIProgressBar 进度条</h3><h3 id="UIPopupList-下拉框"><a href="#UIPopupList-下拉框" class="headerlink" title="UIPopupList 下拉框"></a>UIPopupList 下拉框</h3><h3 id="UIGrid-将子控件按照单元格布局"><a href="#UIGrid-将子控件按照单元格布局" class="headerlink" title="UIGrid 将子控件按照单元格布局"></a>UIGrid 将子控件按照单元格布局</h3><h3 id="UITable-UIGrid加强版，类似Html的table"><a href="#UITable-UIGrid加强版，类似Html的table" class="headerlink" title="UITable UIGrid加强版，类似Html的table"></a>UITable UIGrid加强版，类似Html的table</h3><h3 id="UIPanel-控件渲染器，管理和绘制其下所有的组件"><a href="#UIPanel-控件渲染器，管理和绘制其下所有的组件" class="headerlink" title="UIPanel 控件渲染器，管理和绘制其下所有的组件"></a>UIPanel 控件渲染器，管理和绘制其下所有的组件</h3><h3 id="UIScrollView-滚动视窗"><a href="#UIScrollView-滚动视窗" class="headerlink" title="UIScrollView 滚动视窗"></a>UIScrollView 滚动视窗</h3><h3 id="UIKeyBinding-给控件的点击或者选中事情绑定按键"><a href="#UIKeyBinding-给控件的点击或者选中事情绑定按键" class="headerlink" title="UIKeyBinding 给控件的点击或者选中事情绑定按键"></a>UIKeyBinding 给控件的点击或者选中事情绑定按键</h3><h3 id="UIRoot-NGUI的UI根物体"><a href="#UIRoot-NGUI的UI根物体" class="headerlink" title="UIRoot NGUI的UI根物体"></a>UIRoot NGUI的UI根物体</h3><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="http://www.tasharen.com/forum/index.php?topic=6754" target="_blank" rel="noopener">NGUI官网</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebGL编程模型</title>
      <link href="/2016/12/25/WebGL%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2016/12/25/WebGL%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍编写一个原生的WebGL程序需要哪些步骤。</p><h2 id="WebGL程序的软件结构"><a href="#WebGL程序的软件结构" class="headerlink" title="WebGL程序的软件结构"></a>WebGL程序的软件结构</h2><p>默认情况下，一个动态网页程序只包括HTML和JavaScript两种语言。<br>而在WebGL程序中，还包括了第三种语言：GLSL ES。</p><p><img alt="enter description here" data-src="https://c1.staticflickr.com/1/417/31743655591_e5815e1579_o.png"></p><h2 id="WebGL编程模型"><a href="#WebGL编程模型" class="headerlink" title="WebGL编程模型"></a>WebGL编程模型</h2><p><img alt="enter description here" data-src="https://c1.staticflickr.com/1/502/31050538443_ca9377f3a2_o.png"><br>上图表示一个WebGL程序运行的主要流程。主要分为3个阶段，应用程序阶段、着色器阶段、片元后处理阶段。<br>本文接下来按照一定的规律介绍编写一个原生WebGL程序主要的步骤。</p><h3 id="获得WebGL渲染环境"><a href="#获得WebGL渲染环境" class="headerlink" title="获得WebGL渲染环境"></a>获得WebGL渲染环境</h3><h4 id="在Html中定义canvas标签"><a href="#在Html中定义canvas标签" class="headerlink" title="在Html中定义canvas标签"></a>在Html中定义canvas标签</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">canvas</span> id=<span class="string">"webgl"</span> <span class="attribute">width</span>=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt; &lt;/canvas&gt;</span><br></pre></td></tr></table></figure><h4 id="在JS代码中获得canvas对象"><a href="#在JS代码中获得canvas对象" class="headerlink" title="在JS代码中获得canvas对象"></a>在JS代码中获得canvas对象</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById('webgl');</span><br></pre></td></tr></table></figure><h4 id="通过canvas对象获得WebGL渲染环境"><a href="#通过canvas对象获得WebGL渲染环境" class="headerlink" title="通过canvas对象获得WebGL渲染环境"></a>通过canvas对象获得WebGL渲染环境</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var gl = getWebGLContext(canvas);</span><br></pre></td></tr></table></figure><h3 id="编写着色器"><a href="#编写着色器" class="headerlink" title="编写着色器"></a>编写着色器</h3><h4 id="编写顶点着色器"><a href="#编写顶点着色器" class="headerlink" title="编写顶点着色器"></a>编写顶点着色器</h4><p>顶点着色器是用来描述顶点属性（比如位置、颜色、纹理坐标等的程序）<br><img alt="enter description here" data-src="https://c1.staticflickr.com/1/441/31822594876_583f762171_o.png"></p><h4 id="编写片元着色器"><a href="#编写片元着色器" class="headerlink" title="编写片元着色器"></a>编写片元着色器</h4><p>片元着色器处理光栅后的数据，可以片元将其理解为像素。<br>片元着色器的输出构成了最终的像素值（开启多重采样的话只构成了某个像素的一部分值）<br><img alt="enter description here" data-src="https://c1.staticflickr.com/1/771/31822601086_e8b7848d25_o.png"></p><h3 id="初始化着色器"><a href="#初始化着色器" class="headerlink" title="初始化着色器"></a>初始化着色器</h3><p>初始化着色器基本上是一个固定的流程，主要分为以下几个步骤。</p><h4 id="创建shader"><a href="#创建shader" class="headerlink" title="创建shader"></a>创建shader</h4><h4 id="加载shader源码"><a href="#加载shader源码" class="headerlink" title="加载shader源码"></a>加载shader源码</h4><h4 id="编译shader"><a href="#编译shader" class="headerlink" title="编译shader"></a>编译shader</h4><h4 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h4><h4 id="附加编译好的shader"><a href="#附加编译好的shader" class="headerlink" title="附加编译好的shader"></a>附加编译好的shader</h4><h4 id="链接程序"><a href="#链接程序" class="headerlink" title="链接程序"></a>链接程序</h4><h4 id="使用程序"><a href="#使用程序" class="headerlink" title="使用程序"></a>使用程序</h4><h3 id="获得顶点属性"><a href="#获得顶点属性" class="headerlink" title="获得顶点属性"></a>获得顶点属性</h3><p>顶点上有各种属性，比如空间坐标、纹理坐标、材质等，一个顶点就是一个属性集合。<br>如下图所示的立方体，顶点上有2个属性，坐标和颜色。<br><img alt="enter description here" data-src="https://c1.staticflickr.com/1/280/31487505630_7c7a69ed2f_o.png"><br>顶点属性可以通过读取模型文件，比如obj文件等获得，或者简单写在代码定义中，比如上图的立方体。</p><h3 id="创建顶点缓冲区"><a href="#创建顶点缓冲区" class="headerlink" title="创建顶点缓冲区"></a>创建顶点缓冲区</h3><p>缓冲区存在于显存中，能够被显卡直接用来进行渲染，不需要进行数据传输。<br>在WebGL中，通过以下调用获得一个缓冲区对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var vertexColorBuffer = gl.createBuffer();</span><br></pre></td></tr></table></figure><h3 id="写入顶点数据到顶点缓冲区对象"><a href="#写入顶点数据到顶点缓冲区对象" class="headerlink" title="写入顶点数据到顶点缓冲区对象"></a>写入顶点数据到顶点缓冲区对象</h3><p>这个步骤分为两个操作。</p><h4 id="首先，绑定创建的缓冲区"><a href="#首先，绑定创建的缓冲区" class="headerlink" title="首先，绑定创建的缓冲区"></a>首先，绑定创建的缓冲区</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);</span><br></pre></td></tr></table></figure><h4 id="然后，传输系统内存中上的顶点数据到缓冲区（显存中）"><a href="#然后，传输系统内存中上的顶点数据到缓冲区（显存中）" class="headerlink" title="然后，传输系统内存中上的顶点数据到缓冲区（显存中）"></a>然后，传输系统内存中上的顶点数据到缓冲区（显存中）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure><h4 id="传输数据的标志"><a href="#传输数据的标志" class="headerlink" title="传输数据的标志"></a>传输数据的标志</h4><p>gl.bufferData的第三个参数表示数据的使用标志，表示三种不同的应用场景。<br>1. gl.STATIC_DRAW ：表示数据不会经常改变，通常用于静态物体，比如地形、墙体等。<br>2. gl.STREAM_DRAW：表示数据使用一次后就会被丢弃。<br>3. gl.DYNAMIC_DRAW：表示数据会被多次修改，也会被使用多次。</p><p>系统会根据usage标示符为缓冲区对象分配最佳的存储位置。<br>STATIC_DRAW和STREAM_DRAW分配在显存上，DYNAMIC_DRAW可能分配在AGP中。</p><h3 id="将顶点数据传输到顶点着色器"><a href="#将顶点数据传输到顶点着色器" class="headerlink" title="将顶点数据传输到顶点着色器"></a>将顶点数据传输到顶点着色器</h3><p>目前，我们已经准会了WebGL渲染环境，并且数据已经从系统内存传输到显存中的缓冲区对象中。现在，我们要将缓存区对象中的数据指定给顶点着色器中对应的变量。<br>顶点着色器中的attribute变量对象顶点的属性。我们的顶点着色器中定义了2个变量，a_Position，a_Color。下面我们分为三步为这其指定数据。</p><ol><li>获得着色器中attribute变量位置<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a_Position = gl.getAttribLocation(gl.program, 'a_Position');</span><br></pre></td></tr></table></figure></li><li><p>根据变量位置传入缓冲区中的顶点属性数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.vertexAttribPointer(a_Position, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>启用该attribute变量的属性数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.enableVertexAttribArray(a_Position);</span><br></pre></td></tr></table></figure></li></ol><p>对于a_Color，我们在系统内存中定义在坐标的后面，因此在第2步中需要进行<strong>偏移</strong>，gl.vertexAttribPointer的最后一个参数可以指定数据的偏移位置，因此第2步修改为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.vertexAttribPointer(a_Position, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, FSIZE * <span class="number">3</span>);</span><br></pre></td></tr></table></figure><br>FSIZE表示float的大小。</p><h3 id="传入uniform变量到着色器"><a href="#传入uniform变量到着色器" class="headerlink" title="传入uniform变量到着色器"></a>传入uniform变量到着色器</h3><p>着色器中还存在一种uniform变量，这种变量对于所有顶点来说都是一样的。<br>比如，mvp矩阵就应该定义为uniform变量。一般情况，我们在js代码中计算好mvp矩阵，然后传输到着色器中的uniform变量中。主要步骤如下：<br>1. 获取uniform变量的在着色中的位置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');</span><br></pre></td></tr></table></figure></p><ol><li>计算uniform变量（比如mvp矩阵）的值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var mvpMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">mvpMatrix.setPerspective(<span class="number">30</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">mvpMatrix.lookAt(<span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol><li>传入uniform变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.uniformMatrix4fv(u_MvpMatrix, <span class="literal">false</span>, mvpMatrix.elements);</span><br></pre></td></tr></table></figure><p>目前，顶点着色器已经有了每个顶点的属性，以及用uniform变量表示的mvp矩阵，因此可以变换顶点属性后传入片元着色器中进一步处理。</p><h3 id="定义面片索引"><a href="#定义面片索引" class="headerlink" title="定义面片索引"></a>定义面片索引</h3><p>上面我们处理的数据都是顶点属性，但是我们实际要绘制的图元是面片，比如三角面片。<br>通常情况下，我们会用三个顶点索引表示一个三角面片。<br>如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Indices of the vertices</span></span><br><span class="line">var indices = <span class="keyword">new</span> Uint8Array([</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="comment">// front</span></span><br><span class="line"><span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="comment">// right</span></span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="comment">// up</span></span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="comment">// left</span></span><br><span class="line"><span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="comment">// down</span></span><br><span class="line"><span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span> <span class="comment">// back</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>indices表示一个立方体的面片索引。</p><h3 id="创建索引缓冲区，写入索引"><a href="#创建索引缓冲区，写入索引" class="headerlink" title="创建索引缓冲区，写入索引"></a>创建索引缓冲区，写入索引</h3><p>接下来，我们要创建索引缓冲区，并将内存中的索引数据传入缓存区。<br>1. 创建索引缓冲区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var indexBuffer = gl.createBuffer();</span><br></pre></td></tr></table></figure><ol><li>绑定索引缓冲区</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);</span><br></pre></td></tr></table></figure><ol><li>将面片索引写入缓冲区对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="根据索引绘制图元"><a href="#根据索引绘制图元" class="headerlink" title="根据索引绘制图元"></a>根据索引绘制图元</h3><p>最后一步只需要根据面片索引绘制图元即可。<br>根据面片的顶点索引绘制图元节省内存，不需要存储重复的顶点数据。<br>我们只需要调用gl.drawElements即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其中，第二个参数n表示要绘制的图元（三角形面片）个数。最后一个参数0表示使用已经绑定好的索引缓冲区对象。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>下面给出绘制一个彩色立方体的完整代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader program</span></span><br><span class="line">var VSHADER_SOURCE =</span><br><span class="line">'attribute vec4 a_Position;\n' +</span><br><span class="line">'attribute vec4 a_Color;\n' +</span><br><span class="line">'uniform mat4 u_MvpMatrix;\n' +</span><br><span class="line">'varying vec4 v_Color;\n' +</span><br><span class="line">'void main() &#123;\n' +</span><br><span class="line">' gl_Position = u_MvpMatrix * a_Position;\n' +</span><br><span class="line">' v_Color = a_Color;\n' +</span><br><span class="line">'&#125;\n';</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment shader program</span></span><br><span class="line">var FSHADER_SOURCE =</span><br><span class="line">'#ifdef GL_ES\n' +</span><br><span class="line">'precision mediump float;\n' +</span><br><span class="line">'#endif\n' +</span><br><span class="line">'varying vec4 v_Color;\n' +</span><br><span class="line">'void main() &#123;\n' +</span><br><span class="line">' gl_FragColor = v_Color;\n' +</span><br><span class="line">'&#125;\n';</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Retrieve &lt;canvas&gt; element</span></span><br><span class="line">var canvas = document.getElementById('webgl');</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the rendering context for WebGL</span></span><br><span class="line">var gl = getWebGLContext(canvas);</span><br><span class="line"><span class="keyword">if</span> (!gl) &#123;</span><br><span class="line">console.log('Failed to get the rendering context for WebGL');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize shaders</span></span><br><span class="line"><span class="keyword">if</span> (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) &#123;</span><br><span class="line">console.log('Failed to intialize shaders.');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the vertex coordinates and color</span></span><br><span class="line">var n = initVertexBuffers(gl);</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">console.log('Failed to set the vertex information');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set clear color and enable hidden surface removal</span></span><br><span class="line">gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">gl.enable(gl.DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the storage location of u_MvpMatrix</span></span><br><span class="line">var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');</span><br><span class="line"><span class="keyword">if</span> (!u_MvpMatrix) &#123;</span><br><span class="line">console.log('Failed to get the storage location of u_MvpMatrix');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the eye point and the viewing volume</span></span><br><span class="line">var mvpMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">mvpMatrix.setPerspective(<span class="number">30</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">mvpMatrix.lookAt(<span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass the model view projection matrix to u_MvpMatrix</span></span><br><span class="line">gl.uniformMatrix4fv(u_MvpMatrix, <span class="literal">false</span>, mvpMatrix.elements);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear color and depth buffer</span></span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw the cube</span></span><br><span class="line">gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">initVertexBuffers</span><span class="params">(gl)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create a cube</span></span><br><span class="line"><span class="comment">// v6----- v5</span></span><br><span class="line"><span class="comment">// /| /|</span></span><br><span class="line"><span class="comment">// v1------v0|</span></span><br><span class="line"><span class="comment">// | | | |</span></span><br><span class="line"><span class="comment">// | |v7---|-|v4</span></span><br><span class="line"><span class="comment">// |/ |/</span></span><br><span class="line"><span class="comment">// v2------v3</span></span><br><span class="line">var verticesColors = <span class="keyword">new</span> Float32Array([</span><br><span class="line"><span class="comment">// Vertex coordinates and color</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="comment">// v0 White</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="comment">// v1 Magenta</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="comment">// v2 Red</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="comment">// v3 Yellow</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="comment">// v4 Green</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="comment">// v5 Cyan</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="comment">// v6 Blue</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> <span class="comment">// v7 Black</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indices of the vertices</span></span><br><span class="line">var indices = <span class="keyword">new</span> Uint8Array([</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="comment">// front</span></span><br><span class="line"><span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="comment">// right</span></span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="comment">// up</span></span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="comment">// left</span></span><br><span class="line"><span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="comment">// down</span></span><br><span class="line"><span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span> <span class="comment">// back</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a buffer object</span></span><br><span class="line">var vertexColorBuffer = gl.createBuffer();</span><br><span class="line">var indexBuffer = gl.createBuffer();</span><br><span class="line"><span class="keyword">if</span> (!vertexColorBuffer || !indexBuffer) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the vertex coordinates and color to the buffer object</span></span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">var FSIZE = verticesColors.BYTES_PER_ELEMENT;</span><br><span class="line"><span class="comment">// Assign the buffer object to a_Position and enable the assignment</span></span><br><span class="line">var a_Position = gl.getAttribLocation(gl.program, 'a_Position');</span><br><span class="line"><span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">console.log('Failed to get the storage location of a_Position');</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">gl.vertexAttribPointer(a_Position, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">gl.enableVertexAttribArray(a_Position);</span><br><span class="line"><span class="comment">// Assign the buffer object to a_Color and enable the assignment</span></span><br><span class="line">var a_Color = gl.getAttribLocation(gl.program, 'a_Color');</span><br><span class="line"><span class="keyword">if</span>(a_Color &lt; <span class="number">0</span>) &#123;</span><br><span class="line">console.log('Failed to get the storage location of a_Color');</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">gl.vertexAttribPointer(a_Color, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, FSIZE * <span class="number">3</span>);</span><br><span class="line">gl.enableVertexAttribArray(a_Color);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the indices to the buffer object</span></span><br><span class="line">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);</span><br><span class="line">gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> indices.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中使用到的创建WebGL渲染环境、初始化着色器、创建矩阵的操作，读者可以自行找相应的代码库替代。<br>或者在下面的链接中下载：<br><a href="http://pan.baidu.com/s/1mhVH5Ba" target="_blank" rel="noopener">WebGL Lib</a>， 密码：tncd。</p><p>PPT文档如下：</p><iframe src="https://onedrive.live.com/embed?cid=4330CD349D9ADD44&resid=4330CD349D9ADD44%21739&authkey=AF3XGkUj4jdHiF8&em=2" width="900" height="700" frameborder="0" scrolling="no"></iframe>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> WebGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻三引擎游戏命令</title>
      <link href="/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E6%B8%B8%E6%88%8F%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E6%B8%B8%E6%88%8F%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="命令行参数和控制台命令"><a href="#命令行参数和控制台命令" class="headerlink" title="命令行参数和控制台命令"></a>命令行参数和控制台命令</h2><p>游戏命令包括两种，一种是运行游戏时候指定的命令行参数，另外一种则指的是进入游戏后输入的控制命令。</p><h2 id="控制台命令"><a href="#控制台命令" class="headerlink" title="控制台命令"></a>控制台命令</h2><p>对于虚幻三来说，控制台命令分为两种，一种是引擎中已经支持的可执行命令，这些命令都是在C++类的Exec函数中进行处理的。另一种是带exec前缀的脚本函数，称为可执行函数。<br>下面根据用途统一总结，不进行区分。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="exit-quit"><a href="#exit-quit" class="headerlink" title="exit(quit)"></a>exit(quit)</h4><p>退出游戏</p><h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h4><p>暂停游戏，按pause break键也可以。</p><h4 id="open-url"><a href="#open-url" class="headerlink" title="open [url]"></a>open [url]</h4><p>打开地图，额外的参数同命令行参数的url部分。比如，在大厅中开始游戏就是用的该命令打开服务器下发的ip地址。</p><h4 id="restartLevel"><a href="#restartLevel" class="headerlink" title="restartLevel"></a>restartLevel</h4><p>重启当前关卡</p><h4 id="reconnect-disconnect-cancel"><a href="#reconnect-disconnect-cancel" class="headerlink" title="reconnect/disconnect/cancel"></a>reconnect/disconnect/cancel</h4><p>重新连接服务器，断开服务器连接，取消进行的服务器连接操作。</p><h4 id="Kill系列"><a href="#Kill系列" class="headerlink" title="Kill系列"></a>Kill系列</h4><ol><li>KillAll [class] - 销毁或破坏关卡中特定类的所有实例。</li><li>KillPawns - 销毁关卡中的所有 pawn。</li><li>KillBadGuys - 销毁所有不在同一个团队作为玩家的 pawns。</li><li>Suicide -玩家自杀</li></ol><h4 id="god-fly-walk"><a href="#god-fly-walk" class="headerlink" title="god/fly/walk"></a>god/fly/walk</h4><p>幽灵模式（可以飞、穿墙）/飞行模式/正常模式</p><h4 id="AllAmmo"><a href="#AllAmmo" class="headerlink" title="AllAmmo"></a>AllAmmo</h4><p>将弹药数目设置为所有武器的最大值</p><h4 id="SetRes"><a href="#SetRes" class="headerlink" title="SetRes"></a>SetRes</h4><p>setres [width] [x|X] [height] [w|f]<br>改变分辨率（width为宽，height为高）<br>模式(w = 窗口; f = 全屏)，<br>比如 800x600w表示分辨率为800乘以600的窗口模式，<br>1024x768f表示分辨率为1024乘以768的全屏模式。</p><h4 id="FreeCamera"><a href="#FreeCamera" class="headerlink" title="FreeCamera"></a>FreeCamera</h4><p>将玩家的相机设置为自由轨道相机模式（第三人称视角），FreeCamera false恢复。</p><h4 id="Addbots"><a href="#Addbots" class="headerlink" title="Addbots"></a>Addbots</h4><ol><li>AddBots [number] - 为了进行测试，会向关卡中添加指定机器人数.</li><li>AddBlueBots [number] - 在团队游戏中为蓝队添加指定的机器人数。</li><li>AddRedBots [number] - 在团队游戏中为红队添加指定的机器人数。</li><li>AddNamedBot [name] [bUseTeamNum] [teamnum] - 添加一个使用指定名称的机器人。如果 bUseTeamNum 为真而且指定了团队数，那么将该机器人添加到指定的团队。</li></ol><h4 id="Shot"><a href="#Shot" class="headerlink" title="Shot"></a>Shot</h4><ol><li>shot/screenshot 以当前的屏幕分辨率截取屏幕截图。</li><li>tiledshot [factor] 以当前分辨率乘以指定因数为分辨率来获取屏幕截图。比如，tiledshot 2会得到2乘以2的shot截图，分辨率也是shot的2倍。</li><li>SHOTNOHUD，不截屏hud。</li></ol><h3 id="渲染命令"><a href="#渲染命令" class="headerlink" title="渲染命令"></a>渲染命令</h3><h4 id="ViewMode"><a href="#ViewMode" class="headerlink" title="ViewMode"></a>ViewMode</h4><p>viewmode命令设置渲染模式<br>1. detaillight 默认模式，使用受到法线贴图的光照影响的中性色彩材质渲染场景<br>2. unlit 无光照<br>3. lightingonly 只使用光照<br>4. wireframe 线框模式<br>5. brushwireframe 线框模式，但是显示画刷边缘<br>6. lightcomplexity 显示光照复杂度<br>7. lightmapdensity 显示光照贴图密度<br>8. litlightmapdensity 显示光照贴图像素密度 6和7的结合<br>9. texturedensity 显示每个表面上漫反射通道上的贴图像素密度<br>10. shadercomplexity 显示每个表面上所应用的材质的复杂度</p><h4 id="Show"><a href="#Show" class="headerlink" title="Show"></a>Show</h4><p>切换各种项目的显示(仅用于客户端)<br>1. bounds  切换actor边界的显示（包围盒和包围球）<br>2. volumes 切换体积的显示（体积盒）<br>3. collision 切换碰撞体的显示状态<br>4. bsp  切换bsp几何体的显示（用bsp画刷制作的物体，比如墙）<br>5. fog  切换雾actors的显示<br>6. particles 切换粒子几何体的显示（比如烟雾弹，特效做的门）<br>7. paths 切换路径或导航网格物体的显示<br>8. navnodes 切换和寻路相关的actors的显示<br>9. foliage 切换植被的显示<br>10. terrain 切换地形几何体的显示<br>11. terrainpatches 切换地形块的显示。在每个块的周围描画一个轮廓。<br>12. staticmeshes 切换静态网格物体几何体的显示<br>13. decal 切换decal actors的显示<br>14. decalinfo 切换decals（贴花）的调试开发信息的显示(平头截体、切线轴等)。<br>15. staticmeshes 切换静态网格物体几何体的显示。<br>16. postprocess  切换后期处理特效的显示<br>17. skelmeshes/skeletalmeshes 切换骨架网格物体几何体的显示<br>18. MISSINGCOLLISION  切换高亮显示启用了碰撞但是没有碰撞网格物体的静态网格物体</p><h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><h4 id="display系列"><a href="#display系列" class="headerlink" title="display系列"></a>display系列</h4><h4 id="displayall-class-prop"><a href="#displayall-class-prop" class="headerlink" title="displayall class prop"></a>displayall class prop</h4><p>在屏幕上实时地显示类class所有实例的属性prop的值</p><h4 id="display-obj-prop"><a href="#display-obj-prop" class="headerlink" title="display obj prop"></a>display obj prop</h4><p>在屏幕上实时地显示对象obj的属性prop的值。</p><h4 id="displayallstate-class"><a href="#displayallstate-class" class="headerlink" title="displayallstate class"></a>displayallstate class</h4><p>在屏幕上实时地显示类class所有实例的当前处于的状态，比如行走，空闲，攻击等</p><h4 id="displayclear"><a href="#displayclear" class="headerlink" title="displayclear"></a>displayclear</h4><p>清楚display系列命令所有的输出</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set class/obj prop value<br>1. 设置给定类class（包括其子类）的所有对象的属性prop的值为value<br>2. 设置给定对象obj的属性prop的值为value</p><p>可以用displayall实时显示出来这个属性，再用set设置后观察属性变化。</p><h3 id="统计命令"><a href="#统计命令" class="headerlink" title="统计命令"></a>统计命令</h3><p>stat命令负责在游戏运行时在屏幕上启用显示统计数据功能。</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>关闭所有统计数据的显示</p><h4 id="fps"><a href="#fps" class="headerlink" title="fps"></a>fps</h4><p>切换帧频率统计数据的显示</p><h4 id="anim"><a href="#anim" class="headerlink" title="anim"></a>anim</h4><p>切换动画系统统计数据的显示状态</p><h4 id="net"><a href="#net" class="headerlink" title="net"></a>net</h4><p>切换网络统计数据显示的 打开/关闭 状态</p><h4 id="game"><a href="#game" class="headerlink" title="game"></a>game</h4><p>切换游戏统计数据的显示。(更新时间等)</p><h4 id="ui"><a href="#ui" class="headerlink" title="ui"></a>ui</h4><p>切换UIScene统计数据的显示</p><h4 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h4><p>切换碰撞统计数据的显示状态</p><h4 id="octree"><a href="#octree" class="headerlink" title="octree"></a>octree</h4><p>切换八叉树相关统计数据的显示</p><h4 id="physics"><a href="#physics" class="headerlink" title="physics"></a>physics</h4><p>切换一般物理统计数据的显示<br>1. physicscloth 切换关于布料仿真统计数据的显示。<br>2. physicsfields 切换关于物理域的统计数据的显示状态。<br>3. physicsfluids 切换关于PhysX流体仿真统计数据的显示。</p><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p>切换一般内存统计数据的显示</p><h4 id="memorychurn"><a href="#memorychurn" class="headerlink" title="memorychurn"></a>memorychurn</h4><p>切换处理内存分配的统计数据的显示</p><h4 id="scenerendering"><a href="#scenerendering" class="headerlink" title="scenerendering"></a>scenerendering</h4><p>切换场景渲染统计数据的显示</p><h4 id="startfile-stopfile"><a href="#startfile-stopfile" class="headerlink" title="startfile/stopfile"></a>startfile/stopfile</h4><ol><li>startfile开始捕获统计数据文件以便和StatsViewer结合使用。</li><li>stopfile完成捕获统计数据文件。</li><li>文件存储位置：UDKGame\Profiling\UE3Stats\xxx文件..ustats</li><li>打开工具：Binaries\StatsViewer.exe</li></ol><h4 id="GameProfile-ProfileGame"><a href="#GameProfile-ProfileGame" class="headerlink" title="GameProfile/ProfileGame"></a>GameProfile/ProfileGame</h4><p>该命令在虚幻三和UDK中用于统计脚本函数的运行时间。<br>1. start 开始Profile<br>2. stop 结束Profile<br>3. 文件：UDKGame\Profiling\T-2016.11.29-19.26.55.gprof<br>4. 打开工具：Binaries\GameplayProfiler.exe<br>5. UObject::CallFunction中统计了每个函数的调用时间。</p><h3 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h3><p>调试命令的结果是控制台形式的输出，并不是在游戏窗口中显示。在逆战中，需要按f8显示控制台窗口，再输入调试命令。其余类型的命令可以使用f7也可以使用f8。</p><h4 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h4><h5 id="gc-garbage"><a href="#gc-garbage" class="headerlink" title="gc/garbage"></a>gc/garbage</h5><p>强制进行垃圾回收清理。</p><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>显示包中的一个类别的所有物体的列表。<br>1. obj list显示包中所有的物体列表。<br>2. obj list class=pawn 只显示指定的类的所有物体的对象列表，比如pawn。</p><h5 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h5><p>dump objname<br>在控制台中输出某个对象的所有属性，可以先用displayall找到这个对象名。</p><h3 id="物理命令"><a href="#物理命令" class="headerlink" title="物理命令"></a>物理命令</h3><h5 id="nxvis-collision…"><a href="#nxvis-collision…" class="headerlink" title="nxvis collision…"></a>nxvis collision…</h5><p>碰撞相关命令</p><h5 id="nxvis-joint…"><a href="#nxvis-joint…" class="headerlink" title="nxvis joint…"></a>nxvis joint…</h5><p>关节相关命令</p><h5 id="nxvis-cloth…"><a href="#nxvis-cloth…" class="headerlink" title="nxvis cloth…"></a>nxvis cloth…</h5><p>布料相关命令</p><h5 id="nxvis-fluid…"><a href="#nxvis-fluid…" class="headerlink" title="nxvis fluid…"></a>nxvis fluid…</h5><p>流体相关命令</p><h5 id="nxvis-softbody…"><a href="#nxvis-softbody…" class="headerlink" title="nxvis softbody…"></a>nxvis softbody…</h5><p>软体相关命令</p><h3 id="内存命令"><a href="#内存命令" class="headerlink" title="内存命令"></a>内存命令</h3><h5 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h5><p>显示内存分配信息<br>1.  mem<br>2.  mem detailed<br>3.  mem stat</p><h5 id="configmem"><a href="#configmem" class="headerlink" title="configmem"></a>configmem</h5><p>显示配置文件内存分配信息</p><h5 id="particlememory"><a href="#particlememory" class="headerlink" title="particlememory"></a>particlememory</h5><p>粒子内存信息</p><h5 id="memfragcheck"><a href="#memfragcheck" class="headerlink" title="memfragcheck"></a>memfragcheck</h5><p>内存碎片检测</p><h5 id="memleakcheck"><a href="#memleakcheck" class="headerlink" title="memleakcheck"></a>memleakcheck</h5><p>内存泄漏检测</p><h3 id="UI-GFX命令"><a href="#UI-GFX命令" class="headerlink" title="UI/GFX命令"></a>UI/GFX命令</h3><h3 id="ShowHUD"><a href="#ShowHUD" class="headerlink" title="ShowHUD"></a>ShowHUD</h3><p>显示(隐藏)所有的HUD</p><h5 id="ShowScores"><a href="#ShowScores" class="headerlink" title="ShowScores"></a>ShowScores</h5><p>显示(隐藏)积分面板</p><h5 id="Toggleui"><a href="#Toggleui" class="headerlink" title="Toggleui"></a>Toggleui</h5><p>切换UI的更新和显示</p><h5 id="gfxinvoke"><a href="#gfxinvoke" class="headerlink" title="gfxinvoke"></a>gfxinvoke</h5><p>调用GfxMovie对应的flash文件的as函数</p><h5 id="dumpsftextures"><a href="#dumpsftextures" class="headerlink" title="dumpsftextures"></a>dumpsftextures</h5><p>输出GFx Texture Usage到log文件中。</p><h2 id="虚幻三控制台命令调用流程"><a href="#虚幻三控制台命令调用流程" class="headerlink" title="虚幻三控制台命令调用流程"></a>虚幻三控制台命令调用流程</h2><ul><li>APlayerController::ConsoleCommand。</li><li><ul><li>ULocalPlayer::Exec，处理一部分命令。</li></ul></li><li><ul><li><ul><li>UGameViewportClient::Exec，引擎自带的大部分命令在此函数中实现。</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UGFxInteraction::Exec，执行gfx相关的命令。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UUIInteraction::Exec，处理一部分命令。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>UUIInteraction::ScriptConsoleExec。</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>UGameUISceneClient::Exec。</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>UUISceneClient::Exec.</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li>UUISceneClient::ScriptConsoleExec.</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UGameViewportClient::ScriptConsoleExec。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UEngine::Exec，处理一部分命令。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li>UPlayer::Exec，处理一部分命令。</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UWorld::Exec。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>APlayerInput::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>APlayerController::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>APawn::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AInvManager::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AWeapon::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AHUD::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AGameInfo::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>ACheatManager::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AInteraction::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li>返回APlayerController::ConsoleCommand，命令未处理。</li></ul><p>注意：UObkect::ScriptConsoleExec，处理的是当前类中自定义脚本命令（执行带exec前缀的脚本函数）。<br>因此，流程中带有ScriptConsoleExec函数执行的类（以及子类）都可以定exec脚本函数来执行控制台命令。只有在处理流程中的命令才有效，处理流程外的命令无法被处理。</p><h3 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h3><h4 id="Native命令"><a href="#Native命令" class="headerlink" title="Native命令"></a>Native命令</h4><p>在控制台命令调用流程中涉及到的C++类的Exec函数中添加对新命令的处理逻辑。</p><h4 id="脚本命令"><a href="#脚本命令" class="headerlink" title="脚本命令"></a>脚本命令</h4><p>在处理流程中的有ScriptConsoleExec调用的类(Interaction、UISceneClient、GameViewportClient、PlayerInput、PlayerController、Pawn、InvManager、Weapon、HUD、GameInfo、CheatManager)<br>中添加exec前缀的脚本函数。</p><p>更多的游戏命令可以参考文档：<a href="https://wiki.beyondunreal.com/Legacy:Console_Commands" target="_blank" rel="noopener">Console Commands</a>。</p><h3 id="虚幻引擎游戏命令"><a href="#虚幻引擎游戏命令" class="headerlink" title="虚幻引擎游戏命令"></a>虚幻引擎游戏命令</h3><div class="video-container"><iframe src="https://onedrive.live.com/embed?cid=4330CD349D9ADD44&resid=4330CD349D9ADD44%21723&authkey=AFSrpMCVspcze0g&em=2" width="800" height="700" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> UnrealEngine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnrealEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚幻三命令行参数</title>
      <link href="/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
      <url>/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>命令行参数是指通过命令行或者可执行文件快捷方式启动游戏进程的时候，附加在后面的一系列参数。</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>命令行参数分为两种，一种是编译游戏代码时候需要用到的命令行参数。另一种则是在启动游戏进程时候指定的参数。</p><h3 id="编译命令行参数"><a href="#编译命令行参数" class="headerlink" title="编译命令行参数"></a>编译命令行参数</h3><p>编译代码期间会用到的参数如下：</p><ol><li>版本 -debug -release&lt;/p&gt;</li><li><p>全量 -full （默认增量）</p></li><li><p>自动更新C++头文件，不弹框确认 -auto<br>注意：虚幻三编译脚本.uc文件时候，会更新.h头文件</p></li><li><p>移除.u文件中的源代码信息 -stripsource注意：.u文件是虚幻三脚本文件编译后的字节码文件，虚幻四中不存在</p><p>因此，编译代码时候最多可能指定以下参数组合：<br>make -debug -full -auto -stripsource<br>make -release -full -auto  -stripsource</p></li></ol><p><strong>注意：通过在vs中指定make命令可以调试编译代码的过程。</strong><br>如下图所示：<br><img alt="enter description here" data-src="https://c2.staticflickr.com/6/5486/31353510066_d0fd3565ee_o.png"></p><h3 id="运行命令行参数"><a href="#运行命令行参数" class="headerlink" title="运行命令行参数"></a>运行命令行参数</h3><p>启动游戏进程指定的命令行参数分为两个个部分，第一个部分用于指定进程的运行模式（客户端、服务器、编辑器），第二个部分用于指定地图的URL以及附加选项。</p><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><p>游戏进程可以用三种不同的模式进行启动，分别是客户端、服务器、编辑器模式。因此，虚幻引擎生成的游戏可执行文件同时可以作为游戏服务器、游戏客户端、游戏编辑器运行。这是一个很神奇的地方。</p><ol><li><p>客户端模式<br>默认情况下，启动的游戏进程就是客户端模式，不需要指定额外的命令行参数。<br>在UE4中，也可以指定-game参数。</p></li><li><p>服务器模式<br>通过指定server参数，可以启动一个游戏服务器。<br>比如，udk.exe server，则是使用udk启动一个游戏服务器。<br>对于UE4，则是UE4Editor.exe -server。<br>实际上，可以修改游戏引擎设置，输出自定义的游戏执行文件。在启动这个游戏可执行文件时候，只需要附近sever参数就可以启动一个游戏服务器。</p></li><li><p>编辑器模式<br>通过指定editor参数，可以启动一个游戏服务器。<br>比如，udk.exe editor，则是使用udk启动游戏编辑器。<br>对于UE4，则是UE4Editor.exe -editor。</p></li></ol><h4 id="模式的URL参数"><a href="#模式的URL参数" class="headerlink" title="模式的URL参数"></a>模式的URL参数</h4><p>URL分为两个部分：地图名称或者服务器地址，可选的附加参数。<br>地图部分用于强制游戏启动时候加载特定的地图，附加参数用于设置额外的启动方式，比如设置分辨率，是否打开log窗口等。这些参数和server或editor模式结合起来就可以启动特定地图的服务器或者用编辑器打开特定地图。<br>如果没有url参数，那么游戏进程会打开默认的地图。URL参数必须在可执行命令名称的后面或者在模式参数后面。</p><ol><li><p>地图<br>如果运行本地游戏，则指定Maps目录下的地图名称，比如MyMap. umap。<br>如果运行网络游戏，则指定游戏服务器的IP地址（server模式启动的游戏进程就是游戏服务器）。</p></li><li><p>附加参数<br>附加参数与地图之间用”?”分隔。<br>附加参数分为两种类型，一种是用”=”指定的选项，一种是用”-“指定的开关。</p><p>常用的选项参数：<br>dedicated：指定服务器作为专用服务器。<br>listen: 指定服务器作为监听服务器 。<br>spectatoronly：以观看模式启动游戏<br>class: 告诉引擎要使用的玩家类(覆盖默认值)。<br>game:: 指定使用的GameInfo类。<br>name: 要使用的玩家名称。<br>team: 指定玩家所在的团队。<br>resx/resy: 设置游戏窗口的分辨率。<br>consolex/consoley：设置控制台窗口(log窗口)分辨率。</p><p>常用的开关参数：<br>log: 打开日志窗口。<br>windowed：窗口模式运行。<br>nomoviestartup: 略过启动动画。<br>nosplash: 略过启动splash窗口。</p><p></p><p>更多的附加参数请参考文档：<a href="https://docs.unrealengine.com/latest/CHN/Programming/Basics/CommandLineArguments/index.html" target="_blank" rel="noopener">虚幻四引擎命令行参数</a></p></li><li><p>一些示例：<br>UDK.exe server MyMap.udk<br>UDK.exe 127.0.0.1<br>UDK.exe MyMap.udk?-resX=640 -resY=480 -log log=log.txt<br>UDKLift.exe DM-发电站?Game=UTGame.UTTeamGame?listen=true?TeamIndex=0?Name=FS01 -log -windowed -resX=640 -resY=360 -nomoviestartup -nosplash windowPosX=0 windowPosY=0 -consolePosX=0 -consolePosY=365<br>MyGame.exe editor MyMap.umap -NoLoadStartupPackages -NoGADWarning</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> UnrealEngine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UnrealEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用DebugView实时显示Log</title>
      <link href="/2016/08/15/%E4%BD%BF%E7%94%A8DebugView%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BALog/"/>
      <url>/2016/08/15/%E4%BD%BF%E7%94%A8DebugView%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BALog/</url>
      
        <content type="html"><![CDATA[<h3 id="DebugView简介"><a href="#DebugView简介" class="headerlink" title="DebugView简介"></a>DebugView简介</h3><p>DebugView是一个监视本地系统或者通过tcp/ip连接的网络系统的OutputDebugString输出的应用程序。DebugView不仅能够监视Win32应用的debug输出，还可以监视内核模型的debug输出。因此，如果使用OutputDebugString来打印调试信息的话，就可以在程序运行时候通过DebugView来实时显示程序的调试信息。<br>这种方式在某种意义上，比将Log打印到文件中，关闭程序后再查看Log输出的方式更加方便。而且可以将这两种调试程序的方式结合起来，既使用DebugView来实时显示调试信息，又将调试信息输出到Log文件中，方便以后分析。</p><h2 id="安装DebugView"><a href="#安装DebugView" class="headerlink" title="安装DebugView"></a>安装DebugView</h2><p>下载地址：<a href="https://technet.microsoft.com/en-us/sysinternals/debugview.aspx" target="_blank" rel="noopener">DebugView</a><br>下载后面后解压压缩包，发现里面有三个文件：Dbgview.exe、dbgview.chm、Eula.txt。<br>Dbgview.exe就是我们要使用的实时显示Log工具。dbgview.chm是自带的文档，有不懂的地方可以查阅该文档。<br>现在可以将DebugView.exe放到任何你喜欢的目录，比如桌面。</p><h2 id="配置DebugView"><a href="#配置DebugView" class="headerlink" title="配置DebugView"></a>配置DebugView</h2><h3 id="配置Capture"><a href="#配置Capture" class="headerlink" title="配置Capture"></a>配置Capture</h3><p>如下图所示，要记得勾选Capture Win32和Capture Global Win32。Capture Global Win32用于网络模式下捕获网络主机的Debug输出的时候。如果需要捕获内核模式的调试输出，记得勾选Capture Kernel Win32。<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8750/28713108000_0384dfb06a_o.png"><br>如果点击Capture Global Win32菜单出现提示：<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8315/28999300555_61681b6880_o.png"><br>重新以管理员的身份启动DebugView。<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8897/28999300535_075a591b02_o.png"></p><h3 id="配置Filter"><a href="#配置Filter" class="headerlink" title="配置Filter"></a>配置Filter</h3><p>如下图所示，打开Filter对话框，<br><img alt="enter description here" data-src="https://c2.staticflickr.com/8/7507/28923046321_72cd949daa_o.png"><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8744/28713274070_2809e64189_o.png"><br>然后在Include中输入要包含的字符串，比如”hankpcxiao”，多个字符串用;分隔，比如”hankpcxiao;xpc”。<br>这样就只会捕获包括过滤字符串hankpcxiao或者xpc的OutputDebugString输出。<br>如果我们在每个OutputDebugString输出前自动加上过滤字符串，那么DebugView就只会输出我们的Log信息了。</p><h3 id="开启捕获"><a href="#开启捕获" class="headerlink" title="开启捕获"></a>开启捕获</h3><p>最后确保开启了捕获，如下图所示：<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8842/28999300405_0355a4405f_o.png"></p><h2 id="如何在程序中输出Log信息？"><a href="#如何在程序中输出Log信息？" class="headerlink" title="如何在程序中输出Log信息？"></a>如何在程序中输出Log信息？</h2><p>默认情况下，DebugView会捕获函数OutputDebugString的输出，但是这个函数的参数是个字符串指针，不太方便。下面我们通过一些列步骤来创建一个方便使用的Log类。</p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>我们习惯使用printf这样的函数来格式化输出信息，因此这次我们也把OutputDebugString包装成可变参数形式的格式化输出函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DebugViewOutput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line"></span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, fm);</span><br><span class="line">    vsprintf_s(szMsg, fm, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line"></span><br><span class="line">    OutputDebugString(szMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让DebugView在VS调试程序时候也能够捕获Log"><a href="#让DebugView在VS调试程序时候也能够捕获Log" class="headerlink" title="让DebugView在VS调试程序时候也能够捕获Log"></a>让DebugView在VS调试程序时候也能够捕获Log</h3><p>网上有不少介绍DebugView使用的文章，但是都忽略了一个事实，那就是默认情况下，使用VS运行程序时候，OutputDebugString的输出是到VS的输出窗口中，DebugView中并没有任何信息。只有单独运行程序的时候，DebugView才能够捕捉到信息。<br>但是这样就不能结合打断点调试和DebugView两个强大的调试方法了。不过，还是有解决办法的。通过一个叫做DBWin通信机制可以实现调试程序时候，把OutputDebugString的输出信息显示到DebugView窗口中。这套机制的本质是通过内存映射文件来跨进程交换数据。<br>具体参考以下的类代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">XpcDebugView</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        XpcDebugView() &#123;&#125;</span><br><span class="line">        ~XpcDebugView() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">XpcDebugViewOutput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">DBWinBuffer</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            DWORD ProcessId;</span><br><span class="line">            <span class="keyword">char</span> Data[<span class="number">4096</span> - <span class="keyword">sizeof</span>(DWORD)];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UnInitialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        HANDLE m_mutex;</span><br><span class="line">        HANDLE m_fileMapping;</span><br><span class="line">        HANDLE m_bufferReadyEvent;</span><br><span class="line">        HANDLE m_dataReadyEvent;</span><br><span class="line">        DBWinBuffer* m_buffer;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> XpcDebugView::Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex = OpenMutex(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWinMutex"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER</span></span><br><span class="line">        m_fileMapping = OpenFileMapping(FILE_MAP_WRITE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_fileMapping == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER_READY</span></span><br><span class="line">        m_bufferReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_DATA_READY</span></span><br><span class="line">        m_dataReadyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT(<span class="string">"DBWIN_DATA_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待DBWIN_BUFFER就绪</span></span><br><span class="line">        WaitForSingleObject(m_bufferReadyEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把DBWIN_BUFFER映射到某个地址</span></span><br><span class="line">        m_buffer = (DBWinBuffer*)MapViewOfFile(m_fileMapping, FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        m_buffer-&gt;ProcessId = GetCurrentProcessId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::UnInitialize()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//释放和关闭DBWIN_BUFFER</span></span><br><span class="line">        FlushViewOfFile(m_buffer, <span class="number">0</span>);</span><br><span class="line">        UnmapViewOfFile(m_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发DBWIN_DATA_READY</span></span><br><span class="line">        SetEvent(m_dataReadyEvent);</span><br><span class="line"></span><br><span class="line">        CloseHandle(m_fileMapping);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理</span></span><br><span class="line">        CloseHandle(m_dataReadyEvent);</span><br><span class="line">        CloseHandle(m_bufferReadyEvent);</span><br><span class="line">        ReleaseMutex(m_mutex);</span><br><span class="line">        CloseHandle(m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::XpcDebugViewOutput(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Initialize() == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line"></span><br><span class="line">        va_list argList;</span><br><span class="line">        va_start(argList, fm);</span><br><span class="line">        vsprintf_s(szMsg, fm, argList);</span><br><span class="line">        va_end(argList);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( push )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( disable: 4996 )</span></span><br><span class="line">        <span class="comment">//向DBWIN_BUFFER写入数据</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_buffer-&gt;Data, szMsg);</span><br><span class="line">        <span class="built_in">printf</span>(szMsg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( pop )</span></span><br><span class="line"></span><br><span class="line">        UnInitialize();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用的时候直接调用类成员函数XpcDebugViewOutput即可。<br>关于这部分的内容更具体的可以参考文章，<a href="http://dooof.lofter.com/tag/DebugView" target="_blank" rel="noopener">如何让OutputDebugString绕过调试器</a></p><h3 id="输出到DebugView的同时输出到Log文件"><a href="#输出到DebugView的同时输出到Log文件" class="headerlink" title="输出到DebugView的同时输出到Log文件"></a>输出到DebugView的同时输出到Log文件</h3><p>我将上面的类改造成下面的样子，在初始化时候创建一个Log文件，在反初始化时候关闭Log文件，每次调用XpcDebugViewOutput使用调用fprintf将格式化字符串输出到文件中。这样就能达到输出Log信息到DebugView中的同时，又能够将Log信息持久化保存了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">XpcDebugView</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        XpcDebugView() &#123; m_pszLogName = <span class="string">"DefaultLog.txt"</span>; Initialize();  &#125;</span><br><span class="line">        XpcDebugView(<span class="keyword">const</span> <span class="keyword">char</span>* pszLogName) &#123; m_pszLogName = pszLogName; Initialize();&#125;</span><br><span class="line">        ~XpcDebugView() &#123; UnInitialize(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">XpcDebugViewOutput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">DBWinBuffer</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            DWORD ProcessId;</span><br><span class="line">            <span class="keyword">char</span> Data[<span class="number">4096</span> - <span class="keyword">sizeof</span>(DWORD)];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UnInitialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">InitializeDBWin</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UnInitializeDBWin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        HANDLE m_mutex;</span><br><span class="line">        HANDLE m_fileMapping;</span><br><span class="line">        HANDLE m_bufferReadyEvent;</span><br><span class="line">        HANDLE m_dataReadyEvent;</span><br><span class="line">        DBWinBuffer* m_buffer;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* m_pszLogName;</span><br><span class="line">        FILE* m_pFileLog;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( push )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( disable: 4996 )</span></span><br><span class="line">    <span class="keyword">bool</span> XpcDebugView::Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pFileLog = fopen(m_pszLogName, <span class="string">"w"</span>);</span><br><span class="line">        <span class="keyword">return</span> m_pFileLog != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::UnInitialize()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pFileLog)</span><br><span class="line">        &#123;</span><br><span class="line">            fclose(m_pFileLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> XpcDebugView::InitializeDBWin()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex = OpenMutex(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWinMutex"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER</span></span><br><span class="line">        m_fileMapping = OpenFileMapping(FILE_MAP_WRITE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_fileMapping == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER_READY</span></span><br><span class="line">        m_bufferReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_DATA_READY</span></span><br><span class="line">        m_dataReadyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT(<span class="string">"DBWIN_DATA_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待DBWIN_BUFFER就绪</span></span><br><span class="line">        WaitForSingleObject(m_bufferReadyEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把DBWIN_BUFFER映射到某个地址</span></span><br><span class="line">        m_buffer = (DBWinBuffer*)MapViewOfFile(m_fileMapping, FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        m_buffer-&gt;ProcessId = GetCurrentProcessId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::UnInitializeDBWin()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//释放和关闭DBWIN_BUFFER</span></span><br><span class="line">        FlushViewOfFile(m_buffer, <span class="number">0</span>);</span><br><span class="line">        UnmapViewOfFile(m_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发DBWIN_DATA_READY</span></span><br><span class="line">        SetEvent(m_dataReadyEvent);</span><br><span class="line"></span><br><span class="line">        CloseHandle(m_fileMapping);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理</span></span><br><span class="line">        CloseHandle(m_dataReadyEvent);</span><br><span class="line">        CloseHandle(m_bufferReadyEvent);</span><br><span class="line">        ReleaseMutex(m_mutex);</span><br><span class="line">        CloseHandle(m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::XpcDebugViewOutput(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (InitializeDBWin() == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line"></span><br><span class="line">        va_list argList;</span><br><span class="line">        va_start(argList, fm);</span><br><span class="line">        vsprintf_s(szMsg, fm, argList);</span><br><span class="line">        va_end(argList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向DBWIN_BUFFER写入数据</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_buffer-&gt;Data, szMsg);</span><br><span class="line">        <span class="keyword">if</span> (m_pFileLog)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(m_pFileLog, szMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UnInitializeDBWin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( pop )</span></span><br></pre></td></tr></table></figure><h3 id="如何使用XpcDebugView类"><a href="#如何使用XpcDebugView类" class="headerlink" title="如何使用XpcDebugView类"></a>如何使用XpcDebugView类</h3><p>最简单的方式是定义一个XpcDebugView的全局变量，比如：<br>XpcDebugView myDebugview(“myLog.txt”);<br>输出Log信息的时候调用函数myDebugview.XpcDebugViewOutput(“%d %d %s\n”, 1, 2, “log”):<br>为了方便使用，可以在XpcDebugViewOutput的输出后面添加换行符，这样每次调用后就会自动换行了。<br>并且加上过滤字符串前缀，这样DebugView就只会捕获我们的输出了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> XpcDebugView::XpcDebugViewOutput(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szOutput[MAX_PATH];</span><br><span class="line"></span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, fm);</span><br><span class="line">    vsprintf_s(szMsg, fm, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(szOutput, <span class="string">"[hankpcxiao] "</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(szOutput, szMsg);</span><br><span class="line">    <span class="built_in">strcat</span>(szOutput, <span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_pFileLog)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(m_pFileLog, szOutput);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向DBWIN_BUFFER写入数据</span></span><br><span class="line">    <span class="keyword">if</span> (InitializeDBWin())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(m_buffer-&gt;Data, szOutput);</span><br><span class="line">        UnInitializeDBWin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先需要下载好DebugView程序，然后配置capture选项，另外是Filter字符串。最后为了保证在VS中调试程序时候，能够将调试信息输出到DebugView，需要使用DBWin通信进制。为此，我封装了一个Log类，在将Log输出到DebugView的同时也将Log输出到日志文件中。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>&#91;1]    <a href="https://community.sophos.com/kb/en-us/119577" target="_blank" rel="noopener">Frequently asked questions on the Microsoft application DebugView.exe</a><br>&#91;2]    <a href="http://dooof.lofter.com/tag/DebugView" target="_blank" rel="noopener">如何让OutputDebugString绕过调试器</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DebugView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebGL介绍</title>
      <link href="/2016/07/09/WebGL%E4%BB%8B%E7%BB%8D/"/>
      <url>/2016/07/09/WebGL%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="WebGL概述"><a href="#WebGL概述" class="headerlink" title="WebGL概述"></a>WebGL概述</h2><p>什么是WebGL？WebGL简单的说就是在Web中渲染OpenGL的技术，也可以理解为把OpenGL的接口移植到浏览器中使用。具体的可以参考<a href="https://zh.wikipedia.org/wiki/WebGL" target="_blank" rel="noopener">WebGL的维基百科</a>。<br>使用WebGL可以通过编写网页代码在浏览器中渲染三维图像，而且不需要任何的插件，比如Adobe Flash Player等。<br>WebGL在最新的浏览器中得到了广泛支持。</p><h2 id="WebGL与HTML5的关系"><a href="#WebGL与HTML5的关系" class="headerlink" title="WebGL与HTML5的关系"></a>WebGL与HTML5的关系</h2><p><a href="https://zh.wikipedia.org/zh-cn/HTML5" target="_blank" rel="noopener">HTML5</a>是最新的HTML（超文本标记语言）的最新修订版本。<br>HTML5中新增了<code>&lt;canvas&gt;</code>标签用于绘图。在HTML5之前，只能使用<code>&lt;img&gt;</code>标签在网页中显示静态图片，如果要显示动画得借助于Adobe Flash Player等第三方插件。在HTML5中，可以在<code>&lt;canvas&gt;</code>标签上绘制二维图像，也可以使用WebGL绘制三维图像。<br>WebGL相对于HTML5的关系就好比是OpenGL库和三维应用程序的关系。WebGL只是提供了底层的渲染和计算的函数。</p><h2 id="WebGL与JavaScript的关系"><a href="#WebGL与JavaScript的关系" class="headerlink" title="WebGL与JavaScript的关系"></a>WebGL与JavaScript的关系</h2><p><a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>是一种浏览器中运行的动态脚本语言。WebGL也需要依靠JavaScript来操作浏览器中的对象。JavaScript与WebGL的关系类似于C或者C++和OpenGL的关系。</p><h2 id="WebGL与OpenGL的关系"><a href="#WebGL与OpenGL的关系" class="headerlink" title="WebGL与OpenGL的关系"></a>WebGL与OpenGL的关系</h2><p>WebGL基于OpenGL ES 2.0，WebGL实现了OpenGL ES 2.0的一个子集。WebGL使用Javascript进行内存管理，使用GLSL ES作为着色器语言。具体的关系可以参考下图：<br><img alt="WebGL与OpenGL" data-src="https://c2.staticflickr.com/8/7581/28115784971_1e25355d87_o.png"></p><h2 id="WebGL程序的结构"><a href="#WebGL程序的结构" class="headerlink" title="WebGL程序的结构"></a>WebGL程序的结构</h2><p>默认情况下，网页程序包括HTML和Javascript脚本语言两部分。但是WebGL程序，还有特殊的GLSL ES着色器语言部分。<br>具体结构如下图所示：<br><img alt="WebGL程序的结构" data-src="https://c1.staticflickr.com/9/8738/27578325223_d5b354ecce_o.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍WebGL的基本概念，以及WebGL和HTML、JavaScript、OpenGL之间的关系等。接下来的文章会介绍具体的WebGL编程知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>&#91;1] WebGL编程指南<br>&#91;2] 维基百科</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> WebGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用MFC创建基于图片的不规则窗口程序</title>
      <link href="/2016/04/23/%E4%BD%BF%E7%94%A8MFC%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8D%E8%A7%84%E5%88%99%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
      <url>/2016/04/23/%E4%BD%BF%E7%94%A8MFC%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8D%E8%A7%84%E5%88%99%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章定制IE浏览器弹窗中的外部窗口就是一个不规则窗口，这篇文章介绍下其是如何实现的。思路是根据这张图片创建一个不规则区域，然后将窗口的区域设置为该不规则区域。</p><h2 id="第一步，在资源文件rc中设置对话框的属性"><a href="#第一步，在资源文件rc中设置对话框的属性" class="headerlink" title="第一步，在资源文件rc中设置对话框的属性"></a><strong>第一步，在资源文件rc中设置对话框的属性</strong></h2><p>Border：None</p><p>Style：Popup</p><h2 id="第二步，导入背景图片到程序资源中"><a href="#第二步，导入背景图片到程序资源中" class="headerlink" title="第二步，导入背景图片到程序资源中"></a><strong>第二步，导入背景图片到程序资源中</strong></h2><p>最好是导入位图，虽然也可以导入其它格式的图片。假设导入位图ID为IDB_BITMAP_BACK。</p><h2 id="第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域"><a href="#第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域" class="headerlink" title="第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域"></a><strong>第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OnInitDialog()中</span><br><span class="line">CRgn wndRgn;</span><br><span class="line"></span><br><span class="line">m_bitmapBack.LoadBitmap(IDB_BITMAP_BACK);</span><br><span class="line">CreateRgn(m_bitmapBack, RGB(255, 255, 255), wndRgn);</span><br><span class="line">SetWindowRgn(wndRgn, TRUE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据图片创建区域的函数</span><br><span class="line">void CClientBrowserDlg::CreateRgn(CBitmap cBitmap, COLORREF dwColorKey, CRgn wndRgn)  </span><br><span class="line">&#123;  </span><br><span class="line">    CDC *pDC &#x3D; this-&gt;GetDC();  </span><br><span class="line">    CDC memDC;  </span><br><span class="line">    &#x2F;&#x2F;创建与传入DC兼容的临时DC  </span><br><span class="line">    memDC.CreateCompatibleDC(pDC);  </span><br><span class="line"></span><br><span class="line">    CBitmap *pOldMemBmp&#x3D;NULL;  </span><br><span class="line">    &#x2F;&#x2F;将位图选入临时DC  </span><br><span class="line">    pOldMemBmp &#x3D; memDC.SelectObject(cBitmap);  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建总的窗体区域，初始region为0  </span><br><span class="line">    wndRgn.CreateRectRgn(0,0,0,0);  </span><br><span class="line"></span><br><span class="line">    BITMAP bit;     </span><br><span class="line">    cBitmap.GetBitmap (bit);&#x2F;&#x2F;取得位图参数，这里要用到位图的长和宽       </span><br><span class="line"></span><br><span class="line">    int y;  </span><br><span class="line">    for(y&#x3D;0; y &lt;&#x3D; bit.bmHeight; y++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CRgn rgnTemp;  </span><br><span class="line">        int iX &#x3D; 0;  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            &#x2F;&#x2F;跳过透明色找到下一个非透明色的点.  </span><br><span class="line">            while (iX &lt;&#x3D; bit.bmWidth   memDC.GetPixel(iX, y) &#x3D;&#x3D; dwColorKey)  </span><br><span class="line">                iX++;  </span><br><span class="line">            &#x2F;&#x2F;记住这个起始点  </span><br><span class="line">            int iLeftX &#x3D; iX;  </span><br><span class="line">            &#x2F;&#x2F;寻找下个透明色的点  </span><br><span class="line">            while (iX &lt;&#x3D; bit.bmWidth   memDC.GetPixel(iX, y) !&#x3D; dwColorKey)  </span><br><span class="line">                ++iX;  </span><br><span class="line">            &#x2F;&#x2F;创建一个包含起点与重点间高为1像素的临时“region”  </span><br><span class="line">            rgnTemp.CreateRectRgn(iLeftX, y, iX, y+1);  </span><br><span class="line">            &#x2F;&#x2F;合并到主&quot;region&quot;.  </span><br><span class="line">            wndRgn.CombineRgn(wndRgn, rgnTemp, RGN_OR);  </span><br><span class="line">            &#x2F;&#x2F;删除临时&quot;region&quot;,否则下次创建时和出错  </span><br><span class="line">            rgnTemp.DeleteObject();  </span><br><span class="line">        &#125; while(iX &lt; bit.bmWidth );  </span><br><span class="line">        iX &#x3D; 0;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    if(pOldMemBmp)  </span><br><span class="line">        memDC.SelectObject(pOldMemBmp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四步，在OnPaint-绘制窗口背景图片"><a href="#第四步，在OnPaint-绘制窗口背景图片" class="headerlink" title="第四步，在OnPaint()绘制窗口背景图片"></a><strong>第四步，在OnPaint()绘制窗口背景图片</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void CClientBrowserDlg::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">    if (IsIconic())</span><br><span class="line">    &#123;</span><br><span class="line">        CPaintDC dc(this); &#x2F;&#x2F; device context for painting</span><br><span class="line"></span><br><span class="line">        SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Center icon in client rectangle</span><br><span class="line">        int cxIcon &#x3D; GetSystemMetrics(SM_CXICON);</span><br><span class="line">        int cyIcon &#x3D; GetSystemMetrics(SM_CYICON);</span><br><span class="line">        CRect rect;</span><br><span class="line">        GetClientRect(rect);</span><br><span class="line">        int x &#x3D; (rect.Width() - cxIcon + 1) &#x2F; 2;</span><br><span class="line">        int y &#x3D; (rect.Height() - cyIcon + 1) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Draw the icon</span><br><span class="line">        dc.DrawIcon(x, y, m_hIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;选入DC  </span><br><span class="line">        CClientDC cdc(this);</span><br><span class="line">        CDC comdc;  </span><br><span class="line">        comdc.CreateCompatibleDC(cdc);  </span><br><span class="line">        comdc.SelectObject(m_bitmapBack);  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;生成BITMAP  </span><br><span class="line">        BITMAP bit;  </span><br><span class="line">        m_bitmapBack.GetBitmap(bit);  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;客户区域  </span><br><span class="line">        CRect rect;  </span><br><span class="line">        GetClientRect(rect);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用客户区的DC绘制所生成的BITMAP，并适应为窗口大小  </span><br><span class="line">        cdc.StretchBlt(0,0,rect.Width(),rect.Height(),comdc,0,0,bit.bmWidth,bit.bmHeight,SRCCOPY);</span><br><span class="line"></span><br><span class="line">        CDialog::OnPaint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五步，点击客户区移动窗口"><a href="#第五步，点击客户区移动窗口" class="headerlink" title="第五步，点击客户区移动窗口"></a><strong>第五步，点击客户区移动窗口</strong></h2><p>这一点还是有意义的，比如上一篇定制IE浏览器窗口的文章，其外部窗口就是使用这里介绍的不规则窗体。不规则窗体由于是无边框的，因此无法点击边框移动窗口了。因此，设置点击客户端移动是有意义的。而<strong>且窗口的内部区域已经被浏览器控件占据了，只有外部的边界区域可以点击到，因此这样刚好模拟出了点击正常窗口边框的效果。</strong></p><p>设置客户区可以点击的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CClientBrowserDlg::OnNcHitTest(CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default</span><br><span class="line">    &#x2F;&#x2F; 取得鼠标所在的窗口区域</span><br><span class="line">    UINT nHitTest &#x3D; CDialog::OnNcHitTest(point);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果鼠标在窗口客户区，则返回标题条代号给Windows</span><br><span class="line">    &#x2F;&#x2F; 使Windows按鼠标在标题条上类进行处理，即可单击移动窗口</span><br><span class="line">    return (nHitTest &#x3D;&#x3D; HTCLIENT) ? HTCAPTION : nHitTest;</span><br><span class="line">    &#x2F;&#x2F;return CDialog::OnNcHitTest(point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CWebBrowser2定制IE浏览器窗口</title>
      <link href="/2016/04/21/%E4%BD%BF%E7%94%A8CWebBrowser2%E5%AE%9A%E5%88%B6IE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2016/04/21/%E4%BD%BF%E7%94%A8CWebBrowser2%E5%AE%9A%E5%88%B6IE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>在客户端程序中嵌入浏览器，有两种方式，一种是使用微软的IE控件，一种是使用CEF。这里介绍的是使用CWebBrowser2类（在MFC程序中插入IE的Active控件生成），定制内嵌浏览器窗口的一些经验。</p><p>本文的经验积累于实现逆战退出游戏时候的广告弹窗的过程中，下面Show一下这个自带萌妹子的弹窗吧。</p><p><img alt data-src="https://farm2.staticflickr.com/1575/25953542404_086b3470a8_o.png"></p><p>这是一个无边框的Windows对话框程序，并且是一个基于背景图片的不规则弹窗窗口；内部嵌入了一个浏览器控件窗口，这个漂亮的妹子就是浏览器控件打开的网页显示出来的。对这个妹子有兴趣的，可以去玩一把逆战，退出客户端的时候就会出来这个弹窗了。</p><p>下面介绍一些关于实现该弹窗浏览器的Tips。</p><h2 id="一、如何获得CWebBrowser2"><a href="#一、如何获得CWebBrowser2" class="headerlink" title="一、如何获得CWebBrowser2"></a>一、如何获得CWebBrowser2</h2><p>方法1：网络搜索下载，比如我以前的一篇博文里面有下载链接：vc内嵌浏览器。</p><p>方法2：在MFC程序中插入IE对应的Activex控件，工程中就会生成这个类。</p><p>为了定制浏览器窗口，我继承了该类，自定义了浏览器窗口类CYXBrwser。</p><h2 id="二、让浏览器窗口适应对话框窗口大小"><a href="#二、让浏览器窗口适应对话框窗口大小" class="headerlink" title="二、让浏览器窗口适应对话框窗口大小"></a>二、让浏览器窗口适应对话框窗口大小</h2><p>在对话框类的OnInitDialog()函数中，添加如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m_pBrowser = new CYXBrowser(); </span><br><span class="line">RECT rect; </span><br><span class="line">GetClientRect(rect);</span><br><span class="line">rect.left += 8;</span><br><span class="line">rect.right -= 8;</span><br><span class="line">rect.top += 8;</span><br><span class="line">rect.bottom -= 1;</span><br><span class="line">m_pBrowser-&gt;Create(TEXT("NZBrowser"), WS_CHILD | WS_VISIBLE, rect, this, MY_IEBROWSER_ID);</span><br></pre></td></tr></table></figure><p>注意，rect的大小需要调节来获得需要的效果。</p><h2 id="三、屏蔽右键"><a href="#三、屏蔽右键" class="headerlink" title="三、屏蔽右键"></a>三、屏蔽右键</h2><p>有种比较的方法是在PreTranslateMessage中过滤WM_RBUTTONDOWN消息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏蔽右键</span></span><br><span class="line">BOOL CYXBrowser::PreTranslateMessage(MSG* pMsg) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add your specialized code here and/or call the base class</span></span><br><span class="line">    <span class="keyword">if</span>(WM_RBUTTONDOWN == pMsg-&gt;message)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//AfxMessageBox(_T("Right Menu!"));</span></span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    return CWnd::PreTranslateMessage(pMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、隐藏网页的滚动条"><a href="#四、隐藏网页的滚动条" class="headerlink" title="四、隐藏网页的滚动条"></a>四、隐藏网页的滚动条</h2><p>这是最难处理的一个地方。不仅仅需要修改程序，而且需要web端的配合。</p><p>第一步：添加DocumentComplete事件响应。在C<em>*</em>Dlg的cpp中添加如下宏：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">BEGIN_EVENTSINK_MAP</span><span class="params">(CClientBrowserDlg, CDialog)</span></span></span><br><span class="line">    ON_EVENT(CClientBrowserDlg, MY_IEBROWSER_ID, DISPID_DOCUMENTCOMPLETE, DocumentComplete, VTS_DISPATCH VTS_PVARIANT)</span><br><span class="line"><span class="function"><span class="title">END_EVENTSINK_MAP</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>注意，CClientBrowserDlg是响应函数所在的类，MY_IEBROWSER_ID是二中指定的浏览器窗口ID。DocumentComplete是CClientBrowserDlg中的响应该事件的成员函数。</p><p>第二步：实现该函数，直接贴代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void CClientBrowserDlg::DocumentComplete(LPDISPATCH pDisp, VARIANT* URL)</span><br><span class="line">&#123;</span><br><span class="line">    UNUSED_ALWAYS(pDisp);</span><br><span class="line">    ASSERT(V_VT(URL) == VT_BSTR);</span><br><span class="line"></span><br><span class="line">    CString str(V_BSTR(URL));</span><br><span class="line">    m_pBrowser-&gt;OnDocumentComplete(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnDocumentComplete(LPCTSTR lpszURL)</span><br><span class="line">&#123;</span><br><span class="line">    m_bDocumentComplete = true;</span><br><span class="line">    HideScrollBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::HideScrollBar()</span><br><span class="line">&#123;</span><br><span class="line">    HRESULT hr;</span><br><span class="line">    IDispatch *pDisp = GetDocument();</span><br><span class="line">    IHTMLDocument2 *pDocument = NULL;</span><br><span class="line">    IHTMLElement*   pEl;  </span><br><span class="line">    IHTMLBodyElement   *pBodyEl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDisp)</span><br><span class="line">    &#123;</span><br><span class="line">        hr = pDisp-&gt;QueryInterface(IID_IHTMLDocument2, (void**)pDocument);</span><br><span class="line">        <span class="keyword">if</span> (!SUCCEEDED(hr))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pDocument  SUCCEEDED(pDocument-&gt;get_body(pEl)))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(pEl  SUCCEEDED(pEl-&gt;QueryInterface(IID_IHTMLBodyElement, (void**)pBodyEl)))  </span><br><span class="line">        &#123;  </span><br><span class="line">            pBodyEl-&gt;put_scroll(L"no");//去滚动条</span><br><span class="line">        &#125;  </span><br><span class="line">        IHTMLStyle   *phtmlStyle;  </span><br><span class="line">        pEl-&gt;get_style(phtmlStyle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(phtmlStyle  != NULL)  </span><br><span class="line">        &#123;  </span><br><span class="line">            phtmlStyle-&gt;put_overflow(L"hidden");</span><br><span class="line">            <span class="comment">//需要设置网页源码DOCTYPE为&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span></span><br><span class="line">            <span class="comment">//去除边框才有效</span></span><br><span class="line">            phtmlStyle-&gt;put_border(L"none");//   去除边框</span><br><span class="line"></span><br><span class="line">            phtmlStyle-&gt;Release();  </span><br><span class="line">            pEl-&gt;Release();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数是HideScrollBar()。</p><p>第三步：在浏览器内嵌网页的最前面添加，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span></span><br></pre></td></tr></table></figure><p>注意，第三步是不可缺少的。</p><h2 id="五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框"><a href="#五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框" class="headerlink" title="五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框**"></a>五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框**</h2><p>在CClientBrowserDlg::OnInitDialog()中添加如下代码，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*屏蔽掉"服务器正在运行中"要选择"切换到..."或"重试"的对话框*/</span></span><br><span class="line">AfxOleGetMessageFilter()-&gt;EnableBusyDialog(FALSE);</span><br><span class="line">AfxOleGetMessageFilter()-&gt;SetBusyReply(SERVERCALL_RETRYLATER);</span><br><span class="line">AfxOleGetMessageFilter()-&gt;EnableNotRespondingDialog(TRUE);</span><br><span class="line">AfxOleGetMessageFilter()-&gt;SetMessagePendingDelay(-1);</span><br></pre></td></tr></table></figure><h2 id="六、点击网页打开系统默认浏览器"><a href="#六、点击网页打开系统默认浏览器" class="headerlink" title="六、点击网页打开系统默认浏览器"></a>六、点击网页打开系统默认浏览器</h2><p>第一步：绑定NEWWINDOW2事件。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ON_EVENT</span><span class="params">(CClientBrowserDlg, MY_IEBROWSER_ID, DISPID_NEWWINDOW2, OnNewWindow2, VTS_PDISPATCH VTS_PBOOL)</span></span></span><br></pre></td></tr></table></figure><p>第二步：设置该OnNewWindow2的*bCancel为true，并且调用ShellExecute打开网页。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void CClientBrowserDlg::OnNewWindow2(LPDISPATCH* ppDisp, BOOL* bCancel)</span><br><span class="line">&#123;</span><br><span class="line">    m_pBrowser-&gt;OnNewWindow2(ppDisp, bCancel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnNewWindow2(LPDISPATCH* ppDisp, BOOL* bCancel)</span><br><span class="line">&#123;</span><br><span class="line">    *bCancel = TRUE;//禁止弹出新窗口（因为会使用IE弹窗）</span><br><span class="line"></span><br><span class="line">    HRESULT hr;</span><br><span class="line">    IDispatch *pDisp = GetDocument();</span><br><span class="line">    IHTMLDocument2 *pHTMLDocument2 = NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDisp)</span><br><span class="line">    &#123;</span><br><span class="line">        hr = pDisp-&gt;QueryInterface(IID_IHTMLDocument2, (void**)pHTMLDocument2);</span><br><span class="line">        <span class="keyword">if</span> (!SUCCEEDED(hr))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHTMLDocument2 != NULL)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CComPtr&lt;IHTMLElement&gt; pIHTMLElement;  </span><br><span class="line">        pHTMLDocument2-&gt;get_activeElement(pIHTMLElement);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pIHTMLElement != NULL)  </span><br><span class="line">        &#123;  </span><br><span class="line">            variant_t url;  </span><br><span class="line">            hr = pIHTMLElement-&gt;getAttribute(L"href", 0, url);  </span><br><span class="line">            <span class="keyword">if</span> (SUCCEEDED(hr))  </span><br><span class="line">            &#123;  </span><br><span class="line">                CString strURL(V_BSTR(url));</span><br><span class="line">                <span class="comment">//打开默认浏览器</span></span><br><span class="line">                ShellExecute(m_hWndOwner, NULL, strURL, NULL, NULL, SW_NORMAL);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理了六，五也就不需要了，因为点击网页不会再弹出IE浏览器了。</p><h2 id="七、为网页元素的添加事件处理：比如web按钮的点击等"><a href="#七、为网页元素的添加事件处理：比如web按钮的点击等" class="headerlink" title="七、为网页元素的添加事件处理：比如web按钮的点击等"></a>七、为网页元素的添加事件处理：比如web按钮的点击等</h2><p>第一步：继承CCmdTarget新建类CHtmlEventHandle，代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pragma</span> once</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#import</span> &lt;mshtml.tlb&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CHtmlEventHandle command target</span></span><br><span class="line">class CYXBrowser;</span><br><span class="line"></span><br><span class="line">class CHtmlEventHandle : public CCmdTarget</span><br><span class="line">&#123;</span><br><span class="line">    DECLARE_DYNAMIC(CHtmlEventHandle)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    CHtmlEventHandle();</span><br><span class="line">    virtual ~CHtmlEventHandle();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void SetWnd(CWnd* pWnd) &#123; m_pWnd = pWnd;&#125;</span><br><span class="line">    void SetWebBrowser(CYXBrowser* pWebBroswer) &#123; m_pWebBrowser = pWebBroswer; &#125;</span><br><span class="line">    <span class="comment">// 消息处理函数</span></span><br><span class="line">    void OnClick(MSHTML::IHTMLEventObjPtr pEvtObj);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CWnd* m_pWnd;</span><br><span class="line">    CYXBrowser* m_pWebBrowser;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    DECLARE_MESSAGE_MAP()</span><br><span class="line">    DECLARE_DISPATCH_MAP()</span><br><span class="line">    DECLARE_INTERFACE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HtmlEventHandle.cpp : implementation file</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"ClientBrowser.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"HtmlEventHandle.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"mshtmdid.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"MsHTML.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"YXBrowser.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHtmlEventHandle</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">IMPLEMENT_DYNAMIC</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line"></span><br><span class="line">CHtmlEventHandle::CHtmlEventHandle()</span><br><span class="line">&#123;</span><br><span class="line">    EnableAutomation();  // 重要：激活 IDispatch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHtmlEventHandle::~CHtmlEventHandle()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">BEGIN_MESSAGE_MAP</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line"><span class="function"><span class="title">END_MESSAGE_MAP</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">BEGIN_DISPATCH_MAP</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line">    DISP_FUNCTION_ID(CHtmlEventHandle, <span class="string">"HTMLELEMENTEVENTS2_ONCLICK"</span>,</span><br><span class="line">    DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick,</span><br><span class="line">    VT_EMPTY, VTS_DISPATCH)</span><br><span class="line"><span class="function"><span class="title">END_DISPATCH_MAP</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">BEGIN_INTERFACE_MAP</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line">    INTERFACE_PART(CHtmlEventHandle,</span><br><span class="line">    DIID_HTMLButtonElementEvents2, Dispatch)</span><br><span class="line"><span class="function"><span class="title">END_INTERFACE_MAP</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHtmlEventHandle message handlers</span></span><br><span class="line"></span><br><span class="line">void CHtmlEventHandle::OnClick(MSHTML::IHTMLEventObjPtr pEvtObj)</span><br><span class="line">&#123;</span><br><span class="line">    MSHTML::IHTMLElementPtr pElement =</span><br><span class="line">        pEvtObj-&gt;GetsrcElement(); // 事件发生的对象元素</span><br><span class="line">    while(pElement) <span class="comment">// 逐层向上检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        _bstr_t strId;</span><br><span class="line">        pElement-&gt;get_id(strId.GetBSTR());</span><br><span class="line">        <span class="keyword">if</span>(_bstr_t(HTML_CLOSE_BUTTON) == strId)<span class="comment">//响应关闭按钮点击</span></span><br><span class="line">        &#123;</span><br><span class="line">            PostQuitMessage(0);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_bstr_t(HTML_SET_BUTTON) == strId)<span class="comment">//30天不弹出设置</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pElement = pElement-&gt;GetparentElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意那几个宏。宏的具体解释我没有去深究，仿照DISP_FUNCTION_ID可以为点击外的其它事件添加处理。</span></span><br></pre></td></tr></table></figure><p>第二步：在CYXBrowser中注册这个web事件处理类。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加成员</span></span><br><span class="line">private:</span><br><span class="line">    void InstallEventHandler();</span><br><span class="line">    void UninstallEventHandler();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CHtmlEventHandle *m_pEventHandler;</span><br><span class="line">    DWORD m_dwDocCookie;    // 用于卸载事件响应函数</span><br><span class="line">    IDispatch *m_pDispDoc;  // 用于卸载事件响应函数</span><br><span class="line">    bool m_bDocumentComplete;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相应的函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装响应函数。省略了一些失败判断以突出主要步骤</span></span><br><span class="line">void CYXBrowser::InstallEventHandler()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_dwDocCookie)   <span class="comment">// 已安装，卸载先。最后一次安装的才有效</span></span><br><span class="line">        UninstallEventHandler();</span><br><span class="line"></span><br><span class="line">    m_pDispDoc = GetDocument();</span><br><span class="line">    IConnectionPointContainerPtr pCPC = m_pDispDoc;</span><br><span class="line">    IConnectionPointPtr pCP;</span><br><span class="line">    <span class="comment">// 找到安装点</span></span><br><span class="line">    pCPC-&gt;FindConnectionPoint(DIID_HTMLDocumentEvents2, pCP);</span><br><span class="line">    IUnknown* pUnk = m_pEventHandler-&gt;GetInterface(IID_IUnknown);</span><br><span class="line">    <span class="comment">//安装</span></span><br><span class="line">    HRESULT hr = pCP-&gt;Advise(pUnk, m_dwDocCookie);</span><br><span class="line">    <span class="keyword">if</span>(!SUCCEEDED(hr))  <span class="comment">// 安装失败</span></span><br><span class="line">        m_dwDocCookie = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载响应函数。省略了一些失败判断以突出主要步骤</span></span><br><span class="line">void CYXBrowser::UninstallEventHandler()</span><br><span class="line">&#123;</span><br><span class="line">    if(0 == m_dwDocCookie) return;</span><br><span class="line"></span><br><span class="line">    IConnectionPointContainerPtr pCPC = m_pDispDoc;</span><br><span class="line">    IConnectionPointPtr pCP;</span><br><span class="line">    pCPC-&gt;FindConnectionPoint(DIID_HTMLDocumentEvents2, pCP);</span><br><span class="line">    HRESULT hr = pCP-&gt;Unadvise(m_dwDocCookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在OnDocumentComplete中安装事件处理</span></span><br><span class="line">CYXBrowser::CYXBrowser()</span><br><span class="line">&#123;</span><br><span class="line">    m_pEventHandler = new CHtmlEventHandle;</span><br><span class="line">    m_pEventHandler-&gt;SetWnd(m_pParent);</span><br><span class="line">    m_pEventHandler-&gt;SetWebBrowser(this);</span><br><span class="line">    m_dwDocCookie = 0;    // 用于卸载事件响应函数</span><br><span class="line">    m_pDispDoc = NULL;  // 用于卸载事件响应函数</span><br><span class="line">    m_bDocumentComplete = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnDocumentComplete(LPCTSTR lpszURL)</span><br><span class="line">&#123;</span><br><span class="line">    m_bDocumentComplete = true;</span><br><span class="line">    HideScrollBar();</span><br><span class="line">    InstallEventHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在OnBeforeNavigate2和OnDestroy中卸载处理</span></span><br><span class="line"><span class="comment">// 在 BeforeNavigate2 和 Destroy 事件中卸载响应函数</span></span><br><span class="line">void CYXBrowser::OnBeforeNavigate2(LPCTSTR lpszURL, DWORD nFlags,</span><br><span class="line">                                   LPCTSTR lpszTargetFrameName, CByteArray baPostedData,</span><br><span class="line">                                   LPCTSTR lpszHeaders, BOOL* pbCancel)</span><br><span class="line">&#123;</span><br><span class="line">    UninstallEventHandler();</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">    UninstallEventHandler();</span><br><span class="line">    CWebBrowser2::OnDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就可以在void CHtmlEventHandle::OnClick(MSHTML::IHTMLEventObjPtr pEvtObj)函数内捕获网页按钮之类的点击了。处理代码的思路是从当前元素开始，不断往上查找父元素，直到匹配的元素ID为止。</p><h2 id="八、判断url是否有效，如果无效则打开资源url，防止Web页面为空"><a href="#八、判断url是否有效，如果无效则打开资源url，防止Web页面为空" class="headerlink" title="八、判断url是否有效，如果无效则打开资源url，防止Web页面为空"></a>八、判断url是否有效，如果无效则打开资源url，防止Web页面为空</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用该函数判断url是否能打开</span></span><br><span class="line">bool CYXBrowser::IsUrlAvailable(CString strUrl)</span><br><span class="line">&#123;</span><br><span class="line">    CInternetSession* session = new CInternetSession(); </span><br><span class="line">    CInternetFile* file = NULL; </span><br><span class="line">    bool bAvailable = true;</span><br><span class="line"></span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        file = (CInternetFile*)session-&gt;OpenURL(strUrl); </span><br><span class="line">    &#125;</span><br><span class="line">    catch (CInternetException*)</span><br><span class="line">    &#123;</span><br><span class="line">        bAvailable = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete session;</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">    &#123;</span><br><span class="line">        bAvailable = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bAvailable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在对话框初始化时候，判断外网url是否能打开，如果不能则加载资源内的url</span></span><br><span class="line"><span class="keyword">if</span> (m_pBrowser-&gt;IsUrlAvailable(theApp.m_strUrl))</span><br><span class="line">&#123;</span><br><span class="line">    m_pBrowser-&gt;Navigate2(theApp.m_strUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szModule[MAX_PATH];</span><br><span class="line">    GetModuleFileName(theApp.m_hInstance, szModule, MAX_PATH);</span><br><span class="line">    theApp.m_strUrl.Format(_T("res://%s/%s"), szModule, theApp.m_strLocalUrl);</span><br><span class="line">    m_pBrowser-&gt;Navigate2(theApp.m_strUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意资源url的格式是res://模块名/网页名，因此需要在该程序中导入自定义的资源，并且将其命名为theApp.m_strLocalUrl代表的字符串值，比如”NZ.HTML”。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CWebBrowser2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维表面上基于笔画的纹理交互式合成</title>
      <link href="/2016/03/17/%E4%B8%89%E7%BB%B4%E8%A1%A8%E9%9D%A2%E4%B8%8A%E5%9F%BA%E4%BA%8E%E7%AC%94%E7%94%BB%E7%9A%84%E7%BA%B9%E7%90%86%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%90%88%E6%88%90/"/>
      <url>/2016/03/17/%E4%B8%89%E7%BB%B4%E8%A1%A8%E9%9D%A2%E4%B8%8A%E5%9F%BA%E4%BA%8E%E7%AC%94%E7%94%BB%E7%9A%84%E7%BA%B9%E7%90%86%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%90%88%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>这是我的毕业论文题目，两年前的东西了，来出来纪念下吧。后面附演讲pdf。</p><p>这讲的是在一个三维模型上手绘纹理的故事，纹理是用户选择的样本纹理。因此，实际上我的毕业论文就是做了一个上纹理的工具。用户选择不同的模型，同时选择不同的样本纹理（符合马尔科夫随机场的样本纹理），就可以用鼠标在模型上刷三维纹理了。</p><p>看起来挺好玩的，实际上整个系统的实现过程非常繁杂。这个系统主要用了两个算法，一个是扩展指数映射计算笔画的局部参数化，另外一个是根据样本纹理动态合成新的大纹理（要贴到笔画区域），这个用了并行可控制纹理合成算法，在约束条件下做了特殊实现。由于扩展指数映射用的是他人的实现代码，严重影响了整个系统的速度，也影响了我后面做实验的效果，非常恶心，所以不到无奈时候，千万不要用所谓的牛人的资源。</p><p>系统流程：</p><p><img alt data-src="https://c2.staticflickr.com/8/7736/27418072966_11479198e3_o.png"></p><p>最终效果：</p><p><a href="https://c2.staticflickr.com/8/7178/27380808391_b2dabb9474_o.png" target="_blank" rel="noopener"><img alt data-src="https://c2.staticflickr.com/8/7178/27380808391_b2dabb9474_o.png"></a></p><p><a href="https://c2.staticflickr.com/8/7678/26845040783_b243d6bff6_o.png" target="_blank" rel="noopener"><img alt data-src="https://c2.staticflickr.com/8/7678/26845040783_b243d6bff6_o.png"></a></p><p>PDF下载：<a href="https://pan.baidu.com/s/1dDTrBIL" target="_blank" rel="noopener">三维表面上基于笔画的纹理交互式合成</a></p><p>预览如下：</p><iframe src="https://onedrive.live.com/embed?cid=4330CD349D9ADD44&amp;resid=4330CD349D9ADD44%21366&amp;authkey=AIXNiZJrZHuLNX8&amp;em=2&amp;wdStartOn=1" width="800" height="700" frameborder="0" allowfullscreen="allowfullscreen"></iframe>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
            <tag> 三维模型处理 </tag>
            
            <tag> 纹理合成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++编写的程序启动过程</title>
      <link href="/2016/01/16/C%20C++%E7%BC%96%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2016/01/16/C%20C++%E7%BC%96%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>记得以前学汇编和PE文件的时候知道，系统不会直接调用我们编写的main，而是调用指定的入口地址。实际上这个入口地址，是在链接时候指定的，MS C/C++中使用链接命令/entry:function可以修改默认设置。</p><p>那么，默认情况下，我们使用VC编写的应用程序使用的是什么入口函数了？</p><div class="table-container"><table><thead><tr><th>函数</th><th>默认</th></tr></thead><tbody><tr><td><strong>mainCRTStartup</strong> (or <strong>wmainCRTStartup</strong>)</td><td>An application using /SUBSYSTEM:<strong>CONSOLE</strong>; calls <strong>main</strong> (or <strong>wmain</strong>)</td></tr><tr><td><strong>WinMainCRTStartup</strong> (or <strong>wWinMainCRTStartup</strong>)</td><td>An application using /SUBSYSTEM:<strong>WINDOWS</strong>; calls <strong>WinMain</strong> (or <strong>wWinMain</strong>), which must be defined with <strong>__stdcall</strong></td></tr></tbody></table></div><p>注意，区分入口函数和主函数（main，WinMain）。</p><p>默认情况下，控制台程序使用<strong>mainCRTStartup</strong>作为入口函数，窗口程序使用<strong>WinMainCRTStartup</strong>作为入口函数。同时，这两个函数都有对应的Unicode版本（前缀加w)。</p><p>现在要考虑的是，这些启动函数都做了什么事情？</p><p>在crtexe.c文件中可以找到这几个启动函数的定义，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _WINMAIN_</span><br><span class="line"></span><br><span class="line">#ifdef WPRFLAG</span><br><span class="line">int wWinMainCRTStartup(</span><br><span class="line">#else  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line">int WinMainCRTStartup(</span><br><span class="line">#endif  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line"></span><br><span class="line">#else  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line"></span><br><span class="line">#ifdef WPRFLAG</span><br><span class="line">int wmainCRTStartup(</span><br><span class="line">#else  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line">int mainCRTStartup(</span><br><span class="line">#endif  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line">        void</span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * The &#x2F;GS security cookie must be initialized before any exception</span><br><span class="line">         * handling targetting the current image is registered.  No function</span><br><span class="line">         * using exception handling can be called in the current image until</span><br><span class="line">         * after __security_init_cookie has been called.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        __security_init_cookie();</span><br><span class="line"></span><br><span class="line">        return __tmainCRTStartup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，实际上是根据平台（Windows或者Console），多字节还是Unicode，生成不同的默认入口函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">__declspec(noinline)</span><br><span class="line">int</span><br><span class="line">__tmainCRTStartup(</span><br><span class="line">         void</span><br><span class="line">         )</span><br><span class="line">&#123;</span><br><span class="line">        int initret;</span><br><span class="line">        int mainret&#x3D;0;</span><br><span class="line">        int managedapp;</span><br><span class="line">#ifdef _WINMAIN_</span><br><span class="line">        _TUCHAR *lpszCommandLine;</span><br><span class="line">        STARTUPINFO StartupInfo;</span><br><span class="line"></span><br><span class="line">        __try &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">            Note: MSDN specifically notes that GetStartupInfo returns no error, and throws unspecified SEH if it fails, so</span><br><span class="line">            the very general exception handler below is appropriate</span><br><span class="line">            *&#x2F;</span><br><span class="line">            GetStartupInfo( amp;StartupInfo );</span><br><span class="line">        &#125; __except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">            return 255;</span><br><span class="line">        &#125;</span><br><span class="line">#endif  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Determine if this is a managed application</span><br><span class="line">         *&#x2F;</span><br><span class="line">        managedapp &#x3D; check_managed_app();</span><br><span class="line"></span><br><span class="line">        if ( !_heap_init(1) )               &#x2F;* initialize heap *&#x2F;</span><br><span class="line">            fast_error_exit(_RT_HEAPINIT);  &#x2F;* write message and die *&#x2F;</span><br><span class="line"></span><br><span class="line">        if( !_mtinit() )                    &#x2F;* initialize multi-thread *&#x2F;</span><br><span class="line">            fast_error_exit(_RT_THREAD);    &#x2F;* write message and die *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Enable buffer count checking if linking against static lib *&#x2F;</span><br><span class="line">        _CrtSetCheckCount(TRUE);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Initialize the Runtime Checks stuff</span><br><span class="line">         *&#x2F;</span><br><span class="line">#ifdef _RTC</span><br><span class="line">        _RTC_Initialize();</span><br><span class="line">#endif  &#x2F;* _RTC *&#x2F;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Guard the remainder of the initialization code and the call</span><br><span class="line">         * to user&#39;s main, or WinMain, function in a __try&#x2F;__except</span><br><span class="line">         * statement.</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        __try &#123;</span><br><span class="line"></span><br><span class="line">            if ( _ioinit() lt; 0 )            &#x2F;* initialize lowio *&#x2F;</span><br><span class="line">                _amsg_exit(_RT_LOWIOINIT);</span><br><span class="line"></span><br><span class="line">            &#x2F;* get wide cmd line info *&#x2F;</span><br><span class="line">            _tcmdln &#x3D; (_TSCHAR *)GetCommandLineT();</span><br><span class="line"></span><br><span class="line">            &#x2F;* get wide environ info *&#x2F;</span><br><span class="line">            _tenvptr &#x3D; (_TSCHAR *)GetEnvironmentStringsT();</span><br><span class="line"></span><br><span class="line">            if ( _tsetargv() lt; 0 )</span><br><span class="line">                _amsg_exit(_RT_SPACEARG);</span><br><span class="line">            if ( _tsetenvp() lt; 0 )</span><br><span class="line">                _amsg_exit(_RT_SPACEENV);</span><br><span class="line"></span><br><span class="line">            initret &#x3D; _cinit(TRUE);                  &#x2F;* do C data initialize *&#x2F;</span><br><span class="line">            if (initret !&#x3D; 0)</span><br><span class="line">                _amsg_exit(initret);</span><br><span class="line"></span><br><span class="line">#ifdef _WINMAIN_</span><br><span class="line"></span><br><span class="line">            lpszCommandLine &#x3D; _twincmdln();</span><br><span class="line">            mainret &#x3D; _tWinMain( (HINSTANCE)amp;__ImageBase,</span><br><span class="line">                                 NULL,</span><br><span class="line">                                 lpszCommandLine,</span><br><span class="line">                                 StartupInfo.dwFlags amp; STARTF_USESHOWWINDOW</span><br><span class="line">                                      ? StartupInfo.wShowWindow</span><br><span class="line">                                      : SW_SHOWDEFAULT</span><br><span class="line">                                );</span><br><span class="line">#else  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line">            _tinitenv &#x3D; _tenviron;</span><br><span class="line">            mainret &#x3D; _tmain(__argc, _targv, _tenviron);</span><br><span class="line">#endif  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line"></span><br><span class="line">            if ( !managedapp )</span><br><span class="line">                exit(mainret);</span><br><span class="line"></span><br><span class="line">            _cexit();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Should never reach here</span><br><span class="line">             *&#x2F;</span><br><span class="line"></span><br><span class="line">            mainret &#x3D; GetExceptionCode();</span><br><span class="line"></span><br><span class="line">            if ( !managedapp )</span><br><span class="line">                _exit(mainret);</span><br><span class="line"></span><br><span class="line">            _c_exit();</span><br><span class="line"></span><br><span class="line">        &#125; &#x2F;* end of try - except *&#x2F;</span><br><span class="line"></span><br><span class="line">        return mainret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码，可以很清晰了解启动函数到底做了什么事情。</p><p>Console版本</p><p>1.初始化C的堆申请（_heap_init(1)）</p><p>2.初始化多线程（_mtinit()）</p><p>3.获取命令行（GetCommandLineT()）</p><p>4.获取环境变量（GetEnvironmentStringsT()）</p><p>5.初始化C和C++的全局变量（_cinit(TRUE)）</p><p>6.调用main函数（_tmain(__argc, _targv, _tenviron)）</p><p>Windows版本</p><p>1.获取StartupInfo（GetStartupInfo( StartupInfo )）</p><p>2.初始化C的堆申请（_heap_init(1)）</p><p>3.初始化多线程（_mtinit()）</p><p>4.获取命令行（GetCommandLineT()）</p><p>5.获取环境变量（GetEnvironmentStringsT()）</p><p>6.初始化C和C++的全局变量（_cinit(TRUE)）</p><p>7.调用WinMain函数</p><p>最后再看看_cinit(TRUE)到底做了什么事情？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl _cinit (</span><br><span class="line">        int initFloatingPrecision</span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">        int initret;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * initialize floating point package, if present</span><br><span class="line">         *&#x2F;</span><br><span class="line">#ifdef CRTDLL</span><br><span class="line">        _fpmath(initFloatingPrecision);</span><br><span class="line">#else  &#x2F;* CRTDLL *&#x2F;</span><br><span class="line">        if (_FPinit !&#x3D; NULL amp;amp;</span><br><span class="line">            _IsNonwritableInCurrentImage((PBYTE)amp;_FPinit))</span><br><span class="line">        &#123;</span><br><span class="line">            (*_FPinit)(initFloatingPrecision);</span><br><span class="line">        &#125;</span><br><span class="line">        _initp_misc_cfltcvt_tab();</span><br><span class="line">#endif  &#x2F;* CRTDLL *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * do initializations</span><br><span class="line">         *&#x2F;</span><br><span class="line">        initret &#x3D; _initterm_e( __xi_a, __xi_z );</span><br><span class="line">        if ( initret !&#x3D; 0 )</span><br><span class="line">            return initret;</span><br><span class="line"></span><br><span class="line">#ifdef _RTC</span><br><span class="line">        atexit(_RTC_Terminate);</span><br><span class="line">#endif  &#x2F;* _RTC *&#x2F;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * do C++ initializations</span><br><span class="line">         *&#x2F;</span><br><span class="line">        _initterm( __xc_a, __xc_z );</span><br><span class="line"></span><br><span class="line">#ifndef CRTDLL</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * If we have any dynamically initialized __declspec(thread)</span><br><span class="line">         * variables, then invoke their initialization for the thread on</span><br><span class="line">         * which the DLL is being loaded, by calling __dyn_tls_init through</span><br><span class="line">         * a callback defined in tlsdyn.obj.  We can&#39;t rely on the OS</span><br><span class="line">         * calling __dyn_tls_init with DLL_PROCESS_ATTACH because, on</span><br><span class="line">         * Win2K3 and before, that call happens before the CRT is</span><br><span class="line">         * initialized.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (__dyn_tls_init_callback !&#x3D; NULL amp;amp;</span><br><span class="line">            _IsNonwritableInCurrentImage((PBYTE)amp;__dyn_tls_init_callback))</span><br><span class="line">        &#123;</span><br><span class="line">            __dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">#endif  &#x2F;* CRTDLL *&#x2F;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的两行，initret = _initterm_e( <strong>xi_a, </strong>xi_z )和_initterm( <strong>xc_a, </strong>xc_z )。这两行的作用分别是初始化C标准库中的全局变量和初始化C++的全局变量。</p><p>至此，对C++程序的默认启动函数的基本过程有个了解了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件推荐列表</title>
      <link href="/2015/12/18/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8/"/>
      <url>/2015/12/18/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>1.发布博客软件：Windows Live Write，可以参考<a href="http://www.xpc-yx.com/2015/11/25/%E8%AF%95%E8%AF%95windows-live-write%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">我的WindowsLiveWrite博文</a>。</p><p>2.Windows7/Xp上显示TGA图片的缩略图：MysticThumbs，可以参考<a href="http://www.xpc-yx.com/2015/10/12/%E5%A6%82%E4%BD%95%E8%AE%A9tga%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/" target="_blank" rel="noopener">我的MysticThumbs博文</a>。</p><p>3.记笔记：印象笔记（Evernote），不用介绍了，任何设备上都可以用（电脑，手机，ipad…)。</p><p>4.注册表浏览器：registryworkshop，比Windows默认的注册表舒服很多。</p><p>5.破解工具：<strong>TrialReset。</strong>该软件可以清除很多软件的保护信息，比如visual assist X，我就用它清楚过VA的保护信息。搜索该软件会得到一些介绍，单纯的清除信息操作很简单，清除后相当于<strong>无限延长试用期</strong>。试试会得到你意想不到的结果。</p><p>6.阅读软件：<strong>calibre</strong>。calibre是一个非常优秀的书籍管理软件。当然，我找到它的原因是它可以非常方便的转mobi,epub等。这样就可以将任意格式的书籍放到kindle或者多看阅读器（支持多种设备，手机，ipad，kindle等）上面去看了。这对于用阅读打法无聊时光的我，非常有用。calibre还可以在PC上当做书籍管理和阅读软件，我正在用它看epub格式的书籍了，因为多看阅读器不支持Windows平台。更多功能我就不知道了，有待挖掘。</p><p>7.文件内容搜索工具：<strong>FileSeek</strong>。这款软件能够下载到破解版，我现在主要用来搜索as代码（逆战的界面使用的是ScaleForm开发的，需要写as代码）。Windows自带的搜索功能对于文件内容搜索确实不方便额。</p><p>持续更新…</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTex下如何使Beamer支持中文</title>
      <link href="/2015/11/28/CTex%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BFBeamer%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87/"/>
      <url>/2015/11/28/CTex%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BFBeamer%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>我使用的是windows下的最新版CTex，版本号是CTeX_2.9.2.164_Full.exe。注意使用full版本，如果不是，可能不支持beamer。beamer是一个流行的演讲文档模板，有多种主题，效果也还不错。</p><p>我在尝试beamer的过程中，发现网上大部分例子都不支持中文，或者不支持我使用的环境下的中文，即windows下的最新版CTex。折腾了几天，试了很多个模板，发现xeCJK能够完美解决这个问题，因为很多老的模板都是用的CJK，我将其中一个模板改成xeCJK就支持中文了。<br> 下面给出这个模板的设置。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;beamer&#125;</span><br><span class="line">\usetheme&#123;Warsaw&#125;</span><br><span class="line">\usepackage&#123;fontspec,xunicode,xltxtra&#125;</span><br><span class="line">\usepackage[slantfont,boldfont]&#123;xeCJK&#125; % 允许斜体和粗体</span><br><span class="line">\setbeamercovered&#123;transparent&#125;</span><br><span class="line">\usepackage[english]&#123;babel&#125;</span><br><span class="line">% or whatever</span><br><span class="line">\usepackage&#123;hyperref&#125;</span><br><span class="line">\usepackage[T1]&#123;fontenc&#125;</span><br><span class="line">% or whatever</span><br><span class="line">\usefonttheme&#123;professionalfonts&#125;</span><br><span class="line">\usepackage&#123;times&#125;</span><br><span class="line">\usepackage&#123;mathptmx&#125;</span><br><span class="line">\usepackage&#123;tabularx&#125;</span><br><span class="line">% Or whatever. Note that the encoding and the font should match. If T1</span><br><span class="line">% does not look nice, try deleting the line with the fontenc.</span><br><span class="line">\usepackage&#123;xcolor&#125;</span><br><span class="line">\usepackage&#123;booktabs, multirow, enumerate&#125;</span><br><span class="line">\usepackage&#123;animate&#125;</span><br><span class="line">\usepackage&#123;multimedia&#125;</span><br><span class="line"></span><br><span class="line">% ... or whatever. Note that the encoding and the font should match.</span><br><span class="line">% If T1 does not look nice, try deleting the line with the fontenc.</span><br><span class="line">\usepackage&#123;lmodern&#125; %optional</span><br><span class="line">\usepackage&#123;listings&#125;</span><br><span class="line"></span><br><span class="line">% Delete this, if you do not want the table of contents to pop up at</span><br><span class="line">% the beginning of each subsection:</span><br><span class="line">\AtBeginSection[]</span><br><span class="line">&#123;</span><br><span class="line">    \begin&#123;frame&#125;&lt;beamer&gt;</span><br><span class="line">        \frametitle&#123;内容大纲&#125;</span><br><span class="line">        \tableofcontents[currentsection]</span><br><span class="line">    \end&#123;frame&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\setCJKmainfont&#123;Microsoft YaHei&#125;   % 设置缺省中文字体</span><br><span class="line">\setCJKmonofont&#123;SimSun&#125;   % 设置等宽字体</span><br><span class="line">\setmainfont&#123;TeX Gyre Pagella&#125; % 英文衬线字体</span><br><span class="line">\setmonofont&#123;Microsoft YaHei&#125; % 英文等宽字体</span><br><span class="line">\setsansfont&#123;Trebuchet MS&#125; % 英文无衬线字体</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\title[***纹理***]% optional, use only with long paper titles</span><br><span class="line">&#123; ***纹理***\\[<span class="number">2ex</span>]&#125;</span><br><span class="line"></span><br><span class="line">%\subtitle[malloc] %optional</span><br><span class="line">%&#123;malloc\ 实现&#125;</span><br><span class="line"></span><br><span class="line">\author[yx] % optional, use only with lots of authors</span><br><span class="line">&#123;</span><br><span class="line">\textcolor[rgb]&#123;<span class="number">0.00</span>, <span class="number">0.41</span>, <span class="number">0.66</span>&#125;&#123;yx&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% the titlepage</span><br><span class="line">% the plain option removes the sidebar and header from the title page</span><br><span class="line">\begin&#123;frame&#125;[plain]</span><br><span class="line">  \titlepage</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line">%%%%%%%%%%%%%%%%</span><br><span class="line"></span><br><span class="line">\begin&#123;frame&#125;</span><br><span class="line">        \frametitle&#123;内容大纲&#125;</span><br><span class="line">        \tableofcontents</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line"></span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">\section&#123;研究背景和意义&#125;</span><br><span class="line">%%%%%%%%%%%%%%%%</span><br><span class="line">\begin&#123;frame&#125;&#123;纹理的作用&#125;&#123;&#125;</span><br><span class="line">  \begin&#123;block&#125;&lt;<span class="number">1</span>-&gt;&#123;&#125;</span><br><span class="line">    纹理是图形学中增强真实性的重要手段。</span><br><span class="line">  \end&#123;block&#125;</span><br><span class="line">  \begin&#123;block&#125;&lt;<span class="number">2</span>-&gt;&#123;&#125;</span><br><span class="line">    应用纹理到三维表面能够有效的表示物体表面的颜色，材质，几何等属性。</span><br><span class="line">  \end&#123;block&#125;</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line">%%%%%%%%%%%%%%%%</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，请用utf8来保存该文档，并且在WinEdit中用utf8来打开，否则还是可能看到乱码的。<br>boats against the current, borne back ceaselessly into the past.</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次看到自己的代码上线了</title>
      <link href="/2015/10/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%BA%BF%E4%BA%86/"/>
      <url>/2015/10/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%BA%BF%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>今天逆战发布新版了。我做的新军衔系统和转生系统在这次上线了。哈哈，好有成就感。第一次写的代码能够影响这么多人的生活。听说玩家都挤在主城转生NPC处了。</p><p>新军衔系统：</p><p><a href="https://c7.staticflickr.com/8/7669/27417989086_57309c8dcd_o.jpg" target="_blank" rel="noopener"><img alt data-src="https://c7.staticflickr.com/8/7669/27417989086_57309c8dcd_o.jpg"></a></p><p><img alt data-src="https://c2.staticflickr.com/8/7029/27175748990_4be24a9ea9_o.png"></p><p>转生系统：</p><p><img alt data-src="https://c2.staticflickr.com/8/7286/27380691921_3e234978a3_o.jpg"></p><p><img alt data-src="https://c7.staticflickr.com/8/7197/27352974822_d54441d79d_o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>scaleform中从unrealscript往actionscript传输数据的方式</title>
      <link href="/2015/10/17/scaleform%E4%B8%AD%E4%BB%8Eunrealscript%E5%BE%80actionscript%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2015/10/17/scaleform%E4%B8%AD%E4%BB%8Eunrealscript%E5%BE%80actionscript%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在逆战的界面开发中，一般只需要从uc往flash中单向传输数据，因此这里只总结从uc-&gt;flash的数据流动方法。flash-&gt;uc的数据流动，其实有相对应的方式，比如SetVariableBool函数有对应的GetVariableBool函数。</p><p>在unrealscript中，使用scaleform的界面类，都继承自GfxMoviePlayer。</p><p>一、传输变量</p><p>native function SetVariableString(string path, string s);</p><p>native function SetVariableBool(string path, bool b);</p><p>native function SetVariableNumber(string path, float f);</p><p>我在GfxUIMovie中没找到专门设置int的函数，估计可以用SetVariableNumber替代。关键是理解path的设置，比如对应flash文件的名称是ReBornGuide。那么path可能是ReBornGuide.str或者_root.ReBornGuide.str，具体跟ue3项目的一些设置有关。</p><p>这几个函数对应的cpp声明如下：</p><p>String：SetVariableString(const FString path, const FString s);</p><p>Bool：SetVariableBool(const FString path, UBool b);</p><p>Float：SetVariableNumber(const FString path, float f);</p><p>有趣的是，这几个函数的字符串参数都是引用，这样恰恰说明了在uc中，字符串是引用类型。</p><p>例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.uc中：</span><br><span class="line">String strTest = "测试";</span><br><span class="line">String path = "_root.TestFlash.strTest";</span><br><span class="line">SetVariableString(path，strTest);</span><br><span class="line">TestFlash.as中：</span><br><span class="line">var strTest:String;</span><br></pre></td></tr></table></figure><p>二、传输数组</p><p>native function bool SetVariableStringArray(string path, int index, array<string> Arg);</string></p><p>native function bool SetVariableFloatArray(string path, int index, array<float> Arg);</float></p><p>native function bool SetVariableIntArray(string path, int index, array<int> Arg);</int></p><p>其对应的cpp实现</p><p>String：SetVariableStringArray(const FString path,  INT Index，const TArray<fstring> arg);</fstring></p><p>Float：SetVariableFloatArray(const FString path, INT Index，const TArray<float> arg);</float></p><p>Int：SetVariableFloatArray(const FString path, INT Index，const TArray<int> arg);</int></p><p>这里Index表示从数组的第几个元素开始，0表示传输全部，arg是要传输的数组。</p><p>例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test.uc中：</span><br><span class="line">local array&lt;String&gt; strArray;</span><br><span class="line">strArray.AddItem("0");</span><br><span class="line">strArray.AddItem("1");</span><br><span class="line">String path = "_root.TestFlash.strTest";</span><br><span class="line">SetVariableStringArray(path，strArray);</span><br><span class="line">TestFlash.as中：</span><br><span class="line">var strArray:Array = new Array();</span><br></pre></td></tr></table></figure><p>三、传输复合对象（结构体）</p><p>当需要传输整体的数据，或者传输多个数据的时候，可以将数据组合成一个结构体。假设在uc中定义了如下结构体，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct RankData</span><br><span class="line">&#123;</span><br><span class="line">   var string Name;</span><br><span class="line">   var int Rank;</span><br><span class="line">   var double d;</span><br><span class="line">   <span class="selector-tag">var</span> <span class="attribute">float</span> f;</span><br><span class="line">   var bool b;</span><br><span class="line">&#125;;</span><br><span class="line">RankData RD;</span><br></pre></td></tr></table></figure><p>我们想将其一次性传入as中定义的Object对象,var RD:Object。这里我们可以使用SetVariableObject函数。其定义如下：</p><p>native function SetVariableObject(string path, GFxObject Object);</p><p>下面的例子很好说明了如何使用该函数。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">uc中:</span><br><span class="line">struct RankData</span><br><span class="line">&#123;</span><br><span class="line">   var string Name;</span><br><span class="line">   var int Rank;</span><br><span class="line">   var double d;</span><br><span class="line">   <span class="selector-tag">var</span> <span class="attribute">float</span> f;</span><br><span class="line">   var bool b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SetFlashVariables()</span><br><span class="line">&#123;</span><br><span class="line">    local GFxObject GfxObj;</span><br><span class="line">    local RankData RD;</span><br><span class="line">    local string path;</span><br><span class="line"></span><br><span class="line">    RD.Name = "test";</span><br><span class="line">    RD.Rank = 1;</span><br><span class="line">    RD.d = 1.0;</span><br><span class="line">    RD.f = 1.0;</span><br><span class="line">    RD.b = True;</span><br><span class="line">    GfxObj = CreateObject("Object");</span><br><span class="line">    GfxObj.SetString("Name", RD.Name);</span><br><span class="line">    GfxObj.SetInt("Rank", RD.Rank);</span><br><span class="line">    GfxObj.SetDouble("d", RD.d);</span><br><span class="line">    GfxObj.SetFloat("f", RD.f);</span><br><span class="line">    GfxObj.SetBool("b", RD.b);</span><br><span class="line"></span><br><span class="line">    path = <span class="string">"_root.TestFlash.RD"</span></span><br><span class="line">    SetVariableObject(path, GfxObj);</span><br><span class="line">    GfxObj.DestroyObject();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestFlash.as中:</span><br><span class="line">var RD:Object = new Object();</span><br><span class="line"><span class="comment">//在uc中调用了SetFlashVariables函数后，as中就能获得RD的值。</span></span><br><span class="line">trace(RD.Name);</span><br><span class="line">trace(RD.Name);</span><br><span class="line">trace(RD.f);</span><br><span class="line">trace(RD.d);</span><br><span class="line">trace(RD.b);</span><br></pre></td></tr></table></figure><p>从上面代表可以看出，GFxObject可以代表一个符号变量，可以设置一个GFxObject的多个属性，然后一次性将这个对象传入flash。GFxObject.uc中有如下Set变量的函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">native final function SetBool(string Member, bool b);</span><br><span class="line">native final function SetFloat(string Member, <span class="attribute">float</span> f);</span><br><span class="line">native final function SetDouble(string Member,double d);</span><br><span class="line">native final function SetInt(string Member,int i);</span><br><span class="line">native final function SetString(string Member, string s);</span><br><span class="line">native final function SetObject(string Member, GFxObject val);</span><br></pre></td></tr></table></figure><p>因此，可以看出可以设置GFxObject各种类型的属性。关键的是还可以设置其GFxObject类型的属性，从而可以嵌套定义。比如结构体中定义另一结构体成员。当需要将多次传输组合为一次时候，也可以使用这种方式，并不需要一定定义结构体。</p><p>四、传输结构体数组</p><p>假设as中定义如下数组，var RankListDatas:Array = new Array();那么可以用下面代码传输：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//军衔列表每项的数据</span></span><br><span class="line">struct RankListData</span><br><span class="line">&#123;</span><br><span class="line">    var int Level;//等级</span><br><span class="line">    var string Name;//军衔名</span><br><span class="line">&#125;;</span><br><span class="line">var array&lt;RankListData&gt; RankListDatas;</span><br><span class="line">var string path;</span><br><span class="line">function SetFlashRankListDatas()</span><br><span class="line">&#123;</span><br><span class="line">    local int Index;</span><br><span class="line">    local GFxObject GfxRankListDatas;</span><br><span class="line">    local GFxObject GfxTempObj;</span><br><span class="line"></span><br><span class="line">    GfxRankListDatas = CreateArray();</span><br><span class="line">    for (Index = 0; Index &lt; RankDatas.Length; Index++)//第0项是多余的</span><br><span class="line">    &#123;        </span><br><span class="line">        GfxTempObj = CreateObject("Object");</span><br><span class="line">        GfxTempObj.SetInt("Level", RankListDatas[Index].Level);</span><br><span class="line">        GfxTempObj.SetString("Name", RankListDatas[Index].Name);</span><br><span class="line">        GfxRankListDatas.SetElementObject(Index, GfxTempObj);</span><br><span class="line">        GfxTempObj.DestroyObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetVariableObject(path, GfxRankListDatas);</span><br><span class="line">    GfxRankListDatas.DestroyObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里面可以看到，还是用SetVariableObject传输数据。不过，需要用CreateArray()创建GFxObject对象。在as代码中RankListDatas[0].Name就可以访问第一个元素的Name属性了。</p><p>GfxRankListDatas.SetElementObject(Index, GfxTempObj)则是将GfxTempObj设置为GfxRankListDatas代表的数组的第Index个元素。</p><p>五、传输结构体数组的数组（结构体内部复合结构体数组）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct AwardData</span><br><span class="line">&#123;</span><br><span class="line">    var string IconSource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct RankAwardData</span><br><span class="line">&#123;</span><br><span class="line">    var string RankAwardTitle;</span><br><span class="line">    var array&lt;AwardData&gt; AwardDatas;</span><br><span class="line">&#125;;</span><br><span class="line">var array&lt;RankAwardData&gt; RankAwardDatas;</span><br><span class="line">var string path;</span><br><span class="line"></span><br><span class="line">function SetFlashRankAwardDatas()</span><br><span class="line">&#123;</span><br><span class="line">    local int Index;</span><br><span class="line">    local int i;</span><br><span class="line">    local GFxObject GfxRankAwardDatas;</span><br><span class="line">    local GFxObject GfxTempObj;</span><br><span class="line">    local GFxObject GfxAwardDatas;</span><br><span class="line">    local GFxObject GfxAwardTempObj;</span><br><span class="line"></span><br><span class="line">    GfxRankAwardDatas = CreateArray();</span><br><span class="line">    for (Index = 0; Index &lt; RankAwardDatas.Length; Index++)</span><br><span class="line">    &#123;        </span><br><span class="line">        GfxTempObj = CreateObject("Object");</span><br><span class="line">        GfxTempObj.SetString("RankAwardTitle", RankAwardDatas[Index].RankAwardTitle);</span><br><span class="line"></span><br><span class="line">        GfxAwardDatas = CreateArray();</span><br><span class="line">        for (i = 0; i &lt; RankAwardDatas[Index].AwardDatas.Length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            GfxAwardTempObj = CreateObject("Object");</span><br><span class="line">            GfxAwardTempObj.SetString("IconSource", RankAwardDatas[Index].AwardDatas[i].IconSource);</span><br><span class="line">            GfxAwardDatas.SetElementObject(i, GfxAwardTempObj);</span><br><span class="line">            GfxAwardTempObj.DestroyObject();</span><br><span class="line">        &#125;</span><br><span class="line">        GfxTempObj.SetObject("RankAward", GfxAwardDatas);</span><br><span class="line">        GfxRankAwardDatas.SetElementObject(Index, GfxTempObj);</span><br><span class="line">        GfxAwardDatas.DestroyObject();</span><br><span class="line">        GfxTempObj.DestroyObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetVariableObject(path, GfxRankAwardDatas);</span><br><span class="line">    GfxRankAwardDatas.DestroyObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，调用GfxTempObj.SetObject(“RankAward”, GfxAwardDatas)可以设置GFxObject对象的GFxObject属性，从而能够传输复合结构体类型的数组。假设as中对应的数组定义为var RankAwardDatas:Array=new Array();那么，在as代码中RankAwardDatas[0].RankAward.IconSource则能访问该数组第一个元素的结构体成员的IconSource属性。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> UnrealEngine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scaleform </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows7上面等如何让tga格式图片显示缩略图</title>
      <link href="/2015/10/12/windows7%E4%B8%8A%E9%9D%A2%E7%AD%89%E5%A6%82%E4%BD%95%E8%AE%A9tga%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/"/>
      <url>/2015/10/12/windows7%E4%B8%8A%E9%9D%A2%E7%AD%89%E5%A6%82%E4%BD%95%E8%AE%A9tga%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>我不知道现在的win8和win10系统上是不是自动显示tga格式的缩略图的。我的win7系统确实有时候显示不了。为什么有这样的需求了，因为我现在的工作是开发游戏，虽然这几个月在写界面。在网上搜到有一个这样的软件MysticThumbs。这显然是外国友人做的东西，肯定是要注册的，官网上面下载的肯定是的，要交钱的。伟大的天朝人民肯定有破解版本了。</p><p>下面分享下我下载到的破解版本，里面有使用说明，<a href="https://pan.baidu.com/s/1geCdSxP" target="_blank" rel="noopener">MysticThumbs破解版本</a>。虽然说里面有破解说明，既然写了这篇文章，我就是想更简略的说明下如何使用。</p><p>1.打开之后，直接运行MysticThumbs3.0.0.Multi+Pt FULL。假设安装到默认路径。</p><p>2.打开安装路径C:\Program Files\MysticCoder\MysticThumbs，你会看到里面有几个dll。</p><p>3.把安装文件里面的patch目录下的文件，复制到2所在的目录即可。</p><p>破解完毕，现在不用担心使用一个月后失效了。</p><p>这个破解版本在2个多月后失效了，慎用。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tga缩略图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作一周多解决的一些小问题</title>
      <link href="/2015/08/19/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%91%A8%E5%A4%9A%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2015/08/19/%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%91%A8%E5%A4%9A%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>7月26号封闭培训，到部门来已经是8月10号了。刚开始懵懵懂懂的，不知道干啥。部门上课的那几天，把新人手册的步骤做了一遍。悲伤的是，做完之后不少忘记了。编译脚本的addin插件至今没有显示出来，虽然有几天它显示过。除此之外，还有不少纠结过的问题。让我一一道来吧。配置vs字体和颜色，va快捷键，查找快捷键无效，F12查看定义无效，uc断点无效，调试uc时候游戏进程掉了。。。下面来说说成功解决掉的几个问题吧，非常感谢jerry哥和vivin姐的帮忙。</p><p>1.vs的字体和颜色。默认字体是新宋体，这个字体据说不是很好，推荐consolas字体。颜色的话，有个网站叫做<a href="https://studiostyl.es/" target="_blank" rel="noopener">https://studiostyl.es/</a>，<br>可以去里面选自己喜欢的风格，设置好就行。值得注意的是，安装nfringe后，字体颜色设置面板里面会出现unrealscript相关的设置，注意修改。<br>如图所示，<br><img alt data-src="https://c2.staticflickr.com/8/7317/26842778024_ed21d0f0b6_o.png"></p><p>另一个需要注意的地方是，与.uc文件不同，.cpp中的代码颜色是在visual assist x中修改的，这个我找了半天才反应过来。</p><p>2.visaul assist x的open file in solution快捷键shift+alt+o没掉了，按这个快捷键打开的一个网页模板窗口。方式是配置一个新的快捷键。tools-&gt;options-&gt;environment-&gt;keyboard，打开面板后选中VAssistX.OpenFileInSolutionDialog。再将鼠标焦点切换到Press shortcut keys下面的输入框里面，按下shift+alt+o，就添加一个全局快捷键，点击assign按钮即可。如图，</p><p><img alt data-src="https://c2.staticflickr.com/8/7241/27452123005_d26555f3d8_o.png"></p><p>3.vs的查找文件快捷键，shift+ctrl+f无效。这是因为安装了搜狗输入法造成了。搜狗输入法在更上层截断了这个快捷键，设置下搜狗输入法取消这个快捷键即可。如图，</p><p><img alt data-src="https://c2.staticflickr.com/8/7032/27175666250_9f465482a9_o.png"></p><p>4.调试uc时候游戏进程脱离vs。这个debug-&gt;attach to process即可。注意最上面的tansport可以筛选unrealscript，筛选后再用下面的refresh按钮刷新一下就出来了。</p><p>5.f12查找代码定义的问题并没有彻底解决。在uc文件中，只能用f12查找定义。对于f12失效的情况下，使用3在整个解决方案搜索，不过比较麻烦，但是能解决问题。在cpp文件中，就能够使用va的快捷键alt+g查找定义了。我居然忘记了这茬，以前从没接触过脚本编写，现在项目里面cpp和uc都有，所以混淆了。</p><p>6.uc断点无效，据说是nfringe的bug。</p><p>7.另外项目组的addin插件一直点击没反应，也不知道原因。不过，我在解决问题3之后，addin插件按钮点击后不会造成vs崩溃，但是还是无效的，也就是彻底没反应，我是服了。。。不过，今天前辈在我机子上面调试那个插件的代码，修复了bug，可以使用了，开心。。。</p><p>早上悲催的被发现昨晚上传代码没传全，差点请全组喝饮料了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>stl源码剖析之vector</title>
      <link href="/2015/06/10/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/"/>
      <url>/2015/06/10/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bvector/</url>
      
        <content type="html"><![CDATA[<p>vector是一直在用的东西，太常用了，数组的替代品。大多数时候，都想不出理由不用vector，改用list，deque之类的。从功能来看，vector就是一个动态的数组而已。使用vector时候，唯一需要注意的是，当重新申请更大空间时候，是去了一块新内存，而不是直接在原地址增加，所有迭代器是都会失效的。当然还有其它操作造成某些迭代器失效。</p><p>下面来看看vector的部分定义。全部定义过于冗长了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class Alloc = alloc&gt;  <span class="comment">// 預設使用 alloc 為配置器</span></span><br><span class="line">class vector &#123;</span><br><span class="line">public:</span><br><span class="line">  <span class="comment">// 以下標示 (1),(2),(3),(4),(5)，代表 iterator_traits&lt;I&gt; 所服務的5個型別。</span></span><br><span class="line">  typedef T value_type;             // (1)</span><br><span class="line">  typedef value_type* pointer;          // (2)</span><br><span class="line">  typedef const value_type* const_pointer;</span><br><span class="line">  typedef const value_type* const_iterator;</span><br><span class="line">  typedef value_type reference;         // (3)</span><br><span class="line">  typedef const value_type const_reference;</span><br><span class="line">  typedef size_t size_type;</span><br><span class="line">  typedef ptrdiff_t difference_type;    // (4)</span><br><span class="line">  <span class="comment">// 以下，由於vector 所維護的是一個連續線性空間，所以不論其元素型別為何，</span></span><br><span class="line">  <span class="comment">// 原生指標都可以做為其迭代器而滿足所有需求。</span></span><br><span class="line">  typedef value_type* iterator;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">  <span class="comment">// 專屬之空間配置器，每次配置一個元素大小</span></span><br><span class="line">  typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// vector採用簡單的線性連續空間。以兩個迭代器start和end分別指向頭尾，</span></span><br><span class="line">  <span class="comment">// 並以迭代器end_of_storage指向容量尾端。容量可能比(尾-頭)還大，</span></span><br><span class="line">  <span class="comment">// 多餘即備用空間。</span></span><br><span class="line">  iterator start;</span><br><span class="line">  iterator finish;</span><br><span class="line">  iterator end_of_storage;</span><br><span class="line"></span><br><span class="line">  void insert_aux(iterator <span class="attribute">position</span>, const T x);</span><br><span class="line">  void deallocate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (start)</span><br><span class="line">         data_allocator::deallocate(start, end_of_storage - start);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void fill_initialize(size_type n, const T value) &#123;</span><br><span class="line">    start = allocate_and_fill(n, value);  // 配置空間並設初值</span><br><span class="line">    finish = start + n;             // 調整水位</span><br><span class="line">    end_of_storage = finish;            // 調整水位</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  iterator begin() &#123; return start; &#125;</span><br><span class="line">  const_iterator begin() const &#123; return start; &#125;</span><br><span class="line">  iterator end() &#123; return finish; &#125;</span><br><span class="line">  const_iterator end() const &#123; return finish; &#125;</span><br><span class="line">  reverse_iterator rbegin() &#123; return reverse_iterator(end()); &#125;</span><br><span class="line">  const_reverse_iterator rbegin() const &#123;</span><br><span class="line">    return const_reverse_iterator(end());</span><br><span class="line">  &#125;</span><br><span class="line">  reverse_iterator rend() &#123; return reverse_iterator(begin()); &#125;</span><br><span class="line">  const_reverse_iterator rend() const &#123;</span><br><span class="line">    return const_reverse_iterator(begin());</span><br><span class="line">  &#125;</span><br><span class="line">  size_type size() const &#123; return size_type(end() - begin()); &#125;</span><br><span class="line">  size_type max_size() const &#123; return size_type(-1) / sizeof(T); &#125;</span><br><span class="line">  size_type capacity() const &#123; return size_type(end_of_storage - begin()); &#125;</span><br><span class="line">  bool empty() const &#123; return begin() == end(); &#125;</span><br><span class="line">  reference operator[](size_type n) &#123; return *(begin() + n); &#125;</span><br><span class="line">  const_reference operator[](size_type n) const &#123; return *(begin() + n); &#125;</span><br><span class="line"></span><br><span class="line">  vector() : start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 以下建構式，允許指定大小 n 和初值 value</span></span><br><span class="line">  vector(size_type n, const T value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">  vector(int n, const T value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">  vector(long n, const T value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">  explicit vector(size_type n) &#123; fill_initialize(n, T()); &#125;</span><br><span class="line"></span><br><span class="line">  vector(const vector&lt;T, Alloc&gt; x) &#123;</span><br><span class="line">    start = allocate_and_copy(x.end() - x.begin(), x.begin(), x.end());</span><br><span class="line">    finish = start + (x.end() - x.begin());</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector(const_iterator first, const_iterator last) &#123;</span><br><span class="line">    size_type n = 0;</span><br><span class="line">    distance(first, last, n);</span><br><span class="line">    start = allocate_and_copy(n, first, last);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~vector() &#123;</span><br><span class="line">    destroy(start, finish);  // 全域函式，建構/解構基本工具。</span><br><span class="line">    deallocate();   // 先前定義好的成員函式</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;T, Alloc&gt; operator=(const vector&lt;T, Alloc&gt; x);</span><br><span class="line">  void reserve(size_type n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity() &lt; n) &#123;</span><br><span class="line">      const size_type old_size = size();</span><br><span class="line">      iterator tmp = allocate_and_copy(n, start, finish);</span><br><span class="line">      destroy(start, finish);</span><br><span class="line">      deallocate();</span><br><span class="line">      start = tmp;</span><br><span class="line">      finish = tmp + old_size;</span><br><span class="line">      end_of_storage = start + n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出第一個元素內容</span></span><br><span class="line">  reference front() &#123; return *begin(); &#125;</span><br><span class="line">  const_reference front() const &#123; return *begin(); &#125;</span><br><span class="line">  <span class="comment">// 取出最後一個元素內容</span></span><br><span class="line">  reference back() &#123; return *(end() - 1); &#125;</span><br><span class="line">  const_reference back() const &#123; return *(end() - 1); &#125;</span><br><span class="line">  <span class="comment">// 增加一個元素，做為最後元素</span></span><br><span class="line">  void push_back(const T x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;  <span class="comment">// 還有備用空間</span></span><br><span class="line">      construct(finish, x);         // 直接在備用空間中建構元素。</span><br><span class="line">      ++finish;                             // 調整水位高度</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                  <span class="comment">// 已無備用空間</span></span><br><span class="line">      insert_aux(end(), x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void pop_back() &#123;</span><br><span class="line">    --finish;</span><br><span class="line">    destroy(finish);    // 全域函式，建構/解構基本工具。</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 將迭代器 position 所指之元素移除</span></span><br><span class="line">  iterator erase(iterator <span class="attribute">position</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="attribute">position</span> + <span class="number">1</span> != end()) // 如果 p 不是指向最後一個元素</span><br><span class="line">      <span class="comment">// 將 p 之後的元素一一向前遞移</span></span><br><span class="line">      copy(<span class="attribute">position</span> + <span class="number">1</span>, finish, position); </span><br><span class="line"></span><br><span class="line">    --finish;  // 調整水位</span><br><span class="line">    destroy(finish);    // 全域函式，建構/解構基本工具。</span><br><span class="line">    return <span class="attribute">position</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iterator erase(iterator first, iterator last) &#123;</span><br><span class="line">    iterator i = copy(last, finish, first);</span><br><span class="line">    destroy(i, finish); // 全域函式，建構/解構基本工具。</span><br><span class="line">    finish = finish - (last - first);</span><br><span class="line">    return first;</span><br><span class="line">  &#125;</span><br><span class="line">  void <span class="attribute">resize</span>(size_type new_size, const T x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; size())</span><br><span class="line">      erase(begin() + new_size, end());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      insert(end(), new_size - size(), x);</span><br><span class="line">  &#125;</span><br><span class="line">  void <span class="attribute">resize</span>(size_type new_size) &#123; resize(new_size, T()); &#125;</span><br><span class="line">  <span class="comment">// 清除全部元素。注意，並未釋放空間，以備可能未來還會新加入元素。</span></span><br><span class="line">  void <span class="attribute">clear</span>() &#123; erase(begin(), end()); &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">  iterator allocate_and_fill(size_type n, const T x) &#123;</span><br><span class="line">    iterator result = data_allocator::allocate(n); // 配置n個元素空間</span><br><span class="line">      <span class="comment">// 全域函式，記憶體低階工具，將result所指之未初始化空間設定初值為 x，n個</span></span><br><span class="line">      <span class="comment">// 定義於 &lt;stl_uninitialized.h&gt;。</span></span><br><span class="line">      uninitialized_fill_n(result, n, x);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分几部分来讲述vector的定义。首先，模板参数一个是类型T作为vector的内含物类型，class Alloc = alloc则是使用默认的内存申请器。这一句typedef simple_alloc<value_type, alloc> data_allocator;则是重定义相应的内存申请器类型。<br>然后，vector的迭代器类型其实就是原始的指针类型重定义了一下。以下这几句重定义，</value_type,></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef T value_type;             // (1)</span><br><span class="line">typedef value_type* pointer;          // (2)</span><br><span class="line">typedef const value_type* const_pointer;</span><br><span class="line">typedef const value_type* const_iterator;</span><br><span class="line">typedef value_type reference;         // (3)</span><br><span class="line">typedef const value_type const_reference;</span><br><span class="line">typedef size_t size_type;</span><br><span class="line">typedef ptrdiff_t difference_type;    // (4)</span><br></pre></td></tr></table></figure><p>在list，deque，map，set等支持迭代器操作的容器定义中都会出现。其中，vector中的定义是最简单的。每个容器都有值类型，指针类型，迭代器类型，引用类型，以及大小类型，difference_type。知道这些后，写代码时候，可以避免一些错误，或者说代码更规范，就能自然而然的使用容易内置类型，比如vector<int>::size_type而不是int来进行一些操作。原始指针支持随机存储，因此vector的迭代器就是功能最强的随机迭代器。<br>vector采用的数据结构很简单，就是一段线性内存。不过，有三个指针分别指向内存的头，已使用的尾部，尾。为了避免过多的重新分配内存，vector的容量永远比大小大，而且每次重新配置内存，大小翻倍。所以，vector的很多操作，比如，begin，end，front，back，size等的实现就很直观了，具体参看源码。下图很清楚的说明了这一情况。</int></p><p><img alt data-src="https://c2.staticflickr.com/8/7355/26844795653_d590b6b031_o.png"></p><p>接着要讲的是vector如何管理空间的。先看下面三个函数，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector(size_type n, const T value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">void fill_initialize(size_type n, const T value) &#123;</span><br><span class="line">    start = allocate_and_fill(n, value);  // 配置空間並設初值</span><br><span class="line">    finish = start + n;             // 調整水位</span><br><span class="line">    end_of_storage = finish;            // 調整水位</span><br><span class="line">  &#125;</span><br><span class="line">iterator allocate_and_fill(size_type n, const T x) &#123;</span><br><span class="line">    iterator result = data_allocator::allocate(n); // 配置n個元素空間</span><br><span class="line">      <span class="comment">// 全域函式，記憶體低階工具，將result所指之未初始化空間設定初值為 x，n個</span></span><br><span class="line">      <span class="comment">// 定義於 &lt;stl_uninitialized.h&gt;。</span></span><br><span class="line">      uninitialized_fill_n(result, n, x);  </span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，最终都调用了函数uninitialized_fill_n初始化数据。这个stl的全局函数保证申请内存时候不会调用构造函数做额外的事情，也就是申请内存后，再用数据初始化。下面再看看其余几个操作。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void push_back(const T x) &#123;</span><br><span class="line">   <span class="keyword">if</span> (finish != end_of_storage) &#123;  <span class="comment">// 還有備用空間</span></span><br><span class="line">     construct(finish, x);         // 直接在備用空間中建構元素。</span><br><span class="line">     ++finish;                             // 調整水位高度</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>                                  <span class="comment">// 已無備用空間</span></span><br><span class="line">     insert_aux(end(), x);         </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void pop_back() &#123;</span><br><span class="line">   --finish;</span><br><span class="line">   destroy(finish);    // 全域函式，建構/解構基本工具。</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 將迭代器 position 所指之元素移除</span></span><br><span class="line"> iterator erase(iterator <span class="attribute">position</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="attribute">position</span> + <span class="number">1</span> != end()) // 如果 p 不是指向最後一個元素</span><br><span class="line">     <span class="comment">// 將 p 之後的元素一一向前遞移</span></span><br><span class="line">     copy(<span class="attribute">position</span> + <span class="number">1</span>, finish, position); </span><br><span class="line"></span><br><span class="line">   --finish;  // 調整水位</span><br><span class="line">   destroy(finish);    // 全域函式，建構/解構基本工具。</span><br><span class="line">   return <span class="attribute">position</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> iterator erase(iterator first, iterator last) &#123;</span><br><span class="line">   iterator i = copy(last, finish, first);</span><br><span class="line">   destroy(i, finish); // 全域函式，建構/解構基本工具。</span><br><span class="line">   finish = finish - (last - first);</span><br><span class="line">   return first;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>push_back在还有空间的情况下，也只需要调用construct函数构造数据，否则就需要调用insert_aux申请新的内存，再添加数据了。pop_back相对就简单很多。erase函数也涉及到一些移动内存块的操作，思路基本是先移动内存，然后把末尾多出来的数据析构掉（调用destroy函数）。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值到颜色的自然映射</title>
      <link href="/2015/06/08/%E6%95%B0%E5%80%BC%E5%88%B0%E9%A2%9C%E8%89%B2%E7%9A%84%E8%87%AA%E7%84%B6%E6%98%A0%E5%B0%84/"/>
      <url>/2015/06/08/%E6%95%B0%E5%80%BC%E5%88%B0%E9%A2%9C%E8%89%B2%E7%9A%84%E8%87%AA%E7%84%B6%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>很久没更新博客了。额，一直想写这个来着。记得以前写过绘制三维标量场的文章，方法是找的渐变颜色纹理图片，然后用一维纹理坐标映射贴上去的。后面发现根本不需要去找图片，这种渐变色本来就是一种颜色空间的定义。<a href="http://baike.baidu.com/link?url=RUroPPZprWlPOJx8JaodE2Je0wql6wHv0N3LigWMqsRjCxxVDAT_yWwGYL4myeEkHTKIeBxFbC9qjwvrzD2XlzgyxW-2lUZ25TyUePioufQBbhhZSTRB5VUApB0gCfgsJPG-CtbbTBBs3DacsTvMAFk5YzmyeD5uius5R5vTr3sPZbGsfmiL-6ovaPXrncfqk0vcp8KhirUnmKEEZdR_0q" target="_blank" rel="noopener">请看hsv颜色模型</a>，这种颜色模型类似于rgb，也是三个分量h（色调），s（饱和度），v（亮度）。h表示的绕圆锥的一周，也就是纯颜色的渐变，正是我们需要的东西。s表示从圆心到圆边缘的半径，0-1的范围，表示颜色纯度。v则是垂直的轴，表示亮度。如下图，我们要的就是绕圈一周的颜色渐变。</p><p><img alt data-src="https://c2.staticflickr.com/8/7213/27452089865_0225e3c1e8_o.png"></p><p>总体思路就是数值0-1，映射到hsv颜色空间的（0-360,1,255）。实现标量场的方法是，首先，将hsv的（0-360,1,255）转换为rgb，保存为一维数组。以该数组为数据，生成一维纹理，数值0-1作为纹理坐标，再贴图即可生成标量场。下面是用该方法生成标量场的相关代码。首先是构造一维纹理数组，然后用其生成1d纹理。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int CTexture::BuildColorMapTexture()</span><br><span class="line">&#123;</span><br><span class="line">        const int COLOR_SIZE = 240;//红到蓝</span><br><span class="line">        ImageRGBA colorMap(COLOR_SIZE, 1);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; COLOR_SIZE; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            colorMap.pixel(i, 0) = Hsv2Rgb(i, 1, 255);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class="line">        glGenTextures(1, m_uTexName);</span><br><span class="line">        glBindTexture(GL_TEXTURE_1D, m_uTexName);</span><br><span class="line"></span><br><span class="line">        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">        glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);</span><br><span class="line">        glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成2d的Mipmap纹理</span></span><br><span class="line">        int nRet = gluBuild1DMipmaps(GL_TEXTURE_1D, <span class="number">4</span>, COLOR_SIZE, GL_RGBA, GL_UNSIGNED_BYTE,</span><br><span class="line">            colorMap.raw());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hsv2rgb的代码如下，从网上可以随便找个修改。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">PixelRGBA Hsv2Rgb(<span class="attribute">float</span> H, float S, float V)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attribute">float</span> R, G, B;</span><br><span class="line"></span><br><span class="line">        int i;</span><br><span class="line">        <span class="attribute">float</span> f, p, q, t;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// achromatic (grey)</span></span><br><span class="line">            R = G = B = V;</span><br><span class="line">            return V4B(R, G, B, 255);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        H /= 60; // sector 0 to 5</span><br><span class="line">        i = floor( H );</span><br><span class="line">        f = H - i; // factorial part of h</span><br><span class="line">        p = V * ( 1 - S );</span><br><span class="line">        q = V * ( 1 - S * f );</span><br><span class="line">        t = V * ( 1 - S * ( 1 - f ) );</span><br><span class="line"></span><br><span class="line">        switch( <span class="selector-tag">i</span> )</span><br><span class="line">        &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            R = V;</span><br><span class="line">            G = t;</span><br><span class="line">            B = p;</span><br><span class="line">            break;</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            R = q;</span><br><span class="line">            G = V;</span><br><span class="line">            B = p;</span><br><span class="line">            break;</span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            R = p;</span><br><span class="line">            G = V;</span><br><span class="line">            B = t;</span><br><span class="line">            break;</span><br><span class="line">        case <span class="number">3</span>:</span><br><span class="line">            R = p;</span><br><span class="line">            G = q;</span><br><span class="line">            B = V;</span><br><span class="line">            break;</span><br><span class="line">        case <span class="number">4</span>:</span><br><span class="line">            R = t;</span><br><span class="line">            G = p;</span><br><span class="line">            B = V;</span><br><span class="line">            break;</span><br><span class="line">        default: <span class="comment">// case 5:</span></span><br><span class="line">            R = V;</span><br><span class="line">            G = p;</span><br><span class="line">            B = q;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return V4B(R, G, B, 255);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的事情就是使用BuildColorMapTexture生成1d纹理，然后将数值作为1d纹理坐标设置好就行了。下面是相关的效果图：</p><p>颜色空间转换生成纹理：</p><p><img alt data-src="https://c2.staticflickr.com/8/7138/26844818173_cb7558cfc0_o.png"></p><p>渐变纹理贴图：</p><p><img alt data-src="https://c8.staticflickr.com/8/7638/27452089775_9fe5365f97_o.jpg"><img alt data-src="https://c2.staticflickr.com/8/7365/27175625310_f7f44d74d5_o.png"></p><p>不同的方法效果有区别，原因可能是贴图的数据更精细，而且同一范围比如0-0.3对应的颜色就可能不一致。马上要毕业了，工作内容是游戏开发，以后估计不会再更新读研期间类似的文章的了。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 颜色映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骑行靖港古镇</title>
      <link href="/2015/05/25/%E9%AA%91%E8%A1%8C%E9%9D%96%E6%B8%AF%E5%8F%A4%E9%95%87/"/>
      <url>/2015/05/25/%E9%AA%91%E8%A1%8C%E9%9D%96%E6%B8%AF%E5%8F%A4%E9%95%87/</url>
      
        <content type="html"><![CDATA[<p>很久没骑这么远了。第一次骑三天都不知道是怎么坚持过来的。总的感觉，身体比去年好太多了。虽然脚累，但是呼吸完全不乱，完全不会心累。中午吃错东西了，一开始就来个闹肚子、过敏。我对某种食物强过敏，当时就在为自己生命安全思考了。本打算骑到附近的梅溪湖算了，但是吹了下风，觉得过敏消散了，就坚持走走看吧。</p><p>雷锋大道真的好远，从河西走完整个望城。经过去年的洗心禅寺，发现好近额。为啥去年我走这么点距离会觉得好累了。有些改变确实在不知不觉。不管是身，还是心。永远健康充满活力的身体，是追寻幸福的必要条件。</p><p>最后，附图一张。</p><p><img alt data-src="https://c6.staticflickr.com/8/7623/27380509141_e028f6958d_o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骑行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stl源码剖析之sort</title>
      <link href="/2015/04/22/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bsort/"/>
      <url>/2015/04/22/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bsort/</url>
      
        <content type="html"><![CDATA[<p>排序的重要性就不用说了。stl里面的很多容器都是自序的，比如set和map，从begin到end就是一个顺序，毕竟最基本的概念就是一颗搜索树。另外，stack、queue、priority_queue的顺序也是内部实现决定的，不用多说了。list则不支持随机迭代器，内部也提供sort函数。所以，stl里面的sort泛型算法针对的是vector，deque，原生数组之类的数据。正常情况下，用的最多的也就是vector了。</p><p>插入排序和快速排序大家都知道是什么。但是，stl里面的sort并不仅仅是一个快速排序，而是一个复杂的组合体，有人把它叫做intro_sort。下面说一下introsort的几点要点。</p><p>1&gt; 递归层次的限制，超过一定层次直接堆排序剩余数据。</p><p>2&gt; 数据长度小于一定值，直接返回，不继续排序。</p><p>3&gt;递归结束后，得到多段相互之间有序的数据（段内部无序），再进行一次优化的插入排序。</p><p>4&gt;轴元素选取采用三点取中法，以避免分割不均。</p><p>sort的代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">inline void sort(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    __introsort_loop(first, last, value_type(first), __lg(last - first) * 2);</span><br><span class="line">    __final_insertion_sort(first, last);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看到，sort内部调用的是<strong>introsort_loop排序得到多段互相之间有序的小段，再进行插入排序。其中，</strong>lg是计算递归层次，定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出 2^k &lt;= n 的最大值k。例，n=7，得k=2，n=20，得k=4，n=8，得k=3。</span></span><br><span class="line">template &lt;class Size&gt;</span><br><span class="line">inline Size __lg(Size n) &#123;</span><br><span class="line">  Size k;</span><br><span class="line">  for (k = 0; n &gt; 1; n &gt;&gt;= 1) ++k;</span><br><span class="line">  return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，可以看出长度为64的数据，其递归层次不能超过16。如果超过，则进行堆排序。__introsort_loop的代码如下，是整个算法的关键。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator, class T, class Size&gt;</span><br><span class="line">void __introsort_loop(RandomAccessIterator first,</span><br><span class="line">                      RandomAccessIterator last, T*,</span><br><span class="line">                      Size depth_limit) &#123;</span><br><span class="line">  <span class="comment">// 以下，__stl_threshold 是個全域常數，稍早定義為 const int 16。</span></span><br><span class="line">  while (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth_limit == <span class="number">0</span>) &#123;             <span class="comment">// 至此，切割惡化</span></span><br><span class="line">      partial_sort(first, last, last);  // 改用 heapsort</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    --depth_limit;</span><br><span class="line">    <span class="comment">// 以下是 median-of-three partition，選擇一個夠好的樞軸並決定切割點。</span></span><br><span class="line">    <span class="comment">// 切割點將落在迭代器 cut 身上。</span></span><br><span class="line">    RandomAccessIterator cut = __unguarded_partition</span><br><span class="line">      (first, last, T(__median(*first, *(first + (last - first)/<span class="number">2</span>),</span><br><span class="line">                               *(last - 1))));</span><br><span class="line">    <span class="comment">// 對右半段遞迴進行 sort.</span></span><br><span class="line">    __introsort_loop(cut, last, value_type(first), depth_limit);</span><br><span class="line">    last = cut;</span><br><span class="line">    <span class="comment">// 現在回到while 迴圈，準備對左半段遞迴進行 sort.</span></span><br><span class="line">    <span class="comment">// 這種寫法可讀性較差，效率並沒有比較好。</span></span><br><span class="line">    <span class="comment">// RW STL 採用一般教科書寫法（直觀地對左半段和右半段遞迴），較易閱讀。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里面可以看出，stl里面定义了个常数<strong>stl_threshold决定要不要继续循环，如果数据的长度比该值小，那么就不继续递归排序了，除非是调用了堆排，长度小于</strong>stl_threshold的段是没有经过排序的。当层次耗尽，depth_limit为0，直接调用partial_sort堆排序返回。另外的部分，就是采用三点取中法决定轴元素。还有这个代码写成了类似尾递归的形式，与教科书上不一致，较难阅读和理解。<br>__median的代码如下，容易理解。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">inline const T __median(const T <span class="selector-tag">a</span>, const T <span class="selector-tag">b</span>, const T c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="selector-tag">a</span> &lt; b)</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">b</span> &lt; c)      <span class="comment">// a &lt; b &lt; c</span></span><br><span class="line">      return b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="selector-tag">a</span> &lt; c) <span class="comment">// a &lt; b, b &gt;= c, a &lt; c</span></span><br><span class="line">      return c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      return a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="selector-tag">a</span> &lt; c)   <span class="comment">// c &gt; a &gt;= b</span></span><br><span class="line">    return a;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="selector-tag">b</span> &lt; c)       <span class="comment">// a &gt;= b, a &gt;= c, b &lt; c</span></span><br><span class="line">    return c;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__unguarded_partition与教科书上的partion实现不同，实现简单而且高效。其代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator, class T&gt;</span><br><span class="line">RandomAccessIterator __unguarded_partition(RandomAccessIterator first,</span><br><span class="line">                                           RandomAccessIterator last,</span><br><span class="line">                                           T pivot) &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line"></span><br><span class="line">    while (*first &lt; pivot) ++first; // first 找到 &gt;= pivot 的元素，就停下來</span><br><span class="line">    --last;                     // 調整</span><br><span class="line">    while (pivot &lt; *last) --last;   // last 找到 &lt;= pivot 的元素，就停下來</span><br><span class="line">    <span class="comment">// 注意，以下first &lt; last 判斷動作，只適用於random iterator</span></span><br><span class="line">    if (!(first &lt; last)) return first;  // 交錯，結束迴圈。</span><br><span class="line">    iter_swap(first, last);             // 大小值交換</span><br><span class="line">    ++first;                            // 調整</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回到sort函数中，最后的插入排序__final_insertion_sort。该函数再进行一次插入排序，由于小段之间都是有序的，因此该函数很快就能执行完。其代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">void __final_insertion_sort(RandomAccessIterator first,</span><br><span class="line">                            RandomAccessIterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (last - first &gt; __stl_threshold) &#123;</span><br><span class="line">    __insertion_sort(first, first + __stl_threshold);</span><br><span class="line">    __unguarded_insertion_sort(first + __stl_threshold, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __insertion_sort(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数判断当前排序范围是不是小于等于于<strong>stl_threshold（16），如果是，直接进行优化的插入排序</strong>insertion_sort。否则，排序前面的16个元素，再调用<strong>unguarded_insertion_sort排序剩下的元素。</strong>unguarded_insertion_sort的相关定义代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">inline void __unguarded_insertion_sort(RandomAccessIterator first,</span><br><span class="line">                                RandomAccessIterator last) &#123;</span><br><span class="line">  __unguarded_insertion_sort_aux(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class T&gt;</span><br><span class="line">void __unguarded_insertion_sort_aux(RandomAccessIterator first,</span><br><span class="line">                                    RandomAccessIterator last, T*) &#123;</span><br><span class="line">  for (RandomAccessIterator i = first; i != last; ++i)</span><br><span class="line">    __unguarded_linear_insert(i, T(*i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__insertion_sort的相关代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">  if (first == last) return;</span><br><span class="line">  for (RandomAccessIterator i = first + 1; i != last; ++i)  // 外迴圈</span><br><span class="line">    __linear_insert(first, i, value_type(first));   // first,i形成一個子範圍</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class T&gt;</span><br><span class="line">inline void __linear_insert(RandomAccessIterator first,</span><br><span class="line">                                  RandomAccessIterator last, T*) &#123;</span><br><span class="line">  T value = *last;      // 記錄尾元素</span><br><span class="line">  <span class="keyword">if</span> (value &lt; *first) &#123; <span class="comment">// 尾比頭還小（那就別一個個比較了，一次做完…）</span></span><br><span class="line">    copy_backward(first, last, last + 1); // 將整個範圍向右遞移一個位置</span><br><span class="line">    *first = value;     // 令頭元素等於原先的尾元素值</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __unguarded_linear_insert(last, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class T&gt;</span><br><span class="line">void __unguarded_linear_insert(RandomAccessIterator last, T value) &#123;</span><br><span class="line">  RandomAccessIterator next = last;</span><br><span class="line">  --next;</span><br><span class="line">  <span class="comment">// insertion sort 的內迴圈</span></span><br><span class="line">  <span class="comment">// 注意，一旦不出現逆轉對（inversion），迴圈就可以結束了。</span></span><br><span class="line">  while (value &lt; *next) &#123;   <span class="comment">// 逆轉對（inversion）存在</span></span><br><span class="line">    *last = *next;      // 轉正</span><br><span class="line">    last = next;            // 調整迭代器</span><br><span class="line">    --next;             // 前進一個位置</span><br><span class="line">  &#125;</span><br><span class="line">  *last = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，关于插入排序的代码比sort其它部分的代码都要多，可见stl对插入排序进行了特别的优化，以使得其在处理接近有序数据的时候，速度非常快。从代码中可以看到，这些函数最终都调用了__unguarded_linear_insert函数，该函数优化了插入排序的实现。该函数的思路是从后往前找是否存在比value小的元素，如果还存在，就往后移动数据一个位置。最终，得到的是value需要插入的位置。根据stl源码剖析作者的说法，该函数不需要判断越界，因此提高了速度。在大数据量的排序中，优势很大。毕竟，该函数会被sort频繁调用。</p><p>关于插入排序代码实现的具体思路，参考stl源码剖析一书。本文的代码也取自该书提供的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Eigen解稀疏线性方程组</title>
      <link href="/2015/04/22/%E4%BD%BF%E7%94%A8Eigen%E8%A7%A3%E7%A8%80%E7%96%8F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>/2015/04/22/%E4%BD%BF%E7%94%A8Eigen%E8%A7%A3%E7%A8%80%E7%96%8F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>这里只讲解稀疏矩阵表示的线性系统。最新版本的eigen已经支持稀疏矩阵，以及相关操作了。eigen相对其它库的最大优势，默认情况下，只需要eigen的头文件即可，不需要其它依赖库，除非用对应的加速解法（需要更快的库支持）。所以，eigen就是个牛逼的模板矩阵库。虽然在使用的时候需要套用不少模板参数，有点麻烦。</p><p>eigen里面定义稀疏矩阵，然后加入数据的一种方式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Eigen::SparseMatrix&lt;<span class="attribute">float</span>&gt; smA(m_nRow, m_nColumn);</span><br><span class="line"></span><br><span class="line">std::sort(m_pSI, m_pSI + m_nNum);//排序，列主序</span><br><span class="line">for (int i = 0; i &lt; m_nNum; ++i)// 初始化非零元素</span><br><span class="line">&#123;</span><br><span class="line">    smA.insert(m_pSI[i].r, m_pSI[i].c) = m_pSI[i].v;</span><br><span class="line">&#125;</span><br><span class="line">smA.makeCompressed();</span><br></pre></td></tr></table></figure><p>代码非常简单，makeCompressed是可选的，具体原因不怎么清楚，参考官方文档。<br>知道定义了稀疏矩阵之后，就可以解稀疏线性系统Ax=b了。A作为稀疏系数矩阵输入。eigen里面有多种解线性系统的方法，官方文档有说明。其中，QR分解适合于任何大小的稀疏矩阵A，并且被推荐用来解最小二乘法问题，适用范围很广。下面的是QR分解求线性系统的代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个QR分解的实例</span></span><br><span class="line">Eigen::SparseQR&lt;Eigen::SparseMatrix&lt;<span class="attribute">float</span>&gt;, Eigen::COLAMDOrdering&lt;int&gt;&gt; linearSolver;</span><br><span class="line"><span class="comment">// 计算分解</span></span><br><span class="line">linearSolver.compute(smA);</span><br><span class="line"></span><br><span class="line">Eigen::VectorXf vecB(m_nRow);</span><br><span class="line">for (int i = 0; i &lt; m_nRow; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    vecB[i] = pColumnB[i];</span><br><span class="line">&#125;</span><br><span class="line">Eigen::VectorXf vecX = linearSolver.solve(vecB);// 求一个A*x = b</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; m_nColumn; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    pX[i] = vecX[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的思路是先定义一个QR分解的线性solver，然后调用compute分解。再传入b，再调用solve函数求解，再传出数据。逻辑很简单。值得注意的是，这里用了float来计算，是因为qr分解比较耗内存，如果矩阵过大或者非0值过多就会计算不过来。因此，用float来减少一半内存，不过精度比double下降了，具体看实际需要选择float还是double。至于QR分解的原理，请参考维基百科等。<br>如果使用迭代的办法解线性方程组，该怎么用eigen实现了。eigen里面也提供了迭代的solver，不过要求稀疏矩阵A是方阵。那么，把A转换为方阵即可。Ax=b的两边同时乘以A的转置，得到A’Ax=A’b(A’是A的转置)，再用迭代solver求解。如果得到的答案误差较大，可以在两边乘以个（-1）。如下代码所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把A*X = b，转换为A'*A*X = A'*b，其中A'是A的转置，貌似计算结果不是很对，故没有使用该函数</span></span><br><span class="line">    int CSparseMatrix::SolveLinearSystemByEigenIterative(double* pColumnB, double* pX)</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::SparseMatrix&lt;<span class="attribute">float</span>&gt; smA(m_nRow, m_nColumn);</span><br><span class="line"></span><br><span class="line">        std::sort(m_pSI, m_pSI + m_nNum);//排序，列主序</span><br><span class="line">        for (int i = 0; i &lt; m_nNum; ++i)//初始化非零元素</span><br><span class="line">        &#123;</span><br><span class="line">            smA.insert(m_pSI[i].r, m_pSI[i].c) = m_pSI[i].v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Eigen::SparseMatrix&lt;float&gt; smATranspose = smA.transpose();</span><br><span class="line"></span><br><span class="line">        Eigen::VectorXf vecB(m_nRow);</span><br><span class="line">        for (int i = 0; i &lt; m_nRow; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vecB[i] = pColumnB[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vecB = smATranspose * vecB;//b = A'*b</span><br><span class="line">        vecB = (-1) * vecB;</span><br><span class="line"></span><br><span class="line">        smA = smATranspose * smA;//A = A'*A</span><br><span class="line">        smA = (-1) * smA;</span><br><span class="line">        smA.makeCompressed();</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; smA &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">        Eigen::BiCGSTAB&lt;Eigen::SparseMatrix&lt;<span class="attribute">float</span>&gt;&gt; linearSolver;</span><br><span class="line">        linearSolver.compute(smA);</span><br><span class="line">        Eigen::VectorXf vecX = linearSolver.solve(vecB);// 求一个A*x = b</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "#iterations:     " &lt;&lt; linearSolver.iterations() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; "estimated error: " &lt;&lt; linearSolver.error()      &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m_nColumn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pX[i] = vecX[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代解法对应的头文件是#include “Eigen/IterativeLinearSolvers”。QR分解求线性系统的完整代码如下，相关定义很容易看懂。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适合于解决最小二乘法问题</span></span><br><span class="line">    int CSparseMatrix::SolveLinearSystemByEigenQR(double* pColumnB, double* pX)</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::SparseMatrix&lt;<span class="attribute">float</span>&gt; smA(m_nRow, m_nColumn);</span><br><span class="line"></span><br><span class="line">        std::sort(m_pSI, m_pSI + m_nNum);//排序，列主序</span><br><span class="line">        for (int i = 0; i &lt; m_nNum; ++i)// 初始化非零元素</span><br><span class="line">        &#123;</span><br><span class="line">            smA.insert(m_pSI[i].r, m_pSI[i].c) = m_pSI[i].v;</span><br><span class="line">        &#125;</span><br><span class="line">        smA.makeCompressed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; smA &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个QR分解的实例</span></span><br><span class="line">        Eigen::SparseQR&lt;Eigen::SparseMatrix&lt;<span class="attribute">float</span>&gt;, Eigen::COLAMDOrdering&lt;int&gt;&gt; linearSolver;</span><br><span class="line">        <span class="comment">// 计算分解</span></span><br><span class="line">        linearSolver.compute(smA);</span><br><span class="line"></span><br><span class="line">        Eigen::VectorXf vecB(m_nRow);</span><br><span class="line">        for (int i = 0; i &lt; m_nRow; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vecB[i] = pColumnB[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Eigen::VectorXf vecX = linearSolver.solve(vecB);// 求一个A*x = b</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m_nColumn; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pX[i] = vecX[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  QR分解对应的头文件是#include “Eigen/SparseQR”。&lt;/pre&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性方程组 </tag>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++调用MATLAB引擎求解线性方程组</title>
      <link href="/2015/04/12/C++%E8%B0%83%E7%94%A8MATLAB%E5%BC%95%E6%93%8E%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"/>
      <url>/2015/04/12/C++%E8%B0%83%E7%94%A8MATLAB%E5%BC%95%E6%93%8E%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>以前写过一篇<a href="http://www.xpc-yx.com/2015/01/20/%E4%BD%BF%E7%94%A8c%E8%B0%83%E7%94%A8matlab%E5%BC%95%E6%93%8E%E8%AE%A1%E7%AE%97%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/" target="_blank" rel="noopener" title="C++调用MATLAB引擎计算特征向量">C++调用MATLAB引擎计算特征向量</a>，里面讲了如何配置环境等等。现在又有一个新的需求，求解线性系统。又想起了MATLAB这个工具，于是又写了个小类。这里要求解的是AX=B。其中，A是m*n的矩阵，X是n维行向量，B是m维列向量。MATLAB里面求解很简单X=A\B。</p><p>该类的头文件如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求解线性系统AX = B.</span></span><br><span class="line">    <span class="comment">//A是Row*Column的矩阵,B是Row*1的列向量</span></span><br><span class="line">    class CLinearSystem</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        CLinearSystem() &#123;&#125;</span><br><span class="line">        CLinearSystem(double* pMatrixA, int nRow, int nColumn, double* pColumnB);</span><br><span class="line">        ~CLinearSystem() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        void GetResult(double* pX);//pX保证能输出m_nColumn个元素</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        double* m_pMatrixA;</span><br><span class="line">        double* m_pColumnB;</span><br><span class="line">        int m_nRow;</span><br><span class="line">        int m_nColumn;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>源文件如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"LinearSystem.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;cassert&gt;</span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"engine.h"</span></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"libeng.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"libmx.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"libmat.lib"</span>)</span><br><span class="line"></span><br><span class="line">    CLinearSystem::CLinearSystem(double* pMatrixA, int nRow, int nColumn, double* pColumnB)</span><br><span class="line">        : m_pMatrixA(pMatrixA), m_nRow(nRow), m_nColumn(nColumn), m_pColumnB(pColumnB)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void CLinearSystem::GetResult(double* pX)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pX != NULL);</span><br><span class="line"></span><br><span class="line">        Engine *ep = NULL;</span><br><span class="line">        <span class="keyword">if</span> (!(ep = engOpen(NULL)))<span class="comment">//打开matlab引擎</span></span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, "\nCan't start MATLAB engine\n");</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mxArray* matrixA = mxCreateDoubleMatrix(m_nRow, m_nColumn, mxREAL);</span><br><span class="line">        <span class="comment">//matlab里面的矩阵是列主顺序，这里需要变换位置</span></span><br><span class="line">        double* pA = mxGetPr(matrixA);</span><br><span class="line">        for (int j = 0; j &lt; m_nColumn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; m_nRow; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                *pA++ = *(m_pMatrixA + i * m_nColumn + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mxArray* columnB = mxCreateDoubleMatrix(m_nRow, 1, mxREAL);</span><br><span class="line">        memcpy(mxGetPr(columnB), m_pColumnB, sizeof(double) * m_nRow * 1);</span><br><span class="line"></span><br><span class="line">        engPutVariable(ep, "A", matrixA);</span><br><span class="line">        engPutVariable(ep, "B", columnB);</span><br><span class="line">        engEvalString(ep, "X = A\\B;");</span><br><span class="line"></span><br><span class="line">        mxArray* rowX = engGetVariable(ep, "X"); //返回计算结果</span><br><span class="line">        memcpy(pX, mxGetPr(rowX), sizeof(double) * m_nColumn);</span><br><span class="line"></span><br><span class="line">        mxDestroyArray(matrixA);</span><br><span class="line">        mxDestroyArray(columnB);</span><br><span class="line">        mxDestroyArray(rowX);</span><br><span class="line">        engClose(ep);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该类里面就一个计算结果的函数。实现的过程也很简单，打开MATLAB引擎，创建了对应的矩阵和向量，计算表达式。注意，”X = A\\B;”中必须加转义\。另外，MATLAB中的矩阵是列主序的，也就是按照列存储的。所以，从C++的矩阵变换到MATLAB矩阵需要重新设置值，而不是简单的拷贝内存。<br><span style="font-family: Georgia, 'Times New Roman', 'Bitstream Charter', Times, serif; line-height: 1.5;">  如果，A是巨大的稀疏矩阵，那么就应该创建稀疏矩阵来计算了。测试代码如下：</span></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试线性系统</span></span><br><span class="line">int nRow = 3, nColumn = 2;</span><br><span class="line">double pA[3][2] = &#123; &#123;4, 5&#125;, &#123;1, 2&#125;, &#123;3, 1&#125; &#125;;</span><br><span class="line">double pB[3] = &#123;3, 15, 12&#125;;</span><br><span class="line">CLinearSystem ls((double*)pA, nRow, nColumn, pB);</span><br><span class="line">double pX[2];</span><br><span class="line">ls.GetResult(pX);</span><br><span class="line">printf("%f %f\n", pX[0], pX[1]);</span><br></pre></td></tr></table></figure><p>输出为：3.000000 -0.600000</p><p>前面说了，系数矩阵的事情，现在代码进行了更新，加入了稀疏矩阵，A可以是稀疏矩阵传入，B的话没有当做稀疏矩阵传入了。不过，在调用MATLAB代码时候还是得作为稀疏矩阵。具体代码如下，就不细说了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pragma</span> once</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifndef</span> LIBYX_LINEAR_SYSTEM_H</span><br><span class="line"><span class="number">#def</span>ine LIBYX_LINEAR_SYSTEM_H</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"MatlabSparseMatrix.h"</span></span><br><span class="line"></span><br><span class="line">namespace LibYX</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求解线性系统AX = B.</span></span><br><span class="line">    <span class="comment">//A是Row*Column的矩阵,B是Row*1的列向量</span></span><br><span class="line">    class CLinearSystem</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        CLinearSystem() &#123;&#125;</span><br><span class="line">        CLinearSystem(double* pMatrixA, int nRow, int nColumn, double* pColumnB);</span><br><span class="line">        CLinearSystem(MatlabSparseInfor* pSI, int nNum, int nRow, int nColumn, double* pColumnB);</span><br><span class="line">        ~CLinearSystem() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        void GetResult(double* pX);//pX保证能输出m_nColumn个元素</span><br><span class="line">        void GetResultSparse(double* pX);//中间过程使用稀疏矩阵计算结果</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        double* m_pMatrixA;</span><br><span class="line">        double* m_pColumnB;</span><br><span class="line">        int m_nRow;</span><br><span class="line">        int m_nColumn;</span><br><span class="line"></span><br><span class="line">    private:<span class="comment">//稀疏矩阵形式输入A</span></span><br><span class="line">        MatlabSparseInfor* m_pSI;</span><br><span class="line">        int m_nNum;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"LinearSystem.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;cassert&gt;</span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"engine.h"</span></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"libeng.lib"</span>) </span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"libmx.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"libmat.lib"</span>)</span><br><span class="line"></span><br><span class="line">namespace LibYX</span><br><span class="line">&#123;</span><br><span class="line">    CLinearSystem::CLinearSystem(double* pMatrixA, int nRow, int nColumn, double* pColumnB)</span><br><span class="line">        : m_pMatrixA(pMatrixA), m_nRow(nRow), m_nColumn(nColumn), m_pColumnB(pColumnB)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CLinearSystem::CLinearSystem(MatlabSparseInfor* pSI, int nNum, int nRow, int nColumn, double* pColumnB)</span><br><span class="line">        : m_pSI(pSI), m_nNum(nNum), m_nRow(nRow), m_nColumn(nColumn), m_pColumnB(pColumnB)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void CLinearSystem::GetResult(double* pX)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pX != NULL);</span><br><span class="line"></span><br><span class="line">        Engine *ep = NULL;</span><br><span class="line">        <span class="keyword">if</span> (!(ep = engOpen(NULL)))<span class="comment">//打开matlab引擎</span></span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, "\nCan't start MATLAB engine\n");</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mxArray* matrixA = mxCreateDoubleMatrix(m_nRow, m_nColumn, mxREAL);</span><br><span class="line">        <span class="comment">//matlab里面的矩阵是列主顺序，这里需要变换位置</span></span><br><span class="line">        double* pA = mxGetPr(matrixA);</span><br><span class="line">        for (int j = 0; j &lt; m_nColumn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; m_nRow; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                *pA++ = *(m_pMatrixA + i * m_nColumn + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mxArray* columnB = mxCreateDoubleMatrix(m_nRow, 1, mxREAL);</span><br><span class="line">        memcpy(mxGetPr(columnB), m_pColumnB, sizeof(double) * m_nRow * 1);</span><br><span class="line"></span><br><span class="line">        engPutVariable(ep, "A", matrixA);</span><br><span class="line">        engPutVariable(ep, "B", columnB);</span><br><span class="line">        engEvalString(ep, "X = A\\B;");</span><br><span class="line"></span><br><span class="line">        mxArray* rowX = engGetVariable(ep, "X"); //返回计算结果</span><br><span class="line">        memcpy(pX, mxGetPr(rowX), sizeof(double) * m_nColumn);</span><br><span class="line"></span><br><span class="line">        mxDestroyArray(matrixA);</span><br><span class="line">        mxDestroyArray(columnB);</span><br><span class="line">        mxDestroyArray(rowX);</span><br><span class="line">        engClose(ep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void CLinearSystem::GetResultSparse(double* pX)</span><br><span class="line">    &#123;</span><br><span class="line">        Engine *ep = NULL;</span><br><span class="line">        <span class="keyword">if</span> (!(ep = engOpen(NULL)))<span class="comment">//打开matlab引擎</span></span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, "\nCan't start MATLAB engine\n");</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下代码构造稀疏系数矩阵</span></span><br><span class="line">        mxArray* sm = mxCreateSparse(m_nRow, m_nColumn, m_nNum, mxREAL);</span><br><span class="line">        double* pr = mxGetPr(sm);</span><br><span class="line">        mwIndex* ir = mxGetIr(sm); </span><br><span class="line">        mwIndex* jc = mxGetJc(sm); </span><br><span class="line"></span><br><span class="line">        int k = 0;</span><br><span class="line">        int nLastC = -1;</span><br><span class="line">        for (int i = 0; i &lt; m_nNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pr[i] = m_pSI[i].v;</span><br><span class="line">            ir[i] = m_pSI[i].r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_pSI[i]<span class="selector-class">.c</span> != nLastC)</span><br><span class="line">            &#123;</span><br><span class="line">                jc[k] = i;</span><br><span class="line">                nLastC = m_pSI[i].c;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jc[k] = m_nNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以下代码构造稀疏列</span></span><br><span class="line">        mxArray* columnB = mxCreateSparse(m_nRow, 1, m_nRow, mxREAL);</span><br><span class="line">        pr = mxGetPr(columnB);</span><br><span class="line">        ir = mxGetIr(columnB); </span><br><span class="line">        jc = mxGetJc(columnB); </span><br><span class="line"></span><br><span class="line">        jc[0] = 0;</span><br><span class="line">        for (int i = 0; i &lt; m_nRow; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pr[i] = m_pColumnB[i];</span><br><span class="line">            ir[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        jc[1] = m_nRow;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将构造的稀疏矩阵传入MATLAB命令中</span></span><br><span class="line">        engPutVariable(ep, "sm", sm);</span><br><span class="line">        engPutVariable(ep, "columnB", columnB);</span><br><span class="line">        engEvalString(ep, "X = sm\\columnB;");</span><br><span class="line"></span><br><span class="line">        mxArray* rowX = engGetVariable(ep, "X"); //返回计算结果</span><br><span class="line">        memcpy(pX, mxGetPr(rowX), sizeof(double) * m_nColumn);</span><br><span class="line"></span><br><span class="line">        mxDestroyArray(rowX);</span><br><span class="line">        mxDestroyArray(columnB);</span><br><span class="line">        mxDestroyArray(sm);</span><br><span class="line">        engClose(ep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性方程组 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++实现反射机制</title>
      <link href="/2015/04/11/C++%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2015/04/11/C++%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>这是一个很老的话题了。所谓的反射机制，其实就是MFC里面的对象动态创建。比如说，给一个字符串代表类名，比如”CMesh”，根据这个字符串创建出一个CMesh对象。有不同的实现方法，在MFC里面是用一张巨大的链表网络把所有的类的信息链接起来，里面存储了类名和构造函数，动态创建的时候按照一定的顺序去里面搜索创建函数（构造函数）。</p><p>与其用一张链表网，不如用一个字典保存起来，键是类名字符串，值是对应的构造函数。看起来很简单的样子，确实也很简单额。只是实现起来有些trick，比如字典一般是类的静态成员等。。。假设只有无参数的构造函数，首先定义上面所述的内容，类的字典。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line">    typedef void* (*CreateFuntion)(void);</span><br><span class="line"></span><br><span class="line">    class CClassFactory</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        CClassFactory() &#123;&#125;</span><br><span class="line">        ~CClassFactory() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        static void* GetClassByName(std::string name)</span><br><span class="line">        &#123;</span><br><span class="line">            std::map&lt;std::string, CreateFuntion&gt;::const_iterator find;</span><br><span class="line">            find = m_clsMap.find(name);  </span><br><span class="line"></span><br><span class="line">            if(find==m_clsMap.end())</span><br><span class="line">            &#123;  </span><br><span class="line"></span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                return find-&gt;second();</span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        static void RegistClass(std::string name, CreateFuntion method)</span><br><span class="line">        &#123;</span><br><span class="line">            m_clsMap.insert(std::make_pair(name,method));</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        static std::map&lt;std::string,CreateFuntion&gt; m_clsMap;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//源文件</span></span><br><span class="line">std::map&lt;std::string, CreateFuntion&gt; CClassFactory::m_clsMap;</span><br></pre></td></tr></table></figure><p>到目前为止，使用CClassFactory即可完成工作了。代码实在过于简单，不用解释了。下面看看一些带trick的东西。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    class RegistyClass</span><br><span class="line">    &#123;  </span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        RegistyClass(std::string name, CreateFuntion method)</span><br><span class="line">        &#123;</span><br><span class="line">            CClassFactory::RegistClass(name, method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    template&lt;class T, const char* name&gt;</span><br><span class="line">    class Register</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        Register()</span><br><span class="line">        &#123;</span><br><span class="line">            const RegistyClass tmp = rc;//这一句不能删除，如果不使用rc，那么rc这个模板成员编译器不会生成代码</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        static void* CreateInstance()</span><br><span class="line">        &#123;</span><br><span class="line">            return new T;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        static const RegistyClass rc;</span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    template&lt;class T, const char* name&gt;</span><br><span class="line">    const RegistyClass Register&lt;T, name&gt;::rc(name, Register&lt;T, name&gt;::CreateInstance);</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine REGISTRY_CLASS(class_name) \</span><br><span class="line">extern char const array_##class_name[] = #class_name;\</span><br><span class="line">Register&lt;class_name, array_##class_name&gt; register_class_name</span><br></pre></td></tr></table></figure><p>RegistyClass不用说了，模板类Register是关键。模板T代表要注册的类类型，常量字符串模板name代表类名。其中的static成员rc用于注册当前类。注意CreateInstance的实现，说明只能调用无参数构造函数。至于Register构造函数里面的那句话也是不能省略的。</p><p>最麻烦的是下面的那个REGISTRY_CLASS宏，其余代码都来自网络，这个宏确是我修改实现的。class_name代表类，比如CMesh，注意不是类名。这里有几个关键点，一个是extern。在vs2010中，不加extern修饰无法编译通过，具体原因估计是编译器支持不够吧。另一个是<code>#class_name</code>，是把CMesh转换为”CMesh”。最最关键的是<code>array_##class_name</code>，是生成array_CMesh的变量名。为什么要这么做了，这样注册不同的类就是不同的变量名，避免了变量重定义，否则会链接失败。使用方法是在要注册的类源文件中，包含ClassFactory.h头文件，再添加宏REGISTRY_CLASS(CMesh);即可。</p><p>网上提供的代码，还定义了声明类的宏，表示继承Register模板类自动支持反射机制。相关代码经过修改如下所示，这个就没有去具体使用了，因为修改类定义比较麻烦，添加一句宏到现在代码中却是很方便的事情。这个反射机制已经用到我现在的项目中了，实现了一个从配置文件读取信息，选择创建不同的界面的功能。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">#def</span>ine DEFINE_CLASS(class_name)\</span><br><span class="line">extern char char array_##class_name[]=#class_name;\</span><br><span class="line">class class_name:public Register&lt;class_name, NameArray&gt;  </span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine DEFINE_CLASS_EX(class_name, father_class) \</span><br><span class="line">extern char char array_##class_name[] = #class_name;\</span><br><span class="line">class class_name: public Register&lt;class_name, NameArray&gt;, public father_class</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说我的QT下使用OpenGL渲染Mesh的框架</title>
      <link href="/2015/03/13/%E8%AF%B4%E8%AF%B4%E6%88%91%E7%9A%84QT%E4%B8%8B%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93Mesh%E7%9A%84%E6%A1%86%E6%9E%B6/"/>
      <url>/2015/03/13/%E8%AF%B4%E8%AF%B4%E6%88%91%E7%9A%84QT%E4%B8%8B%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93Mesh%E7%9A%84%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>我终于把界面换成qt的了，即使我从大二开始就用mfc，一直用到去年上半年。也终于到了，我实在受不了mfc代码混乱的时候了，qt那么方便的东西，我为什么不早点用了。这里就不吐槽mfc的混乱，qt的方便了。在mfc里面建立一个复杂的界面，比如说有dock窗口，或者tab页面的，代码多，而且混乱麻烦，更无语的是，每次我都必须去搜索下，解决各种各样的问题，有的还可以理解，有的就是莫名其妙了。更别说什么代码清晰，跨平台之类的，何止是天方夜谭。</p><p>下面，说说我自己逐渐搭建的这个框架吧。其实，这个框架是从我上一个项目里，使用mfc的单文档单视图，主窗口里面有几个dockpane，视图里面放置了渲染OpenGL的子窗口，过渡来的。在qt的框架里面，mfc所有的这些恶心的东西都没有了，只剩下一个MainWindow类。在这个类里面，创建菜单，工具条，状态条，主窗口，dock窗口，tab窗口。代码简洁方便。渲染opengl的窗口设置为MainWindow的主widget。渲染窗口只是一个普通的widget而已，可以任意放置。</p><p>这样的做法能够把界面和渲染窗口独立出来，渲染窗口对应一个独立的类(COglWidget)，所以方便创建不同类型的复杂界面。我觉得我应该先用viso画个类图，才能说清楚。下图是我的界面。中间是COglWidget。右侧是一个DockWidget，里面放置了个设置Mesh属性的widget。</p><p><img alt data-src="https://c7.staticflickr.com/8/7463/26842619574_12cf1f5142_o.jpg"></p><p>通过主窗口的构造函数，可以看看如何创建这个界面，虽然在主窗口里面做这么的事情不是个好的习惯。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CMainWindow::CMainWindow(QWidget *parent)</span><br><span class="line">        : QMainWindow(parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//setWindowFlags(this-&gt;windowFlags()  ~Qt::WindowMaximizeButtonHint);//隐藏最大化按钮</span></span><br><span class="line">        setWindowTitle(tr("Skeleton Extract"));</span><br><span class="line"></span><br><span class="line">        m_pSEMesh = new CSEMesh();</span><br><span class="line">        m_pOglForSE = new COglWidget(this, m_pSEMesh);</span><br><span class="line">        m_pSEMesh-&gt;SetOglWidget(m_pOglForSE);</span><br><span class="line">        setCentralWidget((QWidget*)m_pOglForSE);//设置中间是渲染OpenGL的widget      </span><br><span class="line"></span><br><span class="line">        m_pPCMesh = new CPointCloudMesh();</span><br><span class="line">        m_pOglForPC = new COglWidget(this, m_pPCMesh);</span><br><span class="line">        <span class="comment">//m_pOglForPC-&gt;SetEye(0.0, 0.0, 1.0);</span></span><br><span class="line">        m_pOglForPC-&gt;setFixedSize(960, 720);</span><br><span class="line">        m_pOglForPC-&gt;setWindowTitle(tr("Point Cloud For Geodesic Matrix Eigen Vector"));</span><br><span class="line">        m_pOglForPC-&gt;move((QApplication::desktop()-&gt;<span class="attribute">width</span>() - m_pOglForPC-&gt;width()) / <span class="number">2</span>,</span><br><span class="line">            (QApplication::desktop()-&gt;<span class="attribute">height</span>() - m_pOglForPC-&gt;height())/<span class="number">2</span>);</span><br><span class="line">        m_pOglForPC-&gt;hide();</span><br><span class="line">        m_pOglForPC-&gt;setWindowFlags(Qt::Window);</span><br><span class="line"></span><br><span class="line">        CreateActions();</span><br><span class="line">        CreateMenus();</span><br><span class="line">        CreateToolBars();</span><br><span class="line">        CreateStatusBar();</span><br><span class="line">        CreateDockWidgets();</span><br><span class="line"></span><br><span class="line">        setMinimumSize(960, 720);</span><br><span class="line">        setWindowState(Qt::WindowMaximized);</span><br><span class="line"></span><br><span class="line">        std::string strName = "MeshData\\bunny_3k.m";</span><br><span class="line">        m_pSEMesh-&gt;LoadModel(strName.c_str());</span><br><span class="line">        m_pMeshNameLabel-&gt;setText(QString(strName.c_str()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看一个使用tabwidget的界面，记得在mfc中使用tab页面应该是比较麻烦，我也没用过。不过，在qt里面，唯一需要改变的是把tabwidget设置为central的widget，把其它widget加入到tab页面里面就行了。效果如图：<br><img alt data-src="https://c5.staticflickr.com/8/7433/27175531460_7ebec89490_o.jpg"><br>这个界面的创建代码如下，这里我把菜单，工具条，状态栏都去掉了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">CMainWindow::CMainWindow(QWidget *parent)</span><br><span class="line">        : QMainWindow(parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//setWindowFlags(this-&gt;windowFlags()  ~Qt::WindowMaximizeButtonHint);//隐藏最大化按钮</span></span><br><span class="line">        setWindowTitle(tr("Virtual Box"));</span><br><span class="line"></span><br><span class="line">        m_pMesh = new CCubeMesh();</span><br><span class="line">        m_pOglWidget = new COglWidget(this, m_pMesh);</span><br><span class="line"></span><br><span class="line">        m_pMainViewMesh = new CCubeMesh();</span><br><span class="line">        m_pMainViewMesh-&gt;DrawStyle(CCubeMesh::MAIN_VIEW);</span><br><span class="line">        m_pMainViewWidget = new CViewWidget(this, m_pMainViewMesh);</span><br><span class="line"></span><br><span class="line">        m_pTopViewMesh = new CCubeMesh();</span><br><span class="line">        m_pTopViewMesh-&gt;DrawStyle(CCubeMesh::TOP_VIEW);</span><br><span class="line">        m_pTopViewWidget = new CViewWidget(this, m_pTopViewMesh);</span><br><span class="line"></span><br><span class="line">        m_pSideViewMesh = new CCubeMesh();</span><br><span class="line">        m_pSideViewMesh-&gt;DrawStyle(CCubeMesh::SIDE_VIEW);</span><br><span class="line">        m_pSideViewWidget = new CViewWidget(this, m_pSideViewMesh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CreateActions();</span></span><br><span class="line">        <span class="comment">//CreateMenus();</span></span><br><span class="line">        <span class="comment">//CreateToolBars();</span></span><br><span class="line">        <span class="comment">//CreateStatusBar();</span></span><br><span class="line">        <span class="comment">//CreateDockWidgets();</span></span><br><span class="line"></span><br><span class="line">        setMinimumSize(960, 720);</span><br><span class="line">        setWindowState(Qt::WindowMaximized);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//std::string strName = "cube.obj";</span></span><br><span class="line">        <span class="comment">//m_pMesh-&gt;LoadModel(strName.c_str());</span></span><br><span class="line">        <span class="comment">//m_pMeshNameLabel-&gt;setText(QString(strName.c_str()));</span></span><br><span class="line">        m_pTabWidget = new QTabWidget(this);</span><br><span class="line">        m_pTabWidget-&gt;addTab(m_pOglWidget, "Cube View");</span><br><span class="line">        m_pTabWidget-&gt;addTab(m_pMainViewWidget, "Main View");</span><br><span class="line">        m_pTabWidget-&gt;addTab(m_pTopViewWidget, "Top View");</span><br><span class="line">        m_pTabWidget-&gt;addTab(m_pSideViewWidget, "Side View");</span><br><span class="line">        setCentralWidget((QWidget*)m_pTabWidget);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，可以看到创建一个OglWidget需要一个Mesh指针。在我的框架中，COglWidget内中只使用几个固定的Mesh函数。因此，可以把COglWidget实现为依赖于一个IMesh接口，这样就进一步把OpenGL窗口和Mesh分离开来。不管Mesh类的具体实现如何，OpenGL窗口只需要依赖IMesh接口，因此，第一个界面里面的Mesh类实际上组合了一个CGAL的CGAL::Polyhedron_3对象。而第二个界面的Mesh类是一个简单的渲染长方体的类，不过支持渲染多个视图而已。<br>下面说说，COglWidget类具有哪些功能。首先，渲染Mesh，包括设置视口，eye，投影，光照，背景等等，其次，处理鼠标按键操作模型，我的实现是把所有的鼠标按键消息都丢给了下层的一个trackball类，这个trackball类支持旋转缩放移动模型，另外还写了几个打开文件，以及选取背景色的操作。<br>现在到了Mesh的部分了。因为跟OpenGL窗口相关的只是IMesh接口，所以，我可以任意实现实际的Mesh类。<br>IMesh的定义如下，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> IMESH_H</span><br><span class="line"><span class="number">#def</span>ine IMESH_H</span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"libyx/vertex.h"</span></span><br><span class="line"></span><br><span class="line">namespace LibYX</span><br><span class="line">&#123;</span><br><span class="line">    struct IMesh</span><br><span class="line">    &#123;</span><br><span class="line">        IMesh()</span><br><span class="line">        &#123;</span><br><span class="line">            m_pMatMV = new double[16];</span><br><span class="line">            m_pMatProj = new double[16];</span><br><span class="line">            m_pViewport = new int[4];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtual ~IMesh()</span><br><span class="line">        &#123;</span><br><span class="line">            FreeModel();</span><br><span class="line">            delete[] m_pMatMV;</span><br><span class="line">            delete[] m_pMatProj;</span><br><span class="line">            delete[] m_pViewport;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        virtual bool LoadModel(const char* pFilename) &#123; return true; &#125;</span><br><span class="line">        virtual void SaveModel(const char* sFilename) &#123;&#125;</span><br><span class="line">        virtual void UnifyModel() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        virtual bool HasModelLoad() const &#123; return true; &#125;</span><br><span class="line">        virtual void FreeModel() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        virtual void InitData() &#123;&#125;</span><br><span class="line">        virtual void DestroyData() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        virtual void DrawScene()</span><br><span class="line">        &#123;</span><br><span class="line">            glGetDoublev(GL_MODELVIEW_MATRIX, m_pMatMV);</span><br><span class="line">            glGetDoublev(GL_PROJECTION_MATRIX, m_pMatProj);</span><br><span class="line">            glGetIntegerv(GL_VIEWPORT, m_pViewport);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void WindowWidth(int nWidth) &#123; m_nWinWidth = nWidth; &#125;</span><br><span class="line">        int WindowWidth() const &#123; return m_nWinWidth; &#125;</span><br><span class="line">        void WindowHeight(int nHeight) &#123; m_nWinHeight = nHeight; &#125;</span><br><span class="line">        int WindowHeight() const &#123; return m_nWinHeight; &#125;</span><br><span class="line"></span><br><span class="line">    protected:</span><br><span class="line">        double* m_pMatMV;//模型视图矩阵</span><br><span class="line">        double* m_pMatProj;//投影矩阵</span><br><span class="line">        int* m_pViewport;//视口</span><br><span class="line">        int m_nWinWidth;</span><br><span class="line">        int m_nWinHeight;</span><br><span class="line"></span><br><span class="line">    protected:</span><br><span class="line">        v3d m_vMax, m_vMin;         // bounding box of the scene</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>其中，DrawScene()是渲染接口，另外还有加载模型的接口等，里面还有些数据。我用CTriMesh继承IMesh接口，同时组合Enriched_Model *m_pModel的指针，创建一个CGAL的多边形网格模型，实际的操作基本都交给m_pModel。这个类的定义太复杂了，就不贴了。这个类里面我集成了基本操作，比如按照点，线，面方式渲染，渲染包围盒，坐标轴，法线，顶点，边，面的索引等，加载和保存模型等等。因此，CTriMesh作为模型的基类，在实际的项目中，再继承CTriMesh，比如第一个界面中的CSEMesh，在CSEMesh中进行具体的处理。<br>所以，实际的算法实现都在CSEMesh里面。因为，IMesh和CTriMesh，COglWidget可以固化了。能够变化的只是CMainWindow。如果要添加新的代码，只能继承CTriMesh，在子类里面实现具体的算法，也算是对修改关闭对扩展开放吧。</p><p>因此，如果再做类似的东西，我就有一个很方便的框架了。。。鉴于不少人留言要代码，有兴趣的可以参考这个<a href="https://pan.baidu.com/s/1eSbiwYe" target="_blank" rel="noopener">QtRenderMesh</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提取三维表面标量场的等值线</title>
      <link href="/2015/02/06/%E6%8F%90%E5%8F%96%E4%B8%89%E7%BB%B4%E8%A1%A8%E9%9D%A2%E6%A0%87%E9%87%8F%E5%9C%BA%E7%9A%84%E7%AD%89%E5%80%BC%E7%BA%BF/"/>
      <url>/2015/02/06/%E6%8F%90%E5%8F%96%E4%B8%89%E7%BB%B4%E8%A1%A8%E9%9D%A2%E6%A0%87%E9%87%8F%E5%9C%BA%E7%9A%84%E7%AD%89%E5%80%BC%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章说了提取拉普拉斯矩阵的第二个（或者其它）特征向量能得到一个有规律分布的标量场。现在讲的是如何在这样一个规律分布的标量场上提取出等值线。注意，这是在一个三角网格上面提取等值线，并不是真正的曲面。提取出等值线后，可以做一些相关的应用。</p><p>那么，如何提取等值线了？</p><p>首先，如果只是绘制出等值线，可以简单的设置纹理贴图值（比如间隔多少行，设置纹理值为白色），标量场对应一维纹理坐标。更详细的说明，可以参考我的一篇博文：<a href="http://www.xpc-yx.com/2014/06/26/%E5%9C%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%87%E9%87%8F%E5%9C%BA%E5%8F%8A%E6%B3%A8%E6%84%8F%E6%96%B9%E9%9D%A2/" target="_blank" rel="noopener" title="在三维模型上可视化标量场及注意方面">在三维模型上可视化标量场及注意方面</a>。</p><p>现在考虑如何计算等值线上的间隔点。先看单个的三角面，无论如何可以得到一条等值线的。最简单的思想，就是把单个三角面上的等值线连接起来。</p><p>给定一个三角面，如何计算从该三角面出发的一条等值线了？</p><p>第一步，求出三个顶点的标量值顺序，那么标量范围在[fMin,fMax]之间。可以任选区间内的一个值，比如中间值作为该等值线的标量值。</p><p>第二步，得到等值线标量值在[fMin,fMax]所在边pEdge的位置ptBeg，作为起始点，加入点集合isoLine。</p><p>第三步，在pEdge所在的三角面上，找pEdge相邻的两条边的等值点(ptBeg的标量值相等的点)ptNext。如果存在这样的点，那么修改ptBeg = ptNext，加入点集合isoLine。同时，修改pEdge为对应的相邻边pEdge-&gt;next()或者是pEdge-&gt;next()-&gt;next()。如果不存在ptNext，进入第四步，同时设置不成环标志。否则，pEdge = pEdge-&gt;opposite()，(效果是进入相邻面，再循环第三步），如果发现ptNext等于isoLine的第一个点，那么说明已经成环，进入第四步，同时设置成环标志。</p><p>第四步，返回等值线，以及等值线是否成环状。</p><p>相关代码如下，里面使用了cgal的半边结构，同时该函数标记了当前面是否已经计算过等值线，避免等值线过密。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">bool CSEMesh::ComputeIsoLine(std::vector&lt;double&gt; scalarField, Enriched_Model::Facet_iterator pBegFacet,</span><br><span class="line">    std::vector&lt;bool&gt; bHasIsoLine, IsoLine isoline)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该面已经有通过的isoline</span></span><br><span class="line">    <span class="keyword">if</span> (bHasIsoLine[pBegFacet-&gt;tag()] == true)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isoline<span class="selector-class">.pts</span>.<span class="attribute">clear</span>();</span><br><span class="line">    std::vector&lt;int&gt; visitFaces;//这次访问过的face</span><br><span class="line"></span><br><span class="line">    Enriched_Model::Halfedge_around_facet_circulator pHalfedge = pBegFacet-&gt;facet_begin();</span><br><span class="line"></span><br><span class="line">    int vertexs[3];</span><br><span class="line">    int i = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        vertexs[i++] = pHalfedge-&gt;vertex()-&gt;tag();</span><br><span class="line">    &#125; while (++pHalfedge != pBegFacet-&gt;facet_begin());</span><br><span class="line"></span><br><span class="line">    struct ScalarInfor</span><br><span class="line">    &#123;</span><br><span class="line">        int index;</span><br><span class="line">        double value;</span><br><span class="line">        bool operator &lt; (const ScalarInfor si) const</span><br><span class="line">        &#123;</span><br><span class="line">            return value &lt; si.value;</span><br><span class="line">        &#125;</span><br><span class="line">        ScalarInfor(int <span class="selector-tag">i</span>, double v) : index(i), value(v) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;ScalarInfor&gt; vecSi;</span><br><span class="line">    for (int i = 0; i &lt; 3; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vecSi.push_back(ScalarInfor(vertexs[i], scalarField[vertexs[i]]));</span><br><span class="line">    &#125;</span><br><span class="line">    std::sort(vecSi.begin(), vecSi.end());</span><br><span class="line"></span><br><span class="line">    int nMinIndex = vecSi[0].index;</span><br><span class="line">    int nMaxIndex = vecSi[2].index;</span><br><span class="line"></span><br><span class="line">    Enriched_Model::Edge_iterator pEdge;</span><br><span class="line">    pHalfedge = pBegFacet-&gt;facet_begin();</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nMinIndex == pHalfedge-&gt;vertex()-&gt;tag()  nMaxIndex == pHalfedge-&gt;opposite()-&gt;vertex()-&gt;tag()</span><br><span class="line">        ||  nMaxIndex == pHalfedge-&gt;vertex()-&gt;tag()  nMinIndex == pHalfedge-&gt;opposite()-&gt;vertex()-&gt;tag())</span><br><span class="line">        &#123;</span><br><span class="line">            pEdge = pHalfedge;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (++pHalfedge != pBegFacet-&gt;facet_begin());</span><br><span class="line"></span><br><span class="line">    Enriched_Model::Point pt;</span><br><span class="line">    isoline.isoValue = (scalarField[nMinIndex] + scalarField[nMaxIndex]) / 2.0;//当前等值线的值</span><br><span class="line"></span><br><span class="line">    Enriched_Model::Point ptBeg = pEdge-&gt;opposite()-&gt;vertex()-&gt;point();</span><br><span class="line">    int iBeg = pEdge-&gt;opposite()-&gt;vertex()-&gt;tag();</span><br><span class="line"></span><br><span class="line">    Enriched_Model::Point ptEnd = pEdge-&gt;vertex()-&gt;point();</span><br><span class="line">    int iEnd = pEdge-&gt;vertex()-&gt;tag();</span><br><span class="line">    GetInterpolationPt(ptBeg, ptEnd, scalarField[iBeg], scalarField[iEnd], isoline.isoValue, pt);//得到对边的插值点作为终点</span><br><span class="line">    isoline.pts.push_back(pt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下一个三角面是pEdge所在的相邻三角面</span></span><br><span class="line">    bool bCircle = true;</span><br><span class="line">    while (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pEdge-&gt;is_border())</span><br><span class="line">        &#123;</span><br><span class="line">            bCircle = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int iBeg = pEdge-&gt;opposite()-&gt;vertex()-&gt;tag();</span><br><span class="line">        int iEnd = pEdge-&gt;vertex()-&gt;tag();</span><br><span class="line">        int iNext = pEdge-&gt;next()-&gt;vertex()-&gt;tag();</span><br><span class="line">        <span class="keyword">if</span> (IsValueBetween(isoline<span class="selector-class">.isoValue</span>, scalarField[iNext], scalarField[iBeg]))</span><br><span class="line">        &#123;</span><br><span class="line">            Enriched_Model::Point ptNext = pEdge-&gt;next()-&gt;vertex()-&gt;point();</span><br><span class="line">            Enriched_Model::Point ptBeg = pEdge-&gt;opposite()-&gt;vertex()-&gt;point();</span><br><span class="line">            GetInterpolationPt(ptNext, ptBeg, scalarField[iNext], scalarField[iBeg], isoline.isoValue, pt);//得到对边的插值点作为终点</span><br><span class="line">            isoline.pts.push_back(pt);</span><br><span class="line">            pEdge = pEdge-&gt;next()-&gt;next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IsSamePoint(pt, isoline<span class="selector-class">.pts</span>.front()))</span><br><span class="line">            &#123;</span><br><span class="line">                isoline.pts.back() = isoline.pts.front();</span><br><span class="line">                break;//已经成环状</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (IsValueBetween(isoline<span class="selector-class">.isoValue</span>, scalarField[iEnd], scalarField[iNext]))</span><br><span class="line">        &#123;</span><br><span class="line">            Enriched_Model::Point ptNext = pEdge-&gt;next()-&gt;vertex()-&gt;point();</span><br><span class="line">            Enriched_Model::Point ptEnd = pEdge-&gt;vertex()-&gt;point();</span><br><span class="line">            GetInterpolationPt(ptEnd, ptNext, scalarField[iEnd], scalarField[iNext], isoline.isoValue, pt);//得到对边的插值点作为终点</span><br><span class="line">            isoline.pts.push_back(pt);</span><br><span class="line">            pEdge = pEdge-&gt;next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IsSamePoint(pt, isoline<span class="selector-class">.pts</span>.front()))</span><br><span class="line">            &#123;</span><br><span class="line">                isoline.pts.back() = isoline.pts.front();</span><br><span class="line">                break;//已经成环状</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            bCircle = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visitFaces.push_back(pEdge-&gt;facet()-&gt;tag());</span><br><span class="line">        pEdge = pEdge-&gt;opposite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bCircle)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; visitFaces.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            bHasIsoLine[visitFaces[i]] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bCircle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要讲的是如何遍历整个模型的三角面，使得计算出来的等值线有一定的规律？诚然，任意的顺序都能计算出等值线来。但是，会丢失一些信息。我用的广度优先搜索的顺序计算。我先找到最小的标量值，从这个顶点所在的一个面开始进行广度优先搜索遍历所有的面。同时，在队列里面保存进入队列的顺序，以进行下一步的等值线排序。最终，我得到的是一些根据标量值和进入队列顺序排序过的一堆等值线。相关代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算所有等值线</span></span><br><span class="line">    void CSEMesh::ComputeIsoLines(std::vector&lt;double&gt; scalarField)</span><br><span class="line">    &#123;</span><br><span class="line">        IsoLine isoline;</span><br><span class="line">        std::vector&lt;bool&gt; bHasIsoLine(FaceNum(), false);</span><br><span class="line"></span><br><span class="line">        m_isoLines.<span class="attribute">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到值最小的顶点</span></span><br><span class="line">        Enriched_Model::Vertex_iterator pVertex = m_pModel-&gt;vertices_begin();</span><br><span class="line">        double fMinValue = 1e8;</span><br><span class="line">        Enriched_Model::Vertex_iterator pMinVertex;</span><br><span class="line">        while (pVertex != m_pModel-&gt;vertices_end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (scalarField[pVertex-&gt;tag()] &lt; fMinValue)</span><br><span class="line">            &#123;</span><br><span class="line">                fMinValue = scalarField[pVertex-&gt;tag()];</span><br><span class="line">                pMinVertex = pVertex;</span><br><span class="line">            &#125;</span><br><span class="line">            pVertex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;bool&gt; bVisited(FaceNum(), false);</span><br><span class="line"></span><br><span class="line">        Enriched_Model::Facet_iterator pSourceFace = pMinVertex-&gt;vertex_begin()-&gt;facet();</span><br><span class="line">        &#123;</span><br><span class="line">            struct FaceInfor</span><br><span class="line">            &#123;</span><br><span class="line">                Enriched_Model::Face_iterator pFace;</span><br><span class="line">                int nOrder;</span><br><span class="line">                FaceInfor(Enriched_Model::Face_iterator face, int <span class="attribute">order</span>) : pFace(face), nOrder(order)&#123;&#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            std::queue&lt;FaceInfor&gt; queFaces;</span><br><span class="line">            bVisited[pSourceFace-&gt;tag()] = true;</span><br><span class="line">            queFaces.push(FaceInfor(pSourceFace, 0));</span><br><span class="line"></span><br><span class="line">            while (queFaces.empty() == false)</span><br><span class="line">            &#123;</span><br><span class="line">                FaceInfor faceInfor = queFaces.front();</span><br><span class="line">                queFaces.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ComputeIsoLine(scalarField, faceInfor<span class="selector-class">.pFace</span>, bHasIsoLine, isoline))</span><br><span class="line">                &#123;</span><br><span class="line">                    isoline.order = faceInfor.nOrder;</span><br><span class="line">                    m_isoLines.push_back(isoline);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Enriched_Model::Halfedge_around_facet_circulator pHalfedge = faceInfor.pFace-&gt;facet_begin();</span><br><span class="line">                do</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pHalfedge-&gt;opposite()-&gt;is_border())</span><br><span class="line">                    &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Enriched_Model::Face_iterator pFace = pHalfedge-&gt;opposite()-&gt;facet();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bVisited[pFace-&gt;tag()] == false)</span><br><span class="line">                    &#123;</span><br><span class="line">                        queFaces.push(FaceInfor(pFace, faceInfor.nOrder + 1));</span><br><span class="line">                        bVisited[pFace-&gt;tag()] = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while (++pHalfedge != faceInfor.pFace-&gt;facet_begin());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(m_isoLines.begin(), m_isoLines.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>等值线效果图：</p><p><img alt data-src="https://c2.staticflickr.com/8/7187/27175488890_71fc72e245_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
            <tag> 三维模型处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对模型进行谱分析计算特征向量</title>
      <link href="/2015/02/03/%E5%AF%B9%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E8%B0%B1%E5%88%86%E6%9E%90%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
      <url>/2015/02/03/%E5%AF%B9%E6%A8%A1%E5%9E%8B%E8%BF%9B%E8%A1%8C%E8%B0%B1%E5%88%86%E6%9E%90%E8%AE%A1%E7%AE%97%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>一个三维模型，可以看做是一个无向图。顶点是图的点，边可以作为图的边，那么可以得到一个邻接矩阵，该矩阵叫做拉普拉斯矩阵，计算这个邻接矩阵的特征向量就是所谓的谱分析。</p><p>那么问题来了。如何定义边的权重？额，当然有不同的方法，看你需要分析的特性是什么。一般来说是边的两个对角的cotangle之和。另外，矩阵对角线元素是该行其它元素之和再取负。下一步就是计算该矩阵的特征向量了。如果计算了？我前面写过两篇文章讲述如何使用MATLAB计算稀疏矩阵的特征向量，现在我就是这么做的。首先，拉普拉斯矩阵是一个对称矩阵，而且是一个大型的稀疏矩阵。因此，只能使用稀疏矩阵来存储数据了。而且对称矩阵能保证一些特殊的性质，比如第一个特征向量是k * (1,1,1,1…)。第二个特征向量分布得比较有规律，但是通过实验发现，也许第二个也没有规律，可能是第三或者第四个，因为要利用特征向量的分布，需要综合多个特征向量。</p><p>下面是我计算拉普拉斯矩阵的代码，需要考虑角度大于90的情况，以及除0等等。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a和b夹角的cot</span></span><br><span class="line">    double CSEMesh::GetCotangent(double <span class="selector-tag">a</span>, double <span class="selector-tag">b</span>, double c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a*<span class="selector-tag">b</span> &lt; <span class="number">1</span>e-<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            double cosc = (a*a+b*b-c*c)/(2*a*b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cosc &lt; -<span class="number">1</span>)</span><br><span class="line">                cosc = -1;</span><br><span class="line">            <span class="keyword">if</span> (cosc &gt; <span class="number">1</span>)</span><br><span class="line">                cosc = 1;</span><br><span class="line"></span><br><span class="line">            double angle = acos(cosc);</span><br><span class="line"></span><br><span class="line">            double tan_angle = tan(angle);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fabs(tan_angle) &lt; <span class="number">1</span>e-<span class="number">8</span>)</span><br><span class="line">                return 1 / 1e-8;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                return 0.5 / tan_angle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void CSEMesh::ComputeLaplaceWeight()</span><br><span class="line">    &#123;</span><br><span class="line">        for (Enriched_Model::Edge_iterator pEdge = m_pModel-&gt;edges_begin();</span><br><span class="line">            pEdge != m_pModel-&gt;edges_end();</span><br><span class="line">            pEdge++)</span><br><span class="line">        &#123;</span><br><span class="line">            double cotA = 1.0, cotB = 1.0;</span><br><span class="line">            double a, b, c;</span><br><span class="line"></span><br><span class="line">            Enriched_Model::Edge_iterator pEdgeTmp = pEdge;</span><br><span class="line">            <span class="keyword">if</span> (!pEdgeTmp-&gt;is_border())</span><br><span class="line">            &#123;</span><br><span class="line">                c = pEdgeTmp-&gt;length();</span><br><span class="line">                b = pEdgeTmp-&gt;next()-&gt;length();</span><br><span class="line">                a = pEdgeTmp-&gt;next()-&gt;next()-&gt;length();</span><br><span class="line">                cotA = GetCotangent(a, b, c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pEdgeTmp = pEdge-&gt;opposite();</span><br><span class="line">            <span class="keyword">if</span> (!pEdgeTmp-&gt;is_border())</span><br><span class="line">            &#123;</span><br><span class="line">                c = pEdgeTmp-&gt;length();</span><br><span class="line">                b = pEdgeTmp-&gt;next()-&gt;length();</span><br><span class="line">                a = pEdgeTmp-&gt;next()-&gt;next()-&gt;length();</span><br><span class="line">                cotB = GetCotangent(a, b, c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cotA + cotB &lt; <span class="number">1</span>e-<span class="number">7</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pEdge-&gt;weight() = 1e-7;</span><br><span class="line">                pEdge-&gt;opposite()-&gt;weight() = 1e-7;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pEdge-&gt;weight() = cotA + cotB;</span><br><span class="line">                pEdge-&gt;opposite()-&gt;weight() = cotA + cotB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来是计算特征向量的代码，因为混合着cgal等，不是很好分离，但是可以用来参考下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">void CSEMesh::ComputeEigen(int type)</span><br><span class="line">&#123;</span><br><span class="line">        static vector&lt;MatlabSparseInfor&gt; siVec;</span><br><span class="line"></span><br><span class="line">        int nRow = m_pModel-&gt;size_of_vertices();</span><br><span class="line">        int nColum = nRow;</span><br><span class="line">        m_eigenValues.<span class="attribute">resize</span>(EIGEN_VECTOR_NUM);</span><br><span class="line">        for (int i = 0; i &lt; EIGEN_VECTOR_NUM; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            m_eigenVectors[type][i].<span class="attribute">resize</span>(nRow);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nNum = m_pModel-&gt;size_of_halfedges();</span><br><span class="line">        siVec.<span class="attribute">resize</span>(nNum + nRow);</span><br><span class="line"></span><br><span class="line">        int i = 0;</span><br><span class="line">        for (Enriched_Model::Edge_iterator pEdge = m_pModel-&gt;edges_begin();</span><br><span class="line">            pEdge != m_pModel-&gt;edges_end();</span><br><span class="line">            pEdge++)</span><br><span class="line">        &#123;</span><br><span class="line">            int beg = pEdge-&gt;opposite()-&gt;vertex()-&gt;tag();</span><br><span class="line">            int end = pEdge-&gt;vertex()-&gt;tag();</span><br><span class="line"></span><br><span class="line">            siVec[i].r = beg;</span><br><span class="line">            siVec[i].c = end;</span><br><span class="line">            siVec[i].v = -pEdge-&gt;weight();</span><br><span class="line">            ++i;</span><br><span class="line"></span><br><span class="line">            siVec[i].r = end;</span><br><span class="line">            siVec[i].c = beg;</span><br><span class="line">            siVec[i].v = -pEdge-&gt;weight();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(i == nNum);</span><br><span class="line"></span><br><span class="line">        for(Enriched_Model::Vertex_iterator pVertex = m_pModel-&gt;vertices_begin(); </span><br><span class="line">            pVertex != m_pModel-&gt;vertices_end(); pVertex++)</span><br><span class="line">        &#123;</span><br><span class="line">            Enriched_Model::Vertex::Halfedge_around_vertex_circulator pHalfEdge = pVertex-&gt;vertex_begin();</span><br><span class="line">            Enriched_Model::Vertex::Halfedge_around_vertex_circulator d = pHalfEdge;</span><br><span class="line">            double sum = 0.0;</span><br><span class="line"></span><br><span class="line">            CGAL_For_all(pHalfEdge, d)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += pHalfEdge-&gt;weight();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fabs(sum) &lt; <span class="number">1</span>e-<span class="number">7</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = 0.0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            siVec[i].r = pVertex-&gt;tag();</span><br><span class="line">            siVec[i].c = pVertex-&gt;tag();</span><br><span class="line">            siVec[i].v = sum;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(i == nNum + nRow);</span><br><span class="line">        std::sort(siVec.begin(), siVec.end());</span><br><span class="line"></span><br><span class="line">        CMatlabSparseMatrix sm(siVec[0], nNum + nRow, nRow, nColum);</span><br><span class="line">        int nEigenNum = std::min(nRow, (int)EIGEN_VECTOR_NUM);</span><br><span class="line">        sm.GetEigens(m_eigenValues, m_eigenVectors[type], nEigenNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于如何实现MATLAB稀疏矩阵类，可以参考我其它的两篇文章。下面是第二个特征向量的分布效果，能够观察到是一个非常有规律的标量场。<br><a href="https://c2.staticflickr.com/8/7068/27380408921_bcdfd8ed53_o.png" target="_blank" rel="noopener"><img alt data-src="https://c2.staticflickr.com/8/7068/27380408921_bcdfd8ed53_o.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
            <tag> 三维模型处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CGAL计算SDF分割模型</title>
      <link href="/2015/01/22/%E4%BD%BF%E7%94%A8CGAL%E8%AE%A1%E7%AE%97SDF%E5%88%86%E5%89%B2%E6%A8%A1%E5%9E%8B/"/>
      <url>/2015/01/22/%E4%BD%BF%E7%94%A8CGAL%E8%AE%A1%E7%AE%97SDF%E5%88%86%E5%89%B2%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>最新版的cgal4.5，提供了个<a href="http://doc.cgal.org/latest/Surface_mesh_segmentation/index.html" target="_blank" rel="noopener" title="Triangulated Surface Mesh Segmentation">Triangulated Surface Mesh Segmentation</a>包，利用该部分代码可以计算三维模型每个面或者顶点的sdf（_Shape Diameter Function）_属性。sdf的具体定义可以参考论文：L. Shapira, A. Shamir, and D. Cohen-Or. Consistent mesh partitioning and skeletonisation using the shape diameter function. _The Visual Computer_, 24(4):249–259, 2008.</p><p>那么sdf可以做什么了？sdf最终能表示三维模型上面的一个标量场，该标量场代表的是模型厚度的分布。因此，利用该标量场可以对模型进行分割，不管是自动化的还是交互的都可以。如何计算sdf了？可以利用定义自己去实现算法，或者利用库，比如cgal。</p><p>关于如何使用sdf标量场进行模型分割？cgal的文档说的很清楚，先用k个gmm进行软聚类（每个cluster是k-means初始化的），再利用软聚类的结果进行硬聚类，这一步实际上利用graph-cut求能量最小化。更清楚的解释，参考CGAL的相关文档。刘利刚老师用sdf进行交互式分割的文章，也是利用gmm和graph-cut作为工具实现的，原理和cgal的实现思路基本一致。</p><p>下面将一下，我使用该代码碰到的问题。计算sdf的函数是CGAL::sdf_values，这是一个复杂的模板函数，该函数的第一个参数是一个模板类Polyhedron的引用。由于cgal使用了非常复杂的模板语法，所以经常会碰到一些恶心的语法问题，编译无法通过。这一次也是。由于默认情况下，使用cgal都会继承CGAL::Polyhedron_3<kernel, items>以实现自定义的多面体类。所以，使用这个函数的时候就会出现模板参数不匹配的情况。怎么解决了。首先，没必要去修改自己的多面体类，也不可能去修改cgal库，再重新构造个cgal默认的Polyhedron_3对象也很浪费。</kernel,></p><p>其实，这里可以考虑到转型。类型转换有两种考虑，转值和转指针。如果将自定义多面体类转换为默认的多面体类，肯定会生成个具大的临时对象，多浪费啊。所以了，可以先取地址转换为基类指针再解引用就获得了cgal默认的Polyhedron_3对象了。我的代码如下：std::pair<double, double> min_max_sdf = CGAL::sdf_values(<em>(Polyhedron</em>)m_pModel, m_sdf_property_map);</double,></p><p>至于其它部分的使用，参考cgal手册即可，非常简单方便。下面再贴几张图，展示下sdf标量场的分布，以及利用sdf的分割结果。</p><p>sdf标量场，白色的是等值线。</p><p><img alt data-src="https://c2.staticflickr.com/8/7719/27451907645_8f5cee7a2e_o.png"></p><p>sdf分割模型结果：</p><p><img alt data-src="https://c2.staticflickr.com/8/7604/27417732786_830e67189b_o.png"></p><p>至于分割边界不是很整齐，这只是跟模型密度有关系，模型越密，能够得到越平滑的边界，也有相关的算法优化边界。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> CGAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用C++调用MATLAB引擎计算稀疏矩阵的特征向量</title>
      <link href="/2015/01/20/%E4%BD%BF%E7%94%A8C++%E8%B0%83%E7%94%A8MATLAB%E5%BC%95%E6%93%8E%E8%AE%A1%E7%AE%97%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
      <url>/2015/01/20/%E4%BD%BF%E7%94%A8C++%E8%B0%83%E7%94%A8MATLAB%E5%BC%95%E6%93%8E%E8%AE%A1%E7%AE%97%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章讲了如何用MATLAB计算稀疏矩阵的特征向量，但是我们最终的目的是使用C++达到这个需求。大致搜索了下，发现使用C++调用MATLAB计算引擎的方式最方便，就采用了，目前的计算速度和方便性都能满足要求。下面讲一下如何操作。</p><p>1.首先是安装MATLAB，并且保证版本正确，比如32位程序只能调用32位的MATLAB，如我的机器是64位win8.1，所以必须强制安装32位的MATLAB，才能配合我用vs2010编写的32位程序。如果，我用vs2010开放64位程序，那么当然是可以使用64MATLAB的，但是配置64位开源库是个大工程，有些库并没有针对64位版本测试过。</p><p>2.假设我的MATLAB安装在C:\Program Files (x86)\MATLAB下面，那么include目录是C:\Program Files (x86)\MATLAB\R2013a\extern\include，lib目录是C:\Program Files (x86)\MATLAB\R2013a\extern\lib\win32\microsoft，bin目录是C:\Program Files (x86)\MATLAB\R2013a\bin\win32。include和lib在vs里面设置好就行了，至于bin目录需要加入到path环境变量中，最后重启电脑生效，当然你一个个去找需要的dll也是可以的。</p><p>3.配置好之后，就可以使用MATLAB引擎了。大致需要1&gt;打开引擎，2&gt;用C++创建变量，3&gt;把变量对应到MATLAB命令中，4&gt;执行MATLAB命令，5&gt;将MATLAB变量传回C++这样的一些操作。比如，engOpen打开引擎，mxCreateSparse用于创建稀疏矩阵，engPutVariable将变量传入MATLAB，engEvalString执行命令，engGetVariable返回结果。具体怎么操作还是得参考相应教程。另外，可以用C++创建不同类型的变量，稀疏矩阵是比较特殊的一种。</p><p>4.至于如何用MATLAB计算稀疏矩阵的特征向量，参阅上一篇文章。</p><p>5.关键的一步，如何设置mxCreateSparse返回的稀疏矩阵的值。先看下面的代码吧。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mxArray* sm = mxCreateSparse(m_nRow, m_nColumn, m_nNum, mxREAL);</span><br><span class="line">double* pr = mxGetPr(sm);</span><br><span class="line">mwIndex* ir = mxGetIr(sm);</span><br><span class="line">mwIndex* jc = mxGetJc(sm); </span><br><span class="line"></span><br><span class="line">int k = 0;</span><br><span class="line">int nLastC = -1;</span><br><span class="line">for (int i = 0; i &lt; m_nNum; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    pr[i] = m_pSI[i].v;</span><br><span class="line">    ir[i] = m_pSI[i].r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_pSI[i]<span class="selector-class">.c</span> != nLastC)</span><br><span class="line">    &#123;</span><br><span class="line">        jc[k] = i;</span><br><span class="line">        nLastC = m_pSI[i].c;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jc[k] = m_nNum;</span><br></pre></td></tr></table></figure><p>pr对应的是值，ir对应的是行，关键的是jc，jc并不是列，而是到当前列为止出现的值数目，具体可以查阅MATLAB文档，或者理解下以上代码，正确初始化稀疏矩阵是成功的关键。<br>下面随附我的计算拉普拉斯矩阵FiedlerVector的函数。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void CSparseMatrix::GetFiedlerVector(double* pVector, int nChoose)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(nChoose &gt;= 0  nChoose &lt;= 5);</span><br><span class="line"></span><br><span class="line">        Engine *ep = NULL;</span><br><span class="line">        <span class="keyword">if</span> (!(ep = engOpen(NULL)))<span class="comment">//打开matlab引擎</span></span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, "\nCan't start MATLAB engine\n");</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mxArray* sm = mxCreateSparse(m_nRow, m_nColumn, m_nNum, mxREAL);</span><br><span class="line">        double* pr = mxGetPr(sm);</span><br><span class="line">        mwIndex* ir = mxGetIr(sm);</span><br><span class="line">        mwIndex* jc = mxGetJc(sm); </span><br><span class="line"></span><br><span class="line">        int k = 0;</span><br><span class="line">        int nLastC = -1;</span><br><span class="line">        for (int i = 0; i &lt; m_nNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pr[i] = m_pSI[i].v;</span><br><span class="line">            ir[i] = m_pSI[i].r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_pSI[i]<span class="selector-class">.c</span> != nLastC)</span><br><span class="line">            &#123;</span><br><span class="line">                jc[k] = i;</span><br><span class="line">                nLastC = m_pSI[i].c;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        jc[k] = m_nNum;</span><br><span class="line"></span><br><span class="line">        engPutVariable(ep, "sm", sm);</span><br><span class="line">        engEvalString(ep, "max_d = eigs(sm, 1);");//获得最大绝对值的特征值</span><br><span class="line"></span><br><span class="line">        double fMaxE;</span><br><span class="line">        mxArray* max_d = engGetVariable(ep, "max_d");</span><br><span class="line">        memcpy(fMaxE, (void *)mxGetPr(max_d), sizeof(double));//获得最大的特征值(假设特征值是从最大排列到0)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新对角线元素，相当于sm = sm - fMaxE，这样会使计算出来的特征值都减去fMaxE</span></span><br><span class="line">        pr = mxGetPr(sm);</span><br><span class="line">        for (int i = 0; i &lt; m_nNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pr[i] = m_pSI[i].v;</span><br><span class="line">            <span class="keyword">if</span> (m_pSI[i]<span class="selector-class">.r</span> == m_pSI[i].c)<span class="comment">//对角线元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                pr[i] -= fMaxE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        engPutVariable(ep, "sm", sm);</span><br><span class="line">        engEvalString(ep, "[V,D] = eigs(sm);");</span><br><span class="line">        engEvalString(ep, "[newD,IX] = sort(diag(D));");</span><br><span class="line">        engEvalString(ep, "newV=V(:,IX);");</span><br><span class="line"></span><br><span class="line">        const int EVAl_STR_LEN = 100;</span><br><span class="line">        char szEvalString[EVAl_STR_LEN];</span><br><span class="line">        sprintf(szEvalString, "Fiedler = newV(:, %d);", nChoose);</span><br><span class="line">        engEvalString(ep, szEvalString);</span><br><span class="line"></span><br><span class="line">        mxArray* fiedler = engGetVariable(ep, "Fiedler"); //返回计算结果</span><br><span class="line">        memcpy(pVector, (void *)mxGetPr(fiedler), sizeof(double) * m_nRow);</span><br><span class="line"></span><br><span class="line">        mxDestroyArray(sm);</span><br><span class="line">        mxDestroyArray(fiedler);</span><br><span class="line">        engClose(ep);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参照以上函数基本可以知道本文所讲的内容了，一切尽在代码中。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 特征向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Matlab计算稀疏矩阵的特征向量</title>
      <link href="/2015/01/12/%E4%BD%BF%E7%94%A8Matlab%E8%AE%A1%E7%AE%97%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
      <url>/2015/01/12/%E4%BD%BF%E7%94%A8Matlab%E8%AE%A1%E7%AE%97%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>首先，说明下为什么要用MATLAB。原因是，支持稀疏矩阵的矩阵库比较少，即使支持去学习使用时间也更多。所以，就用MATLAB了。目的是使用MATLAB计算稀疏矩阵的特征向量，再用C++调用MATLAB代码。</p><p>问题1：如何定义稀疏矩阵。MATLAB使用sparse函数创建稀疏矩阵。如下调用：S = sparse(i,j,s,m,n)，根据参数创建稀疏矩阵。i和j代表不为0元素的行和列值，s则是对应的值，m和n是矩阵的大小。当然还有其它接口，具体查阅MATLAB文档。</p><p>问题2：怎么计算稀疏矩阵的特征向量？MATLAB提供了eigs函数。其实，还有个eig函数，经本人实验，在使用C++调用MATLAB引擎的过程中，该函数失败了。那么，就只能使用eigs函数了。eigs函数有几种形式。下面说下我用到的几种形式。</p><p>形式1：d = eigs(A)，返回的是稀疏矩阵A的特征值（所有的特征值构成一个向量d，本人的理解是没有保证d是有序的）。</p><p>形式2：d = <tt><span class="highlight_01">eigs</span>(A,k)，返回的是最大的k个特征值，文档也没有说是有序的，如果设置k为1，那么返回的是最大的特征值。</tt></p><p>形式3：[V,D] = eigs(A)，V是特征向量构成的矩阵，每列是一个特征矩阵，D则是一个对角矩阵，对角线上的值是和V对应的特征值。不过，V和D的大小都固定为6。</p><p>形式4：[V,D] = eigs(A，k)，则可以返回最大的k个特征向量和对应的特征值，但是也没有排序，需要根据D排序V，以方便使用。</p><p>问题3：如何实现返回k个根据特征值排序后的特征向量？这是最有价值的问题了。直接提供代码吧。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[V,D] = eigs(sm,k);</span><br><span class="line">[newD,IX] = sort(diag(D)));;</span><br><span class="line">newV=V(:,IX);</span><br></pre></td></tr></table></figure><p>newV就是根据特征值排序后的特征向量，sm当然需要先建立了。<br>写在最后的话，之所以使用MATLAB计算稀疏矩阵的特征向量，是因为可以用C++调用。所以，关于这篇文章这些知识就够了，也算是我为自己做的整理吧。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 特征向量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stl源码剖析之heap</title>
      <link href="/2015/01/01/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bheap/"/>
      <url>/2015/01/01/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bheap/</url>
      
        <content type="html"><![CDATA[<p>前面提到priority_queue的内部使用了stl的泛型heap算法。现在让我们看看怎么来实现heap。至于heap，就不作仔细介绍了，本质上是用一个数组表示的完全二叉树，并且父节点总是大于（或者小于）子节点的值。我们先来看push_heap。</p><p>下图是push_heap的示意图。<img alt data-src="https://c2.staticflickr.com/8/7396/26842499204_ef7d51fc09_o.png"></p><p>从图中可以看到算法的过程是将新加入堆的值（50），层层上挪，直到正确的位置。下面来看，摘录出来的代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">    <span class="comment">// 注意，调用该函数时候，新元素位于最后一个位置(last-1)。</span></span><br><span class="line">    __push_heap_aux(first, last, distance_type(first), value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class Distance, class T&gt;</span><br><span class="line">inline void __push_heap_aux(RandomAccessIterator first,</span><br><span class="line">    RandomAccessIterator last, Distance*, T*) &#123;</span><br><span class="line">    __push_heap(first, Distance((last - first) - <span class="number">1</span>), Distance(<span class="number">0</span>),</span><br><span class="line">        T(*(last - 1)));</span><br><span class="line">    <span class="comment">// (last-first)–1代表新元素的索引，0是堆首的索引，*(last - 1)是新加入的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class Distance, class T&gt;</span><br><span class="line">void __push_heap(RandomAccessIterator first, Distance holeIndex,</span><br><span class="line">    Distance topIndex, T value) &#123;</span><br><span class="line">    Distance parent = (holeIndex - 1) / 2;  // 找出父節點</span><br><span class="line">    while (holeIndex &gt; topIndex  *(first + parent) &lt; value) &#123;</span><br><span class="line">        <span class="comment">// 尚未到达顶端，且父节点小于新值</span></span><br><span class="line">        <span class="comment">// 由于以上使用 operator&lt;，可知 STL heap 是max-heap</span></span><br><span class="line">        *(first + holeIndex) = *(first + parent);   // 令洞值为父值</span><br><span class="line">        holeIndex = parent; // percolate up：调整洞号，向上提升至父节点。</span><br><span class="line">        parent = (holeIndex - 1) / 2;   // 新洞的父节点</span><br><span class="line">    &#125;    <span class="comment">// 持续至顶端，或满足 heap 的次序特性为止。</span></span><br><span class="line">    *(first + holeIndex) = value;   // 令洞值为新值。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>push_heap的用法是输入迭代器对，并且保证[first,last-1)是最大堆，*(last-1)是新加入的元素。push_heap调用辅助函数<strong>push_heap_aux。至于为什么需要这个辅助函数了？应该是为了提取出distance_type和value_type吧，这两个内联函数的定义，可以参考stl源码剖析迭代器的那章。下面来思考真正的实现函数</strong>push_heap。这个函数需要新加入元素位置holeIndex和堆首位置topIndex，另外还有保存好的新加入值。算法的过程很简单，就是上溯holeIndex，找到真正满足条件的位置（无法继续上回溯），然后把value放入该位置即可。<br>pop_heap实际上是一个相反的过程。实现思路是将堆大小加一后，再找出最后一个元素应该放入的位置holeIndex，最后再加入这个值。示意图如下：</p><p><img alt data-src="https://c2.staticflickr.com/8/7380/27175417620_82251818fc_o.png"><br>下面看看摘录出来的代码，思想类似于push_heap，只需要求出最终的holeIndex。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">    __pop_heap_aux(first, last, value_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class T&gt;</span><br><span class="line">inline void __pop_heap_aux(RandomAccessIterator first,</span><br><span class="line">    RandomAccessIterator last, T*) &#123;</span><br><span class="line">    __pop_heap(first, last - 1, last - 1, T(*(last - 1)), distance_type(first));</span><br><span class="line">    <span class="comment">// pop动作的結果为底层容器的第一個元素。因此，首先设定欲调整值为尾值，然后將首值調至 </span></span><br><span class="line">    <span class="comment">// 尾节点（所以以上將迭代器result设为last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">    <span class="comment">// 使之重新成一個合格的 heap。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class T, class Distance&gt;</span><br><span class="line">inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,</span><br><span class="line">    RandomAccessIterator result, T value, Distance*) &#123;</span><br><span class="line">    *result = *first; // 設定尾值为首值，于是尾值即是結果，</span><br><span class="line">    <span class="comment">// 可由调用底层容器之 pop_back() 取出尾值。</span></span><br><span class="line">    __adjust_heap(first, Distance(0), Distance(last - first), value);</span><br><span class="line">    <span class="comment">// 以上欲重新調整 heap，洞号为 0，欲調整值为value。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class RandomAccessIterator, class Distance, class T&gt;</span><br><span class="line">void __adjust_heap(RandomAccessIterator first, Distance holeIndex,</span><br><span class="line">    Distance len, T value) &#123;</span><br><span class="line">    Distance topIndex = holeIndex;</span><br><span class="line">    Distance secondChild = 2 * holeIndex + 2;   // 洞节点之右子节点</span><br><span class="line">    while (secondChild &lt; len) &#123;</span><br><span class="line">        <span class="comment">// 比较洞节点之左右兩个子值，然后以 secondChild 代表较大子节点。</span></span><br><span class="line">        <span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>)))</span><br><span class="line">            secondChild--;</span><br><span class="line">        <span class="comment">// Percolate down：令较大大子值为洞值，再令洞号下移至较大子节点处。</span></span><br><span class="line">        *(first + holeIndex) = *(first + secondChild);</span><br><span class="line">        holeIndex = secondChild;</span><br><span class="line">        <span class="comment">// 找出新洞节点的右子节点</span></span><br><span class="line">        secondChild = 2 * (secondChild + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondChild == len) &#123; <span class="comment">// 沒有右子节点，只有左子节点</span></span><br><span class="line">        <span class="comment">// Percolate down：令左子值为洞值，再令洞号下移至左子节点处。</span></span><br><span class="line">        *(first + holeIndex) = *(first + (secondChild - 1));</span><br><span class="line">        holeIndex = secondChild - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將欲调整值填入目前的洞号內。注意，此時肯定滿足次序特性。</span></span><br><span class="line">    <span class="comment">// 依侯捷之见，下面直接改為 *(first + holeIndex) = value; 应该可以。</span></span><br><span class="line">    __push_heap(first, holeIndex, topIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于push_heap，pop_heap也是调用辅助函数<strong>pop_heap_aux。</strong>pop_heap_aux调用<strong>pop_heap。</strong>pop_heap调用<strong>adjust_heap调整holeIndex，最终在holeIndex处放入value（原最后一个的值）。关键代码是</strong>adjust_heap中的循环。循环的主要意思是将holeIndex不断下放，直到最底层。最后的if语句的意思是，如果最底层有左子节点，而没有右子节点，那么最终位置肯定是这个左子节点。最后一句代码的意思是加入value到holeIndex，由于已经调整完毕，所以一个赋值操作也可以达到要求，参见侯捷注释。<br>sort_heap就比较简单了，不断将极值移动到末尾，不断pop_heap。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下這個 sort_heap() 不允許指定「大小比較標準」</span></span><br><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">void sort_heap(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">    <span class="comment">// 以下，每執行一次 pop_heap()，極值（在STL heap中為極大值）即被放在尾端。</span></span><br><span class="line">    <span class="comment">// 扣除尾端再執行一次 pop_heap()，次極值又被放在新尾端。一直下去，最後即得</span></span><br><span class="line">    <span class="comment">// 排序結果。</span></span><br><span class="line">    while (last - first &gt; <span class="number">1</span>)</span><br><span class="line">        pop_heap(first, last--); // 每執行 pop_heap() 一次，操作範圍即退縮一格。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要将的是make_heap，即将一个迭代器对里面的内容构造为最大堆。代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 [first,last) 排列為一個 heap。</span></span><br><span class="line">template &lt;class RandomAccessIterator&gt;</span><br><span class="line">inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) &#123;</span><br><span class="line">    __make_heap(first, last, value_type(first), distance_type(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下這組 make_heap() 不允許指定「大小比較標準」。</span></span><br><span class="line">template &lt;class RandomAccessIterator, class T, class Distance&gt;</span><br><span class="line">void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,</span><br><span class="line">    Distance*) &#123;</span><br><span class="line">    if (last - first &lt; 2) return;   // 如果長度為 0 或 1，不必重新排列。</span><br><span class="line">    Distance len = last - first;</span><br><span class="line">    <span class="comment">// 找出第一個需要重排的子樹頭部，以 parent 標示出。由於任何葉節點都不需執行 </span></span><br><span class="line">    <span class="comment">// perlocate down，所以有以下計算。parent 命名不佳，名為 holeIndex 更好。</span></span><br><span class="line">    Distance parent = (len - 2) / 2;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        <span class="comment">// 重排以 parent 為首的子樹。len 是為了讓 __adjust_heap() 判斷操作範圍</span></span><br><span class="line">        __adjust_heap(first, parent, len, T(*(first + parent)));</span><br><span class="line">        if (parent == 0) return;    // 走完根節點，就結束。</span><br><span class="line">        parent--;                   // （即將重排之子樹的）頭部向前一個節點</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>make_heap中代码的思路也很简单。从原序列的中间位置开始不断调整（调用</strong>adjust_heap），每次调整的目的是以当前位置为根的构建一个子堆。至于为什么从中间位置开始就可以了？原因很简单，最底层元素的数目大致就会占了一半了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stl源码剖析之stack</title>
      <link href="/2014/12/31/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bstack/"/>
      <url>/2014/12/31/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bstack/</url>
      
        <content type="html"><![CDATA[<p>类似于queue，stack也是个简单的适配器。在实现上，stack与queue非常类似。底层可以使用同样的容器，比如默认都采用deque。因此，stack的源码和queue的非常类似。代码过于简单，都可以自解释了。下面是摘录出来的代码，可以顺便编译通过。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> _STL_STACK_H</span><br><span class="line"><span class="number">#def</span>ine _STL_STACK_H</span><br><span class="line"></span><br><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">    template &lt;class T, class Sequence = deque&lt;T&gt; &gt;</span><br><span class="line">    class stack &#123;</span><br><span class="line">        friend bool operator==(const stack, const stack);</span><br><span class="line">        friend bool operator&lt;(const stack, const stack);</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        typedef typename Sequence::value_type value_type;</span><br><span class="line">        typedef typename Sequence::size_type size_type;</span><br><span class="line">        typedef typename Sequence::reference reference;</span><br><span class="line">        typedef typename Sequence::const_reference const_reference;</span><br><span class="line">    protected:</span><br><span class="line">        Sequence c; // 底层容器</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 以下完全利用 Sequence c 的操作，完成 stack 的操作。</span></span><br><span class="line">        bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">        size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">        reference top() &#123; return c.back(); &#125;</span><br><span class="line">        const_reference top() const &#123; return c.back(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deque 是两头可进出，stack 是末端进，末端出（所以后进者先出）。</span></span><br><span class="line">        void push(const value_type x) &#123; c.push_back(x); &#125;</span><br><span class="line">        void pop() &#123; c.pop_back(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, class Sequence&gt;</span><br><span class="line">    bool operator==(const stack&lt;T, Sequence&gt; x, const stack&lt;T, Sequence&gt; y) &#123;</span><br><span class="line">        return x.c == y.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, class Sequence&gt;</span><br><span class="line">    bool operator&lt;(const stack&lt;T, Sequence&gt; x, const stack&lt;T, Sequence&gt; y) &#123;</span><br><span class="line">        return x.c &lt; y.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>代码非常类似于queue，除了pop弹出的是末尾元素，top也是返回末尾元素之外。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stl源码剖析之queue</title>
      <link href="/2014/12/31/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bqueue/"/>
      <url>/2014/12/31/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bqueue/</url>
      
        <content type="html"><![CDATA[<p>接着上面一篇，这次要讲的是另一个适配器容器queue。queue的操作很简单，先进先出。现在能够使用底层容器来实现，所以也非常简单。总之，这就是个简单的适配器吧。queue需要两个模版参数，类型和底层容器，默认的底层容器是deque。摘录出的代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> _STL_QUEUE_H</span><br><span class="line"><span class="number">#def</span>ine _STL_QUEUE_H</span><br><span class="line"><span class="selector-id">#include</span> &lt;deque&gt;</span><br><span class="line"></span><br><span class="line">namespace std</span><br><span class="line">&#123;</span><br><span class="line">    template &lt;class T, class Sequence = deque&lt;T&gt; &gt;</span><br><span class="line">    class queue &#123;</span><br><span class="line">        friend bool operator== (const queue x, const queue y);</span><br><span class="line">        friend bool operator&lt; (const queue x, const queue y);</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        typedef typename Sequence::value_type value_type;</span><br><span class="line">        typedef typename Sequence::size_type size_type;</span><br><span class="line">        typedef typename Sequence::reference reference;</span><br><span class="line">        typedef typename Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line">    protected:</span><br><span class="line">        Sequence c; // 底层容器</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        <span class="comment">// 以下完全利用 Sequence c 的操作，完成 queue 的操作。</span></span><br><span class="line">        bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">        size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">        reference front() &#123; return c.front(); &#125;</span><br><span class="line">        const_reference front() const &#123; return c.front(); &#125;</span><br><span class="line">        reference back() &#123; return c.back(); &#125;</span><br><span class="line">        const_reference back() const &#123; return c.back(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// deque 是两头可进出，queue 是末端进，前端出（所以先进者先出）。</span></span><br><span class="line">        void push(const value_type x) &#123; c.push_back(x); &#125;</span><br><span class="line">        void pop() &#123; c.pop_front(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, class Sequence&gt;</span><br><span class="line">    bool operator==(const queue&lt;T, Sequence&gt; x, const queue&lt;T, Sequence&gt; y) &#123;</span><br><span class="line">        return x.c == y.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, class Sequence&gt;</span><br><span class="line">    bool operator&lt;(const queue&lt;T, Sequence&gt; x, const queue&lt;T, Sequence&gt; y) &#123;</span><br><span class="line">        return x.c &lt; y.c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>总之，代码非常简洁。分析下代码，<span style="font-family: Consolas, Monaco, 'Bitstream Vera Sans Mono', 'Courier New', Courier, monospace; font-size: 13px; line-height: 1.5;">typedef typename Sequence::value_type value_type;</span>这其实，就是声明嵌套模版类型。还有必须注意的是，声明嵌套模版类型，必须加typename关键字，否则会将其视作定义。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stl源码剖析之priority_queue</title>
      <link href="/2014/12/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bpriority_queue/"/>
      <url>/2014/12/29/stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B9%8Bpriority_queue/</url>
      
        <content type="html"><![CDATA[<p>暑假时候好好阅读过，stl源码剖析这本书，之后又看了c++标准程序库，effective c++，more<br>effecttive c++。虽然每次都如醍醐灌顶般，明白了很多知识概念，有种拨开迷雾的感觉，但是终究抵不过<br>遗忘，所以了还是随便写写吧。<br>首先从实现代码差不多最短的优先队列开始，虽然简单的代码后面依赖很庞大的东西，比如泛型<br>迭代器，还有泛型二叉堆算法。我是这样理解优先队列的。首先，数据是存在一个泛型序列容器(线性容器)，<br>这个可以指定，默认是vector，当然指定list和deque也是可以的。另外还需要给数据类型提供个小于比较仿<br>函数，有些类型有默认的less泛型仿函数。所以了，对模版比较熟悉的同学，很自然就猜到了，priority_queue<br>的外观-&gt;一个模版（类型，线性容器，less仿函数）。<br>优先队列支持哪些操作了？什么empty，size，top，直接转交给底层容器就行了，所谓的适配器模式。<br>只需要思考，如何实现push和pop操作。对算法熟悉的同学，都知道底层数据的组织是用二叉堆的，而且是最大<br>堆。问题是，我们还需不需要实现个堆操作了。不需要了，stl做了所有的事情。push_heap就是将输入范围的最<br>后一个元素作为在原堆后面加入的新元素，再重构堆。pop_heap则是将堆首元素交换到堆末，再重构缩小之后的堆。<br>至于二叉堆的原理，就不仔细介绍了。其实也比较简单，如果不去思考一些复杂度的证明。<br>到最后，priority_queue的代码可以很清爽的出来了。尤其注意下面的那些typedef，可以说是模版<br>trick的常见手法，习惯了就好。这种写法还有个用法是为了使内嵌模版声明可见，记得effect c++提到过。以下<br>源码基本来自stl源码剖析随书奉送代码，做了些修改。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename Sequence = vector&lt;T&gt;,</span><br><span class="line">    typename Compare = less&lt;typename Sequence::value_type &gt;&gt;</span><br><span class="line">class  priority_queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef typename Sequence::value_type value_type;</span><br><span class="line">    typedef typename Sequence::size_type size_type;</span><br><span class="line">    typedef typename Sequence::reference reference;</span><br><span class="line">    typedef typename Sequence::const_reference const_reference; //为了使内嵌模版声明可见</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    Sequence c; // 底层容器</span><br><span class="line">    Compare comp;   // 元素大小比较仿函数</span><br><span class="line"></span><br><span class="line">    priority_queue() : c() &#123;&#125;</span><br><span class="line">    explicit priority_queue(const Compare x) : c(), comp(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class InputIterator&gt;</span><br><span class="line">    priority_queue(InputIterator first, InputIterator last, const Compare x)</span><br><span class="line">        : c(first, last), comp(x) &#123;</span><br><span class="line">        make_heap(c.begin(), c.end(), comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class InputIterator&gt;</span><br><span class="line">    priority_queue(InputIterator first, InputIterator last)</span><br><span class="line">        : c(first, last) &#123;</span><br><span class="line">        make_heap(c.begin(), c.end(), comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() const &#123; return c.empty(); &#125;</span><br><span class="line">    size_type size() const &#123; return c.size(); &#125;</span><br><span class="line">    const_reference top() const &#123; return c.front(); &#125;</span><br><span class="line"></span><br><span class="line">    void push(const value_type x)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            c.push_back(x);</span><br><span class="line">            push_heap(c.begin(), c.end(), comp);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (...)</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="attribute">clear</span>();</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            pop_heap(c.begin(), c.end(), comp);</span><br><span class="line">            c.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (...)</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="attribute">clear</span>();</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>再啰嗦几句，刚看源码剖析的时候，对某些模版写法很头疼，但是看完书之后，另外看了几本其它的书，<br>就对这些写法习以为常了，觉得不这么写才怪了。有点艺术的感觉。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stl源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任意点到二维直线或者三维平面上的投影点</title>
      <link href="/2014/12/09/%E4%BB%BB%E6%84%8F%E7%82%B9%E5%88%B0%E4%BA%8C%E7%BB%B4%E7%9B%B4%E7%BA%BF%E6%88%96%E8%80%85%E4%B8%89%E7%BB%B4%E5%B9%B3%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%8A%95%E5%BD%B1%E7%82%B9/"/>
      <url>/2014/12/09/%E4%BB%BB%E6%84%8F%E7%82%B9%E5%88%B0%E4%BA%8C%E7%BB%B4%E7%9B%B4%E7%BA%BF%E6%88%96%E8%80%85%E4%B8%89%E7%BB%B4%E5%B9%B3%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%8A%95%E5%BD%B1%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>这里统一考虑二维直线和三维平面的情况。<br>假设法线（二维直线和三维平面的法线）为n，其上的任意一点为p0。那么，<br>可以得到方程为：(p - p0)  *  n = 0。展开得到p * n = p0 * n。令p0 * n = d，由此可以得到<br>方程可以简单的表示为p * n = d，即(x, y, z) * (nx ,ny, nz) = d，二维情况直线的为(x, y) * (nx, ny) = d。<br>至此，我们可以方便的用(n,d)代表任意的二维直线或者三维平面了。<br>下面，开始应用这个表示。<br>比如，求点到直线或者平面的距离，然后求投影点，再求对称点。<br>最关键的是如何方便求出距离。假设我们要求q到直线的距离。我们现在的直线方程为<br>p * n = d。那么经过q与当前直线的平行直线的法线也为n。由于q在经过q的平行直线上面，有q * n = d’。<br>有符号距离为 d - d’ = d - q * n。通过这个式子，也可以知道d其实就是原点到直线或者平面的有符号距离。<br>那么投影点q’ = q + (d - d’) = q + (d - q * n)。<br>对称点则为 q’’ =  q’ +  (d  -  d’)  =  q + 2 * (d  -  q * n)。<br>利用这种表示方法，基本上可以直接给出答案。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>delete NULL是安全的</title>
      <link href="/2014/11/27/delete%20NULL%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84/"/>
      <url>/2014/11/27/delete%20NULL%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>一直以来都默认删除指针前，都得判断下是否是空指针。直到最近在看More Effective C++<br>的时候，作者明确指出了C++在语言层次上保证删除空指针是安全的，我才意识到这个问题。<br>我用vs2013实践了下，发现没有运行错误。所以了，这大概是从学习C语言起遗留下来的思维<br>定势吧。以前用C调用malloc申请内存的时候，对应的是free释放，free肯定是不能释放NULL指针的，所以<br>自然而然就觉得delete也不能处理NULL指针。<br>虽然说，这件事情无伤大雅，但是确实没必要在delete之前判断下是否为NULL了，毕竟自己<br>判断和编译器判断都是一样的结果，也不存在什么效率问题。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vs2013下配置cuda6.5和opencv2.4.10的gpu版本</title>
      <link href="/2014/11/13/vs2013%E4%B8%8B%E9%85%8D%E7%BD%AEcuda6.5%E5%92%8Copencv2.4.10%E7%9A%84gpu%E7%89%88%E6%9C%AC/"/>
      <url>/2014/11/13/vs2013%E4%B8%8B%E9%85%8D%E7%BD%AEcuda6.5%E5%92%8Copencv2.4.10%E7%9A%84gpu%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>首先，当然是安装好vs2013。第二步是配置最新的cuda6.5版本，这个有相关的教程。<br>这里要讲的是如何生成相应的opencv的gpu版本。<br>首先，当然是去opencv官方网站下载opencv，然后解压到指定的目录，最好不要出现<br>中文路径，因为后面需要用到cmake。2.4.10的<a href="http://sourceforge.net/projects/opencvlibrary/files/latest/download?source=files" target="_blank" rel="noopener">下载地址</a>，已经不好找了。最新的是3.0beta版本，<br>由于模块分类完全变了，所以还是别去吃螃蟹了。<br>下载好解压之后，会出现两个子目录，build和source。如果，你只使用cpu版本，那么build<br>里面的内容就满足你的要求了。否则，打开source目录，你会发现有一个CMakeLists.txt文件。<br>那么，肯定是需要使用cmake生成相应的工程了。<br>第二步，下载cmake，安装好cmake。<br>第三步，用cmake生成工程。操作方法：假如opencv在f盘根目录下面，那么设置好cmake的<br>source目录和build目录。然后点击configure按钮，选择对应的平台如visual studio 12。注意，现在<br>记得选择WITH_CUDA，WITH_CUFFT，WITH_CUBLAS等相关的选项。<br>然后，点击generate按钮就能生成对应的工程。如果，出现配置错误，可以根据cmake的<br>提示寻找原因。基本上是些环境变量的设置问题，或者是平台不匹配等。<br>如图所示：</p><p><img alt data-src="https://c2.staticflickr.com/8/7282/27175321180_663e09d18f_o.png"><br>注意build目录不用和source目录设置为同一个，否则可能引起问题，cmake也会出警告。<br>第四步，就是打开工程生成文件了。用vs2013或者你的使用版本，打开build目录下的OpenCV.sln<br>文件。最简单的办法，就是批生成-&gt;全选-&gt;重新生成。<br>关键的问题出现，如果你只是这样做，可能有几个dll无法编译出来，比如说opencv_gpu2410.dll。<br>问题在哪里了。我试验了好几次，每次几个小时，都是这样的结果。顿时觉得很郁闷，<br>只能去分析vs的输出内容了。突然发现有个错误提示：大致内容是NCV.cu文件中的std::max没有<br>定义。这个cu文件在..\opencv\sources\modules\gpu\src\nvidia\core下面。<br>你最后需要做的就是打开这个文件，然后包含algorithm头文件就行了，然后再重新编译吧。<br>PS：我只生成过32平台下的gpu版本了，64位的就没有去尝试了。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv gpu或者cuda加速第一次调用</title>
      <link href="/2014/11/11/opencv%20gpu%E6%88%96%E8%80%85cuda%E5%8A%A0%E9%80%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8/"/>
      <url>/2014/11/11/opencv%20gpu%E6%88%96%E8%80%85cuda%E5%8A%A0%E9%80%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>经测试，第一次gpu调用，无论是用opencv的gpu模块或者cuda都会比较耗时，可能将近1s。<br>额，这也不是我一个人碰到的问题，确实有这回事。stackoverflow上面有个帖子就是关于这个的。<br>帖子地址：<a href="http://stackoverflow.com/questions/12074281/why-opencv-gpu-codes-is-slower-than-cpu" target="_blank" rel="noopener">关于速度慢</a>，<a href="https://stackoverflow.com/questions/10415204/how-to-create-a-cuda-context" target="_blank" rel="noopener">关于解决办法</a>。<br>如果，看了上面的帖子话，这篇文章也不用看下去了。因为我要讲的就是这件事情。<br>我的观点也是，在第一次调用之前先建立cuda context。为什么需要做这样的事情了？额，假如，<br>你只调用一次gpu处理，总不能太慢了吧。那样就看不到速度了，所以先调用次垃圾操作初始化cuda环境。<br>方法是调用cudaFree(0)，在这之前最好调用先调用cudaSetDevice(0)。记住包含cuda的头文件，<br>如果只有opencv的头文件，这2个函数是找不到的。还有，建立的工程是cuda runtime模版。<br>在我的L0Smooth代码里，这样的处理之后，初次L0Smooth调用能减少1s左右，从3s变成了2s。<br>其余的耗时，基本都在gpu版本的dft和idft，还得继续寻找加快速度的办法。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv的gpu部分实现dft</title>
      <link href="/2014/11/10/opencv%E7%9A%84gpu%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0dft/"/>
      <url>/2014/11/10/opencv%E7%9A%84gpu%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0dft/</url>
      
        <content type="html"><![CDATA[<p>最近打算使用gpu优化L0Smooth的代码，但是不熟悉opencv的gpu部分的使用，<br>直接用cuda觉得太麻烦，还是继续试试opencv吧。<br>首先，从网站上下载下来的默认版本是不支持gpu的，必须下载代码下来，用cmake生成工程，注意<br>选择支持cuda等选项，具体参考教程。这样生成的版本才能支持gpu运算。<br>那么如何测试自己的opencv是否支持gpu计算了，以及自己的硬件是否符合要求？<br>使用这句代码打印cuda设备个数：<br>printf(“Device Num:%d\n”, cv::gpu::getCudaEnabledDeviceCount());<br>如果，个数大于0，那么说明你的显卡是支持cuda的，并且你的opencv版本支持gpu运算了。<br>下面是我测试成功的gpumat实现的dft和idft函数，输入和输出的都是cpu上的mat。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void Dft(cv::Mat <span class="keyword">in</span>, cv::Mat out)</span><br><span class="line">&#123;</span><br><span class="line">    cv::gpu::GpuMat gpuIn0(in.size(), CV_32FC1);</span><br><span class="line">    gpuIn0.upload(in);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;cv::gpu::GpuMat&gt; planes;</span><br><span class="line"></span><br><span class="line">    planes.push_back(gpuIn0);</span><br><span class="line"></span><br><span class="line">    cv::Mat zero = cv::Mat::zeros(in.size(), CV_32FC1);</span><br><span class="line">    cv::gpu::GpuMat gpuZero(in.size(), CV_32FC1);</span><br><span class="line">    gpuZero.upload(zero);</span><br><span class="line"></span><br><span class="line">    planes.push_back(gpuZero);</span><br><span class="line"></span><br><span class="line">    cv::gpu::GpuMat gpuIn(in.size(), CV_32FC2);</span><br><span class="line">    cv::gpu::merge(planes, gpuIn);</span><br><span class="line"></span><br><span class="line">    cv::gpu::GpuMat gpuOut(gpuIn.size(), CV_32FC2);</span><br><span class="line"></span><br><span class="line">    cv::gpu::dft(gpuIn, gpuOut, gpuIn.size(), 0);</span><br><span class="line"></span><br><span class="line">    out.create(in.size(), CV_32FC2);</span><br><span class="line">    gpuOut.download(out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IDft(cv::Mat <span class="keyword">in</span>, cv::Mat out)</span><br><span class="line">&#123;</span><br><span class="line">    cv::gpu::GpuMat gpuIn(in.size(), CV_32FC2);</span><br><span class="line">    cv::gpu::GpuMat gpuOut(in.size(), CV_32FC2);</span><br><span class="line"></span><br><span class="line">    gpuIn.upload(in);</span><br><span class="line">    cv::gpu::dft(gpuIn, gpuOut, gpuIn.size(), cv::DFT_INVERSE);</span><br><span class="line"></span><br><span class="line">    cv::gpu::GpuMat splitter[2];</span><br><span class="line">    cv::gpu::split(gpuOut, splitter);</span><br><span class="line"></span><br><span class="line">    out.create(in.size(), CV_32FC1);</span><br><span class="line"></span><br><span class="line">    double minV, maxV;</span><br><span class="line">    cv::gpu::minMax(splitter[0], minV, maxV);</span><br><span class="line">    splitter[0].convertTo(splitter[0], CV_32F, 255.0 / maxV);</span><br><span class="line">    splitter[0].download(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从代码上，可以看出，要尽可能把运算放到gpu上去，包括很多辅助运算，比如说merge,convert等可以加快速度。<br>这个版本的代码，dft的输入和输出都是双通道的，也就是一个通道实数，一个是复数的矩阵。通过merge生成和split分离。<br>这两个函数在分离通道单独处理时候非常有用，比如说可以分离彩色图像的三个通道，单独进行dft处理。最后再将结果合并。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅立叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv实现快速傅立叶变换和逆变换</title>
      <link href="/2014/11/07/opencv%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%92%8C%E9%80%86%E5%8F%98%E6%8D%A2/"/>
      <url>/2014/11/07/opencv%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%92%8C%E9%80%86%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>说实话觉得网上很多人转载的文章的挺坑的，全部是opencv文档程序的翻译，看来看去都是那一<br>篇，真的没啥意思。<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html" target="_blank" rel="noopener">文档的地址</a>。<br>本来opencv实现dft就是一个函数的事情，但是很少有关于逆变换使用的资料。我这几天在翻译<br>matlab版本的L0Smooth到opencv上面，就碰到这样一件很坑爹的事情。<br>首先，很少有人说清楚这个函数的使用方法。还有，根据教程，dft之前最好扩充原矩阵到合适的尺<br>寸(2,3,5的倍数)，再调用dft会加快速度。那么，idft的时候了？如何恢复原有的尺寸？<br>在我的L0Smooth代码里，就碰到这样的事情了。如果，图片尺寸是2，3，5的倍数，那么能够得到<br>正确结果。否则得到是全黑的图片。如果，我不扩张矩阵，那么就能正确处理。<br>所以，到这里，我不推荐调用dft之前先扩充矩阵了。因为，我找了很久也没找到解决办法。<br>我数学水平有限，也分析不出原因，也没有时间去系统的学习这些了。<br>这里提供两个例子，说明dft和idft的使用。<br>例子一：类似于opencv官方文档的例子<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"opencv2/core/core.hpp"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"opencv2/imgproc/imgproc.hpp"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"opencv2/highgui/highgui.hpp"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifdef</span> _DEBUG</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247d.lib"</span>)</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247.lib"</span>)</span><br><span class="line"><span class="selector-id">#endif</span> <span class="comment">// DEBUG</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read image from file</span></span><br><span class="line">    <span class="comment">// Make sure that the image is in grayscale</span></span><br><span class="line">    cv::Mat img = cv::imread("lena.JPG",0);</span><br><span class="line"></span><br><span class="line">    cv::Mat planes[] = &#123;cv::Mat_&lt;float&gt;(img), cv::Mat::zeros(img.size(), CV_32F)&#125;;</span><br><span class="line">    cv::Mat complexI;    //Complex plane to contain the DFT coefficients &#123;[0]-Real,[1]-Img&#125;</span><br><span class="line">    cv::merge(planes, 2, complexI);</span><br><span class="line">    cv::dft(complexI, complexI);  // Applying DFT</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里可以对复数矩阵comlexI进行处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reconstructing original imae from the DFT coefficients</span></span><br><span class="line">    cv::Mat invDFT, invDFTcvt;</span><br><span class="line">    cv::idft(complexI, invDFT, cv::DFT_SCALE | cv::DFT_REAL_OUTPUT ); // Applying IDFT</span><br><span class="line">    cv::invDFT.convertTo(invDFTcvt, CV_8U); </span><br><span class="line">    cv::imshow("Output", invDFTcvt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//show the image</span></span><br><span class="line">    cv::imshow("Original Image", img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until user press some key</span></span><br><span class="line">    cv::waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码意思很简单，dft之后再idft，注意参数额，必须有DFT_SCALE。代码中，先merge了个<br>复数矩阵，在例子2中可以看到，其实这一步可以去掉。<br>例子2：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"opencv2/core/core.hpp"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"opencv2/imgproc/imgproc.hpp"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"opencv2/highgui/highgui.hpp"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifdef</span> _DEBUG</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247d.lib"</span>)</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247.lib"</span>)</span><br><span class="line"><span class="selector-id">#endif</span> <span class="comment">// DEBUG</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read image from file</span></span><br><span class="line">    <span class="comment">// Make sure that the image is in grayscale</span></span><br><span class="line">    cv:;Mat img = cv::imread("lena.JPG",0);</span><br><span class="line"></span><br><span class="line">    cv::Mat dftInput1, dftImage1, inverseDFT, inverseDFTconverted;</span><br><span class="line">    cv::img.convertTo(dftInput1, CV_32F);</span><br><span class="line">    cv::dft(dftInput1, dftImage1, cv::DFT_COMPLEX_OUTPUT);    // Applying DFT</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reconstructing original imae from the DFT coefficients</span></span><br><span class="line">    cv::idft(dftImage1, inverseDFT, cv::DFT_SCALE | cv::DFT_REAL_OUTPUT ); // Applying IDFT</span><br><span class="line">    cv::inverseDFT.convertTo(inverseDFTconverted, CV_8U);</span><br><span class="line">    cv::imshow("Output", inverseDFTconverted);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//show the image</span></span><br><span class="line">    cv::imshow("Original Image", img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until user press some key</span></span><br><span class="line">    waitKey(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从代码中可以看到，dft时候添加参数DFT_COMPLEX_OUTPUT，就可以自动得到复数矩阵了，代码更加简洁。<br>注意，必须先将图片对应的uchar矩阵转换为float矩阵，再进行dft，idft，最后再转换回来。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 傅立叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cuda结合opencv实现简单的平滑滤波</title>
      <link href="/2014/11/05/cuda%E7%BB%93%E5%90%88opencv%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B3%E6%BB%91%E6%BB%A4%E6%B3%A2/"/>
      <url>/2014/11/05/cuda%E7%BB%93%E5%90%88opencv%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%B3%E6%BB%91%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p>这次也是使用opencv的mat加载处理图像。唯一与上次有区别的是核函数的编写。<br>根据cuda的线程分配模型，每一个像素是分配单独的线程处理的。那么有这样的一个疑问？<br>像平滑滤波这些应用，如何在每一个线程中获取周围的像素了？<br>其实，这个问题很好解决。因为，在核函数中，我们能够根据线程id，块id，块尺寸等计算<br>出当前像素的位置。那么，自然能够得到其邻域的位置。从而实现了平滑滤波。<br>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv/cv.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv/highgui.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv2/opencv.hpp&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"cuda_runtime.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"device_launch_parameters.h"</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifdef</span> _DEBUG</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247d.lib"</span>)</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247.lib"</span>)</span><br><span class="line"><span class="selector-id">#endif</span> <span class="comment">// DEBUG</span></span><br><span class="line"></span><br><span class="line">__global__ void smooth_kernel(const uchar3* src, uchar3* dst, int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    int x = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    int y = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="attribute">width</span>  y &lt; height)</span><br><span class="line">    &#123;</span><br><span class="line">        int offset = x + y * width;</span><br><span class="line">        int <span class="attribute">left</span> = offset - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">left</span> += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int <span class="attribute">right</span> = offset + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x + <span class="number">1</span> &gt;= <span class="attribute">width</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">right</span> -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int <span class="attribute">top</span> = offset - width;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">top</span> += width;</span><br><span class="line">        &#125;</span><br><span class="line">        int <span class="attribute">bottom</span> = offset + width;</span><br><span class="line">        <span class="keyword">if</span> (y + <span class="number">1</span> &gt;= <span class="attribute">height</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">bottom</span> -= width;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dst[offset].x = 0.125 * (4 * src[offset].x + src[left].x + src[right].x + src[top].x + src[bottom].x);</span><br><span class="line">        dst[offset].y = 0.125 * (4 * src[offset].y + src[left].y + src[right].y + src[top].y + src[bottom].y);</span><br><span class="line">        dst[offset].z = 0.125 * (4 * src[offset].z + src[left].z + src[right].z + src[top].z + src[bottom].z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void smooth_caller(const uchar3* src, uchar3* dst, int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    dim3 threads(16, 16);</span><br><span class="line">    dim3 grids((width + threads.x - 1) / threads.x, (height + threads.y - 1) / threads.y);</span><br><span class="line"></span><br><span class="line">    smooth_kernel&lt;&lt; &lt;grids, threads &gt;&gt; &gt;(src, dst, <span class="attribute">width</span>, height);</span><br><span class="line">    cudaThreadSynchronize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat image = cv::imread("lena.png");</span><br><span class="line">    cv::imshow("src", image);</span><br><span class="line"></span><br><span class="line">    size_t memSize = image.step * image.rows;</span><br><span class="line">    uchar3* d_src = NULL;</span><br><span class="line">    uchar3* d_dst = NULL;</span><br><span class="line">    cudaMalloc((void**)d_src, memSize);</span><br><span class="line">    cudaMalloc((void**)d_dst, memSize);</span><br><span class="line">    cudaMemcpy(d_src, image.data, memSize, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    smooth_caller(d_src, d_dst, image.cols, image.rows);</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(image.data, d_dst, memSize, cudaMemcpyDeviceToHost);</span><br><span class="line">    cv::imshow("gpu", image);</span><br><span class="line">    cv::waitKey(0);</span><br><span class="line"></span><br><span class="line">    cudaFree(d_src);</span><br><span class="line">    cudaFree(d_dst);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图：<br><img alt data-src="https://c2.staticflickr.com/8/7602/26844527913_20fbe94fea_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> 滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cuda和opencv混合使用</title>
      <link href="/2014/11/03/cuda%E5%92%8Copencv%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/"/>
      <url>/2014/11/03/cuda%E5%92%8Copencv%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这里我既不介绍opencv的基本使用，也更加不会介绍cuda的使用。推荐下cuda的一本书：GPU高性能编程CUDA实战。<br>opencv这么强大的工具不用肯定是浪费了，opencv也有gpu的部分，据说也是用cuda实现的，但是灵活性肯定不如直接用cuda吧。<br>所以，我觉得只需要使用opencv负责cpu的部分，比如加载图片，gui之类的，而cuda负责并行的处理。还有，本着方便的原则，<br>opencv使用cpp的版本，不想再去管内存分配释放了。虽然，Mat相对来说更难使用。<br>下面是一个简短的交换rb通道的cuda和opencv混合的程序。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv/cv.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv/highgui.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv2/opencv.hpp&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"cuda_runtime.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"device_launch_parameters.h"</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifdef</span> _DEBUG</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247d.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247d.lib"</span>)</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc247.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui247.lib"</span>)</span><br><span class="line"><span class="selector-id">#endif</span> <span class="comment">// DEBUG</span></span><br><span class="line"></span><br><span class="line">__global__ void swap_rb_kernel(const uchar3* src, uchar3* dst, int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    int x = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    int y = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="attribute">width</span>  y &lt; height)</span><br><span class="line">    &#123;</span><br><span class="line">        int offset = x + y * width;</span><br><span class="line">        uchar3 v = src[offset];</span><br><span class="line">        dst[offset].x = v.z;</span><br><span class="line">        dst[offset].y = v.y;</span><br><span class="line">        dst[offset].z = v.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap_rb_caller(const uchar3* src, uchar3* dst, int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    dim3 threads(16, 16);</span><br><span class="line">    dim3 grids((width + threads.x - 1) / threads.x, (height + threads.y - 1) / threads.y);</span><br><span class="line"></span><br><span class="line">    swap_rb_kernel&lt;&lt;&lt;grids, threads&gt;&gt;&gt;(src, dst, <span class="attribute">width</span>, height);</span><br><span class="line">    cudaThreadSynchronize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat image = cv::imread("lena_1.jpg");</span><br><span class="line">    cv::imshow("src", image);</span><br><span class="line"></span><br><span class="line">    size_t memSize = image.step * image.rows;</span><br><span class="line">    uchar3* d_src = NULL;</span><br><span class="line">    uchar3* d_dst = NULL;</span><br><span class="line">    cudaMalloc((void**)d_src, memSize);</span><br><span class="line">    cudaMalloc((void**)d_dst, memSize);</span><br><span class="line">    cudaMemcpy(d_src, image.data, memSize, cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    swap_rb_caller(d_src, d_dst, image.cols, image.rows);</span><br><span class="line"></span><br><span class="line">    cudaMemcpy(image.data, d_dst, memSize, cudaMemcpyDeviceToHost);</span><br><span class="line">    cv::imshow("gpu", image);</span><br><span class="line">    cv::waitKey(0);</span><br><span class="line"></span><br><span class="line">    cudaFree(d_src);</span><br><span class="line">    cudaFree(d_dst);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><a href="https://c2.staticflickr.com/8/7795/26842443314_eb03e5fc25_o.png" target="_blank" rel="noopener"><img alt data-src="https://c2.staticflickr.com/8/7795/26842443314_eb03e5fc25_o.png"></a><br>opencv部分不用做过多解释了，cuda的那些内存操作函数也不用解释。唯一需要解释的是核函数里面的这两句：int x = threadIdx.x + blockIdx.x * blockDim.x;<br>int y = threadIdx.y + blockIdx.y * blockDim.y;千万别搞错x和y，否则效果就完全不对了。根据cuda的模型，线程是一块一块的。一个线程块里面有很多线程，那么如何索引这些线程了？<br>把线程块看作是是三维的（一般用到一维或者二维）数组，然后根据数组索引得到具体线程。至于blockDim指的是一共有多少线程块了，这个也是三维的，意思一个gpu格子里面，<br>会出现三维的线程块组合。gpu格子的大小，在cuda里面用gridDim指代。所以，从上到下就是三层模型吧，三维的grid-&gt;三维的block-&gt;三维的thread。具体的理解，参照书籍或者教程吧。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs2013下设置cuda高亮</title>
      <link href="/2014/11/03/vs2013%E4%B8%8B%E8%AE%BE%E7%BD%AEcuda%E9%AB%98%E4%BA%AE/"/>
      <url>/2014/11/03/vs2013%E4%B8%8B%E8%AE%BE%E7%BD%AEcuda%E9%AB%98%E4%BA%AE/</url>
      
        <content type="html"><![CDATA[<p>因为是最近才接触cuda，安装的是6.5版本，所以网上的教程都不是完全适用了。<br>总之，设置高亮大致分为四步，不限于vs2013，其他平台下也类似。<br>第一步，是在vs2013里面设置vc++文件支持.cu;cuh;文件。方法：工具-&gt;选项-&gt;文本编辑器-&gt;文件扩展名。<br>得到如图所示的界面：注意，在右侧可以添加vc++类型的文件扩展名，这是我的设置效果，操作就不用细说了。<br><img alt data-src="https://c2.staticflickr.com/8/7108/27175378080_ea4f90c9db_o.png"><br>第二步，是设置visual assist的目录。在va的c/c++directory里面，选择custom选项，然后包含你的cuda的sdk目录，效果如图：<br><img alt data-src="https://c2.staticflickr.com/8/7376/27175377940_b07f4d0af3_o.png"><br>第三步，是设置va的支持文件类型，类似于第一步。但是，这次是修改注册表的值。注册表目录：<br>HKEY_CURRENT_USER/Software/Whole Tomato/Visual Assist X/VANet12，修改属性ExtSource的值为：.c;.cpp;.cc;.cxx;.tli;.cu;.cuh;<br>意思就是添加上cuda的头文件和源文件类型，vs2010的改法类似。<br>第四步，完成以上步骤之后，还可能会发现一些内置变量下面是有波浪线的。怎么办了？<br>加上这句：#include “device_launch_parameters.h”，就行了。cuda 6.5估计把内置变量的声明放在该头文件下面了吧。<br>最终的效果：<br><img alt data-src="https://c2.staticflickr.com/8/7543/26844573893_3f74990273_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>main函数返回,exit,abort</title>
      <link href="/2014/10/31/main%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E,exit,abort/"/>
      <url>/2014/10/31/main%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E,exit,abort/</url>
      
        <content type="html"><![CDATA[<p>最近在看C++标准程序库，看到介绍这两个函数的地方，记起来刚上大学的时候用exit结束<br>程序。那个时候什么都不懂，程序能运行就行了。不过，也好奇过这些东西，到底有什么区别了。<br>书上说的很简单，exit会释放static对象(当然包括全局对象，函数static对象，类的static对象)，<br>清空缓冲区，关闭io，然后终止程序（如果atexit有登记函数，那么执行这些函数）。<br>abort则真的是什么都不干，就退出来了。<br>以上两者都没有解栈(stack unwinding），也就是栈里面的变量没有析构。这个只有从main函数返回才会正常解栈。<br>那么，考虑这样的一个问题，既然程序都要结束了，这些操作到底有没有区别了。进程介绍了，<br>所有的资源都是还给操作系统了吧。只是从程序设计角度来说，资源还是应该由申请者释放的，个人是从这个角度看的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exit函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找工作的经历</title>
      <link href="/2014/10/29/%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
      <url>/2014/10/29/%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>工作其实早就确定了，三方也接受入库了。成埃落定，也是时候扯两句了。<br>由于以前没打算去工作，所以就没参加实习的校园招聘。暑假7月份尝试找了一次实习，没成功。校园招聘面试了四家，拿到了两家。<br>找工作的时候，也看了一些别人的面经，抱着回馈社会的想法，也写写我碰到的问题。虽然三言两语很难描述清楚，权当随便扯扯吧。</p><hr><p>第一家，2014.7月，AMD实习，结果：经理面没通过<br>参加的原因也莫名其妙，七月初，论文投出去了，导师给我发了个AMD科研小组实习招聘消息，我本着试一试的态度就试一试了。<br>1.科研小组实习面试<br>人家本来要的就是去做科研的，所以要求里面最好是发了文章，最好是博士生，硕士生也考虑。反正，当时我是做了英文版的简历投过去了。<br>过了几天hr确定电话面试的时候，那个小组的负责人就给我电话面试了。<br>大致问题：科研项目，C++(虚函数，多态)，算法(链表有环，数组中出现一次的数字，其余出现两次)，图形学(居然问我基本算法细节，只能说我简历写偏差了)。<br>大致就是问的这些吧，时间久了，也回忆不起来了。基本当然是最重要的，我暑假还没开始准备工作，所以也答得不怎么样。结果当时没有通过，虽然感觉面试官很热情，很有可能，<br>然后非常感谢他把我的简历给了驱动开发小组，所以我后面还有次机会。<br>2.OpenGL驱动开发小组面试<br>1&gt;1面：一面的面试官好喜欢聊，巴拉巴拉的说了一大堆。我还是分块回忆下吧。C++（vector和list的使用场合，map的实现）,体系结构（cpu缓存更新算法），操作系统（用户态和内核态区别），<br>算法（快排），OpenGL（glsl常用细节，VBO）等等。<br>2&gt;2面：二面面试官打电话一开始就跟我说一面反应非常好，也许是和一面面试官聊得很投缘吧，然后他要来确认下。所以，他就继续问了。大致问题：项目相关的东西，其余的和一面的差不多，<br>主要是根据简历问了下，记不起来了。<br>3&gt;3面经理面试：这次谈了好久，问题也问了很多，也说到以后实习的细节，但是我最终还是傻逼了，经理问我，如果AMD给我offer，问我怎么选，我说我现在还不清楚，<br>还没考虑这件事情，然后是双方沉默了一会儿。最终估计是他们考虑到我从长沙去上海的成本问题，以及中途必须去参加校招耽误时间等等，就不搭理我了，也算是客气的拒绝吧。<br>问题也问了很多，以项目和图形学为主。图形学（OpenGL光照模型，VBO，normal map），界面（MFC/QT熟悉程度)，其余大致和前面的差不多。主要是时间长了，记不起来了。</p><hr><p>第二家，2014.9月，阿里巴巴，结果：一面挂了<br>通过这次面试，我终于感受到了阿里的火爆程度和神奇程度。本来就打算去做游戏的，所以也没不是很在意结果，只是跑了一次武汉，等了那么久。<br>阿里是在线笔试，通过的人比较多。记得笔试题里面有个dp的最长连续子串。<br>从长沙跑去武汉，住了一晚。我选了11点的时间，但是9点多去的，结果一直在那里等，问了无数次hr，一直是再等15分钟，结果就真的等到11点了。<br>好吧，终于能够面试了。我面的方向是C++，但是一进去发现面试官的桌子上摆着java的牌子。无所谓了，开始面吧。<br>面试题目：C++（野指针有哪些情况，内存泄漏，怎么理解面向对象），数据结构和算法（B树，B+树，还有个简单的手写算法题，忘记了），操作系统（进程和线程的区别），<br>其余的就是我简历上的科研项目，<br>说了一大堆，自我感觉良好了，感觉面试官也有兴趣。只是最后，他问了句，你对互联网其他的方向了解不，我说不了解，听说过大数据什么的，然后就让等消息去了。<br>坐在外面等了一会儿，就有通知说你可以回去等消息了，意思是你玩完了。后面才知道，我和同学是同一个面试官一面刷的，他也是面c++，然后两个人还问了类似的题目，<br>只是刷的莫名其妙的。。。好吧，就这样吧。</p><hr><p>第三家，2014.9月，腾讯游戏，结果：终于拿到offer了<br>只能说幸福来的太突然。阿里挂了之后，就和同学去找另外的同学了。他们要去华科参加腾讯笔试，我腾讯选的地点是长沙，所以不怎么想笔试了。但是，既然来了就去霸笔下吧。<br>腾讯笔试的选择题范围比较广，也很基础，大家学好基础就什么都不怕了。大题一个进制转换，还有个进程通信，还有个好像是ios的。<br>说说面试吧。笔试完了之后就回长沙了，也没报希望，毕竟是霸笔的。大概是17号半夜1点多给我发的短信和邮件，呵呵，我早上9点多一到实验室才发现。hr工作时间挺晚的额，<br>让我10点钟赶到武汉面试，这是不可能的。然后，我就咨询同学怎么办，有人说打电话问，有人说发邮件问。我就抱着试一试的态度，发邮件到校招邮箱说明了情况。腾讯的效率真高，马上就有hr<br>打电话问我了。然后，商量好时间调到下午2点。唉，既然说话了，我只能再次踏上去武汉的征途了。<br>一面：两点多才赶到地点，找到之后去大厅问问，还以为我错过时间了，hr打电话问面试官，然后就让我马上去房间面试了。一面的估计是小boss。我说明了下从长沙赶来的情况，<br>面试官表示清楚，然后就开始面试了。题目：话说我记得的不多了，智力题（分油，这类题大家可以好好学学，我没做出来，我只是提出可以用搜索状态解决，然后面试官说不用这么麻烦，<br>让我再想，只是没思路了），算法题（有序数组构建搜索二叉树），图形学（直线和球求交点），其余的，我确实记得不清楚了。。。最后问了下，我这几年碰到什么过不去的难事没，<br>还有工作地点的倾向。然后面试官直接让我拿着草稿纸去二面面试官的房间了。<br>二面：二面感觉也是大boss了。二面问的问题更多，一开始是针对我的简历问我的科研项目，讲了好多，感觉面试官很多东西也懂，一直到后面问到无法问了，才问其他内容。<br>图形学（渲染管线，ogl或者dx都行，点关于平面对称点怎么求），智力题（显示读数的称，一次称重，区分不同的堆，具体的忘记了），算法题（用尽可能少的队列实现一个栈），C++（static的<br>用法，异常的初次处理和二次处理的区别），大概就这些吧，很多也忘记了。面试官人挺好的，给我安排第二天最早的hr，非常感谢额。<br>三面：第二天9点的hr面，基本上是自我介绍，然后问了我一个关于逻辑的智力题（如何处理城市拥堵与汽车发展的矛盾）。然后谈谈对腾讯氛围的感受之类的，问问就业地点意向。<br>回到长沙之后收到电话通知了，确认知道是一个游戏工作室，虽然在二面时候也询问了。再次感谢面试官的照顾，让我不用在武汉呆那么久。</p><hr><p>第四家，2014.9月，美团网，结果：拿到offer<br>在学校参加了美团的笔试和面试，过程挺顺利的。美团笔试毕竟变态，全部是写代码的大题，貌似大家也就能写完几个，时间也就90分钟。面试是在学校的一间教室。<br>一面、二面、三面，都是在教室一上午面完的，挺累的。<br>一面：先是问简历，问得比较详细，甚至到一些实现细节，这个得准备充分。算法（一个大数组找出一个重复出现的数字），操作系统（程序的堆和栈等信息，进程和线程的区别），<br>网络（四次挥手），其余的记不起来了。<br>二面：简历没怎么问了。C++（虚函数表），算法（两个矩形求交，顺子和同花计算概率），其余的也记不起来了。<br>三面：问了下就业意向，还有如何说明自己学习能力好。算法（大数组找中位数），其余的题目也记不起来了。<br>因为没抱什么希望，所以对offer也没什么感觉。因为不想去北京，后面hr叫过去谈offer的时候，差不多直接拒绝了，后面还是发了电子档的offer。</p><hr><p>第五家，2014.10月，网易游戏，结果：终面挂了<br>参加笔试和面试一共跑了武汉两趟，也是悲剧。笔试是9月底，在华科。笔试很长的试卷，貌似是150分钟。前面是变态的基础题，后面是变态的算法题。笔试是通过了，<br>虽然做的乱七八糟了。最难看的是我的字迹。算法题：记得有个递归改非递归，四叉树，dp，还有k-d tree等等。。<br>面试一共是两面，一个上午面完的，面完之后感觉还不错，只是后面就没消息了。一面之前先手写了个代码题（我的是合并字符串，类似于归并排序的合并部分），<br>再拿过去给一面面试官，话说我硬是在那里等了一个小时，别人只需要等20分钟左右，真的很无解额。<br>一面：先也是针对简历，然后是c++，设计模式，算法，图形学之类的。C++（多态…），设计模式（貌似是个状态模式还是啥，我设计模式很渣），<br>算法（概率类dp，最优化搜索二叉树），图形学（glsl常识），更多的忘记了，过了一会儿就去二面了。<br>二面：二面面试官感觉人很和善，一直笑眯眯的。也问了很多问题，最后还聊了腾讯和网易这两家。开始也先是问简历，只是这次我说的不多，感觉不给力，说实话得注意突出自己。<br>C++（实现类的set和get），图形学（光照模型，glsl片元获得实际位置等），算法题（手写数组去重，线段树实现区间覆盖查询，我当时居然没说清楚线段树实现，败了），<br>感觉问题不多，聊得也不错。后面就问我拿到什么offer，我说了有腾讯的。然后，他就开始比较腾讯了，说了一些某些公司怎么样的话，进行了一些对比，也说了网易的培训机制。<br>这样一说，我就感觉我通过的可能性很大的。而且，最后他还送我出门，握手了，受宠若惊。只是最后居然没通知，非常意外的感觉。只能说，我还是太年轻了， 很多准备没做充分，好好努力吧。<br>PS：说实话，即使过了我也不一定去，因为我爸爸和叔叔在深圳那边上班。也感觉腾讯氛围和平台确实更舒服，虽然网易多几万的工资，也号称工资和奖金分开算。<br>不过，我既然去不了就永远不会知道内幕了。<br>这就是我找工作的整个过程，因为时间有点久了，记不起那么多了，再不写估计就忘记完了。感谢碰到的每个面试官，是你们让我成长和得到承认额，<br>尤其感觉腾讯的面试官，给了我人生的这次非常重要的机会。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL立即模式必须先指定纹理坐标</title>
      <link href="/2014/10/27/OpenGL%E7%AB%8B%E5%8D%B3%E6%A8%A1%E5%BC%8F%E5%BF%85%E9%A1%BB%E5%85%88%E6%8C%87%E5%AE%9A%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87/"/>
      <url>/2014/10/27/OpenGL%E7%AB%8B%E5%8D%B3%E6%A8%A1%E5%BC%8F%E5%BF%85%E9%A1%BB%E5%85%88%E6%8C%87%E5%AE%9A%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>说实话，立即模式用了一年多了，还是犯了这个错误。因为很多代码例子里面都是先指定法线，再指定位置，结果添加纹理坐标的时候就变成了指定纹理坐标在最后。<br>错误的写法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glNormal3f(n.x(), n.y(), n.z());</span><br><span class="line">glVertex3f(p.x(), p.y(), p.z());</span><br><span class="line">glTexCoord1f(g_p_DisFromFile-&gt;norm_dis[g_denoted_point_id][he-&gt;vertex()-&gt;tag()]);</span><br></pre></td></tr></table></figure><p>不要以为这个bug很简单，说实话这种绘制的bug，不知道真的无从调试起来。。。这样写出现什么样子的bug，看下图吧。。。<br><img alt data-src="https://c2.staticflickr.com/8/7241/27175251640_077ce24c67_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7691/27417552636_58c2958b6a_o.png"><br>面片是不是很恶心的块状物？？？我这里绘制的是三维属性场，肯定是连续的，我无论怎么改插值模式，都没有用。。。<br>后面才回想起以前遇到过这个bug，所以改过来了。正确的代码应该是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glTexCoord1f(g_p_DisFromFile-&gt;norm_dis[g_denoted_point_id][he-&gt;vertex()-&gt;tag()]);</span><br><span class="line">glNormal3f(n.x(), n.y(), n.z());</span><br><span class="line">glVertex3f(p.x(), p.y(), p.z());</span><br></pre></td></tr></table></figure><p>正确的显示结果是：</p><p><img alt data-src="https://c2.staticflickr.com/8/7425/27380202661_e1bb2be00c_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7541/27175250770_c2656854e3_o.png"><br>如此简单的事情，能造成这样大的差距。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快排的N种写法</title>
      <link href="/2014/10/09/%E5%BF%AB%E6%8E%92%E7%9A%84N%E7%A7%8D%E5%86%99%E6%B3%95/"/>
      <url>/2014/10/09/%E5%BF%AB%E6%8E%92%E7%9A%84N%E7%A7%8D%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>首先声明下，只扯面试时候容易手写出来的代码。不写类似于stl里面实现sort的优化部分，包括递归层次太深了改用堆排序，还有当序列长度小于一定值，改用插排，等等。<br>这里只讲快排主函数的三种写法和partion的两种写法，加上轴元素的选择。<br>为了兼容stl，假设传入的参数是指针(直接可以换成迭代器了)。<br>所以主函数应该是这样的接口:void QSort(int<em>beg, int</em> end);<br>主函数写法1—-分治递归，也就是常用的写法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void QSort(int* beg, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    if (beg &gt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int* middle = Partion(beg, end);</span><br><span class="line">    QSort(beg, middle);</span><br><span class="line">    QSort(middle + 1, end);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个是最直观，最简单的写法，至于快排的思路就不介绍了。下面是将其改成循环形式的递归，也有人说这是尾递归，但是当前栈不能完全消除额。所以，到底是不是尾递归了？<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void QSort(int* beg, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    if (beg &gt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (beg &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int* middle = Partion(beg, end);</span><br><span class="line">        QSort(beg, middle);</span><br><span class="line">        beg = middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说下我对这种写法的理解。其实，推广一下，分治造成的多次递归调用都可以改成这种循环形式。这样的话，双支就变成单支了，至少能减少爆栈的可能性。其余的好处，应该不大吧。问题是，如何将其改成这种循环形式了。额，其实可以这样想。分治的话，是划分为多个子问题，那么循环尾递归的话，是一次处理原问题的一部分，不断减少原问题，那么代码思路就顺理成章的出来了。上面的代码[beg,end)就代表的是问题空间，每次循环一直在减小这个空间。<br>下面说一个更少见的写法，就是将递归改成非递归。其实了，这种写法，会的人觉得很简单，不会的人就会觉得少见。递归改循环，大家都知道是加个栈，问题是如何用栈模拟递归了。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void QSort(int* beg, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    if (beg &gt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Infor</span><br><span class="line">    &#123;</span><br><span class="line">        int* beg;</span><br><span class="line">        int* end;</span><br><span class="line">        Infor(int* b = 0, int* e = 0) : beg(b), end(e) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    stack&lt;Infor&gt; si;</span><br><span class="line">    si.push(Infor(beg, end));</span><br><span class="line"></span><br><span class="line">    while (si.size())</span><br><span class="line">    &#123;</span><br><span class="line">        Infor <span class="keyword">in</span> = si.<span class="attribute">top</span>();</span><br><span class="line">        si.pop();</span><br><span class="line"></span><br><span class="line">        int* middle = Partion(in.beg, in.end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (middle &gt; <span class="keyword">in</span>.beg)</span><br><span class="line">        &#123;</span><br><span class="line">            si.push(Infor(in.beg, middle));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (middle  + 1 &lt; in.end)</span><br><span class="line">        &#123;</span><br><span class="line">            si.push(Infor(middle + 1, in.end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上面的代码中，能够体会到，其实在栈里面存储下递归的参数就行了。栈反正是先入后出的，递归不也是这样么？那么，我们可以采用模拟先序，中序，或者后序遍历树的方法，任何递归都能够模拟出来吧，只是代码复杂程度的问题了。只是真正理解这个，需要一点点时间而已。上面的代码，其实就是用栈模拟了先序遍历二叉树吧。<br>那么剩下的就是partion函数了。<br>先来一个教科书版本的代码。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int* Partion(int* beg, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    --end;</span><br><span class="line">    int tmp = *end;</span><br><span class="line">    while (beg &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        while (beg &lt; end  *beg &lt;= tmp) ++beg;</span><br><span class="line">        *end = *beg;</span><br><span class="line"></span><br><span class="line">        while (beg &lt; end  *end &gt;= tmp) --end;</span><br><span class="line">        *beg = *end;</span><br><span class="line">    &#125;</span><br><span class="line">    *end = tmp;</span><br><span class="line"></span><br><span class="line">    return end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个代码应该非常常见，大部分写法就是这种。首先，看到轴元素是在end处。所以了，将end处的元素暂存，所以end就空出来了。因此，先从头开始遍历到第一个大于*end的元素，然后将其放入end。剩下的一个循环就是从后面往前面遍历了。最后大循环结束时候，beg必定等于end，而且必定放的是一个重复的元素，所以了，放入轴元素就行了。<br>下面介绍种更简便的写法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int* Partion(int* beg, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    --end;</span><br><span class="line">    int* small = beg;</span><br><span class="line">    while (beg &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*beg &lt; *end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (beg != small)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(*beg, *small);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++small;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(*end, *small);</span><br><span class="line"></span><br><span class="line">    return small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个代码只要一个循环，思路是[0,small)中放小于轴元素的数字，保持这个集合就行了。那么，最终轴元素就应该放在small处。理解下吧，这个代码更方面手写出来。<br>现在还剩个更严重的问题，如何消除快排的最坏情况出现的可能。最坏情况出现在输入数据本身有序的时候。<br>如果听说过随机算法，那么这个问题就知道怎么轻松解决了。在算法中，加入随机性操作吧。在partion，可以随机选择轴元素，也可以采用三点取中法选择轴元素。至于证明，参加算法导论。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int* Partion(int* beg, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    int len = end - beg;</span><br><span class="line"></span><br><span class="line">    swap(beg[rand() % len], *(end - 1));//随机选取轴元素</span><br><span class="line"></span><br><span class="line">    --end;</span><br><span class="line">    int* small = beg;</span><br><span class="line">    while (beg &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*beg &lt; *end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (beg != small)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(*beg, *small);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++small;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(*end, *small);</span><br><span class="line"></span><br><span class="line">    return small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三点取中法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int* Partion(int* beg, int* end)</span><br><span class="line">&#123;</span><br><span class="line">    int len = end - beg;</span><br><span class="line">    int* middle = beg + len / 2;</span><br><span class="line">    --end;</span><br><span class="line">    <span class="keyword">if</span> (*middle &lt; *beg)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(*middle, *beg);</span><br><span class="line">    &#125;</span><br><span class="line">    if (*end &lt; *beg)//最小</span><br><span class="line">    &#123;</span><br><span class="line">        swap(*beg, *end);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (*end &gt; *middle)//最大</span><br><span class="line">    &#123;</span><br><span class="line">        swap(*middle, *end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int* small = beg;</span><br><span class="line">    while (beg &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*beg &lt; *end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (beg != small)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(*beg, *small);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++small;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(*end, *small);</span><br><span class="line"></span><br><span class="line">    return small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>组合这些不同的写法，确实可以出现很多个版本的快排算法了。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>top k算法和partial_sort</title>
      <link href="/2014/10/08/top%20k%E7%AE%97%E6%B3%95%E5%92%8Cpartial_sort/"/>
      <url>/2014/10/08/top%20k%E7%AE%97%E6%B3%95%E5%92%8Cpartial_sort/</url>
      
        <content type="html"><![CDATA[<p>最近因为准备找工作的东西，看了不少书，感悟也挺多的。stl源码剖析，effective c++，面试宝典，剑指offer，大话设计模式，编程精粹，还有很多想看的还没看完了。。。这段时间，看完这些书后，真的发现，看书是一件很棒的事情，不仅仅是知识的学习，查漏补缺，思维的体验也是一件让人觉得满心愉悦的事情。有点明白古人雪夜读书的感觉，那时候没有电脑可以玩，没有那么多娱乐的游戏，读书确实是一件让人愉悦的事情。<br>很久没有更新博客了，随便扯扯吧。<br>所谓的top k算法，意思就是求n个数字的最大k个或者最小k个，大概也是个比较常见的面试题了。一般有两种思路，第一种是利用快排里面的partion函数，不断用轴元素分割数组，直到分割出前k个或者后k个，迭代或者递归都是很方便的；stl里面有个nth_element泛函做的就是这件事情。第二种思路，则是假定有一个容量为k的容器，存储了当前的top k元素，当处理下一个元素的时候，判断当前处理元素是否可能是top k元素，比如如果求最大的k个元素，则判断当前处理元素是否比容器里面最小元素大，如果大的话，则需要加入当前元素，并且删除容器里面最小的元素，反之亦然。现在的问题是，如何选取一个很好的容器了。能够使得这些操作尽可能快。其实大家知道的容器也就那几种类型，基本上是stl里面已经实现了的。线性？搜索树？hash？<br>hash的话，没法快速查找极值，线性结构的话，插入新元素，保持有序结构的话，也需要O(n)。那么，搜索树结构了，查找和删除都是log(n)，stl里面有现成的红黑树实现set容器。另外，还有个更奇葩的用数组表示的完全二叉树结构，最大堆和最小堆。可以满足O(1)查找极值元素和log(n)插入删除操作，最终还可以排序元素。综上所说，堆结构是在时间和空间上最佳的满足要求的容器了。<br>刚好stl里面有个partial_sort函数也是用这个思路实现的，而且最后还排了一个序，所以，实际开发的时候多了解下标准库是值得投入的一件事情。<br>下面是用stl的heap操作实现的top k算法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;cstdlib&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; vi;</span><br><span class="line">    const int NUM = 100;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vi.push_back(rand() % NUM);</span><br><span class="line">        printf("%d ", vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf("\n");</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求最小k个数字</span></span><br><span class="line">    const int K = 10;</span><br><span class="line"></span><br><span class="line">    make_heap(vi.begin(), vi.begin() + K);</span><br><span class="line">    for (int i = K; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vi[i] &lt; vi[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            pop_heap(vi.begin(), vi.begin() + K);</span><br><span class="line">            vi[K - 1] = vi[i];</span><br><span class="line">            push_heap(vi.begin(), vi.begin() + K);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort_heap(vi.begin(), vi.begin() + K);</span><br><span class="line">    for (int i = 0; i &lt; K; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf("%d ", vi[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf("\n");</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> top k </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态的内存结构</title>
      <link href="/2014/08/17/%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2014/08/17/%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>这里的多态指的是动态多态，不包括函数重装和模版的静态多态内容。多态所代表的特性，才是面向对象的真正表现。具体行为其实就是用基类的指针或者引用调用虚函数，得到的结果跟指针指向对象的具体类型有关，而跟指针的静态类型无关。比如说，基类指针指向派生类A的对象，那么调用的其实是派生类A里面实现的虚函数，如果是派生类B的对象，那么则是B类里面实现的虚函数。<br>我们先定义一个接口。也就是一个包含纯虚函数的类，这种类不能用于构造对象。其实，接口才是我们最关心的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">#def</span>ine interface struct</span><br><span class="line">interface IAnimal</span><br><span class="line">&#123;</span><br><span class="line">    virtual void Eat() = 0;</span><br><span class="line">    virtual void Drink() = 0;</span><br><span class="line">    virtual void Sleep() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后定义2个类继承这个接口。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">class  CMonkey : public IAnimal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CMonkey()</span><br><span class="line">    &#123;</span><br><span class="line">        m_nSex = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Eat()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "Monkey Eat" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Drink()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "Monkey Drink" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Sleep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "Monkey Sleep" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enum SEX</span><br><span class="line">    &#123;</span><br><span class="line">        MALE = <span class="number">0</span>,</span><br><span class="line">        FEMALE = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int GetSex() const &#123; return m_nSex; &#125;</span><br><span class="line">    void SetSex(int nSex) &#123; m_nSex = nSex; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_nSex;//0:male,1:female</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class  CMonster : public IAnimal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CMonster()</span><br><span class="line">    &#123;</span><br><span class="line">        m_nEvil = NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Eat()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "Monster Eat" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Drink()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "Monster Drink" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Sleep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "Monster Sleep" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enum EVIL</span><br><span class="line">    &#123;</span><br><span class="line">        NO = <span class="number">0</span>,</span><br><span class="line">        YES = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    int GetEvil() const &#123; return m_nEvil; &#125;</span><br><span class="line">    void SetEvil(int nEvil) &#123; m_nEvil = nEvil; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_nEvil;//0:no,1:yes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再定义CPeople多重继承上面2个类。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class CPeople : public CMonkey, public CMonster</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Eat()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "People Eat" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Drink()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "People Drink" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Sleep()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "People Sleep" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void Name()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; "People Name" &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char* GetName() const &#123; return m_szName; &#125;</span><br><span class="line">    void SetName(char* pszName) &#123; strcpy(m_szName, pszName); &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char m_szName[12];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先来测试多态是如何表现的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CMonkey monkey;</span><br><span class="line">monkey.SetSex(CMonkey::MALE);</span><br><span class="line"></span><br><span class="line">CMonster monster;</span><br><span class="line">monster.SetEvil(CMonster::YES);</span><br><span class="line"></span><br><span class="line">CPeople people;</span><br><span class="line">people.SetName("Jack");</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面代码用于展示多态</span></span><br><span class="line">IAnimal* pAnimal[3];</span><br><span class="line">pAnimal[0] = monkey;</span><br><span class="line">pAnimal[1] = monster;</span><br><span class="line">pAnimal[2] = (CMonkey*)people;</span><br><span class="line">for (int i = 0; i &lt; 3; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    pAnimal[i]-&gt;Eat();</span><br><span class="line">    pAnimal[i]-&gt;Drink();</span><br><span class="line">    pAnimal[i]-&gt;Sleep();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这段代码的输出如下：<br><img alt data-src="https://c2.staticflickr.com/8/7434/27380153181_ff9b2957e2_o.png"><br>从代码的输出可以看到，pAnimal[i]是根据所指向的数据类型确定该调用什么函数的。这就是多态的意思。相同的接口，不同的表现。<br>下面我们来推测这几个对象的内存布局。首先是monkey。<br>假设，对象monkey的内存布局，如图：<img alt data-src="https://c2.staticflickr.com/8/7437/27417494266_3100a6f0a1_o.png"><br>也就是，monkey保护2个成员，一个虚函数表指针和一个int成员。虚函数表指针指向一个表，前面3项是函数地址，第四项是NULL，第五项根据有些书籍的说法是type_info对象的地址。<br>我用下面的代码来验证这个内存布局。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*FunType) ();</span><br><span class="line">FunType p;</span><br><span class="line">int nSex;</span><br><span class="line">int* vtbl = NULL;</span><br><span class="line">cout &lt;&lt; "sizeof(monkey): " &lt;&lt; sizeof(monkey) &lt;&lt; endl;</span><br><span class="line">vtbl = (int*)(*(int*)monkey);//虚函数指针</span><br><span class="line">cout &lt;&lt; "vtbl address:" &lt;&lt; (int)vtbl &lt;&lt; endl;</span><br><span class="line">p = (FunType)vtbl[0];</span><br><span class="line">p();</span><br><span class="line">p = (FunType)vtbl[1];</span><br><span class="line">p();</span><br><span class="line">p = (FunType)vtbl[2];</span><br><span class="line">p();</span><br><span class="line">cout &lt;&lt; "vtbl[3]:" &lt;&lt; vtbl[3] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "vtbl[4]:" &lt;&lt; vtbl[4] &lt;&lt; endl;</span><br><span class="line">nSex = *((int*)monkey + 1);</span><br><span class="line">cout &lt;&lt; "nSex: " &lt;&lt; nSex &lt;&lt; endl &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出如同：<img alt data-src="https://c2.staticflickr.com/8/7353/27417494176_8b8ba18342_o.png"><br>从输出可以看到，monkey大小为8字节，刚好是一个指针和一个int的大小。而且，monkey的地址转换为int*之后，再取值就可以得到虚函数表的地址。用vtbl[0]到vtbl[2]调用刚好是调用接口里面定义的三个虚函数。vtbl[3]为0，vtbl[4]为一个地址。为什么，这里推断vtbl里面含有5项了，而不是4项了。下面再说明。<br>monster的内存布局类似，就不说明了。<br>最关键的是people的内存布局。推测如下图所示：<img alt data-src="https://c2.staticflickr.com/8/7493/27451678785_83cd5ec637_o.png"><br>用下面的代码，来验证这个假设。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; "sizeof(people): " &lt;&lt; sizeof(people) &lt;&lt; endl;</span><br><span class="line">vtbl = (int*)(*(int*)people);//虚函数指针</span><br><span class="line">cout &lt;&lt; "vtbl address:" &lt;&lt; (int)vtbl &lt;&lt; endl;</span><br><span class="line">p = (FunType)vtbl[0];</span><br><span class="line">p();</span><br><span class="line">p = (FunType)vtbl[1];</span><br><span class="line">p();</span><br><span class="line">p = (FunType)vtbl[2];</span><br><span class="line">p();</span><br><span class="line">p = (FunType)vtbl[3];</span><br><span class="line">p();</span><br><span class="line">cout &lt;&lt; "vtbl[4]:" &lt;&lt; vtbl[4] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "vtbl[5]:" &lt;&lt; vtbl[5] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">nSex = *((int*)people + 1);</span><br><span class="line">cout &lt;&lt; "nSex: " &lt;&lt; nSex &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vtbl = (int*)(*((int*)people + 2));//虚函数指针</span><br><span class="line">cout &lt;&lt; "vtbl address:" &lt;&lt; (int)vtbl &lt;&lt; endl;</span><br><span class="line">p = (FunType)vtbl[0];</span><br><span class="line">p();</span><br><span class="line">p = (FunType)vtbl[1];</span><br><span class="line">p();</span><br><span class="line">p = (FunType)vtbl[2];</span><br><span class="line">p();</span><br><span class="line">cout &lt;&lt; "vtbl[3]:" &lt;&lt; vtbl[3] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; "vtbl[4]:" &lt;&lt; vtbl[4] &lt;&lt; endl;</span><br><span class="line">nEvil = *((int*)people + 3);</span><br><span class="line">cout &lt;&lt; "nEvil: " &lt;&lt; nEvil &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">char* pszName = (char*)((int*)people + 4);</span><br><span class="line">cout &lt;&lt; pszName &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>输出如同：<img alt data-src="https://c2.staticflickr.com/8/7050/27380153041_b39de8e71f_o.png"><br>people大小为28字节，符合假设。第一个成员为继承自CMonkey的虚函数表指针，符合假设。虚函数表的前三项，是在CPeople类中实现的接口里面虚函数地址，接下来CPeolple里面定义的虚函数Name的地址，最后是NULL和type_info obj的地址。people的第三个成员为继承自CMonster的虚函数指针，指向虚函数表的第七项。从第七项开始，可以看作继承自CMonster的虚函数表。<br>从输出可以看出，CPeople里面新定义的虚函数，放到第一个虚函数指针所指向的虚表里面了。并且，由于一个类只有只有一张虚表，所以不同的虚函数指针所指向的其实是虚表的不同部分。这些表可以看作是独立的，也可以看作是地址上面连续的。<br>前面说过，为什么猜测虚函数表里面还有一个NULL项了，然后才跟随一个type_info obj的地址？由于，在上面的输出中，2个虚函数指针相差是24。所以，我猜测第一个虚表里面含有6项。经过代码测试，第五项也是0。<br>至于为什么猜测内存布局里面先是虚函数表的指针，再是数据成员，这个是我通过代码测试得来的。环境是vs2013。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>extern &quot;C&quot;的理解</title>
      <link href="/2014/08/15/extern%20C%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2014/08/15/extern%20C%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>我们经常会看到头文件里面会有下列的结构。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifdef</span> __cplusplus</span><br><span class="line">extern <span class="string">"C"</span> &#123;</span><br><span class="line">#endif</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"><span class="selector-id">#ifdef</span> __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>而且我们也大都知道这是为了和C语言兼容。但是更具体的事情了？<br>实际上，这段代码是为了保证用C语言调用C++函数或者用C++调用C语言实现的函数，都能够顺利进行。不仅仅是单向的左右。如果没有加#ifdef <strong>cplusplus判断就是单向的吧。<br>大家都知道C++支持函数重载，而C语言是不支持的。所以，类似函数int add(int,int)很可能在链接的时候，符号是_add_int_int。而在C语言里面，还是_add。既然符号不一样，那就会找不到吧。这就发生在用C语言去调用C++实现的函数的时候。如果在C++头文件里面加上extern “C”声明，那么就会按照C语言的方式生成函数，自然能和C语言兼容了。<br>如下列代码，就能顺利运行。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="selector-id">#ifndef</span> ADD_H</span><br><span class="line"><span class="number">#def</span>ine ADD_H</span><br><span class="line"></span><br><span class="line"><span class="comment">//int add(int x, int y);</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifdef</span> __cplusplus</span><br><span class="line">extern <span class="string">"C"</span> &#123;</span><br><span class="line">#endif</span><br><span class="line">    int add(int x, int y);</span><br><span class="line"><span class="selector-id">#ifdef</span> __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.cpp</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"add.h"</span></span><br><span class="line"></span><br><span class="line">int add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"add.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    add(1, 2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果把头文件定义改成，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="selector-id">#ifndef</span> ADD_H</span><br><span class="line"><span class="number">#def</span>ine ADD_H</span><br><span class="line"></span><br><span class="line">int add(int x, int y);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*#ifdef __cplusplus</span></span><br><span class="line"><span class="comment">extern "C" &#123;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    int add(int x, int y);</span></span><br><span class="line"><span class="comment">#ifdef __cplusplus</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#endif*/</span></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>main.c就无法链接到函数_add上面。提示：main.obj : error LNK2019: 无法解析的外部符号 _add，该符号在函数 _main 中被引用。<br>现在再反过来，用c语言实现add，c++实现main。代码如下，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.h</span></span><br><span class="line"><span class="selector-id">#ifndef</span> ADD_H</span><br><span class="line"><span class="number">#def</span>ine ADD_H</span><br><span class="line"></span><br><span class="line">int add(int x, int y);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*#ifdef __cplusplus</span></span><br><span class="line"><span class="comment">extern "C" &#123;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    int add(int x, int y);</span></span><br><span class="line"><span class="comment">#ifdef __cplusplus</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">#endif*/</span></span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">//add.c</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"add.h"</span></span><br><span class="line"></span><br><span class="line">int add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"add.h"</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    add(1, 2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果还是无法链接，提示： error LNK2019: 无法解析的外部符号 “int </strong>cdecl add(int,int)” (?add@@YAHHH@Z)，该符号在函数 _main 中被引用。这是因为main.cpp用C++的方式去查找函数符号，_add_int_int，而add.c里面生成的符号是_add。因此无法链接上去。那么，能不能直接加上extern “C”就行了？<br>由于C语言里面不支持extern “C”，那么作为C语言的头文件就不能这么加，应该加上#ifdef __cplusplus的判断，再将所有的函数定义前加上extern “C”，就能保证该头文件同时兼容C语言和C++了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> extern &quot;C&quot; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于引用可以被重新赋值的搞笑误解</title>
      <link href="/2014/08/15/%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%E7%9A%84%E6%90%9E%E7%AC%91%E8%AF%AF%E8%A7%A3/"/>
      <url>/2014/08/15/%E5%85%B3%E4%BA%8E%E5%BC%95%E7%94%A8%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%E7%9A%84%E6%90%9E%E7%AC%91%E8%AF%AF%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>以前在群里面发现有人说，引用可以被赋值，然后其推断出引用其实是可以重新指向其它对象的，而不是只能在初始化时确定所指对象，以后不能改变。如果是这样的话，引用和指针还有什么区别了。存在引用的好处就是，引用一经过定义就确定所指对象，以后不用测试其是否指向无效对象，也不用担心所指对象会改变。<br>下面来看看这段造成误解的代码吧。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nA = 10;</span><br><span class="line">    int nRef = nA;//必须初始化</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; "nA:" &lt;&lt; nA &lt;&lt; ' ' &lt;&lt; "nRef:" &lt;&lt; nRef &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    int nB = 11;</span><br><span class="line">    nRef = nB;//难道引用可以重新指向nB?</span><br><span class="line">    cout &lt;&lt; "nB:" &lt;&lt; nB &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; "nA:" &lt;&lt; nA &lt;&lt; ' ' &lt;&lt; "nRef:" &lt;&lt; nRef &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    nRef = 12;</span><br><span class="line">    cout &lt;&lt; "nB:" &lt;&lt; nB &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; "nA:" &lt;&lt; nA &lt;&lt; ' ' &lt;&lt; "nRef:" &lt;&lt; nRef &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<img alt data-src="https://c2.staticflickr.com/8/7748/26842243484_a7c00a4ac5_o.png"><br>从结果可以看到，用nB对nRef进行赋值后，nA的值也变成11了，由此可见nRef仍然指向nA。而再对nRef赋值12，只有nA变成12，而nB仍然是11。这些都可以很清楚的说明，引用所指的对象是没有变化的，一经初始化就不会改变。<br>下面再来看看，注释掉输出语句后的反汇编代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">00</span>EC48F0  push        ebp  </span><br><span class="line"><span class="number">00</span>EC48F1  mov         ebp,esp  </span><br><span class="line"><span class="number">00</span>EC48F3  sub         esp,<span class="number">0</span>E4h  </span><br><span class="line"><span class="number">00</span>EC48F9  push        ebx  </span><br><span class="line"><span class="number">00</span>EC48FA  push        esi  </span><br><span class="line"><span class="number">00</span>EC48FB  push        edi  </span><br><span class="line"><span class="number">00</span>EC48FC  lea         edi,[ebp-<span class="number">0</span>E4h]  </span><br><span class="line"><span class="number">00</span>EC4902  mov         ecx,<span class="number">39</span>h  </span><br><span class="line"><span class="number">00</span>EC4907  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line"><span class="number">00</span>EC490C  rep stos    dword ptr es:[edi]  </span><br><span class="line">    int nA = 10;</span><br><span class="line"><span class="number">00</span>EC490E  mov         dword ptr [nA],<span class="number">0</span>Ah  </span><br><span class="line">    int nRef = nA;//必须初始化</span><br><span class="line"><span class="number">00</span>EC4915  lea         eax,[nA]  </span><br><span class="line"><span class="number">00</span>EC4918  mov         dword ptr [nRef],eax  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "nA:" &lt;&lt; nA &lt;&lt; ' ' &lt;&lt; "nRef:" &lt;&lt; nRef &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    int nB = 11;</span><br><span class="line"><span class="number">00</span>EC491B  mov         dword ptr [nB],<span class="number">0</span>Bh  </span><br><span class="line">    nRef = nB;//难道引用可以重新指向nB?</span><br><span class="line"><span class="number">00</span>EC4922  mov         eax,dword ptr [nRef]  </span><br><span class="line"><span class="number">00</span>EC4925  mov         ecx,dword ptr [nB]  </span><br><span class="line"><span class="number">00</span>EC4928  mov         dword ptr [eax],ecx  </span><br><span class="line">    <span class="comment">//cout &lt;&lt; "nB:" &lt;&lt; nB &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "nA:" &lt;&lt; nA &lt;&lt; ' ' &lt;&lt; "nRef:" &lt;&lt; nRef &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    nRef = 12;</span><br><span class="line"><span class="number">00</span>EC492A  mov         eax,dword ptr [nRef]  </span><br><span class="line"><span class="number">00</span>EC492D  mov         dword ptr [eax],<span class="number">0</span>Ch  </span><br><span class="line">    <span class="comment">//cout &lt;&lt; "nB:" &lt;&lt; nB &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "nA:" &lt;&lt; nA &lt;&lt; ' ' &lt;&lt; "nRef:" &lt;&lt; nRef &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"><span class="number">00</span>EC4933  xor         eax,eax  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以下几句能看到nRef实际上存储的是nA的地址。lea是取有效地址的意思。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int nRef = nA;//必须初始化</span><br><span class="line"><span class="number">00</span>EC4915  lea         eax,[nA]  </span><br><span class="line"><span class="number">00</span>EC4918  mov         dword ptr [nRef],eax</span><br></pre></td></tr></table></figure><p>从给引用赋值的汇编代码可以看出，实际上的动作是把nRef代表的地址放入一个寄存器，再取nB的值放入一个寄存器，然后将nB的值赋给nRef指向的内存。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nRef = nB;//难道引用可以重新指向nB?</span><br><span class="line"><span class="number">00</span>EC4922  mov         eax,dword ptr [nRef]  </span><br><span class="line"><span class="number">00</span>EC4925  mov         ecx,dword ptr [nB]  </span><br><span class="line"><span class="number">00</span>EC4928  mov         dword ptr [eax],ecx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模块、进程、线程的概念</title>
      <link href="/2014/08/07/%E6%A8%A1%E5%9D%97%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2014/08/07/%E6%A8%A1%E5%9D%97%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>通常，我们知道，一个程序执行起来就是一个进程，一个进程里面至少包含一个线程。那么什么是模块了，被加载内存中的dll或者exe都是模块。<br>据说，windows有个数据结构叫做Module Database(MDB)，专门代表模块。可执行程序（exe或者dll)，包括其代码、资源等被加载到内存中，windows大概就用这个结果管理它吧。这个数据结构其实代表的就是一个PE文件的表头。<br>那么进程了，代表的又是什么了，既然模块表示的是加载到内存的pe文件。进程应该代表的是资源拥有者吧。比如说，地址空间、申请的内存、打开的文件、所有的线程、以及模块(加载的dll，本身的exe）。windows也有一个叫做Process Database(PDB)的数据结构负责管理它。这样看，进程是各种所有权的集合吧。<br>那么线程了。执行的线程表示的是模块中一段正在被执行的代码吧。线程是被cpu调度的基本单位，因此真正占有cpu时间片的是线程，而不是进程。也有一个叫做Thread Database（TDB）的数据结构来代表线程，里面会记录执行线程区域储存空间（Thread Local Storage，TLS）、讯息队列、handle表格等等。其实，只有在多cpu的机器上面才能实现真正的并行。在单cpu上面，只是在硬件计时器的通知下不断的切换线程。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator new 和placement new表达式</title>
      <link href="/2014/07/31/operator%20new%20%E5%92%8Cplacement%20new%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2014/07/31/operator%20new%20%E5%92%8Cplacement%20new%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章里面讲到用allocator预分配空间已经在需要的时候才构造对象，其实还有其它的办法实现这一功能。operator new表达式也可以只分配内存而不初始化，但是返回的是void指针，因此没有allocator类型化的优点。同样placement new表达式只负责调用指定的构造函数初始化内存，不申请内存，与allocator的construct相比，这个表达式更加方便，可以使用任意类型的构造函数参数列表。但是，construct只能使用复制构造函数。<br>同样的，可以使用operator delete代替allocator的deallocate释放内存。使用析构函数代替allocator的destroy清理对象。下面我把原来使用allocator的代码改写成使用这些表达式的。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;memory&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Vector() : elements(0), first_free(0), end(0) &#123;&#125;</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        for (T* p = first_free; p != elements;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//allocator.destroy(--p);</span></span><br><span class="line">            --p;</span><br><span class="line">            p-&gt;~T();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//allocator.deallocate(elements, end - elements);</span></span><br><span class="line">            operator delete[](elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const T t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (first_free == end)</span><br><span class="line">        &#123;</span><br><span class="line">            reallocate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//allocator.construct(first_free, t);//复制构造新对象</span></span><br><span class="line">        new (first_free) T(t);</span><br><span class="line">        ++first_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (first_free != elements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//allocator.destroy(--first_free);</span></span><br><span class="line">            --first_free;</span><br><span class="line">            first_free-&gt;~T();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">//std::allocator&lt;T&gt; allocator;</span></span><br><span class="line">    void reallocate()</span><br><span class="line">    &#123;</span><br><span class="line">        std::ptrdiff_t size = first_free - elements;</span><br><span class="line">        std::ptrdiff_t newcapacity = 2 * std::max(size, 1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//T* newelements = allocator.allocate(newcapacity);//申请新内存</span></span><br><span class="line">        T* newelements = static_cast&lt;T*&gt;(operator new[](newcapacity * sizeof(T)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//newelements处直接复制构造</span></span><br><span class="line">        std::uninitialized_copy(elements, first_free, newelements);</span><br><span class="line"></span><br><span class="line">        for (T* p = first_free; p != elements;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//allocator.destroy(--p);//析构原对象</span></span><br><span class="line">            --p;</span><br><span class="line">            p-&gt;~T();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//allocator.deallocate(elements, end - elements);//释放内存</span></span><br><span class="line">            operator delete[](elements);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elements = newelements;</span><br><span class="line">        first_free = elements + size;</span><br><span class="line">        end = elements + newcapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* elements;</span><br><span class="line">    T* first_free;</span><br><span class="line">    T* end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template &lt;typename T&gt; std::allocator&lt;T&gt; Vector&lt;T&gt;::allocator;</span></span><br></pre></td></tr></table></figure><br>placement new表达式的一般形式是new (地址) 类型名(初始化列表)，由于使用初始化列表直接构造对象，因此不用拷贝。而且比只能用复制构造函数构造的allocator的construct函数更方便。<br>比如，allocator<t> alloc;string* sp = alloc.allocate(2);如果用定位new表达式，new (sp) string(b, e);(b,e是用2个迭代器构造string类型)。但是，用construct的话，则是alloc.construct(sp+1,string(b,e));可以清楚的看到，需要用迭代器构造个临时的string对象，再用这个临时对象调用复制构造函数。因此，会有细微的性能损失。最终要的是，有些类根本没有可以调用的复制构造函数，比如该函数是私有的，那么就必须使用placement new表达式了。<br>operator new和operator delete的使用方式类似于new和delete，具体的可以参看代码。</t></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>allocator的一些理解</title>
      <link href="/2014/07/31/allocator%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>/2014/07/31/allocator%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>相信大家都用过vector，而且用多了之后会发现怎么还有一个我们基本上不会使用的模版参数Allocator。查阅msdn能够看到，vector的类型是template <class type, class allocator="allocator<Type"> &gt;class vector。那么这个Allocator到底是用来做什么的了。实际上，Allocator是stl里面用到的内存管理工具，因为这个时候new和delete已经不能满足要求了。<br>比如说，vector需要预分配内存，需要添加元素。如果使用new分配内存的话，那么在预分配内存的时候就会调用一次构造函数，添加元素的时候会调用一次赋值操作符。其实，这些操作都是冗余的，会降低效率。这也是stl和手写容器的最大区别。如果使用allocator，那么可以把<strong>分配内存和构造操作分开</strong>，在预分配内存的时候单纯分配空间，不构造，而在添加新元素的时候，调用复制构造函数。<br>要达到这样的要求，需要allocator提供对应的接口。实际上，std::allocator有allocate和deallocate负责内存申请释放，construct和destroy负责对象构造和析构。下面来解析相关模拟的代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;memory&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Vector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Vector() : elements(0), first_free(0), end(0) &#123;&#125;</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        for (T* p = first_free; p != elements;)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator.destroy(--p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elements)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator.deallocate(elements, end - elements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push_back(const T t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (first_free == end)</span><br><span class="line">        &#123;</span><br><span class="line">            reallocate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        allocator.construct(first_free, t);//复制构造新对象</span><br><span class="line">        ++first_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop_back()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (first_free != elements)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator.destroy(--first_free);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    static std::allocator&lt;T&gt; allocator;</span><br><span class="line">    void reallocate()</span><br><span class="line">    &#123;</span><br><span class="line">        std::ptrdiff_t size = first_free - elements;</span><br><span class="line">        std::ptrdiff_t newcapacity = 2 * std::max(size, 1);</span><br><span class="line"></span><br><span class="line">        T* newelements = allocator.allocate(newcapacity);//申请新内存</span><br><span class="line">        <span class="comment">//newelements处直接复制构造</span></span><br><span class="line">        std::uninitialized_copy(elements, first_free, newelements);</span><br><span class="line"></span><br><span class="line">        for (T* p = first_free; p != elements;)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator.destroy(--p);//析构原对象</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (elements)</span><br><span class="line">        &#123;</span><br><span class="line">            allocator.deallocate(elements, end - elements);//释放内存</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elements = newelements;</span><br><span class="line">        first_free = elements + size;</span><br><span class="line">        end = elements + newcapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* elements;</span><br><span class="line">    T* first_free;</span><br><span class="line">    T* end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; std::allocator&lt;T&gt; Vector&lt;T&gt;::allocator;</span><br></pre></td></tr></table></figure><br>在push_back里面，使用allocator.construct(first_free, t)初始化内容，相当于调用复制构造函数。如果空间已满，调用reallocate。在这里面用allocator.allocate(newcapacity)申请原来2倍大小的空间，这个操作不会调用构造函数。有意思的是接下来调用uninitialized_copy，这个函数直接在新地址上面使用原来的值构造对象，而不是赋值。然后，循环析构原来对象，释放原来内存。如果清楚了解复制构造函数和赋值操作的区别，那么理解allocator的意义是很容易的。关于这个，可以阅读我<a href="http://www.xpc-yx.com/2013/12/19/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E9%94%99%E8%AF%AF/" target="_blank" rel="noopener" title="拷贝构造函数的理解错误">另外一篇文章</a>。<br>另外一个关于模版类静态成员的初始化，大家可以看到我直接写在<strong>头文件</strong>的最后一句了。如果写在源文件里面，那么特例化模版才能定义静态成员。而这样直接包含头文件就可以使用了，不信大家可以试试。我的环境是vs2013。</class></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> allocator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维平面的向量表示法</title>
      <link href="/2014/07/06/%E4%B8%89%E7%BB%B4%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%90%91%E9%87%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
      <url>/2014/07/06/%E4%B8%89%E7%BB%B4%E5%B9%B3%E9%9D%A2%E7%9A%84%E5%90%91%E9%87%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们都知道平面可以表示为A<em>x+B</em>y+C<em>z+d=0，但是很多人不知道这个表达式隐含的意义。<br>从另一个角度，点法式来看平面，假设法线n=(a,b,c),平面上一点p0(x0,y0,z0),平面上任意一点p为(x,y,z)。那么平面可以表示为n</em>(p-p0)=0，即(a,b,c)<em>(x-x0,y-y0,z-z0)=0，可以化简为a</em>x+b<em>y+c</em>z-a<em>x0-b</em>y0-c<em>z0=0。<br>上面两个式子一对比，就能发现a=kA,b=kB,c=kC，-a</em>x0-b<em>y0-c</em>z0=kD。取k=1，就可以得到系数相等。所以，看到平面的一般式就能够得到法线为n=(A,B,C)。<br>根据上面的结论，进一步推广，我们可以把一般式改成点积的形式(A,B,C)<em>(x,y,z)+D=0。这个就是平面的向量表示，即**n</em>P+d=0<strong>。那么这个向量表示法有什么意义了。首先，在程序实现中，我们只需要保存法线n和系数d就可以了。<br>其次，d还代表从原点到平面上任意点的向量在法线上的投影长度。所以，利用这个信息，可以方便的求出任意点到平面的距离。<br>假设n为单位法线，假设任意点为q，q在平面上的投影为q’，那么向量</strong>(q-q’)=kn<strong>。意思是向量(q-q’)肯定和法线共线，长度是其k倍。在上式两边乘以n，可以得到(q-q’)<em>n=kn</em>n，即(q<em>n-q’</em>n)=k，即k=q*n-q’n。由于q’是平面上的点，所以</strong>q’<em>n=-d<strong>，那么，</strong>k=q</em>n+d<strong>。k即是点q到平面的长度，其中q，n，d都是已知的。运用这个式子的时候，必须得先</strong>归一化n**。<br>现在可以很清晰的看到，如果我们将平面表示为向量形式，而且n是归一化的，那么计算任意点到平面的距离是非常方便的。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在三维模型上可视化标量场及注意方面</title>
      <link href="/2014/06/26/%E5%9C%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%87%E9%87%8F%E5%9C%BA%E5%8F%8A%E6%B3%A8%E6%84%8F%E6%96%B9%E9%9D%A2/"/>
      <url>/2014/06/26/%E5%9C%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B%E4%B8%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%87%E9%87%8F%E5%9C%BA%E5%8F%8A%E6%B3%A8%E6%84%8F%E6%96%B9%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>三维模型上的标量场指的是三维模型上面的每个顶点都有一个标量值，从而构成了整体的标量场。如果能够以颜色代表这个标量值的大小，那么整体的标量场就能够方便的观察出来。一般来说，hls颜色模型的色相能够代表从红到蓝的渐进过度，因此可以用hsl转rgb的方法生成一维纹理。然后归一化标量场，将标量值作为一维的纹理坐标，从而显示出整个标量场。如何加载任意格式图片作为纹理，以及其它关于OpenGL纹理的内容，可以参考我其它文章。<br>但是这样比较麻烦。首先，需要颜色空间转换，还有使用的是一维纹理。其实，有更方便的做法。直接找一张代表从红到蓝的渐进过度纹理图片，加载这张图片生成纹理，使用二维纹理坐标，固定一维的坐标，如s，变化t。<br>对应的二维纹理图和实现效果：</p><p><img alt data-src="https://c2.staticflickr.com/8/7400/27380050181_bbd0509152_o.png"><br>这里需要注意一个问题，就是极限纹理坐标的跳变。比如说，纹理坐标很小接近0，可能就会直接跳到1去了，插值出来的颜色就会从红直接变成蓝，或者从蓝直接变成红，明显是不对的。如图所示，</p><p><img alt data-src="https://c2.staticflickr.com/8/7299/27380049411_75cf1fbd34_o.png"><br>处理这个问题的方法，有两种，一种是修改纹理坐标的模型为GL_MIRRORED_REPEAT的而不是一般的GL_REPEAT，第二个是将纹理坐标的范围压缩到大于0小于1之间。求的最大和最小标量值后，往外扩展下，再进行标量值的归一化。可以用下面的代码，处理。<br>float fDis = fMax - fMin;<br>fMin = fMin - fDis <em> 0.001;<br>fMax = fMax + fDis </em> 0.001;<br>这样正确的显示如下，</p><p><img alt data-src="https://c2.staticflickr.com/8/7149/27352273672_2f6dc50da7_o.png"><br>现在可以看到，本来是带蓝色中心的红带，变成了全部是红色的带了。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可视化标量场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在MFC中使用AntTweakBar</title>
      <link href="/2014/04/27/%E5%A6%82%E4%BD%95%E5%9C%A8MFC%E7%9A%84OpenGL%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%BF%E7%94%A8AntTweakBar/"/>
      <url>/2014/04/27/%E5%A6%82%E4%BD%95%E5%9C%A8MFC%E7%9A%84OpenGL%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%BF%E7%94%A8AntTweakBar/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是在我的另一篇文章“<a href="http://www.xpc-yx.com/2014/02/15/%E7%BB%A7%E6%89%BFmfc%E7%9A%84cwnd%E7%B1%BB%E6%B8%B2%E6%9F%93opengl/" target="_blank" rel="noopener">继承mfc的cwnd类渲染opengl</a>”的基础上改进的。<br>AntTweakBar是一个条状的菜单库，类似于内嵌于渲染窗口的属性条，可以和OpenGL渲染窗口融为一体，效果很好看。以前见过有人用这个库，效果比较好看就关注了下。在网上找相关的资料，发现只有人在glut下使用。还有人因为在MFC下使用不成功，认为和MFC不兼容。其实，这个库只要给了渲染引擎就行了，然后把一些事情传给它就能交互了。<br>AntTweakBar提供的都是简单的C接口，所以非常方便和已有的界面框架整合，无论你用的是OpenGL还是DX渲染，无论你用的界面框架是glut还是glfw或者sdl等等都行。官方网站也提供了<a href="http://anttweakbar.sourceforge.net/doc/tools:anttweakbar:howto" target="_blank" rel="noopener">整合步骤</a>。<br>我现在介绍下，在我的框架里面的整合步骤。<br>第一步，在OnCreate函数里面调用TwInit(TW_OPENGL, NULL);初始化。<br>第二步，在OnCreate函数里面创建bar并且绑定变量。如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*myBar;</span><br><span class="line">myBar &#x3D; TwNewBar(&quot;Test&quot;);</span><br><span class="line">TwDefine(&quot; Test refresh&#x3D;0.5 color&#x3D;&#39;96 216 224&#39; alpha&#x3D;0 text&#x3D;dark&quot;);</span><br><span class="line">static int nTest &#x3D; 0;</span><br><span class="line">TwAddVarRW(myBar, &quot;Test&quot;, TW_TYPE_INT32, nTest, &quot;test&quot;);</span><br></pre></td></tr></table></figure><p>第三步，在OnSize里面调用TwWindowSize(cx, cy);<br>第四步，修改PreTranslateMessage实现为，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (TwEventWin(pMsg-&gt;hwnd, pMsg-&gt;message, pMsg-&gt;wParam, pMsg-&gt;lParam))</span><br><span class="line">&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">return CWnd::PreTranslateMessage(pMsg);</span><br></pre></td></tr></table></figure><p>第五步，在RenderScene函数最后添加TwDraw()，但是得保证在SwapBuffers(m_hDC)之前添加这句。<br>第六步，在OnDestroy()中调用TwTerminate()释放资源。<br>综上所述，整合还是非常简单的。<br>另外，AntTweakBar提供TwDefine函数用于设置颜色，透明度等参数，可以调整效果，非常方便。还有一个需要注意的是，TwAddVarRW绑定的变量不能是局部变量，否则会出错。当你绑定的变量值变化时候，就是你和AntTweakBar交互的时候了。总之，非常方便使用吧。<br>最后，我要说的是，AntTweakBar自己会使用自身的光标，它的光标会覆盖MFC窗口的光标。如果，我们坚持使用MFC的光标的话，该怎么办了。只能禁止掉AntTweakBar的光标了。方法是，修改它的源码，重新编译成库。我们把TwMgr.cpp的针对windows系统的<strong>SetCursor</strong>函数内部实现注视掉就行了。如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void CTwMgr::SetCursor(CTwMgr::CCursor _Cursor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*if( m_CursorsCreated )</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">CURSORINFO ci;</span></span><br><span class="line"><span class="comment">memset(ci, 0, sizeof(ci));</span></span><br><span class="line"><span class="comment">ci.cbSize = sizeof(ci);</span></span><br><span class="line"><span class="comment">BOOL ok = ::GetCursorInfo(ci);</span></span><br><span class="line"><span class="comment">if( ok  (ci.flags  CURSOR_SHOWING) )</span></span><br><span class="line"><span class="comment">::SetCursor(_Cursor);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是实现效果，</p><p><img alt data-src="https://c4.staticflickr.com/8/7482/27380004971_4d45801816_o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL视口点投影到视角空间及反投影</title>
      <link href="/2014/03/13/OpenGL%E8%A7%86%E5%8F%A3%E7%82%B9%E6%8A%95%E5%BD%B1%E5%88%B0%E8%A7%86%E8%A7%92%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8F%8D%E6%8A%95%E5%BD%B1/"/>
      <url>/2014/03/13/OpenGL%E8%A7%86%E5%8F%A3%E7%82%B9%E6%8A%95%E5%BD%B1%E5%88%B0%E8%A7%86%E8%A7%92%E7%A9%BA%E9%97%B4%E5%8F%8A%E5%8F%8D%E6%8A%95%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<p>有些时候，我们想知道鼠标点中了哪个物体或者哪个部分，更详细的是最靠近模型的哪个顶点或者哪条线，或者哪个面。这些选取问题有不同的解决办法。如果只是针对<strong>图元</strong>的选取，可以直接用OpenGL的<strong>选取模式</strong>实现。但是有的时候，情况更加复杂，比如我们想通过鼠标在模型上面绘制一条线，然后对模型进行剖分等。这就需要把鼠标点变换到三维顶点，再进一步的操作。<br>我在这里贴出2个我自己使用的函数，针对鼠标点投影视角空间和反投影。<br>投影：``` stylus<br>void CMesh::ScreenToModel(v2f point, v3f point3d)<br>{<br>        float fWinX, fWinY, fWinZ;<br>        int nX, nY;<br>        GLdouble fX, fY, fZ;</p><pre><code>    nX = point[0];    nY = point[1];    glReadBuffer(GL_BACK);    glReadPixels(nX, nY, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, fWinZ);    if (fabs(fWinZ - 1.0) &gt; 1e-8)    {        fWinX = nX;        fWinY = nY;        gluUnProject(fWinX, fWinY, fWinZ, m_pMatMV, m_pMatProj, m_pViewport,            fX, fY, fZ);        point3d[0] = fX;        point3d[1] = fY;        point3d[2] = fZ;    }    else    {        point3d[0] = point3d[1] = 0.0;        point3d[2] = 1.0;    }</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用该函数必须注意的是，point必须已经转换为**视口点**，即point[1] &#x3D; window_height - point[1] - 1。</span><br><span class="line">反投影:&#96;&#96;&#96; stylus</span><br><span class="line">void CMesh::ModelToScreen(v3f point3d, v2f point)</span><br><span class="line">&#123;</span><br><span class="line">        double fWinX, fWinY, fWinZ;</span><br><span class="line">        gluProject(point3d[0], point3d[1], point3d[2], m_pMatMV, m_pMatProj, m_pViewport,</span><br><span class="line">            fWinX, fWinY, fWinZ);</span><br><span class="line"></span><br><span class="line">        point[0] &#x3D; (float)fWinX;</span><br><span class="line">        point[1] &#x3D; (float)fWinY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>反投影得到的2维点同样是基于<strong>左下角</strong>为原点的视口点，要转换为鼠标点的话还得变换y值，即point[1] = window_height - point[1] - 1。<br>至于其它的实现方法，当然可以自己直接操作投影矩阵和模型矩阵，视口信息，进行转换，不过也是重复造轮子，但对于理解原理有帮助。<br>鼠标点投影到三维之后，就可以找到<strong>最近</strong>的模型点，或者通过射线之类求相交面。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC框架下OpenGL多重采样的bug</title>
      <link href="/2014/03/10/MFC%E6%A1%86%E6%9E%B6%E4%B8%8BOpenGL%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E7%9A%84bug/"/>
      <url>/2014/03/10/MFC%E6%A1%86%E6%9E%B6%E4%B8%8BOpenGL%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E7%9A%84bug/</url>
      
        <content type="html"><![CDATA[<p>我前段时间写了一篇关于MFC界面框架下，OpenGL全屏抗锯齿的文章。原以为这份代码可以方便的使用了，没想到今天就出问题了。这也许不能算在代码上的bug，或许是硬件的原因。今天我换了台电脑尝试了下，出现了很奇怪的现象，调试了很久才找到原因是<strong>开启了多重采样</strong>。这个调试过程也是让我非常痛苦的，写图形学程序对调试的经验和功底要求真的不浅啊。<br>我只能猜测是<strong>硬件</strong>的原因了。在学校里的时候，实验室的机器上运行得好好的，但是在这台电脑上就不行。这台电脑确实有点不一样，是妹子的mac，被我装了windows7在用着。估计是硬件不一样吧。再说我的多重采样是参照nehe的实现方法，也许实现方法不太兼容了。<br>有必要展示下这个<strong>奇葩的结果</strong>。<img alt data-src="https://c1.staticflickr.com/8/7118/27175072760_7f967ff641_o.jpg"><br>从图片可以看出，本应该被遮挡的部分显示出来了。这个也不像完全是透明混合的效果，也不是深度测试的原因。总之是很奇怪的结果，我也调试过深度测试和混合，都没有用。最后，经过一番调试才知道是因为<strong>开启多重采样</strong>的原因。<br>只能把多重采样去掉，效果才显示正常了，并且程序的其它部分才正常，比如鼠标点和模型求交等。<br>在这里，不能不再次感叹调试的力量。我今天是实在没办法了，只能把以前版本的代码下载下来，替换不同的文件才找到bug的所在。因为当工程里面代码量太大的时候，注释掉某些部分，vs已经不一定会正确生成结果了，这种事情只能全部重新生成，才能保证代码真的更新了。<br>调试功底真的很重要。比如文件替换来排查错误的所在，打log，调试状态查看内存等。没有强悍的调试手段，很多事情真的是继续不下去的。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重采样 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用OpenGL渲染到图片</title>
      <link href="/2014/03/03/%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93%E5%88%B0%E5%9B%BE%E7%89%87/"/>
      <url>/2014/03/03/%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93%E5%88%B0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>标题的意思是使用OpenGL生成特定的图片。比如说，把OpenGL渲染出来的特定结果保存出来，或者生成特殊的纹理图片。<br>第一步，保存OpenGL环境。这个使用glPushAttrib(GL_ALL_ATTRIB_BITS)实现。<br>第二步，设置视口。既然我们要生成指定大小的图片，那我们就<strong>把视口设置为该图片的大小</strong>。glViewport(0, 0, nWidth, nHeight);<br>第三步，设置投影矩阵。<br>第四步，设置模型视图矩阵。<br>第五步，进行相关绘制。<br>第六步，调用<strong>glReadPixels</strong>保存绘制内容。（这一步也可以放到后面的任意位置）<br>第七步，恢复模型视图矩阵。<br>第八步，恢复投影矩阵。<br>第九步，恢复OpenGL环境。<br>大致的代码，可以用下面这个函数描述。只需要替换绘制的代码就可以改成你需要的形式了。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void CDrawedTexture::InterpolateData(int m_nWidth, int m_nHeight)</span><br><span class="line">&#123;</span><br><span class="line">    glPushAttrib(GL_ALL_ATTRIB_BITS);</span><br><span class="line"></span><br><span class="line">    glViewport(0, 0, nWidth, nHeight);</span><br><span class="line">    glClearColor(0.0, 0.0, 0.0, 1.0);</span><br><span class="line">    glDisable(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, 1.0, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制三角形</span></span><br><span class="line">    glEnable(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m_faces.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m_faces[i].v[0].pTexture-&gt;Bind2d();</span><br><span class="line">        glBegin(GL_TRIANGLES);</span><br><span class="line">        for (int j = 0; j &lt; 3; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//设置纹理坐标</span></span><br><span class="line">            glTexCoord2f(m_faces[i].v[j].oldTexPos[0], m_faces[i].v[j].oldTexPos[1]);</span><br><span class="line">            <span class="comment">//设置坐标</span></span><br><span class="line">            glVertex2f(m_faces[i].v[j].newTexPos[0], m_faces[i].v[j].newTexPos[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        glEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glReadPixels(0, 0, nWidth, nHeight, GL_RGBA, GL_UNSIGNED_BYTE, m_img.raw());</span><br><span class="line"></span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glPopAttrib();</span><br><span class="line"></span><br><span class="line">    m_img.save("插值纹理.bmp");</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意请使用<strong>双缓存区</strong>，而且<strong>绝对不能调用交换缓存区函数</strong>。原因是生成图片是幕后工作，交换缓存区会破坏屏幕当前的显示。这里还有个必须很注意的地方，就是glReadPixels的参数一定要正确。比如<strong>像素的格式</strong>，还有<strong>数据的类型</strong>。如果你的颜色缓存区是rgba的，那么你一定得使用<strong>GL_RGBA</strong>而不是GL_RGB，还有一般不能使用GL_BYTE，而是要使用<strong>GL_UNSIGNED_BYTE</strong>，否则会造成数据截断。<br>我这段代码的意图是将笔画绘制所经过的三维部分投影到二维图片上面保存起来。三维模型上面贴了纹理。<br>当然还可以用FBO实现和本文类似的功能。<br>如果实现所谓的渲染到纹理，我们只需要把渲染到后缓存区的数据提取出来，绑定到纹理就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC的单文档(SDI)的CMainFrame中添加托盘</title>
      <link href="/2014/02/26/MFC%E7%9A%84%E5%8D%95%E6%96%87%E6%A1%A3(SDI)%E7%9A%84CMainFrame%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%89%98%E7%9B%98/"/>
      <url>/2014/02/26/MFC%E7%9A%84%E5%8D%95%E6%96%87%E6%A1%A3(SDI)%E7%9A%84CMainFrame%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%89%98%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>第一步，在CMainFrame中定义NOTIFYICONDATA结构m_notify。</p><p>第二步，在OnCreate中添加下面的代码。代码的解释参见注释。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m_notify.cbSize = sizeof(NOTIFYICONDATA);//结构体大小</span><br><span class="line">m_notify.hWnd = m_hWnd;//对应窗口</span><br><span class="line">m_notify.uID = IDR_MAINFRAME;//托盘id</span><br><span class="line">m_notify.hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_MAINFRAME));//图标</span><br><span class="line">strcpy(m_notify.szTip, "ConuterPerDay");//提示字符</span><br><span class="line">m_notify.uCallbackMessage = WM_USER_NOTIFYICON;//处理消息</span><br><span class="line">m_notify.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP; //有效标志</span><br><span class="line">Shell_NotifyIcon(NIM_ADD, m_notify);//添加托盘</span><br></pre></td></tr></table></figure><p>需要注意的是，m_notify.uFlags必须设置正确，如果不正确，那么有些功能是不会有效的，还有m_notify.cbSize也是必须设置的。<br>第三步，在MainFrame.h中添加宏定义#define WM_USER_NOTIFYICON (WM_USER + 100)，再定义对应的消息处理函数，afx_msg LRESULT OnNotifyMsg(WPARAM wparam, LPARAM lparam);注意该函数的格式。这是普通的消息处理函数，消息的参数必须带全。再在源文件中的BEGIN_MESSAGE_MAP和END_MESSAGE_MAP()之间添加消息映射ON_MESSAGE(WM_USER_NOTIFYICON, OnNotifyMsg)。<br>第四步，实现OnNotifyMsg。我的OnNotifyMsg实现如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMainFrame 消息处理程序</span></span><br><span class="line">LRESULT  CMainFrame::OnNotifyMsg(WPARAM wparam, LPARAM lparam)<span class="comment">//wParam接收的是图标的ID，而lParam接收的是鼠标的行为</span></span><br><span class="line">&#123;</span><br><span class="line">    if (wparam != IDR_MAINFRAME) return  1;</span><br><span class="line"></span><br><span class="line">    CPoint pos;</span><br><span class="line">    CMenu    menu;</span><br><span class="line">    switch (lparam)</span><br><span class="line">    &#123;</span><br><span class="line">    case  WM_RBUTTONUP:<span class="comment">//右键起来时弹出快捷菜单，这里只有一个“关闭”</span></span><br><span class="line">        GetCursorPos(pos);</span><br><span class="line">        menu.CreatePopupMenu();//声明一个弹出式菜单</span><br><span class="line">        <span class="comment">//增加菜单项“关闭”，点击则发送消息WM_DESTROY给主窗口（已</span></span><br><span class="line">        <span class="comment">//隐藏），将程序结束。</span></span><br><span class="line">        menu.AppendMenu(MF_STRING, WM_USER_EXIT, "关闭");</span><br><span class="line">        <span class="comment">//确定弹出式菜单的位置</span></span><br><span class="line">        SetForegroundWindow();</span><br><span class="line">        menu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pos.x, pos.y, this);</span><br><span class="line">        menu.DestroyMenu();</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case  WM_LBUTTONDBLCLK:<span class="comment">//双击左键的处理</span></span><br><span class="line">        <span class="keyword">if</span> (IsWindowVisible())</span><br><span class="line">        &#123;</span><br><span class="line">            ShowWindow(SW_HIDE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ShowWindow(SW_SHOW);//简单的显示主窗口完事儿</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是menu.AppendMenu(MF_STRING, WM_USER_EXIT, “关闭”);，我用了自定义的消息WM_USER_EXIT而不是WM_DESTROY。刚开始我参照别人的代码，使用WM_DESTROY，结果弹出菜单一直是灰色的。我换成WM_CLOSE也是一样的效果。没办法，我就试了下自定义消息。刚开始我采样的是普通类型的消息映射处理该菜单消息，菜单也是灰色的。<strong>直到最后我用ON_COMMAND映射菜单消息，菜单才能够点击</strong>。<br>第四步，在MainFrame.h中添加宏定义#define WM_USER_EXIT (WM_USER + 101)，再定义对应的消息处理函数，aafx_msg void OnExit();注意该函数的格式，与第三步不同，因为这是命令消息。再在源文件中的BEGIN_MESSAGE_MAP和END_MESSAGE_MAP()之间添加消息映射ON_COMMAND(WM_USER_EXIT, OnExit)。第四步是使弹出菜单能够点击的关键。我在OnExit直接调用DestroyWindow退出程序。<br>第五步，重载WM_CLOSE，在其中调用ShowWindow(SW_HIDE);。这样点击关闭按钮则进入托盘状态，而点击最小化按钮在任务栏上有程序的图标。<br>第六步，重载WM_DESTROY，程序退出时候删除托盘。对应代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void CMainFrame::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">    CFrameWndEx::OnDestroy();</span><br><span class="line"></span><br><span class="line">    NOTIFYICONDATA tnid;</span><br><span class="line">    tnid.cbSize = sizeof(NOTIFYICONDATA);</span><br><span class="line">    tnid.hWnd = m_hWnd;</span><br><span class="line">    tnid.uID = IDR_MAINFRAME;</span><br><span class="line">    <span class="comment">//用NIM_DELETE删除图标</span></span><br><span class="line">    Shell_NotifyIcon(NIM_DELETE, tnid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，实现了一个SDI框架下，完整的托盘程序。<br>我写这篇文章的目的是为了说明ON_MESSAGE和ON_COMMAND的区别。<strong>ON_COMMAND对应的普通的windows消息，ON_COMMAND则对应的是菜单和按钮之类的命令消息，需要区别对待</strong>。也就是处理不同类型的消息，需要使用不同类型的消息处理函数。如果消息处理函数类型不正确，有可能出现问题。比如，弹出菜单一直是灰色。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统托盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL渲染速度优化(一)------降低材质的切换频率</title>
      <link href="/2014/02/24/OpenGL%E6%B8%B2%E6%9F%93%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96(%E4%B8%80)------%E9%99%8D%E4%BD%8E%E6%9D%90%E8%B4%A8%E7%9A%84%E5%88%87%E6%8D%A2%E9%A2%91%E7%8E%87/"/>
      <url>/2014/02/24/OpenGL%E6%B8%B2%E6%9F%93%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96(%E4%B8%80)------%E9%99%8D%E4%BD%8E%E6%9D%90%E8%B4%A8%E7%9A%84%E5%88%87%E6%8D%A2%E9%A2%91%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>在这里我只写我遇到过的一种情况。因为以前没有发现原因，好几个月的我的代码渲染速度都很慢，以至于最后被老师狠狠得说了一顿。最后，没办法了，我才通过仔细对比，一步步排查，发现了最终的原因。<br>说到渲染速度优化，大家肯定会说用<strong>显示列表</strong>啊。这个我知道，书上都有。我尝试过显示列表，但是还是解决不了我的问题。再一个，假如你写的是一个模型编辑的软件，<strong>也就是渲染数据会发生变化的，那么用显示列表好像不太方便</strong>。当然，肯定也能使用显示列表，数据改变的时候重新生成一次显示列表呗。<br>我用的界面框架是MFC，刚开始我以为是用MFC的原因导致渲染速度大幅度下降。但是，我对比过别人的MFC渲染程序，发现不存这样的事情。毕竟windows下的glut肯定是用windows api实现的，MFC只是多了层封装而已。那么原因在哪里了。<br>大家都知道我们在贴纹理的时候，需要在每个顶点处指定纹理坐标，但是这样做渲染速度也很快。假如把纹理换成颜色怎么样了。假设不同的顶点有各自的颜色，这种情况下，我们必须开启光照，然后不断设置不同顶点的材质。那么，这个速度和设置纹理坐标的速度相比怎么样了？<br>结果是慢得不行，基本上50w左右的顶点，连旋转都延迟了。谁让我以前都使用以k为数量级的模型了，一直没面对这个问题。<br>也许是纹理的实现比光照的实现要快很多。毕竟贴纹理得到最终像素的颜色，差不多就是双线性差值之类的方法。当然纹理的具体实现肯定要复杂很多，内容多很多。但是，光照的实现需要更复杂的计算公式。但是这就是真正的原因么？<br>我只是在一直切换顶点的材质而已，为什么比切换顶点的纹理坐标慢了至少10倍了。我针对这种情况修改了代码，将材质切换进行了判断，使材质切换大大减少了，渲染速度果断达到了要求，可以顺畅渲染<strong>100w</strong>以上的数据。<br>现在，我只能经验性的知道不能<strong>频繁切换材质</strong>，但是能频繁切换纹理坐标。具体原因，我就不深入探究了。也许得从渲染片段的顺序之类的讨论起吧。<br>另外谈一下优化代码速度的关键，别磨磨蹭蹭想其它的原因了，直接去找一直在哪里<strong>循环执行</strong>的东西吧。优化循环或者循环被调用的东西吧。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MFC框架下OpenGL全屏抗锯齿</title>
      <link href="/2014/02/24/MFC%E6%A1%86%E6%9E%B6%E4%B8%8BOpenGL%E5%85%A8%E5%B1%8F%E6%8A%97%E9%94%AF%E9%BD%BF/"/>
      <url>/2014/02/24/MFC%E6%A1%86%E6%9E%B6%E4%B8%8BOpenGL%E5%85%A8%E5%B1%8F%E6%8A%97%E9%94%AF%E9%BD%BF/</url>
      
        <content type="html"><![CDATA[<p>其实OpenGL的全屏抗锯齿就是开启多重采样。在使用glut的时候，很方便就能实现。只要启用多重采样缓冲就行了。但是，在MFC窗口中的实现就很麻烦了。<br>首先，在MFC窗口中渲染OpenGL就需要比较麻烦的设置。所以，需要在设置OpenGL渲染环境的时候进一步处理。具体的来看下面一段代码吧。<br>这段代码就是MFC窗口创建的时候，设置OpenGL渲染环境的代码。<br>对于没有启用多重采样的情况，思路是先获取DC，然后调用ChoosePixelFormat获取最佳像素格式，再调用SetPixelFormat设置像素格式，接着调用wglCreateContext创建OpenGL渲染环境，最后调用wglMakeCurrent设置OpenGL渲染环境。<br>如果启用了多重采样，代码逻辑就更加复杂了。最恶心的一点是窗口必须创建2次。第一次按照常规思路设置好OpenGL渲染环境，然后调用函数InitMultisample判断是否支持多重采样，如果支持则销毁窗口，重新创建一次。第二次的思路是按照多重采样初始化得到的像素格式设置好OpenGL渲染环境的像素格式，其余的设置和常规的一样。具体参见下面的代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">BOOL COglWnd::SetupGLContext()</span><br><span class="line"> &#123;</span><br><span class="line">     DWORD dwFlags = (PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER | PFD_SUPPORT_OPENGL);</span><br><span class="line"></span><br><span class="line">     PIXELFORMATDESCRIPTOR pfd =</span><br><span class="line">     &#123;</span><br><span class="line">         sizeof(PIXELFORMATDESCRIPTOR),  <span class="comment">// Structure size,</span></span><br><span class="line">         <span class="number">1</span>,              <span class="comment">// Structure version number</span></span><br><span class="line">         dwFlags,            <span class="comment">// Property flags</span></span><br><span class="line">         PFD_TYPE_RGBA,          <span class="comment">// RGBA mode</span></span><br><span class="line">         <span class="number">24</span>,             <span class="comment">// 24-bit color</span></span><br><span class="line">         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,       <span class="comment">// 8-bit each color</span></span><br><span class="line">         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,        <span class="comment">// No alpha or accum. buffer,</span></span><br><span class="line">         <span class="number">16</span>,             <span class="comment">// 32-bit z-buffer</span></span><br><span class="line">         <span class="number">0</span>, <span class="number">0</span>,               <span class="comment">// No stencil or aux buffer</span></span><br><span class="line">         PFD_MAIN_PLANE,         <span class="comment">// Mainn layer type</span></span><br><span class="line">         <span class="number">0</span>,              <span class="comment">// Reserved</span></span><br><span class="line">         <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,            <span class="comment">// Unsupported.</span></span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     BOOL bOk = false;</span><br><span class="line">     m_hDC = GetDC()-&gt;m_hDC;</span><br><span class="line">     int PixelFormat;</span><br><span class="line"></span><br><span class="line">     static bool bFirst = true;</span><br><span class="line">     <span class="keyword">if</span> (bFirst)</span><br><span class="line">     &#123;</span><br><span class="line">         bFirst = false;</span><br><span class="line"></span><br><span class="line">         PixelFormat = ChoosePixelFormat(m_hDC, pfd);</span><br><span class="line">         bOk = SetPixelFormat(m_hDC, PixelFormat, pfd);</span><br><span class="line">         <span class="keyword">if</span> (!bOk)</span><br><span class="line">         &#123;</span><br><span class="line">             MessageBox(_T("GL set pixel format fail!"), _T("Error"), MB_OK);</span><br><span class="line">             return bOk;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         m_hGLRC = wglCreateContext(m_hDC);</span><br><span class="line">         bOk = wglMakeCurrent(m_hDC, m_hGLRC);</span><br><span class="line">         <span class="keyword">if</span> (!bOk)</span><br><span class="line">         &#123;</span><br><span class="line">             MessageBox(_T("Set up GL render context fail!"), _T("Error"), MB_OK);</span><br><span class="line">             return bOk;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         InitMultisample(m_hWnd);</span><br><span class="line">         <span class="keyword">if</span> (arbMultisampleSupported)</span><br><span class="line">         &#123;</span><br><span class="line">             DestroyWindow();</span><br><span class="line">             CreateEx(0, m_className, "OglWnd", WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,</span><br><span class="line">                 m_rect, m_parent, 0);</span><br><span class="line">             return bOk;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         PixelFormat = arbMultisampleFormat;//第二次创建</span><br><span class="line">         bOk = SetPixelFormat(m_hDC, PixelFormat, pfd);</span><br><span class="line">         <span class="keyword">if</span> (!bOk)</span><br><span class="line">         &#123;</span><br><span class="line">             MessageBox(_T("GL set pixel format fail!"), _T("Error"), MB_OK);</span><br><span class="line">             return bOk;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         m_hGLRC = wglCreateContext(m_hDC);</span><br><span class="line">         bOk = wglMakeCurrent(m_hDC, m_hGLRC);</span><br><span class="line">         <span class="keyword">if</span> (!bOk)</span><br><span class="line">         &#123;</span><br><span class="line">             MessageBox(_T("Set up GL render context fail!"), _T("Error"), MB_OK);</span><br><span class="line">             return bOk;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return bOk;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>那么函数InitMultisample是怎么来的了。NeHe刚好有一节课是讲这个的，我是从那里下载得到的。该函数代码如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitMultisample: Used To Query The Multisample Frequencies</span></span><br><span class="line">bool InitMultisample(HWND hWnd)</span><br><span class="line">&#123;  </span><br><span class="line">     <span class="comment">// See If The String Exists In WGL!</span></span><br><span class="line">    <span class="keyword">if</span> (!WGLisExtensionSupported(<span class="string">"WGL_ARB_multisample"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        arbMultisampleSupported=false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Our Pixel Format</span></span><br><span class="line">    PFNWGLCHOOSEPIXELFORMATARBPROC wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC)wglGetProcAddress("wglChoosePixelFormatARB");  </span><br><span class="line">    <span class="keyword">if</span> (!wglChoosePixelFormatARB) </span><br><span class="line">    &#123;</span><br><span class="line">        arbMultisampleSupported=false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Our Current Device Context</span></span><br><span class="line">    HDC hDC = GetDC(hWnd);</span><br><span class="line"></span><br><span class="line">    int     pixelFormat;</span><br><span class="line">    int     valid;</span><br><span class="line">    UINT    numFormats;</span><br><span class="line">    <span class="attribute">float</span>   fAttributes[] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These Attributes Are The Bits We Want To Test For In Our Sample</span></span><br><span class="line">    <span class="comment">// Everything Is Pretty Standard, The Only One We Want To </span></span><br><span class="line">    <span class="comment">// Really Focus On Is The SAMPLE BUFFERS ARB And WGL SAMPLES</span></span><br><span class="line">    <span class="comment">// These Two Are Going To Do The Main Testing For Whether Or Not</span></span><br><span class="line">    <span class="comment">// We Support Multisampling On This Hardware.</span></span><br><span class="line">    int iAttributes[] =</span><br><span class="line">    &#123;</span><br><span class="line">        WGL_DRAW_TO_WINDOW_ARB,GL_TRUE,</span><br><span class="line">        WGL_SUPPORT_OPENGL_ARB,GL_TRUE,</span><br><span class="line">        WGL_ACCELERATION_ARB,WGL_FULL_ACCELERATION_ARB,</span><br><span class="line">        WGL_COLOR_BITS_ARB,<span class="number">24</span>,</span><br><span class="line">        WGL_ALPHA_BITS_ARB,<span class="number">8</span>,</span><br><span class="line">        WGL_DEPTH_BITS_ARB,<span class="number">16</span>,</span><br><span class="line">        WGL_STENCIL_BITS_ARB,<span class="number">0</span>,</span><br><span class="line">        WGL_DOUBLE_BUFFER_ARB,GL_TRUE,</span><br><span class="line">        WGL_SAMPLE_BUFFERS_ARB,GL_TRUE,</span><br><span class="line">        WGL_SAMPLES_ARB,<span class="number">16</span>,<span class="comment">//16设置了抗锯齿的质量</span></span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First We Check To See If We Can Get A Pixel Format For 4 Samples</span></span><br><span class="line">    valid = wglChoosePixelFormatARB(hDC,iAttributes,fAttributes,1,pixelFormat,numFormats);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If We Returned True, And Our Format Count Is Greater Than 1</span></span><br><span class="line">    <span class="keyword">if</span> (valid  numFormats &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arbMultisampleSupported = true;</span><br><span class="line">        arbMultisampleFormat = pixelFormat; </span><br><span class="line">        return arbMultisampleSupported;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our Pixel Format With 4 Samples Failed, Test For 2 Samples</span></span><br><span class="line">    iAttributes[19] = 2;</span><br><span class="line">    valid = wglChoosePixelFormatARB(hDC,iAttributes,fAttributes,1,pixelFormat,numFormats);</span><br><span class="line">    <span class="keyword">if</span> (valid  numFormats &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arbMultisampleSupported = true;</span><br><span class="line">        arbMultisampleFormat = pixelFormat;  </span><br><span class="line">        return arbMultisampleSupported;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return The Valid Format</span></span><br><span class="line">    return  arbMultisampleSupported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的使用还是很简单的，基本上是修改了2个全局变量，arbMultisampleSupported判断是否支持多重采样，arbMultisampleFormat则是对应的像素格式。我在代码中注释了一行：WGL_SAMPLES_ARB,16,//16设置了抗锯齿的质量。这里貌似可以修改数字的大小，据说一般显卡都支持到16，16的情况下，抗锯齿很好了，4的话效果一般般。这个函数相关的完整代码可以从NeHe下载。<br>至于完整代码，可以参考我上一篇文章，然后将这一篇文章的代码加进去即可。<br>未抗锯齿的效果：<img alt data-src="https://c2.staticflickr.com/8/7346/27417287776_bda4d8b386_o.png"><br>抗锯齿的效果：<img alt data-src="https://c2.staticflickr.com/8/7593/27417289466_6e1071be4d_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全屏抗锯齿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承MFC的CWnd类渲染OpenGL</title>
      <link href="/2014/02/15/%E7%BB%A7%E6%89%BFMFC%E7%9A%84CWnd%E7%B1%BB%E6%B8%B2%E6%9F%93OpenGL/"/>
      <url>/2014/02/15/%E7%BB%A7%E6%89%BFMFC%E7%9A%84CWnd%E7%B1%BB%E6%B8%B2%E6%9F%93OpenGL/</url>
      
        <content type="html"><![CDATA[<p>我以前使用过glut的窗口环境，以及在CView中渲染OpenGL的类。但是这些都不怎么方便。首先，在windows下，MFC比glut，glui作为界面框架要方便很多，其次，CView类没有单独的CWnd类方便，自定义的窗口类可以<strong>嵌入</strong>到任意窗口内部，这样就可以脱离框架，方便移植了。<br>我的思路是实现一个COglWnd类。该类可以负责构建OpenGL渲染环境，并且调用模型类渲染，另外负责响应鼠标旋转放缩移动模型等，也可以添加一些额外的操作。<br>该类需要提供的外部接口，创建窗口和渲染模型。<br>COglWnd使用方法：在容器类（比如CView）的OnCreate函数内调用COglWnd的Create函数创建窗口，在容器类的OnSize函数类内调用COglWnd类的<strong>SetWindowPos</strong>移动窗口位置。<br>COglWnd的实现：<br>1.构建OpenGL渲染环境。这个必须在COglWnd的OnCreate函数类实现。具体实现我写在了SetupGLContext函数内部。该函数主要是依次调用了ChoosePixelFormat，SetPixelFormat，wglCreateContext，wglMakeCurrent函数而已。基本上就是设置下OpenGL的一些参数，然后构造下渲染环境的意思，非常好理解。具体可以google。<br>2.渲染。这里需要屏蔽<strong>OnEraseBkgnd</strong>函数，还有OnPaint内调用实际的渲染函数RenderScene而已。这里需要注意的是，我们屏蔽了CWnd的背景擦除函数，这样能够避免一定程度的闪烁。还有，当我们需要更新显示的时候，可以直接调用RenderScene而不是调用MFC的Invalidate函数。这样可以略去MFC的消息传递等。<br>3.鼠标响应。这里旋转我使用了<strong>轨迹球</strong>类。其余的直接调用OpenGL函数即可实现。<br>下面是我的COglWnd类，内部使用了一个vertex模版类存储数据和渲染球类来实现鼠标响应。上面所述，均可参照我的实现细节。我这个类就是嵌入在CView内作为子窗口使用的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"libyx/vertex.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"libyx/trackball.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"Mesh/TriMesh.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"Mesh/Texture.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="comment">// COglWnd</span></span><br><span class="line"></span><br><span class="line">namespace LibYX</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">class COglWnd : public CWnd</span><br><span class="line">&#123;</span><br><span class="line">DECLARE_DYNAMIC(COglWnd)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">COglWnd();</span><br><span class="line">virtual ~COglWnd();</span><br><span class="line">enum CURSOR_TYPE</span><br><span class="line">&#123;</span><br><span class="line">CURSOR_HAND = <span class="number">0</span>, CURSOR_PEN = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum MOUSE_STATE</span><br><span class="line">&#123;</span><br><span class="line">MOUSE_NONE = <span class="number">0</span>,</span><br><span class="line">MOUSE_LEFTBUTTON_DOWN = <span class="number">1</span>, MOUSE_LEFTBUTTON_UP = <span class="number">2</span>,</span><br><span class="line">MOUSE_MIDDLEBUTTON_DOWN = <span class="number">3</span>, MOUSE_MIDDLEBUTTON_UP = <span class="number">4</span>,</span><br><span class="line">MOUSE_RIGHTBUTTON_DOWN = <span class="number">5</span>, MOUSE_RIGHTBUTTON_UP = <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部接口</span></span><br><span class="line">public:</span><br><span class="line">void Create(CRect rect, CWnd *parent);</span><br><span class="line">CString LoadModel();</span><br><span class="line">CString SaveModel();</span><br><span class="line">bool ChooseDrawColor(v4f <span class="attribute">color</span>);</span><br><span class="line">bool ChooseStrokeColor(v4f <span class="attribute">color</span>);</span><br><span class="line">CString ChooseDrawTexture();</span><br><span class="line">bool ChooseBackColor(v4f <span class="attribute">color</span>);</span><br><span class="line">void RenderScene();//渲染函数</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">void SetCursorType(int nType) &#123; m_cursorType = nType; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息处理函数</span></span><br><span class="line">protected:</span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);</span><br><span class="line">afx_msg void OnSize(UINT nType, int cx, int cy);</span><br><span class="line">afx_msg void OnDestroy();</span><br><span class="line">afx_msg void OnPaint();</span><br><span class="line">afx_msg BOOL OnEraseBkgnd(CDC* pDC);</span><br><span class="line">afx_msg void OnLButtonDown(UINT nFlags, CPoint point);</span><br><span class="line">afx_msg void OnLButtonUp(UINT nFlags, CPoint point);</span><br><span class="line">afx_msg void OnMButtonDown(UINT nFlags, CPoint point);</span><br><span class="line">afx_msg void OnMButtonUp(UINT nFlags, CPoint point);</span><br><span class="line">afx_msg void OnRButtonDown(UINT nFlags, CPoint point);</span><br><span class="line">afx_msg void OnRButtonUp(UINT nFlags, CPoint point);</span><br><span class="line">afx_msg void OnMouseMove(UINT nFlags, CPoint point);</span><br><span class="line">afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);</span><br><span class="line">afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenGL函数</span></span><br><span class="line">private:</span><br><span class="line">BOOL SetupGLContext();</span><br><span class="line">BOOL DetachGLContext();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">void SetGLViewFrustum(int <span class="attribute">left</span>, int top, int right, int bottom, float DepthMin, float DepthMax, float Fov);</span><br><span class="line">void SetGLViewFrustum(int <span class="attribute">left</span>, int top, int right, int bottom);</span><br><span class="line">void SetGLFOV(<span class="attribute">float</span> Fov);</span><br><span class="line">void ResizeGLViewport(int <span class="attribute">width</span>, int height);</span><br><span class="line">void SetEye(v3f pos, v3f dest, v3f up);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">void InitColor();</span><br><span class="line">void InitLight();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">void InitialScene();</span><br><span class="line">void ReleaseScene();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">void RenderBackGround();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">CTriMesh m_mesh;</span><br><span class="line">CTexture m_backTexture;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">CRect m_rect;</span><br><span class="line">CWnd* m_parent;</span><br><span class="line">intm_nWinWidth;</span><br><span class="line">intm_nWinHeight;</span><br><span class="line">HDCm_hDC;</span><br><span class="line">HGLRCm_hGLRC;</span><br><span class="line"><span class="attribute">float</span> m_fGLDepthMin;</span><br><span class="line"><span class="attribute">float</span> m_fGLDepthMax;</span><br><span class="line"><span class="attribute">float</span> m_fGLFov;</span><br><span class="line">BOOL m_bGLSetup;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">v4fm_backColor;</span><br><span class="line">v4f m_diffuseLight;</span><br><span class="line">v4f m_specularLight;</span><br><span class="line">v4fm_ambientLight;</span><br><span class="line">v4f m_emissionLight;</span><br><span class="line">v4f m_gloabalAmbientLight;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">v3f m_eye;</span><br><span class="line">v3f m_dest;</span><br><span class="line">v3f m_up;</span><br><span class="line">Trackball m_trackball;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_cursorType;</span><br><span class="line">int m_mouseState;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>GlWnd.cpp : 实现文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"OglWnd.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"../Resource.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glew.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opengl.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"glu.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"glew32.lib"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// CGlWnd</span></span><br><span class="line">namespace LibYX</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">IMPLEMENT_DYNAMIC(COglWnd, CWnd)</span><br><span class="line"></span><br><span class="line">COglWnd::COglWnd()</span><br><span class="line">&#123;</span><br><span class="line">m_bGLSetup = false;</span><br><span class="line">m_fGLDepthMin = 0.0001f;</span><br><span class="line">m_fGLDepthMax = 100.0f;</span><br><span class="line">m_fGLFov = 60.0f;</span><br><span class="line">m_cursorType = CURSOR_HAND;</span><br><span class="line">m_mouseState = MOUSE_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">COglWnd::~COglWnd()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::Create(CRect rect, CWnd *parent)</span><br><span class="line">&#123;</span><br><span class="line">if (m_bGLSetup) return;</span><br><span class="line"></span><br><span class="line">ASSERT(rect);</span><br><span class="line">ASSERT(parent);</span><br><span class="line">m_rect = rect;</span><br><span class="line">m_parent = parent;</span><br><span class="line"></span><br><span class="line">CString className = AfxRegisterWndClass(</span><br><span class="line">CS_HREDRAW | CS_VREDRAW | CS_OWNDC, NULL, (HBRUSH)GetStockObject(BLACK_BRUSH), NULL);</span><br><span class="line"></span><br><span class="line">CreateEx(0, className, "OglWnd", WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,</span><br><span class="line">rect, parent, 0);</span><br><span class="line">m_mesh.Wnd(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString COglWnd::LoadModel()</span><br><span class="line">&#123;</span><br><span class="line">char filefilter[] = _T("M Files (*.m) |*.m|Wavefront Files (*.obj) |*.obj|");</span><br><span class="line">CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,</span><br><span class="line">filefilter, NULL, 0);</span><br><span class="line">CString pathname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IDOK != dlg.DoModal())</span><br><span class="line">return pathname;</span><br><span class="line"></span><br><span class="line">pathname = dlg.GetPathName();</span><br><span class="line"><span class="keyword">if</span> (pathname.IsEmpty() == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">AfxMessageBox("输入模型文件名为空!");</span><br><span class="line">return pathname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString ext = dlg.GetFileExt();</span><br><span class="line">if (ext == "obj" || ext == "OBJ")</span><br><span class="line">&#123;</span><br><span class="line">m_mesh.LoadOBJModel(pathname);</span><br><span class="line">&#125;</span><br><span class="line">else if (ext == "m" || ext == "M")</span><br><span class="line">&#123;</span><br><span class="line">m_mesh.LoadMModel(pathname);</span><br><span class="line">&#125;</span><br><span class="line">RenderScene();</span><br><span class="line"></span><br><span class="line">return pathname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString COglWnd::SaveModel()</span><br><span class="line">&#123;</span><br><span class="line">CString pathname;</span><br><span class="line"><span class="keyword">if</span> (m_mesh.HasModelLoad() == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">return pathname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char defExt[] = _T(".obj");</span><br><span class="line">char filefilter[] = _T("Wavefront Files (*.obj) |*.obj|m Files (*.m) |*.m||");</span><br><span class="line">CFileDialog dlg(FALSE, defExt, m_mesh.GetModelName().c_str(), OFN_HIDEREADONLY, filefilter, NULL, 0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IDOK != dlg.DoModal())</span><br><span class="line">return pathname;</span><br><span class="line"></span><br><span class="line">CString ext = dlg.GetFileExt();</span><br><span class="line"></span><br><span class="line">if (ext == _T("obj") || ext == _T("OBJ"))</span><br><span class="line">&#123;</span><br><span class="line">pathname = dlg.GetPathName();</span><br><span class="line"><span class="keyword">if</span> (pathname.IsEmpty())</span><br><span class="line">&#123;</span><br><span class="line">AfxMessageBox("输入模型文件名为空!");</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_mesh.SaveOBJModel(pathname);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (ext == _T("m") || ext == _T("M"))// Save model without material)</span><br><span class="line">&#123;</span><br><span class="line">pathname = dlg.GetPathName();</span><br><span class="line"><span class="keyword">if</span> (pathname.IsEmpty())</span><br><span class="line">&#123;</span><br><span class="line">AfxMessageBox("输入模型文件名为空!");</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_mesh.SaveMModel(pathname);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return pathname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool COglWnd::ChooseDrawColor(v4f <span class="attribute">color</span>)</span><br><span class="line">&#123;</span><br><span class="line">CColorDialog colorDialog;</span><br><span class="line">COLORREF colorRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (colorDialog.DoModal() == IDOK)<span class="comment">//如果按下颜色对话框的OK键</span></span><br><span class="line">&#123;</span><br><span class="line">colorRef = colorDialog.GetColor();</span><br><span class="line"><span class="attribute">color</span>[<span class="number">0</span>] = GetRValue(colorRef);</span><br><span class="line"><span class="attribute">color</span>[<span class="number">1</span>] = GetGValue(colorRef);</span><br><span class="line"><span class="attribute">color</span>[<span class="number">2</span>] = GetBValue(colorRef);</span><br><span class="line"></span><br><span class="line">m_mesh.DrawColor(<span class="attribute">color</span>);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool COglWnd::ChooseStrokeColor(v4f <span class="attribute">color</span>)</span><br><span class="line">&#123;</span><br><span class="line">CColorDialog colorDialog;</span><br><span class="line">COLORREF colorRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (colorDialog.DoModal() == IDOK)<span class="comment">//如果按下颜色对话框的OK键</span></span><br><span class="line">&#123;</span><br><span class="line">colorRef = colorDialog.GetColor();</span><br><span class="line"><span class="attribute">color</span>[<span class="number">0</span>] = GetRValue(colorRef);</span><br><span class="line"><span class="attribute">color</span>[<span class="number">1</span>] = GetGValue(colorRef);</span><br><span class="line"><span class="attribute">color</span>[<span class="number">2</span>] = GetBValue(colorRef);</span><br><span class="line">m_mesh.StrokeColor(<span class="attribute">color</span>);</span><br><span class="line">RenderScene();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool COglWnd::ChooseBackColor(v4f <span class="attribute">color</span>)</span><br><span class="line">&#123;</span><br><span class="line">CColorDialog colorDialog;</span><br><span class="line">COLORREF colorRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (colorDialog.DoModal() == IDOK)<span class="comment">//如果按下颜色对话框的OK键</span></span><br><span class="line">&#123;</span><br><span class="line">colorRef = colorDialog.GetColor();</span><br><span class="line">m_backColor[0] = GetRValue(colorRef);</span><br><span class="line">m_backColor[1] = GetGValue(colorRef);</span><br><span class="line">m_backColor[2] = GetBValue(colorRef);</span><br><span class="line"><span class="attribute">color</span> = m_backColor;</span><br><span class="line">glClearColor(m_backColor[0], m_backColor[1], m_backColor[2], 1.0f);</span><br><span class="line">RenderScene();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString COglWnd::ChooseDrawTexture()</span><br><span class="line">&#123;</span><br><span class="line">char filefilter[] = _T(<span class="string">"Jpg Files (*.jpg)|*jpg|Bmp Files (*.bmp)|*.bmp|\</span></span><br><span class="line">   Png Files (*.png)|*.png|Gif Files (*.gif)|*.gif|Tga Files (*.tga)|*.tga|");</span><br><span class="line">CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,</span><br><span class="line">filefilter, NULL, 0);</span><br><span class="line">CString strPathName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dlg.DoModal() == IDOK)</span><br><span class="line">&#123;</span><br><span class="line">strPathName = dlg.GetPathName();</span><br><span class="line">m_mesh.SetTexture(strPathName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return strPathName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//以下是OpenGL相关的函数</span></span><br><span class="line">BOOL COglWnd::SetupGLContext()</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwFlags = (PFD_DRAW_TO_WINDOW | PFD_DOUBLEBUFFER | PFD_SUPPORT_OPENGL);</span><br><span class="line"></span><br><span class="line">PIXELFORMATDESCRIPTOR pfd =</span><br><span class="line">&#123;</span><br><span class="line">sizeof(PIXELFORMATDESCRIPTOR),<span class="comment">// Structure size,</span></span><br><span class="line"><span class="number">1</span>,<span class="comment">// Structure version number</span></span><br><span class="line">dwFlags,<span class="comment">// Property flags</span></span><br><span class="line">PFD_TYPE_RGBA,<span class="comment">// RGBA mode</span></span><br><span class="line"><span class="number">24</span>,<span class="comment">// 24-bit color</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="comment">// 8-bit each color</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="comment">// No alpha or accum. buffer,</span></span><br><span class="line"><span class="number">32</span>,<span class="comment">// 32-bit z-buffer</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>,<span class="comment">// No stencil or aux buffer</span></span><br><span class="line">PFD_MAIN_PLANE,<span class="comment">// Mainn layer type</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">// Reserved</span></span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="comment">// Unsupported.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">m_hDC = GetDC()-&gt;m_hDC;</span><br><span class="line"></span><br><span class="line">int PixelFormat = ChoosePixelFormat(m_hDC, pfd);</span><br><span class="line">BOOL bOk = false;</span><br><span class="line">bOk = SetPixelFormat(m_hDC, PixelFormat, pfd);</span><br><span class="line"><span class="keyword">if</span> (!bOk)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T("GL set pixel format fail!"), _T("Error"), MB_OK);</span><br><span class="line">return bOk;</span><br><span class="line">&#125;</span><br><span class="line">m_hGLRC = wglCreateContext(m_hDC);</span><br><span class="line">bOk = wglMakeCurrent(m_hDC, m_hGLRC);</span><br><span class="line"><span class="keyword">if</span> (!bOk)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T("Set up GL render context fail!"), _T("Error"), MB_OK);</span><br><span class="line">return bOk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return bOk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL COglWnd::DetachGLContext()</span><br><span class="line">&#123;</span><br><span class="line">wglMakeCurrent(m_hDC, NULL);</span><br><span class="line">wglDeleteContext(m_hGLRC);</span><br><span class="line">::ReleaseDC(this-&gt;m_hWnd, m_hDC);</span><br><span class="line"></span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::SetGLViewFrustum(GLint <span class="attribute">left</span>, GLint top, GLint right, GLint bottom,</span><br><span class="line">GLfloat DepthMin, GLfloat DepthMax, GLfloat Fov)</span><br><span class="line">&#123;</span><br><span class="line">m_fGLDepthMin = DepthMin;</span><br><span class="line">m_fGLDepthMax = DepthMax;</span><br><span class="line">m_fGLFov = Fov;</span><br><span class="line"></span><br><span class="line">SetGLViewFrustum(<span class="attribute">left</span>, top, right, bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::SetGLViewFrustum(GLint <span class="attribute">left</span>, GLint top, GLint right, GLint bottom)</span><br><span class="line">&#123;</span><br><span class="line">glViewport(<span class="attribute">left</span>, top, (right - left), (bottom - top));</span><br><span class="line"></span><br><span class="line"><span class="attribute">float</span> AspectRatio = (float)(right - left) / (float)(bottom - top);</span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">glLoadIdentity();</span><br><span class="line"></span><br><span class="line">gluPerspective(m_fGLFov, AspectRatio, m_fGLDepthMin, m_fGLDepthMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::SetGLFOV(GLfloat Fov)</span><br><span class="line">&#123;</span><br><span class="line">m_fGLFov = Fov;</span><br><span class="line"></span><br><span class="line">int vp[4];</span><br><span class="line">glGetIntegerv(GL_VIEWPORT, vp);</span><br><span class="line"><span class="attribute">float</span> AspectRatio = (float)(vp[<span class="number">2</span>]) / (float)(vp[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">glLoadIdentity();</span><br><span class="line"></span><br><span class="line">gluPerspective(m_fGLFov, AspectRatio, m_fGLDepthMin, m_fGLDepthMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::SetEye(v3f pos, v3f desti, v3f up)</span><br><span class="line">&#123;</span><br><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glLoadIdentity();</span><br><span class="line">gluLookAt(pos[0], pos[1], pos[2], desti[0], desti[1], desti[2], up[0], up[1], up[2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::ResizeGLViewport(GLint <span class="attribute">width</span>, GLint height)</span><br><span class="line">&#123;</span><br><span class="line">glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="attribute">width</span>, height);</span><br><span class="line"></span><br><span class="line"><span class="attribute">float</span> AspectRatio = (float)width / (float)height;</span><br><span class="line"></span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">glLoadIdentity();</span><br><span class="line"></span><br><span class="line">gluPerspective(m_fGLFov, AspectRatio, m_fGLDepthMin, m_fGLDepthMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::InitialScene()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (glewInit() != GLEW_OK)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_eye[0] = m_eye[1] = 0.0;</span><br><span class="line">m_eye[2] = 6.0f;</span><br><span class="line">m_dest[0] = m_dest[1] = m_dest[2] = 0.0;</span><br><span class="line">m_up[0] = m_up[2] = 0.0;</span><br><span class="line">m_up[1] = 1.0;</span><br><span class="line">SetEye(m_eye, m_dest, m_up);</span><br><span class="line"></span><br><span class="line">InitColor();</span><br><span class="line">InitLight();</span><br><span class="line"></span><br><span class="line">glCullFace(GL_BACK);</span><br><span class="line">glEnable(GL_CULL_FACE);</span><br><span class="line">glShadeModel(GL_SMOOTH);</span><br><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glDepthFunc(GL_LEQUAL);</span><br><span class="line">glClearColor(m_backColor[0], m_backColor[1], m_backColor[2], 1.0f);</span><br><span class="line">glDrawBuffer(GL_BACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">//glEnable(GL_ALPHA_TEST);</span></span><br><span class="line"><span class="comment">//glAlphaFunc(GL_GREATER, 0.9);//0.5可以换成任何在0~1之间的数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m_backTexture.LoadFromFile("OglWnd\\blue_back.jpg");</span></span><br><span class="line"><span class="comment">//m_backTexture.Init2DTex();</span></span><br><span class="line"></span><br><span class="line">m_trackball.setBallSpeed(10.0);</span><br><span class="line">m_mesh.InitData();</span><br><span class="line">m_mesh.DrawMouseStroke(true);</span><br><span class="line"><span class="comment">//m_mesh.LoadOBJModel("MeshData\\bunny_480k.obj");</span></span><br><span class="line"><span class="comment">//m_mesh.LoadModel("MeshData\\plane.obj");</span></span><br><span class="line">m_mesh.LoadMModel("MeshData\\bunny_80k.m");</span><br><span class="line"><span class="comment">//m_mesh.LoadMModel("MeshData\\bunny_5k.m");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::InitColor()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//m_backColor[0] = 0.15f;</span></span><br><span class="line"><span class="comment">//m_backColor[1] = 0.20f;</span></span><br><span class="line"><span class="comment">//m_backColor[2] = 0.267f;</span></span><br><span class="line">m_backColor[0] = m_backColor[1] = m_backColor[2] = 0.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::InitLight()</span><br><span class="line">&#123;</span><br><span class="line">v4f lightOnePos(V4F(0.0f, 0.0f, 20.0f, 0.0f));</span><br><span class="line"></span><br><span class="line">m_gloabalAmbientLight[<span class="number">0</span>] = m_gloabalAmbientLight[<span class="number">1</span>] = m_gloabalAmbientLight[<span class="number">2</span>]</span><br><span class="line">= m_gloabalAmbientLight[3] = 0.2f;</span><br><span class="line">m_diffuseLight[0] = m_diffuseLight[1] = m_diffuseLight[2] = m_diffuseLight[3] = 1.0;</span><br><span class="line">m_diffuseLight[3] = 1.0;</span><br><span class="line">m_specularLight[0] = m_specularLight[1] = m_specularLight[2] = m_specularLight[3] = 1.0;</span><br><span class="line">m_specularLight[3] = 1.0;</span><br><span class="line">m_ambientLight[0] = m_ambientLight[1] = m_ambientLight[2] = m_ambientLight[3] = 0.2;</span><br><span class="line">m_emissionLight[0] = m_emissionLight[1] = m_emissionLight[2] = m_emissionLight[3] = 0.1;</span><br><span class="line"></span><br><span class="line">glEnable(GL_LIGHT0);</span><br><span class="line">glEnable(GL_LIGHTING);</span><br><span class="line"></span><br><span class="line">glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL, GL_SEPARATE_SPECULAR_COLOR);//纹理映射之后再应用镜面光高亮的效果</span><br><span class="line">glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (<span class="attribute">float</span>*)m_gloabalAmbientLight);</span><br><span class="line"></span><br><span class="line">glLightfv(GL_LIGHT0, GL_POSITION, (<span class="attribute">float</span>*)lightOnePos);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_DIFFUSE, (<span class="attribute">float</span>*)m_diffuseLight);</span><br><span class="line">glLightfv(GL_LIGHT0, GL_SPECULAR, (<span class="attribute">float</span>*)m_specularLight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::RenderBackGround()</span><br><span class="line">&#123;</span><br><span class="line">glPushAttrib(GL_ALL_ATTRIB_BITS);</span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">glEnable(GL_TEXTURE_2D);</span><br><span class="line">m_backTexture.Bind2d();</span><br><span class="line"></span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">glPushMatrix();</span><br><span class="line">glLoadIdentity();</span><br><span class="line">gluOrtho2D(0.0, 1.0, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glPushMatrix();</span><br><span class="line">glLoadIdentity();</span><br><span class="line">glBegin(GL_QUADS);</span><br><span class="line">glTexCoord2f(0.0, 1.0);</span><br><span class="line">glVertex2f(0.0, 0.0);</span><br><span class="line">glTexCoord2f(1.0, 1.0);</span><br><span class="line">glVertex2f(1.0, 0.0);</span><br><span class="line">glTexCoord2f(1.0, 0.0);</span><br><span class="line">glVertex2f(1.0, 1.0);</span><br><span class="line">glTexCoord2f(0.0, 0.0);</span><br><span class="line">glVertex2f(0.0, 1.0);</span><br><span class="line">glEnd();</span><br><span class="line">glPopMatrix();</span><br><span class="line"></span><br><span class="line">glMatrixMode(GL_PROJECTION);</span><br><span class="line">glPopMatrix();</span><br><span class="line"></span><br><span class="line">glPopAttrib();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::RenderScene()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_hGLRC != wglGetCurrentContext())</span><br><span class="line">&#123;</span><br><span class="line">wglMakeCurrent(m_hDC, m_hGLRC);</span><br><span class="line">&#125;</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear Screen And Depth Buffer</span><br><span class="line"></span><br><span class="line"><span class="comment">//RenderBackGround();</span></span><br><span class="line">glMatrixMode(GL_MODELVIEW);</span><br><span class="line">glPushMatrix();</span><br><span class="line">glMultMatrixf((float*)(m_trackball.matrix().transpose()));</span><br><span class="line"></span><br><span class="line">m_mesh.DrawScene();</span><br><span class="line"></span><br><span class="line">glPopMatrix();</span><br><span class="line">SwapBuffers(m_hDC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::ReleaseScene()</span><br><span class="line">&#123;</span><br><span class="line">m_mesh.DestroyData();</span><br><span class="line">DetachGLContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN_MESSAGE_MAP(COglWnd, CWnd)</span><br><span class="line">ON_WM_DESTROY()</span><br><span class="line">ON_WM_PAINT()</span><br><span class="line">ON_WM_CREATE()</span><br><span class="line">ON_WM_SIZE()</span><br><span class="line">ON_WM_ERASEBKGND()</span><br><span class="line">ON_WM_LBUTTONDOWN()</span><br><span class="line">ON_WM_LBUTTONUP()</span><br><span class="line">ON_WM_MBUTTONDOWN()</span><br><span class="line">ON_WM_MBUTTONUP()</span><br><span class="line">ON_WM_RBUTTONDOWN()</span><br><span class="line">ON_WM_RBUTTONUP()</span><br><span class="line">ON_WM_MOUSEMOVE()</span><br><span class="line">ON_WM_MOUSEWHEEL()</span><br><span class="line">ON_WM_SETCURSOR()</span><br><span class="line">ON_WM_MBUTTONDOWN()</span><br><span class="line">ON_WM_MBUTTONUP()</span><br><span class="line">ON_WM_RBUTTONDOWN()</span><br><span class="line">ON_WM_RBUTTONUP()</span><br><span class="line">END_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是消息处理函数</span></span><br><span class="line">int COglWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CWnd::OnCreate(lpCreateStruct) == -<span class="number">1</span>)</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SetupGLContext())</span><br><span class="line">&#123;</span><br><span class="line">AfxMessageBox("初始化OpenGL窗口设置失败!");</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InitialScene();</span><br><span class="line"></span><br><span class="line">m_bGLSetup = TRUE;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// COglWnd 消息处理程序</span></span><br><span class="line"></span><br><span class="line">void COglWnd::OnSize(UINT nType, int cx, int cy)</span><br><span class="line">&#123;</span><br><span class="line">CWnd::OnSize(nType, cx, cy);</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">m_nWinWidth = cx;</span><br><span class="line">m_nWinHeight = cy;</span><br><span class="line">m_mesh.WindowWidth(m_nWinWidth);</span><br><span class="line">m_mesh.WindowHeight(m_nWinHeight);</span><br><span class="line">m_trackball.init(cx, cy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_bGLSetup)</span><br><span class="line">&#123;</span><br><span class="line">wglMakeCurrent(m_hDC, m_hGLRC);</span><br><span class="line">ResizeGLViewport(cx, cy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL COglWnd::OnEraseBkgnd(CDC* pDC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">return TRUE;</span><br><span class="line"><span class="comment">//return CWnd::OnEraseBkgnd(pDC);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">CWnd::OnDestroy();</span><br><span class="line"></span><br><span class="line">ReleaseScene();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">CPaintDC dc(this); // device context for painting</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_bGLSetup)</span><br><span class="line">&#123;</span><br><span class="line">RenderScene();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL COglWnd::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)</span><br><span class="line">&#123;</span><br><span class="line">SetCursor(LoadCursor(AfxGetApp()-&gt;m_hInstance, MAKEINTRESOURCE(IDC_CURSOR_HAND)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_cursorType == CURSOR_PEN)</span><br><span class="line">&#123;</span><br><span class="line">SetCursor(LoadCursor(AfxGetApp()-&gt;m_hInstance, MAKEINTRESOURCE(IDC_CURSOR_PEN)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return TRUE;</span><br><span class="line"><span class="comment">//return CWnd::OnSetCursor(pWnd, nHitTest, message);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnLButtonDown(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">m_mouseState = MOUSE_LEFTBUTTON_DOWN;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)<span class="comment">//如果是浏览模式</span></span><br><span class="line">&#123;</span><br><span class="line">m_trackball.buttonPressed(Trackball::LEFT_BUTTON, point.x, point.y);</span><br><span class="line">m_mesh.DrawMouseStroke(false);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_cursorType == CURSOR_PEN)<span class="comment">//如果是绘制模式</span></span><br><span class="line">&#123;</span><br><span class="line">m_mesh.DrawMouseStroke(true);</span><br><span class="line">m_mesh.ClearMouseStroke();//清除原鼠标点集合</span><br><span class="line"><span class="comment">//添加新鼠标点</span></span><br><span class="line">m_mesh.AddMousePoint(V2F(point.x, m_nWinHeight - point.y - 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CWnd::OnLButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnLButtonUp(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">m_mouseState = MOUSE_LEFTBUTTON_UP;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)</span><br><span class="line">&#123;</span><br><span class="line">m_trackball.buttonReleased(Trackball::LEFT_BUTTON);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_cursorType == CURSOR_PEN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加新鼠标点</span></span><br><span class="line">m_mesh.AddMousePoint(V2F(point.x, m_nWinHeight - point.y - 1));</span><br><span class="line">m_mesh.DrawStroke();//绘制笔画</span><br><span class="line">&#125;</span><br><span class="line">RenderScene();</span><br><span class="line"></span><br><span class="line">CWnd::OnLButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnMButtonDown(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">m_mouseState = MOUSE_MIDDLEBUTTON_DOWN;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)</span><br><span class="line">&#123;</span><br><span class="line">m_mesh.DrawMouseStroke(false);</span><br><span class="line">m_trackball.buttonPressed(Trackball::MIDDLE_BUTTON, point.x, point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CWnd::OnMButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnMButtonUp(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">m_mouseState = MOUSE_MIDDLEBUTTON_UP;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)</span><br><span class="line">&#123;</span><br><span class="line">m_trackball.buttonReleased(Trackball::MIDDLE_BUTTON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CWnd::OnMButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnRButtonDown(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">m_mouseState = MOUSE_RIGHTBUTTON_DOWN;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)</span><br><span class="line">&#123;</span><br><span class="line">m_mesh.DrawMouseStroke(false);</span><br><span class="line">m_trackball.buttonPressed(Trackball::RIGHT_BUTTON, point.x, point.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CWnd::OnRButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnRButtonUp(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">m_mouseState = MOUSE_RIGHTBUTTON_UP;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)</span><br><span class="line">&#123;</span><br><span class="line">m_trackball.buttonReleased(Trackball::RIGHT_BUTTON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CWnd::OnRButtonUp(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void COglWnd::OnMouseMove(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">SetFocus();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_mouseState == MOUSE_LEFTBUTTON_DOWN</span><br><span class="line">|| m_mouseState == MOUSE_MIDDLEBUTTON_DOWN</span><br><span class="line">|| m_mouseState == MOUSE_RIGHTBUTTON_DOWN)</span><br><span class="line">&#123;</span><br><span class="line">m_trackball.update(point.x, point.y);</span><br><span class="line">RenderScene();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_cursorType == CURSOR_PEN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_mouseState == MOUSE_LEFTBUTTON_DOWN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//添加新鼠标点</span></span><br><span class="line">m_mesh.AddMousePoint(V2F(point.x, m_nWinHeight - point.y - 1));</span><br><span class="line">RenderScene();//更新显示</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CWnd::OnMouseMove(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中键滚动放缩模型</span></span><br><span class="line">BOOL COglWnd::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_cursorType == CURSOR_HAND  m_mesh.HasModelLoad())</span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">float</span> z = m_eye[<span class="number">2</span>];</span><br><span class="line">z += zDelta / 1000.f;</span><br><span class="line">z = z &lt; m_fGLDepthMin ? m_fGLDepthMin : z;</span><br><span class="line">SetEye(m_eye, m_dest, m_up);</span><br><span class="line"></span><br><span class="line">RenderScene();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return CWnd::OnMouseWheel(nFlags, zDelta, pt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果如下图所示的中间渲染窗口：<br><img alt data-src="https://c7.staticflickr.com/8/7755/27174995310_3c6b96eba2_o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMFCToolBar上添加组合框的bug</title>
      <link href="/2013/12/21/CMFCToolBar%E4%B8%8A%E6%B7%BB%E5%8A%A0%E7%BB%84%E5%90%88%E6%A1%86%E7%9A%84bug/"/>
      <url>/2013/12/21/CMFCToolBar%E4%B8%8A%E6%B7%BB%E5%8A%A0%E7%BB%84%E5%90%88%E6%A1%86%E7%9A%84bug/</url>
      
        <content type="html"><![CDATA[<p>说实话，这几天为了CMFCToolBarComboBoxButton上的莫名其妙自动切换选择的bug烦死了，浪费了很多时间。也是过其它替代方法，发现都实现不了需要的界面效果。<br>我也不知道为什么自己对界面效果这么纠结。伤不起啊。本来我就没用过vs2008更新版本的MFC，也没打算用这个。由于上一次做的东西用到了切分视图，但是发现FormView自适应控件大小的实现非常麻烦，老是出现些不爽的bug，而且添加新的控件还得编辑界面，非常不爽。所以，打算使用新版本MFC里面的属性窗口。<br>刚好发现vs2010的项目导航可以生成这样的工程，果断试验之。虽然过程无比艰辛，总算可以使用这些自适应的DockPane窗口了。而且还发现这样的结构非常合适添加子窗口，以后的项目都可以采用这样的界面了，只要平台在windows下。<br>但是，美中最不足的是CFrameWndEx(使用CDockablePane必须使用扩展的框架窗口)，<strong>只能使用恶心的CMFCToolBar</strong>，因为CFrameWndEx的菜单和工具栏都是可以DockPane的子类。我只能说CMFCToolBar的使用太TMD的讲究了，一个不注意效果就不对。因为使用这个东西的人少，网上资料也很少。只能一直google，还有查看类定义的源码，慢慢尝试了。<br>现在，我这里说的只是添加组合框。<br>首先，在资源编辑器中新建工具栏IDR_BUILD，留下一个<strong>空位</strong>，如ID_BUILD_CHOOSE。如下图，第二个就是我预留的ID_BUILD_CHOOSE的空位。<img alt data-src="https://c8.staticflickr.com/8/7637/27379836511_65ae3047e4_o.jpg"><br>然后，在CMainFrame::OnCreate中创建两个工具栏，代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER</span><br><span class="line">| CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC)</span><br><span class="line">|| !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))</span><br><span class="line">&#123;</span><br><span class="line">TRACE0("未能创建工具栏\n");</span><br><span class="line">return -1;      // 未能创建</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!m_wndToolBarBuild.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_TOOLTIPS | CBRS_FLYBY</span><br><span class="line">| CBRS_HIDE_INPLACE | CBRS_SIZE_DYNAMIC| CBRS_GRIPPER | CBRS_BORDER_3D, IDC_MFCTOOLBAR_BUILD)</span><br><span class="line">|| !m_wndToolBarBuild.LoadToolBar(IDR_BUILD))</span><br><span class="line">&#123;</span><br><span class="line">TRACE0("未能创建build工具栏\n");</span><br><span class="line">return -1;      // 未能创建</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_wndStatusBar.Create(this))</span><br><span class="line">&#123;</span><br><span class="line">TRACE0("未能创建状态栏\n");</span><br><span class="line">return -1;      // 未能创建</span><br><span class="line">&#125;</span><br><span class="line">m_wndStatusBar.SetIndicators(indicators, sizeof(indicators)/sizeof(UINT));</span><br><span class="line"></span><br><span class="line">m_wndMenuBar.EnableDocking(CBRS_ALIGN_ANY);</span><br><span class="line">m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);</span><br><span class="line">m_wndToolBarBuild.EnableDocking(CBRS_ALIGN_ANY);</span><br><span class="line"></span><br><span class="line">EnableDocking(CBRS_ALIGN_ANY);</span><br><span class="line">DockPane(m_wndMenuBar);</span><br><span class="line">DockPane(m_wndToolBarBuild);</span><br><span class="line">DockPaneLeftOf(m_wndToolBar, m_wndToolBarBuild);</span><br></pre></td></tr></table></figure><p>注意，创建第二个工具栏的时候需要使用<strong>Create</strong>而不是CreateEx，如果使用CreateEx就不能使用后面的ID参数。<br>现在需要实现三个消息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ON_REGISTERED_MESSAGE</span><span class="params">(AFX_WM_RESETTOOLBAR, CMainFrame::OnToolbarReset)</span></span></span><br><span class="line"><span class="function"><span class="title">ON_COMMAND</span><span class="params">(ID_BUILD_CHOOSE, CMainFrame::OnClickChoose)</span></span></span><br><span class="line"><span class="function"><span class="title">ON_CBN_SELCHANGE</span><span class="params">(ID_BUILD_CHOOSE, CMainFrame::OnSelChangeClick)</span></span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CMainFrame::OnToolbarReset(WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">UINT uiToolBarId = (UINT)wParam;</span><br><span class="line"></span><br><span class="line">switch (uiToolBarId)</span><br><span class="line">&#123;</span><br><span class="line">case IDR_MAINFRAME:</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case IDR_BUILD:</span><br><span class="line">&#123;</span><br><span class="line">   CMFCToolBarComboBoxButton comboButton(ID_BUILD_CHOOSE, GetCmdMgr()-&gt;GetCmdImage(ID_BUILD_CHOOSE, FALSE), CBS_DROPDOWN);</span><br><span class="line">   comboButton.EnableWindow(TRUE);</span><br><span class="line">   comboButton.SetCenterVert();</span><br><span class="line">   comboButton.SetFlatMode();</span><br><span class="line">   comboButton.AddItem(_T("Example Stack"));</span><br><span class="line">   comboButton.AddItem(_T("Upsample Pyramid"));</span><br><span class="line">   comboButton.AddItem(_T("Jitter Pyramid"));</span><br><span class="line">   comboButton.AddItem(_T("Correct Pyramid"));</span><br><span class="line">   comboButton.SelectItem(0);</span><br><span class="line">   m_wndToolBarBuild.ReplaceButton(ID_BUILD_CHOOSE, comboButton);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CMainFrame::OnClickChoose()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CMainFrame::OnSelChangeClick()</span><br><span class="line">&#123;</span><br><span class="line">CMFCToolBarComboBoxButton* pCombo = CMFCToolBarComboBoxButton::GetByCmd(ID_BUILD_CHOOSE, TRUE);</span><br><span class="line"></span><br><span class="line">int nIndex = pCombo-&gt;GetCurSel();</span><br><span class="line">theAppState.ts.m_nDisplayMode = nIndex;</span><br><span class="line">theAppState.ts.UpdateDisplayWnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OnToolbarReset中实现的是添加组合框，根据MSDN的文档，应该采用这样的方法，当然也可以采用CMFCToolBar的protected方法InsertButton，不过需要把这个方法改成public的，这个就需要修改类定义的源码。必须响应ID_BUILD_CHOOSE的点击消息，否则组合框是灰的，无法点击。<br>OnSelChangeClick响应的是组合框选择变化的消息，这个消息的实现必须用 CMFCToolBarComboBoxButton::GetByCmd获得组合框的指针，否则得不到正确的效果。<br>最后要讲的是我碰到的一个bug，恶心了我一周了。我在工具栏上面定义了向前和向后操作，如果我一直点击向前或者向后按钮，<strong>组合框会自动切换选择到最后一项</strong>。我调试了很久，发现跟我的算法实现代码一点关系都没有，我什么都不做，操作界面就会出现这个bug。最后，我偶然发现修改CMFCToolBarComboBoxButton comboButton(ID_BUILD_CHOOSE, GetCmdMgr()-&gt;GetCmdImage(ID_BUILD_CHOOSE, FALSE), <strong>CBS_DROPDOWNLIST</strong>);的最后一个参数为<strong>CBS_DROPDOWN</strong>就不会出现这样的bug。只是有一个不爽的地方，那就是点击组合框的时候，会出现光标而已。勉强接受了吧。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMFCToolBar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用OpenCV实现PCA降维</title>
      <link href="/2013/12/19/%E5%A6%82%E4%BD%95%E7%94%A8OpenCV%E5%AE%9E%E7%8E%B0PCA%E9%99%8D%E7%BB%B4/"/>
      <url>/2013/12/19/%E5%A6%82%E4%BD%95%E7%94%A8OpenCV%E5%AE%9E%E7%8E%B0PCA%E9%99%8D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>这里讲的不是pca的原理，我还没仔细去研究过。我刚刚使用过opencv进行pca降维，效果成功过。所以只是记录下方式和注意的地方。当然也参考了网上很多的代码。网上的代码大多大同小异，我的代码当然也和别人的差不多。</p><p>首先，我用的是C版本的OpenCV。我不是嫌弃C++版本的，而是C版本的OpenCV本来已经够复杂了，我不想再跟踪C++版本的这些对象的内存了。我们需要使用到OpenCV的CvMat结构存储数据。</p><p>我们需要使用以下的CvMat。<br>CvMat<em> m_pData;//原始样本集<br>CvMat</em> m_pMean;//平均值向量、<br>CvMat<em> m_pEigVals;//协方差矩阵的特征值<br>CvMat</em> m_pEigVecs;//协方差矩阵的特征向量<br>CvMat<em> m_pResult;//PCA降维的结果<br>CvMat</em> m_pQueryIn;//输入的一个数据<br>CvMat* m_pQueryOut;//用样本集的PCA信息降维后的一个数据</p><p>首先，我们创建数据m_pData = cvCreateMat(m_nRows, m_nDim, CV_64FC1);然后初始化数据。再创建m_pMean，m_pEigVals，m_pEigVecs。然后调用cvCalcPCA计算平均值向量和协方差矩阵的特征值和特征向量。最后一步是cvProjectPCA，在这个函数里面可以指定维度。我们就可以得到降维之后的数据。</p><p>现在再讲查询。首先创建一个数据。m_pQueryIn = cvCreateMat(1, m_nDim, CV_64FC1);m_pQueryOut = cvCreateMat(1, m_nUseDim, CV_64FC1);然后，我们初始化m_pQueryIn。再调用cvProjectPCA(m_pQueryIn, m_pMean, m_pEigVecs, m_pQueryOut);就可以得到降维之后的数据。</p><p>下面看下综合起来的代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_pData)</span><br><span class="line">&#123;</span><br><span class="line">cvReleaseMat(m_pData);</span><br><span class="line">&#125;</span><br><span class="line">m_pData = cvCreateMat(m_nRows, m_nDim, CV_64FC1);</span><br><span class="line"><span class="comment">//在这里初始化样本集合</span></span><br><span class="line"><span class="keyword">if</span> (m_pMean)</span><br><span class="line">&#123;</span><br><span class="line">cvReleaseMat(m_pMean);</span><br><span class="line">&#125;</span><br><span class="line">m_pMean = cvCreateMat(1, m_nDim, CV_64FC1);</span><br><span class="line"><span class="keyword">if</span> (m_pEigVals)</span><br><span class="line">&#123;</span><br><span class="line">cvReleaseMat(m_pEigVals);</span><br><span class="line">&#125;</span><br><span class="line">m_pEigVals = cvCreateMat(1, std::min(m_nRows, m_nDim), CV_64FC1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_pEigVecs)</span><br><span class="line">&#123;</span><br><span class="line">cvReleaseMat(m_pEigVecs);</span><br><span class="line">&#125;</span><br><span class="line">m_pEigVecs = cvCreateMat(std::min(m_nRows, m_nDim), m_nDim, CV_64FC1);</span><br><span class="line"></span><br><span class="line">cvCalcPCA(m_pData, m_pMean, m_pEigVals, m_pEigVecs, CV_PCA_DATA_AS_ROW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_pResult)</span><br><span class="line">&#123;</span><br><span class="line">cvReleaseMat(m_pResult);</span><br><span class="line">&#125;</span><br><span class="line">m_pResult = cvCreateMat(m_nRows, m_nUseDim, CV_64FC1);</span><br><span class="line">cvProjectPCA(m_pData, m_pMean, m_pEigVecs, m_pResult);//现在m_pResult保存的就是降低维度之后的信息</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化查询需要使用的数据</span></span><br><span class="line"><span class="keyword">if</span> (m_pQueryIn)</span><br><span class="line">&#123;</span><br><span class="line">cvReleaseMat(m_pQueryIn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_pQueryOut)</span><br><span class="line">&#123;</span><br><span class="line">cvReleaseMat(m_pQueryOut);</span><br><span class="line">&#125;</span><br><span class="line">m_pQueryIn = cvCreateMat(1, m_nDim, CV_64FC1);</span><br><span class="line">m_pQueryOut = cvCreateMat(1, m_nUseDim, CV_64FC1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从m_nDim降到m_nUseDim维</span></span><br><span class="line">double* CNeighborSet::Pca(double* pfIn)</span><br><span class="line">&#123;</span><br><span class="line">m_pQueryIn-&gt;data.db = pfIn;</span><br><span class="line">cvProjectPCA(m_pQueryIn, m_pMean, m_pEigVecs, m_pQueryOut);//现在pResult保存的是降低维度之后的信息</span><br><span class="line">return m_pQueryOut-&gt;data.db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还有一个问题，是确定我们到底能够降低到多少维度了。<strong>如果维度降低太多，就保持不了足够的信息，就会失真，达不到应用的效果。</strong>当然如果效果不对，可以慢慢增大维度，直到够用为止。<br>当然还有其它办法了。<strong>比如说，在代码中计算我们应该保留多少维度就能够保持90%的信息了。</strong>下面要给出的就是这个办法。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">double fSum = 0.0;</span><br><span class="line">double fSum0 = 0.0;</span><br><span class="line">for (int i = 0; i &lt; m_pEigVals-&gt;cols; ++i)</span><br><span class="line">&#123;</span><br><span class="line">fSum += *(m_pEigVals-&gt;data.db + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double fTmp = fSum * m_fPcaRatio;</span><br><span class="line">for (int i = 0; i &lt; m_pEigVals-&gt;cols; ++i)</span><br><span class="line">&#123;</span><br><span class="line">fSum0 += *(m_pEigVals-&gt;data.db + i);</span><br><span class="line"><span class="keyword">if</span> (fSum0 &gt;= fTmp)</span><br><span class="line">&#123;</span><br><span class="line">m_nUseDim = i + 1;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造函数的理解错误</title>
      <link href="/2013/12/19/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E9%94%99%E8%AF%AF/"/>
      <url>/2013/12/19/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p> 事情的经过是这样的，我在实现一个基于OpenCv的CImage类。我需要实现它的拷贝构造函数，因为我要把它push_back到vector里面去。我过去的一直做法是在赋值操作符中实现真正的操作，在拷贝构造函数中调用。但是在这里却出现了内存错误。</p><p> 好歹我还写过几年程序，那我就开始了艰辛的调试。经过调试我发现，我的程序一直只进入拷贝构造函数，然后进去赋值操作符，在赋值操作符中我释放了对象原有的内存。错误就出现在了这里。按照我这种写法的理解，push_back是先用默认构造函数构造对象加入vector，然后再用原有拷贝构造函数初始化内容，或者说用赋值操作符初始化内容。</p><p> 事实上，完全不是这样的。<strong>push_back直接添加新的内存，然后对这块新的内存用拷贝构造函数初始化而已。</strong>既然这样的话，拷贝构造函数是不能够直接调用赋值操作符的。应该再重新写一个真正的赋值子函数，拷贝构造函数和赋值操作符都调用这个子函数。赋值操作符中多了一个先检查是否同一个对象，如果不是同一个则释放原有内存的过程而已。</p><p> 具体的可以看，CImage的部分代码。</p><pre class="brush:cpp;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;">class CImage{public:    CImage();    ~CImage();    CImage(const CImage yxImage);    CImage operator =(const CImage yxImage);//深度拷贝private:    void CopyData(const CImage yxImage);};</pre><pre class="brush:cpp;first-line:1;pad-line-numbers:true;highlight:null;collapse:false;">CImage::CImage(void){    m_pImg = NULL;    m_ppfData = NULL;    m_pfData = NULL;}CImage::CImage(const char* pcszName) {    m_pImg = NULL;    m_ppfData = NULL;    m_pfData = NULL;    Load(pcszName);}CImage::~CImage(void){    UnInit();}void CImage::CopyData(const CImage yxImage){    m_pImg = cvCloneImage(yxImage.m_pImg);    m_nRows = m_pImg->height;    m_nCols = m_pImg->width * m_pImg->nChannels;    int nLineSize = m_nCols * sizeof(double);    m_ppfData = new double*[m_nRows];    m_pfData = new double[m_nRows * m_nCols];    for (int i = 0; i < m_pImg->height; ++i)    {        m_ppfData[i] = m_pfData[i * m_nCols];        memcpy(m_ppfData[i], yxImage[i], nLineSize);    }}CImage::CImage(const CImage yxImage)//复制构造函数{    //*this = yxImage;//不能用=来实现,否则在push_back时候会出现内存错误,因为vector不调用默认构造函数     //而是先添加对象的内存,再用复制构造函数初始化数据    CopyData(yxImage);}CImage CImage::operator=(const CImage yxImage){    if (this == yxImage)    {        return *this;    }    UnInit();    CopyData(yxImage);    return *this;}</pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Assimp与CGAL的联合使用问题</title>
      <link href="/2013/11/15/Assimp%E4%B8%8ECGAL%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2013/11/15/Assimp%E4%B8%8ECGAL%E7%9A%84%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p> 昨天一直在尝试使用assimp导入obj模型，再把数据导入到cgal的Polyhedron_3中。结果发现，所有的模型都是平滑着色的。好奇怪的现象。。。我尝试了很多次修改着色模式，一点反应都没有。我去掉assimp显示就是对的。后面，怀疑到我在cgal中计算顶点法线的过程。果然是这里出问题了。计算顶点法线的过程中基本上只使用了一个邻接面。也就是cgal里面已经没有原有obj模型的拓扑性质了。所以，顶点法线基本上等于面法线了，效果就成了flat着色了。</p><p> 这有什么办法了。难道在assimp中计算法线。即使这样，我能够得到正确的顶点法线，但是cgal里面已经没有原有模型的拓扑性质了。我的数据结构还是加载失败的。所以，我不能使用assimp。而且，assimp还不能导入.m模型。虽然，它能导入格式麻烦的obj模型已经很不错了。</p><p> 下面是我用assimp加载模型，并且导入到cgal中的代码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;CGAL/Polyhedron_incremental_builder_3.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"Enriched_polyhedron.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;assimp/Importer.hpp&gt;      <span class="comment">// C++ importer interface</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;assimp/scene.h&gt;           <span class="comment">// Output data structure</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;assimp/postprocess.h&gt;     <span class="comment">// Post processing flags</span></span><br><span class="line"></span><br><span class="line">template &lt;class HDS&gt;</span><br><span class="line">class Builder_obj : public CGAL::Modifier_base&lt;HDS&gt;</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">typedef typename HDS::Vertex::Point Point;</span><br><span class="line">typedef typename CGAL::Polyhedron_incremental_builder_3&lt;HDS&gt; Builder;</span><br><span class="line">const char* pcszfileName;</span><br><span class="line">const aiScene* scene;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Builder_obj(const char* pFilename)</span><br><span class="line">&#123;</span><br><span class="line">pcszfileName = pFilename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Builder_obj() &#123;&#125;</span><br><span class="line"></span><br><span class="line">void operator()(HDS hds)</span><br><span class="line">&#123;</span><br><span class="line">Builder builder(hds,true);</span><br><span class="line">builder.begin_surface(3,1,6);</span><br><span class="line"></span><br><span class="line">Assimp::Importer importer;</span><br><span class="line">scene = importer.ReadFile(pcszfileName,  aiProcessPreset_TargetRealtime_Quality);</span><br><span class="line"><span class="keyword">if</span> (!scene) &#123;</span><br><span class="line">fprintf (stderr, "ERROR: reading mesh %s\n", pcszfileName);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (unsigned int m_i = 0; m_i &lt; scene-&gt;mNumMeshes; m_i++)</span><br><span class="line">&#123;</span><br><span class="line">const aiMesh* mesh = scene-&gt;mMeshes[m_i];</span><br><span class="line"></span><br><span class="line">for (unsigned int v_i = 0; v_i &lt; mesh-&gt;mNumVertices; v_i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mesh-&gt;HasPositions())</span><br><span class="line">&#123;</span><br><span class="line">const aiVector3D* vp = (mesh-&gt;mVertices[v_i]);</span><br><span class="line">printf ("      vp %i (%f,%f,%f)\n", v_i, vp-&gt;x, vp-&gt;y, vp-&gt;z);</span><br><span class="line">builder.add_vertex(Point(vp-&gt;x, vp-&gt;y, vp-&gt;z));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (unsigned int j = 0; j &lt; mesh-&gt;mNumFaces; ++j)</span><br><span class="line">&#123;</span><br><span class="line">const aiFace face = mesh-&gt;mFaces[j];</span><br><span class="line">assert(face.mNumIndices == 3);</span><br><span class="line"></span><br><span class="line">builder.begin_facet();</span><br><span class="line">builder.add_vertex_to_facet(face.mIndices[0]);</span><br><span class="line">builder.add_vertex_to_facet(face.mIndices[1]);</span><br><span class="line">builder.add_vertex_to_facet(face.mIndices[2]);</span><br><span class="line">builder.end_facet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">builder.end_surface();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class kernel, class items&gt;</span><br><span class="line">class Parser_obj</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">typedef typename Enriched_Model::HalfedgeDS HalfedgeDS;</span><br><span class="line">Parser_obj() &#123;&#125;</span><br><span class="line">~Parser_obj() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">bool read(const char*pFilename,</span><br><span class="line">Enriched_Model *pMesh)</span><br><span class="line">&#123;</span><br><span class="line">CGAL_assertion(pMesh != NULL);</span><br><span class="line">Builder_obj&lt;HalfedgeDS&gt; builder(pFilename);</span><br><span class="line">pMesh-&gt;delegate(builder);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 代码确实非常简洁，但是不能到达要求，又有什么办法了。如果谁有什么解决办法的，欢迎回复啊。。。所以，我打算自己实现一个适用于cgal的导入obj模型（我只导入顶点），.m模型，.off模型等的类吧，以方便以后扩充和重复使用吧。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> CGAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈QT和OpenGL</title>
      <link href="/2013/11/07/%E8%B0%88%E8%B0%88QT%E5%92%8COpenGL/"/>
      <url>/2013/11/07/%E8%B0%88%E8%B0%88QT%E5%92%8COpenGL/</url>
      
        <content type="html"><![CDATA[<p>最近用了点时间学习了QT，重新阅读了下OpenGL超级宝典第四版，并且基本阅读完了。坑爹的是看完了第四版居然在网上发现了已经可以下载第五版的中文版了。翻阅了下第五版的目录，发现作者已经把GPU编程融合到整本书里面去了。而不像第四版和第三版那样只是分出几张做些介绍而已。我以前在图书馆借了本OpenGL编程宝典第三版，居然只有第三版（PS：我堂堂大中南的图书馆也该更新下了，真不明白图书馆买那么多不需要的办公室软件书籍作甚，整个图书馆只能索引到3本qt相关的书籍），里面居然还有用汇编语言形式的GPU底层着色操作。这个在第四版就去掉了。第五版我没有仔细阅读。以后有时间的话，还是阅读下第五版的内容吧。接下来，也不打算继续看Qt的东西了，毕竟界面编程这种东西，看多了没意义。我毕竟用了几年的MFC，看qt这种封装的太好的东西跟看手册一样的，所以我还是不需要继续去背书了。。。<br>所以，接下来可能学习下着色语言的所谓橙皮书。也可能阅读英文原版的，毕竟我还没看过一本英文原版的书籍，也提高一下英语。还有要看看微分几何的书籍了。如果还有时间的话，看看数字图像处理，以及matlab的一些东西。<br>我还是回到标题吧。。。<br>前段时间，用MFC做了个交互式分割模型的程序，我用的CSplitWnd切分主窗口为三个视图。做这个界面的过程中，遇到最恶心的问题是，我的一个基于对话框的视图无法很好的自放缩子控件，也就是自动调整控件大小。不要跟我说在OnSize里面处理下就行了。不要告诉我再禁止掉滚动条。总之很难达到想要的结果。而且，代码会乱成一团，本来就不爽mfc框架生成的那么多代码。不要以为我在这里喷MFC，我毕竟是学MFC过来的，用了很多次。我以前的界面99%都是MFC做的。可以说是MFC养大了我，但是我慢慢发现我还是对MFC越来越不满了。<br>所以，我就去看Qt了。同学介绍有个豆子的空间里面关于qt的教程不错，我就把前面的大部分看了一遍，并且都把代码提取出来，全部整合到一个工程里面实验了一下。总之，发现qt还不错吧。至少对于前面的那个问题，qt里面非常好解决，因为它有水平布局和垂直布局的概念。<br>至于Qt和Opengl的结合，也非常简单。直接继承QGLWidget，实现几个函数就行了。qt5还提供了增强版本的3d类QGLView。这里我要说的是libQglviewer。这个是在qt上的一个增强opengl渲染C++库。封装了很多默认的功能，非常强大。cgal上面的qt框架的3d显示就是推荐的这个东西。<br>至于模型加载，我打算试试Assimp，用这个加载模型之后，提取出数据，再来初始化cgal的数据结构。这样就不用处理各种烦人的obj,m格式等等了。。。<br>估计下一个需要渲染的东西就是用这些东西实现了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纹理合成</title>
      <link href="/2013/10/21/%E7%BA%B9%E7%90%86%E5%90%88%E6%88%90/"/>
      <url>/2013/10/21/%E7%BA%B9%E7%90%86%E5%90%88%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>这里讲得纹理合成指的是合成图片纹理，也就是二维纹理合成，并不是指将纹理直接合成到三维模型上面。虽然从本质上面来说，三维纹理合成和二维纹理是一样的。<br>纹理合成基本上是用的非参数化的采样方法，也就是Li-Yi-Wei的那篇纹理合成的论文所使用的方法。基本思路就是为当前要合成的像素在样图中寻找一个最佳的邻域，至于这个邻域的形状是可以变化的。合成像素选取的顺序也是可以变化的。这些或多或少都会影响合成的最终结果。LiYiWei的论文里面选取的是L形状的邻域，并且使用扫描线的顺序。<br>在LiYiWei的三维纹理合成论文居然又提到了合成顺序对合成结果影响不大，这个好像没那么正确。因为，合成纹理像素的使用，需要匹配邻域，而且这些邻域最好是已经合成的像素，如果不是就不会得到较好的结果。这个是最关键的一点。所以说，合成顺序对合成结果还是有一定的影响的。<br>为什么L邻域能够得到较好的结果了，那是因为扫描线顺序下，L邻域里面的像素都是已经合成的像素。所以，如果打算对合成纹理算法进行局部的修改就需要注意邻域和合成顺序的设定，必须尽可能使用已经合成的像素。<br>为什么说三维纹理的合成和二维纹理的合成，本质是一致的了？因为三维纹理合成需要局部铺平，来构造邻域，然后的匹配和二维的思想是完全一致的。<br>下面是我自己实现代码的合成结果。纹理合成的代码网上还是能够找到的，虽然不是那么好找，这也只限于二维合成的代码。最好不要看csdn上面那个自以为写了加速的代码。<br>样本纹理：<img alt data-src="https://c1.staticflickr.com/8/7087/27352028232_085b3cb8aa_o.jpg"><br>合成纹理：<img alt data-src="https://c2.staticflickr.com/8/7455/26841928854_35ef671fb0_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
            <tag> 纹理合成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GDI+和CListCtrl实现缩略图控件</title>
      <link href="/2013/09/12/%E4%BD%BF%E7%94%A8GDI+%E5%92%8CCListCtrl%E5%AE%9E%E7%8E%B0%E7%BC%A9%E7%95%A5%E5%9B%BE%E6%8E%A7%E4%BB%B6/"/>
      <url>/2013/09/12/%E4%BD%BF%E7%94%A8GDI+%E5%92%8CCListCtrl%E5%AE%9E%E7%8E%B0%E7%BC%A9%E7%95%A5%E5%9B%BE%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>本来这个东西我是用CxImage加载了多种格式的图片，结果今天发现在vs2010的debug模型下有内存溢出，调试了半天才找到是它的原因，所以非常不爽，换了GDI+的实现方法。该控件支持加载多种格式的图片，并且在增加的项内部存储的图片路径。重要的一点是必须在控件的OnDestroy里面释放申请的ItemData，否则退出程序时候还是能检测到内存泄露。这个也是找了半天才找到的。郁闷之。<br>关于该控件类的具体实现过程，有点复杂。使用到是比较简单，绑定到CListCtrl控件上。用InitCtrl初始化，用AddImage添加。<br>该类还支持多选和全选，以及删除所有的选择。代码如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pragma</span> once</span><br><span class="line"><span class="comment">// CImageListCtrl</span></span><br><span class="line"></span><br><span class="line">class CImageListCtrl : public CListCtrl</span><br><span class="line">&#123;</span><br><span class="line">    DECLARE_DYNAMIC(CImageListCtrl)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    CImageListCtrl();</span><br><span class="line">    virtual ~CImageListCtrl();</span><br><span class="line">    CImageList m_ImageList;</span><br><span class="line">WCHAR m_char16ImgName[MAX_PATH];</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    DECLARE_MESSAGE_MAP()</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"><span class="comment">// 添加图片</span></span><br><span class="line">int AddImage(CString imgPath);</span><br><span class="line">void DelImage(CString imgPath);</span><br><span class="line">void RemoveAllImg(void);</span><br><span class="line"><span class="comment">// 获得当前显示所有图片的路径</span></span><br><span class="line">void GetImgPathList(CStringList strListPath);</span><br><span class="line">BOOL InitCtrl(int nX, int nY);</span><br><span class="line">void DeleteSelItem(void);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_nX;</span><br><span class="line">int m_nY;</span><br><span class="line">int m_nNum;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);</span><br><span class="line">afx_msg void OnDestroy();</span><br><span class="line">afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageListCtrl.cpp : 实现文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"CxImage/ximage.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"ImageListCtrl.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CImageListCtrl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">IMPLEMENT_DYNAMIC</span><span class="params">(CImageListCtrl, CListCtrl)</span></span></span><br><span class="line"></span><br><span class="line">CImageListCtrl::CImageListCtrl()</span><br><span class="line">&#123;</span><br><span class="line">    m_nNum = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CImageListCtrl::~CImageListCtrl()</span><br><span class="line">&#123;</span><br><span class="line">    m_ImageList.DeleteImageList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">BEGIN_MESSAGE_MAP</span><span class="params">(CImageListCtrl, CListCtrl)</span></span></span><br><span class="line">    ON_WM_CREATE()</span><br><span class="line">    ON_WM_DESTROY()</span><br><span class="line">ON_WM_KEYDOWN()</span><br><span class="line"><span class="function"><span class="title">END_MESSAGE_MAP</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CImageListCtrl 消息处理程序</span></span><br><span class="line"></span><br><span class="line">int CImageListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (CListCtrl::OnCreate(lpCreateStruct) == -<span class="number">1</span>)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL CImageListCtrl::InitCtrl(int nX, int nY)</span><br><span class="line">&#123;</span><br><span class="line">m_nX = nX;</span><br><span class="line">m_nY = nY;</span><br><span class="line">SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);//LVS_EX_CHECKBOXES</span><br><span class="line"><span class="keyword">if</span>(!m_ImageList.Create(nX, nY, ILC_COLOR24, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeleteAllItems();</span><br><span class="line">m_ImageList.SetBkColor(RGB(125, 125, 0));</span><br><span class="line"><span class="keyword">if</span>(SetImageList(m_ImageList, LVSIL_NORMAL) == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加图片</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int CImageListCtrl::AddImage(CString imgPath)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int nEndLen = imgPath.GetLength() - imgPath.ReverseFind('.') - 1;</span></span><br><span class="line"><span class="comment">CString strEnd = imgPath.Right(nEndLen);</span></span><br><span class="line"><span class="comment">strEnd.MakeLower();</span></span><br><span class="line"><span class="comment">if(strEnd.Compare(_T("jpg")) == 0 || strEnd.Compare(_T("gif")) == 0</span></span><br><span class="line"><span class="comment">|| strEnd.Compare(_T("bmp")) == 0 || strEnd.Compare(_T("png")) == 0</span></span><br><span class="line"><span class="comment">|| strEnd.Compare(_T("tga")) == 0 || strEnd.Compare(_T("tiff")) == 0</span></span><br><span class="line"><span class="comment">|| strEnd.Compare(_T("exif")) == 0 || strEnd.Compare(_T("wmf")) == 0</span></span><br><span class="line"><span class="comment">|| strEnd.Compare(_T("emf")) == 0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">CxImage image;</span></span><br><span class="line"><span class="comment">//应用CXImage载入图像，本程序是相对路径</span></span><br><span class="line"><span class="comment">image.Load(imgPath);</span></span><br><span class="line"><span class="comment">if (image.IsValid() == false)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">image.Resample(m_nX, m_nY, 2);</span></span><br><span class="line"><span class="comment">CDC *pDC = GetDC();//应用CXImage在内存中生产位图</span></span><br><span class="line"><span class="comment">HBITMAP hBit = image.MakeBitmap(pDC-&gt;GetSafeHdc());</span></span><br><span class="line"><span class="comment">CBitmap bmp;</span></span><br><span class="line"><span class="comment">bmp.Attach(hBit);</span></span><br><span class="line"><span class="comment">int nResult = m_ImageList.Add(bmp, RGB(255, 255, 255));</span></span><br><span class="line"><span class="comment">bmp.Detach();</span></span><br><span class="line"><span class="comment">ReleaseDC(pDC);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int nIndex = imgPath.ReverseFind(_T('\\'));</span></span><br><span class="line"><span class="comment">CString strFileName = imgPath.Right(imgPath.GetLength() - (nIndex + 1));</span></span><br><span class="line"><span class="comment">InsertItem(m_nNum, strFileName, nResult);</span></span><br><span class="line"><span class="comment">SetItemData(m_nNum, (DWORD_PTR)strdup(imgPath));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">RedrawItems(m_nNum, m_nNum);</span></span><br><span class="line"><span class="comment">m_nNum++;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return 1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">int CImageListCtrl::AddImage(CString imgPath)</span><br><span class="line">&#123;</span><br><span class="line">int nEndLen = imgPath.GetLength() - imgPath.ReverseFind('.') - 1;</span><br><span class="line">CString strEnd = imgPath.Right(nEndLen);</span><br><span class="line">strEnd.MakeLower();</span><br><span class="line">if(strEnd.Compare(_T("jpg")) == 0 || strEnd.Compare(_T("gif")) == 0</span><br><span class="line">|| strEnd.Compare(_T("bmp")) == 0 || strEnd.Compare(_T("png")) == 0</span><br><span class="line">|| strEnd.Compare(_T("tga")) == 0 || strEnd.Compare(_T("tiff")) == 0</span><br><span class="line">|| strEnd.Compare(_T("exif")) == 0 || strEnd.Compare(_T("wmf")) == 0</span><br><span class="line">|| strEnd.Compare(_T("emf")) == 0)</span><br><span class="line">&#123;</span><br><span class="line">int nStrLen = imgPath.GetLength();</span><br><span class="line">char* pCharBuf = imgPath.GetBuffer(0);</span><br><span class="line">imgPath.ReleaseBuffer();</span><br><span class="line">int nLen = MultiByteToWideChar(CP_ACP, 0, pCharBuf, nStrLen, NULL, 0);</span><br><span class="line">MultiByteToWideChar(CP_ACP, 0, pCharBuf, nStrLen, m_char16ImgName, nLen);</span><br><span class="line">m_char16ImgName[nLen] = '\0'; //添加字符串结尾，注意不是len+1</span><br><span class="line"></span><br><span class="line">Gdiplus::Bitmap* pImage = new Gdiplus::Bitmap(m_char16ImgName, true);</span><br><span class="line"><span class="keyword">if</span> (pImage == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">Gdiplus::Bitmap* pThumbnail = (Gdiplus::Bitmap*)pImage-&gt;GetThumbnailImage(m_nX, m_nY);</span><br><span class="line">HBITMAP hBmp;</span><br><span class="line">pThumbnail-&gt;GetHBITMAP(Gdiplus::Color(255, 255, 255), hBmp);</span><br><span class="line"></span><br><span class="line">CBitmap bmp;</span><br><span class="line">bmp.Attach(hBmp);</span><br><span class="line">int nResult = m_ImageList.Add(bmp, RGB(255, 255, 255));</span><br><span class="line">bmp.Detach();</span><br><span class="line">int nIndex = imgPath.ReverseFind(_T('\\'));</span><br><span class="line">CString strFileName = imgPath.Right(imgPath.GetLength() - (nIndex + 1));</span><br><span class="line"></span><br><span class="line">InsertItem(m_nNum, strFileName, nResult);</span><br><span class="line">SetItemData(m_nNum, (DWORD_PTR)strdup(imgPath));</span><br><span class="line">RedrawItems(m_nNum, m_nNum);</span><br><span class="line"></span><br><span class="line">delete pThumbnail;</span><br><span class="line">delete pImage;</span><br><span class="line">m_nNum++;</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CImageListCtrl::DelImage(CString imgPath)</span><br><span class="line">&#123;</span><br><span class="line">    int nCount = GetItemCount();</span><br><span class="line">    for (int i = 0; i &lt; nCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char *pData = (char *)GetItemData(i);</span><br><span class="line">        <span class="keyword">if</span>(pData != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            CString str;</span><br><span class="line">            str.Format(_T("%s"), pData);</span><br><span class="line">            str = str.Trim();</span><br><span class="line">            <span class="keyword">if</span>(str.CompareNoCase(imgPath) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                free(pData);</span><br><span class="line">                DeleteItem(i);</span><br><span class="line">break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CImageListCtrl::RemoveAllImg(void)</span><br><span class="line">&#123;</span><br><span class="line">    int nCount = GetItemCount();</span><br><span class="line">    for (int i=0;i&lt;nCount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char *pData = (char *)GetItemData(i);</span><br><span class="line">        <span class="keyword">if</span>(pData!=NULL)</span><br><span class="line">            free(pData);</span><br><span class="line">    &#125;</span><br><span class="line">    DeleteAllItems();</span><br><span class="line">    m_nNum = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得当前显示所有图片的路径</span></span><br><span class="line">void CImageListCtrl::GetImgPathList(CStringList strListPath)</span><br><span class="line">&#123;</span><br><span class="line">    int nCount = GetItemCount();</span><br><span class="line">    strListPath.RemoveAll();</span><br><span class="line">    for (int i=0;i&lt;nCount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char *pData = (char *)GetItemData(i);</span><br><span class="line">        <span class="keyword">if</span>(pData!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            CString str;</span><br><span class="line">            str.Format(_T("%s"),pData);</span><br><span class="line">            str = str.Trim();</span><br><span class="line">            strListPath.AddTail(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CImageListCtrl::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">int nCnt = GetItemCount();</span><br><span class="line">for (int i = 0; i &lt; nCnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">char *pData = (char *)GetItemData(i);</span><br><span class="line"><span class="keyword">if</span> (pData)</span><br><span class="line">&#123;</span><br><span class="line">delete [] pData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    CListCtrl::OnDestroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有选中的项</span></span><br><span class="line">void CImageListCtrl::DeleteSelItem(void)</span><br><span class="line">&#123;</span><br><span class="line">POSITION pos = GetFirstSelectedItemPosition();</span><br><span class="line">while(pos != NULL)</span><br><span class="line">&#123;</span><br><span class="line">int nItem = GetNextSelectedItem(pos);</span><br><span class="line">TRACE1("Item %d was selected!\n", nItem);</span><br><span class="line"></span><br><span class="line">char *pData = (char *)GetItemData(nItem);</span><br><span class="line"><span class="keyword">if</span>(pData != NULL)</span><br><span class="line">&#123;</span><br><span class="line">free(pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeleteItem(nItem);</span><br><span class="line">pos = GetFirstSelectedItemPosition();</span><br><span class="line">--m_nNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrange(LVA_ALIGNLEFT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CImageListCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="keyword">if</span> (nChar == VK_DELETE)</span><br><span class="line">&#123;</span><br><span class="line">DeleteSelItem();</span><br><span class="line">&#125;</span><br><span class="line">else if ((nChar == 'a' || nChar == 'A')  GetKeyState(VK_CONTROL))</span><br><span class="line">&#123;</span><br><span class="line">for (int i = m_nNum - 1; i &gt;= 0; --i)</span><br><span class="line">&#123;</span><br><span class="line">SetItemState(i, LVIS_SELECTED, LVIS_SELECTED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果如图：<br><a href="https://c2.staticflickr.com/8/7371/26844072333_a9a690360a_o.png" target="_blank" rel="noopener"><img alt data-src="https://c2.staticflickr.com/8/7371/26844072333_a9a690360a_o.png"></a><br>关于MFC方面的问题，欢迎加群：87236798交流。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDI+ </tag>
            
            <tag> 缩略图控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GDI+加载多种格式的纹理</title>
      <link href="/2013/09/12/%E4%BD%BF%E7%94%A8GDI+%E5%8A%A0%E8%BD%BD%E5%A4%9A%E7%A7%8D%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%BA%B9%E7%90%86/"/>
      <url>/2013/09/12/%E4%BD%BF%E7%94%A8GDI+%E5%8A%A0%E8%BD%BD%E5%A4%9A%E7%A7%8D%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>今天在做一个缩略图的控件的时候发现，CXImage库在VS2010的debug模型下有内存泄露，这可是我查错查了几个小时最后得出的结论。瞬间觉得很不爽，就不用CxImage了。觉得加载不同种格式的需求，GDI+应该能够满足我的要求。那么久果断改为GDI+了。GDI+我也没使用过，果断只能搜索其用法了。<br>后面发现只需要使用Gdiplus::Bitmap就可以处理多种格式的图片。虽然该类叫做位图，实际上可以处理多种格式，据说从Gdiplus::Image继承而来。<br>nsp; 使用GDI+据说在vs2010下也不需要初始化该库，vc6和vs2008下面需要初始化。初始化也很简单，在App里面包含个成员ULONG_PTR m_gdiplusToken，在InitInstance里面加上Gdiplus::GdiplusStartupInput gdiplusStartupInput;Gdiplus::GdiplusStartup(m_gdiplusToken, gdiplusStartupInput, NULL);在ExitInstance里面加上Gdiplus::GdiplusShutdown(m_gdiplusToken);就行了。<br>由于GDI+使用的是Unicode，而我一般用的是多字节工程，所以还需要将图片名字转换为Unicode。具体过程是先把图片名字转换为Unicode，再用Gdiplus::Bitmap类的对象bitmap加载图片，然后锁定图片数据，申请一块数据从bitmap内部提取出像素数据，然后释放图片数据，剩下的就是ogl的操作了。<br>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> XPC_YX_TEXTURE_H</span><br><span class="line"><span class="number">#def</span>ine XPC_YX_TEXTURE_H</span><br><span class="line"></span><br><span class="line">class CxImage;</span><br><span class="line"></span><br><span class="line">class CTexture</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CTexture() &#123; m_byData = NULL; m_szTexName[0] = 0; &#125;</span><br><span class="line">    CTexture(const char* pcszFileName) &#123; m_byData = 0; LoadFromFile(pcszFileName); &#125;</span><br><span class="line">  ~CTexture();</span><br><span class="line">    int LoadFromFile(const char* pcszFileName);</span><br><span class="line">  void Init2DTex();</span><br><span class="line">  void Init1DVertTex();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  int m_nWidth;</span><br><span class="line">  int m_nHeight;</span><br><span class="line">    BYTE* m_byData;</span><br><span class="line">    char m_szTexName[MAX_PATH];</span><br><span class="line">  WCHAR m_char16ImgName[MAX_PATH];</span><br><span class="line">    unsigned m_uTexName;</span><br><span class="line">  double m_fTexScaleX;</span><br><span class="line">    double m_fTexScaleY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"Texture.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"CxImage/ximage.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数只处理了没有压缩的格式</span></span><br><span class="line"><span class="comment">/*int CTexture::LoadFromFile(const char* pcszFileName)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  if (pcszFileName != NULL)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    strcpy(m_szTexName, pcszFileName);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  CxImage image;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  image.Load(pcszFileName);</span></span><br><span class="line"><span class="comment">  if (image.IsValid() == false)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  m_nWidth = image.GetWidth();</span></span><br><span class="line"><span class="comment">  m_nHeight = image.GetHeight();</span></span><br><span class="line"><span class="comment">  if (m_byData)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    delete m_byData;</span></span><br><span class="line"><span class="comment">    m_byData = NULL;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  m_byData = new BYTE[m_nWidth * m_nHeight * 3];</span></span><br><span class="line"><span class="comment">  for (int i = 0; i &lt; m_nHeight; ++i)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    for (int j = 0; j &lt; m_nWidth; ++j)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      RGBQUAD rgb = image.GetPixelColor(j, i);</span></span><br><span class="line"><span class="comment">      m_byData[(i * m_nWidth + j) * 3] = rgb.rgbRed;</span></span><br><span class="line"><span class="comment">      m_byData[(i * m_nWidth + j) * 3 + 1] = rgb.rgbGreen;</span></span><br><span class="line"><span class="comment">      m_byData[(i * m_nWidth + j) * 3 + 2] = rgb.rgbBlue;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  for (int i = 0; i &lt; m_nHeight; i += 5)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    for (int j = 0; j &lt; m_nWidth; ++j)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      m_byData[(i * m_nWidth + j) * 3] = 0;</span></span><br><span class="line"><span class="comment">      m_byData[(i * m_nWidth + j) * 3 + 1] = 0;</span></span><br><span class="line"><span class="comment">      m_byData[(i * m_nWidth + j) * 3 + 2] = 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  return 1;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line">int CTexture::LoadFromFile(const char* pcszFileName)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (pcszFileName != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    strcpy(m_szTexName, pcszFileName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int nStrLen = strlen(pcszFileName);</span><br><span class="line">  int nLen = MultiByteToWideChar(CP_ACP, 0, pcszFileName, nStrLen, NULL, 0);</span><br><span class="line">  MultiByteToWideChar(CP_ACP, 0, pcszFileName, nStrLen, m_char16ImgName, nLen);</span><br><span class="line">  m_char16ImgName[nLen] = '\0'; //添加字符串结尾，注意不是len+1*/</span><br><span class="line"></span><br><span class="line">  Gdiplus::Bitmap image(m_char16ImgName);</span><br><span class="line"></span><br><span class="line">  m_nWidth = image.GetWidth();</span><br><span class="line">  m_nHeight = image.GetHeight();</span><br><span class="line">  Gdiplus::Rect rect(0, 0, m_nWidth, m_nHeight);</span><br><span class="line">  Gdiplus::BitmapData bitmapData;</span><br><span class="line">  image.LockBits(rect, Gdiplus::ImageLockModeRead | Gdiplus::ImageLockModeWrite,</span><br><span class="line">    PixelFormat24bppRGB,  bitmapData);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m_byData)</span><br><span class="line">  &#123;</span><br><span class="line">    delete m_byData;</span><br><span class="line">    m_byData = NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  m_byData = new BYTE[m_nWidth * m_nHeight * 3];</span><br><span class="line"></span><br><span class="line">  BYTE* pByte = (BYTE*)bitmapData.Scan0;</span><br><span class="line">  int nOffset = bitmapData.Stride - m_nWidth * 3;</span><br><span class="line">  for (int i = 0; i &lt; m_nHeight; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    for (int j = 0; j &lt; m_nWidth; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      m_byData[(i * m_nWidth + j) * 3] = pByte[0];</span><br><span class="line">      m_byData[(i * m_nWidth + j) * 3 + 1] = pByte[1];</span><br><span class="line">      m_byData[(i * m_nWidth + j) * 3 + 2] = pByte[2];</span><br><span class="line">      pByte += 3;</span><br><span class="line">    &#125;</span><br><span class="line">    pByte += nOffset;</span><br><span class="line">  &#125;</span><br><span class="line">  image.UnlockBits(bitmapData);</span><br><span class="line"></span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CTexture::Init2DTex()</span><br><span class="line">&#123;</span><br><span class="line">  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class="line">  glGenTextures(1, m_uTexName);</span><br><span class="line">  glBindTexture(GL_TEXTURE_2D, m_uTexName);</span><br><span class="line"></span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);</span><br><span class="line">  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</span><br><span class="line"></span><br><span class="line">  int nRet = gluBuild2DMipmaps(GL_TEXTURE_2D, <span class="number">3</span>, m_nWidth, m_nHeight, GL_RGB, GL_UNSIGNED_BYTE,</span><br><span class="line">    m_byData);</span><br><span class="line">  <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    AfxMessageBox("加载纹理失败");</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CTexture::Init1DVertTex()</span><br><span class="line">&#123;</span><br><span class="line">  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class="line">  glGenTextures(1, m_uTexName);</span><br><span class="line">  glBindTexture(GL_TEXTURE_1D, m_uTexName);</span><br><span class="line"></span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST);</span><br><span class="line">  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</span><br><span class="line"></span><br><span class="line">  BYTE* pbyData = new BYTE[m_nHeight * 3];</span><br><span class="line">  int nAdd = m_nWidth / 2;</span><br><span class="line">  for (int i = 0; i &lt; m_nHeight; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    pbyData[i * 3] = m_byData[(i * m_nWidth + nAdd) * 3];</span><br><span class="line">    pbyData[i * 3 + 1] = m_byData[(i * m_nWidth + nAdd) * 3 + 1];</span><br><span class="line">    pbyData[i * 3 + 2] = m_byData[(i * m_nWidth + nAdd) * 3 + 2];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int nRet = gluBuild1DMipmaps(GL_TEXTURE_1D, <span class="number">3</span>, m_nHeight, GL_RGB, GL_UNSIGNED_BYTE,</span><br><span class="line">    pbyData);</span><br><span class="line">  <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    AfxMessageBox("加载纹理失败");</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete pbyData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTexture::~CTexture()</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">if</span> (m_byData) </span><br><span class="line">    delete m_byData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，在vs2010和vs2008下，不需要使用额外的库就能处理多种格式的纹理了。下面是一个贴图效果，用的是一维纹理显示了sdf值在模型顶点上的分布。<br><img alt data-src="https://c2.staticflickr.com/8/7477/27351972272_12745eca94_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 纹理 </tag>
            
            <tag> GDI+ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL使用多种格式和任意尺寸的图片作为纹理</title>
      <link href="/2013/08/31/OpenGL%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%92%8C%E4%BB%BB%E6%84%8F%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E7%BA%B9%E7%90%86/"/>
      <url>/2013/08/31/OpenGL%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%92%8C%E4%BB%BB%E6%84%8F%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>处理多种格式本身就是件麻烦的事情。但是使用cximage的话，就可以完美解决这个问题了。cximage可以处理多种常见格式的图片，比如bmp，png，jpg等。<br>那么如何使用任意尺寸的图片了。glTexImage2D必须使用长宽二次方的图片，使用非二次方的图片，必须用glTexSubImage2D进行处理，具体方法，可以参考 OpenGL使用长宽非二次方纹理 。<br>那么如何避免使用glTexSubImage2D了。我们可以使用函数gluBuild2DMipmaps来完成以上两个函数完成的工作，还不需要对纹理坐标进行放缩。这是一件非常方便的事情。<br>下面提供我的纹理类。使用方法很简单。先调用加载图片函数，再调用初始化纹理函数，可以选择二维和一维垂直方向的。然后，在绘制的时候使用纹理就行了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> XPC_YX_TEXTURE_H</span><br><span class="line"><span class="number">#def</span>ine XPC_YX_TEXTURE_H</span><br><span class="line"></span><br><span class="line">class CTexture</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CTexture() &#123; m_byData = NULL; m_szTexName[0] = 0; &#125;</span><br><span class="line">    CTexture(const char* pcszFileName) &#123; m_byData = 0; LoadFromFile(pcszFileName); &#125;</span><br><span class="line">  ~CTexture();</span><br><span class="line">    int LoadFromFile(const char* pcszFileName);</span><br><span class="line">  void Init2DTex();</span><br><span class="line">  void Init1DVertTex();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  int m_nWidth;</span><br><span class="line">  int m_nHeight;</span><br><span class="line">    BYTE* m_byData;</span><br><span class="line">    char m_szTexName[MAX_PATH];</span><br><span class="line">    unsigned m_uTexName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"Texture.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"../CxImage/ximage.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"cximage.lib"</span>)</span><br><span class="line"></span><br><span class="line">int CTexture::LoadFromFile(const char* pcszFileName)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (pcszFileName != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    strcpy(m_szTexName, pcszFileName);</span><br><span class="line">  &#125;</span><br><span class="line">  CxImage image;</span><br><span class="line">  image.Load(pcszFileName);</span><br><span class="line">  <span class="keyword">if</span> (image.IsValid() == false)</span><br><span class="line">  &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m_nWidth = image.GetWidth();</span><br><span class="line">  m_nHeight = image.GetHeight();</span><br><span class="line">  <span class="keyword">if</span> (m_byData)</span><br><span class="line">  &#123;</span><br><span class="line">    delete m_byData;</span><br><span class="line">  &#125;</span><br><span class="line">  m_byData = new BYTE[m_nWidth * m_nHeight * 3];</span><br><span class="line">  for (int i = 0; i &lt; m_nHeight; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    for (int j = 0; j &lt; m_nWidth; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      RGBQUAD rgb = image.GetPixelColor(j, i);</span><br><span class="line">      m_byData[(i * m_nWidth + j) * 3] = rgb.rgbRed;</span><br><span class="line">      m_byData[(i * m_nWidth + j) * 3 + 1] = rgb.rgbGreen;</span><br><span class="line">      m_byData[(i * m_nWidth + j) * 3 + 2] = rgb.rgbBlue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CTexture::Init2DTex()</span><br><span class="line">&#123;</span><br><span class="line">    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class="line">    glGenTextures(1, m_uTexName);</span><br><span class="line">  glBindTexture(GL_TEXTURE_2D, m_uTexName);</span><br><span class="line"></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);</span><br><span class="line"></span><br><span class="line">  int nRet = gluBuild2DMipmaps(GL_TEXTURE_2D, <span class="number">3</span>, m_nWidth, m_nHeight, GL_RGB, GL_UNSIGNED_BYTE,</span><br><span class="line">    m_byData);</span><br><span class="line">  <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    AfxMessageBox("加载纹理失败");</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CTexture::Init1DVertTex()</span><br><span class="line">&#123;</span><br><span class="line">  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class="line">  glGenTextures(1, m_uTexName);</span><br><span class="line">  glBindTexture(GL_TEXTURE_1D, m_uTexName);</span><br><span class="line"></span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">  glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);</span><br><span class="line"></span><br><span class="line">  BYTE* pbyData = new BYTE[m_nHeight * 3];</span><br><span class="line">  int nAdd = m_nWidth / 2;</span><br><span class="line">  for (int i = 0; i &lt; m_nHeight; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    pbyData[i * 3] = m_byData[(i * m_nWidth + nAdd) * 3];</span><br><span class="line">    pbyData[i * 3 + 1] = m_byData[(i * m_nWidth + nAdd) * 3 + 1];</span><br><span class="line">    pbyData[i * 3 + 2] = m_byData[(i * m_nWidth + nAdd) * 3 + 2];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int nRet = gluBuild1DMipmaps(GL_TEXTURE_1D, <span class="number">3</span>, m_nHeight, GL_RGB, GL_UNSIGNED_BYTE,</span><br><span class="line">    pbyData);</span><br><span class="line">  <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    AfxMessageBox("加载纹理失败");</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete pbyData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CTexture::~CTexture()</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">if</span> (m_byData) </span><br><span class="line">  delete m_byData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用该类，还得配置CxImage。下面这张图片是使用一维垂直纹理的效果。<br><img alt data-src="https://c2.staticflickr.com/8/7635/27451191995_e448a2f0bc_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PaintMeshCutting的实现</title>
      <link href="/2013/08/31/PaintMeshCutting%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2013/08/31/PaintMeshCutting%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>这篇论文讲的是交互式模型分割。用户用画笔在模型上面绘制出一笔，然后获得相关的分割区域。<br>这篇论文的思路大致分为三步。第一步，对所有顶点或者面计算sdf值。第二步，将笔画投影作为前景，估计一个混合高斯模型，另外随机选取1000个顶点或面估计一个高斯混合模型。第三步，利用sdf值和高斯混合模型，进行graph-cut。<br>关于sdf值和graph-cut都可以阅读论文引用的文章从而得到知晓。sdf值的计算可以到提出该观点的作者主页上面下载相关软件。但是该软件只能计算面的sdf值，不过可以再映射到顶点上面。graph-cut的应用更为广泛，这个也能到Yuri Y. Boykov主页上下载相关代码，然后使用即可。<br>更困难的事情是确定graph-cut的参数，这个需要多次调整。<br>下面是实现效果。<br><img alt data-src="https://c2.staticflickr.com/8/7355/27379585191_91565d63b1_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7623/26843934273_32cfa03b9b_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7741/26843934033_afc01718a5_o.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维模型处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CGAL实现简单的模型分割</title>
      <link href="/2013/08/05/%E4%BD%BF%E7%94%A8CGAL%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E5%9E%8B%E5%88%86%E5%89%B2/"/>
      <url>/2013/08/05/%E4%BD%BF%E7%94%A8CGAL%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E5%9E%8B%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p>第一步，先把鼠标轨迹点<strong>逆投影</strong>到三维世界的观察坐标系。<br>第二步，把第一步获得的三维坐标点集合<strong>投射到模型上面</strong>，获得笔画，就是模型内部的一些相互连接的边。<br>第三步，沿着第二步获得那些相互连接的边进行<strong>欧拉操作分裂边</strong>。可能需要多分割几次才会分割出模型的一部分。<br>第四步，<strong>搜索整个模型，对不同的部分进行标记</strong>。</p><p>下面是实现的一些效果。绿色线是鼠标轨迹，红色线是投影到模型上面的边的连接线。</p><p><img alt data-src="https://c2.staticflickr.com/8/7641/27451248125_5ea8669c0c_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7046/27417002526_77b7704140_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7021/27174724330_dab475eef1_o.png"><br>下面具体解释下以上几个步骤。<br>步骤一，比较简单，网上代码一堆，不过要自己注意理解。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">glGetIntegerv(GL_VIEWPORT, m_nViewPort);</span><br><span class="line">glGetDoublev(GL_PROJECTION_MATRIX, m_fProjmatrix);</span><br><span class="line">glGetDoublev(GL_MODELVIEW_MATRIX, m_fMvmatrix);</span><br><span class="line"></span><br><span class="line"><span class="attribute">float</span> fWinX, fWinY, fWinZ;</span><br><span class="line">int nX, nY;</span><br><span class="line">double fX, fY, fZ;</span><br><span class="line"></span><br><span class="line">m_pt3ds.<span class="attribute">clear</span>();</span><br><span class="line">for (int i = 0; i &lt; m_ptStroke.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    nX = m_ptStroke[i].x;</span><br><span class="line">    nY = m_nViewPort[3] - m_ptStroke[i].y - 1;</span><br><span class="line">    glReadBuffer(GL_BACK);</span><br><span class="line">    glReadPixels(nX, nY, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, fWinZ);</span><br><span class="line">    <span class="comment">//if (fabs(fWinZ - 1.0) &gt; 1e-8)</span></span><br><span class="line">    &#123;</span><br><span class="line">        fWinX = nX;</span><br><span class="line">        fWinY = nY;</span><br><span class="line">        gluUnProject(fWinX, fWinY, fWinZ, m_fMvmatrix, m_fProjmatrix, m_nViewPort,</span><br><span class="line">            fX, fY, fZ);</span><br><span class="line">        m_pt3ds.push_back(Point_3(fX, fY, fZ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">m_ptStroke.<span class="attribute">clear</span>();</span><br></pre></td></tr></table></figure><p>该代码就是把m_ptStroke的点转化为观察坐标系的点m_pt3ds。<br>步骤二，大致思路如下：第一步，把所有鼠标经过的点，都投影回观察空间。第二步，找到离第一个鼠标点p[0]，最近的模型内的顶点pClosed。第三步，循环剩余的鼠标点，如果当前鼠标点离pClosed的相邻顶点更近的话，那么将pClosed更新为上一次找到的pClosed的相邻顶点。所有的这些，pClosed点就是笔画的投影点。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">FILE* fpLog = fopen("log.txt", "w");</span><br><span class="line">char szStr[MAX_PATH];</span><br><span class="line">CString str;</span><br><span class="line">str.Format("%d", pt3ds.size());</span><br><span class="line"><span class="comment">//AfxMessageBox(str);</span></span><br><span class="line">sprintf(szStr, "pt3ds.size():%d\n", pt3ds.size());</span><br><span class="line">fprintf(fpLog, "%s", szStr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pt3ds.size() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double fX = CGAL::to_double(pt3ds[0].x());</span><br><span class="line">double fY = CGAL::to_double(pt3ds[0].y());</span><br><span class="line">double fZ = CGAL::to_double(pt3ds[0].z());</span><br><span class="line">double fX1, fY1, fZ1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得离第一个投影点最近的halfedge_handle</span></span><br><span class="line">Halfedge_handle heClosed = facets_begin()-&gt;halfedge();</span><br><span class="line">double fDiff = 1e10;</span><br><span class="line">for(Face_iterator pf = facets_begin();</span><br><span class="line">    pf != facets_end(); pf++)</span><br><span class="line">&#123;</span><br><span class="line">    Halfedge_handle he = pf-&gt;halfedge();</span><br><span class="line"></span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        Point_3 p = he-&gt;vertex()-&gt;point();</span><br><span class="line">        fX1 = CGAL::to_double(p.x());</span><br><span class="line">        fY1 = CGAL::to_double(p.y());</span><br><span class="line">        fZ1 = CGAL::to_double(p.z());</span><br><span class="line">        double fTemp = (fX1 - fX) * (fX1 - fX) + (fY1 - fY) * (fY1 - fY)</span><br><span class="line">            + (fZ1 - fZ) * (fZ1 - fZ);</span><br><span class="line">        <span class="keyword">if</span> (fTemp &lt; fDiff)</span><br><span class="line">        &#123;</span><br><span class="line">            fDiff = fTemp;</span><br><span class="line">            heClosed = he;</span><br><span class="line">        &#125;</span><br><span class="line">        he = he-&gt;next();</span><br><span class="line">    &#125;while(he!= pf-&gt;halfedge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Halfedge_handle&gt; vh;</span><br><span class="line">vh.push_back(heClosed);</span><br><span class="line">for (unsigned i = 1; i &lt; pt3ds.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    sprintf(szStr, "处理第:%d个笔画点\n", i);</span><br><span class="line">    fprintf(fpLog, szStr);</span><br><span class="line"></span><br><span class="line">    fX = CGAL::to_double(pt3ds[i].x());</span><br><span class="line">    fY = CGAL::to_double(pt3ds[i].y());</span><br><span class="line">    fZ = CGAL::to_double(pt3ds[i].z());</span><br><span class="line">    sprintf(szStr, "笔画点坐标为:%f,%f,%f\n", fX, fY, fZ);</span><br><span class="line">    fprintf(fpLog, szStr);</span><br><span class="line"></span><br><span class="line">    Halfedge_handle next = heClosed;</span><br><span class="line">    Point_3 p = heClosed-&gt;vertex()-&gt;point();</span><br><span class="line"></span><br><span class="line">    fX1 = CGAL::to_double(p.x());</span><br><span class="line">    fY1 = CGAL::to_double(p.y());</span><br><span class="line">    fZ1 = CGAL::to_double(p.z());</span><br><span class="line">    sprintf(szStr, "heClosed坐标为:%f,%f,%f\n", fX1, fY1, fZ1);</span><br><span class="line">    fprintf(fpLog, szStr);</span><br><span class="line"></span><br><span class="line">    fDiff = (fX1 - fX) * (fX1 - fX) + (fY1 - fY) * (fY1 - fY)</span><br><span class="line">        + (fZ1 - fZ) * (fZ1 - fZ);</span><br><span class="line"></span><br><span class="line">    Vertex_handle v = heClosed-&gt;vertex();</span><br><span class="line">    Halfedge_around_vertex_circulator he, end;</span><br><span class="line">    he = end = v-&gt;vertex_begin();</span><br><span class="line">    CGAL_For_all(he, end)</span><br><span class="line">    &#123;</span><br><span class="line">        Halfedge_handle heTemp = he-&gt;opposite();</span><br><span class="line">        p = heTemp-&gt;vertex()-&gt;point();</span><br><span class="line">        fX1 = CGAL::to_double(p.x());</span><br><span class="line">        fY1 = CGAL::to_double(p.y());</span><br><span class="line">        fZ1 = CGAL::to_double(p.z());</span><br><span class="line"></span><br><span class="line">        double fTemp = (fX1 - fX) * (fX1 - fX) + (fY1 - fY) * (fY1 - fY)</span><br><span class="line">            + (fZ1 - fZ) * (fZ1 - fZ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fTemp &lt; fDiff  heClosed != he)</span><br><span class="line">        &#123;</span><br><span class="line">            sprintf(szStr, "heTemp坐标为:%f,%f,%f\n", fX1, fY1, fZ1);</span><br><span class="line">            fprintf(fpLog, szStr);</span><br><span class="line"></span><br><span class="line">            sprintf(szStr, "fDiff:%f,fTemp:%f\n", fDiff, fTemp);</span><br><span class="line">            fprintf(fpLog, szStr);</span><br><span class="line"></span><br><span class="line">            if (std::find(vh.begin(), vh.end(), heTemp) != vh.end())</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//if (vh.size() != 1  heClosed-&gt;facet() == heTemp-&gt;facet())</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//  continue;</span></span><br><span class="line">            &#125;</span><br><span class="line">            fDiff = fTemp;</span><br><span class="line">            next = heTemp;</span><br><span class="line">            <span class="comment">//sprintf(szStr, "next坐标为:%f,%f,%f\n", fX1, fY1, fZ1);</span></span><br><span class="line">            <span class="comment">//fprintf(fpLog, szStr);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去掉已经出现过的顶点</span></span><br><span class="line">    <span class="keyword">if</span> (next != heClosed)</span><br><span class="line">    &#123;</span><br><span class="line">        heClosed = next;</span><br><span class="line">        vh.push_back(heClosed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glDisable(GL_LIGHTING);</span><br><span class="line">glDisable(GL_DEPTH_TEST);</span><br><span class="line">glColor3f(1.0, 0.0, 0.0);</span><br><span class="line">glLineWidth(3.0);</span><br><span class="line">glBegin(GL_LINE_STRIP);</span><br><span class="line">for (int i = 0; i &lt; vh.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    glVertex3d(CGAL::to_double(vh[i]-&gt;vertex()-&gt;point().x()),</span><br><span class="line">        CGAL::to_double(vh[i]-&gt;vertex()-&gt;point().y()),</span><br><span class="line">        CGAL::to_double(vh[i]-&gt;vertex()-&gt;point().z()));</span><br><span class="line">    sprintf(szStr, <span class="string">"i:%d, x:%f,y:%f,z:%f\n"</span>, <span class="selector-tag">i</span>,</span><br><span class="line">        CGAL::to_double(vh[i]-&gt;vertex()-&gt;point().x()),</span><br><span class="line">        CGAL::to_double(vh[i]-&gt;vertex()-&gt;point().y()),</span><br><span class="line">        CGAL::to_double(vh[i]-&gt;vertex()-&gt;point().z()));</span><br><span class="line">    fprintf(fpLog, szStr);</span><br><span class="line">&#125;</span><br><span class="line">glEnd();</span><br><span class="line">glFlush();</span><br></pre></td></tr></table></figure><p>步骤三是欧拉操作。我的思路是将经过的边都变成边界边，方便第四步的搜索。首先，split_edge。然后，把沿着边的相邻的两个面沿着原来的边split_facet，再删除多余的面。那么，该经过的边就会变成边界边。代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; vh.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    Halfedge_handle hBegOne = vh[i]-&gt;next()-&gt;next();</span><br><span class="line">    fprintf(fpLog ,"处理i:%d\n", i);</span><br><span class="line">    split_edge(vh[i]);</span><br><span class="line"></span><br><span class="line">    Halfedge_handle hBegTwo = vh[i]-&gt;opposite()-&gt;next();</span><br><span class="line">    Halfedge_handle hEndOne = vh[i];</span><br><span class="line">    Halfedge_handle hEndTwo = hBegTwo-&gt;next()-&gt;next();</span><br><span class="line">    split_facet(hBegOne, hEndOne);</span><br><span class="line">    split_facet(hBegTwo, hEndTwo);</span><br><span class="line">    erase_facet(hEndOne);</span><br><span class="line">    erase_facet(hBegTwo);</span><br><span class="line">    fprintf(fpLog, "is border:%d\n", hBegOne-&gt;next()-&gt;is_border_edge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤五，对整个模型的面进行dfs即可了。代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void SetComponent()</span><br><span class="line">&#123;</span><br><span class="line">    for (Facet_iterator i = facets_begin(); i != facets_end(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        i-&gt;component(-1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nComponent = 1;</span><br><span class="line">    for (Facet_iterator i = facets_begin(); i != facets_end(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i-&gt;component() == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DfsComponent(i, nComponent);</span><br><span class="line">            nComponent++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DfsComponent(Facet_iterator <span class="selector-tag">i</span>, int nComponent)</span><br><span class="line">&#123;</span><br><span class="line">    CString str;</span><br><span class="line">    str.Format("处理第:%d个面", i-&gt;tag());</span><br><span class="line">    <span class="comment">//AfxMessageBox(str);</span></span><br><span class="line">    i-&gt;component(nComponent);</span><br><span class="line"></span><br><span class="line">    Halfedge_around_facet_circulator  j = i-&gt;facet_begin();</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        Halfedge_handle hfTemp = j;</span><br><span class="line">        <span class="keyword">if</span> (hfTemp-&gt;is_border_edge())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//AfxMessageBox("找到边界边");</span></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        Halfedge_handle hf = j-&gt;opposite();</span><br><span class="line">        Facet_handle fh = hf-&gt;facet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fh-&gt;component() == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DfsComponent(fh, nComponent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ( ++j != i-&gt;facet_begin());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为每个面里面都有个代表属于哪个组件的标记，这样就实现了模型的分割。利用该方法就能实现分割出狗的腿和头部等等。</p><p>代码分享链接：链接: <a href="http://pan.baidu.com/s/1eQ50rf0" target="_blank" rel="noopener">http://pan.baidu.com/s/1eQ50rf0</a> 密码: 7f6v</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> CGAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CGAL实现平面分割三维模型</title>
      <link href="/2013/08/05/%E4%BD%BF%E7%94%A8CGAL%E5%AE%9E%E7%8E%B0%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B/"/>
      <url>/2013/08/05/%E4%BD%BF%E7%94%A8CGAL%E5%AE%9E%E7%8E%B0%E5%B9%B3%E9%9D%A2%E5%88%86%E5%89%B2%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>关于cgal的使用就不介绍了。安装了也很麻烦，但是可以直接使用库，可以去我的上一篇文章下载，<a href="http://www.xpc-yx.com/2013/07/%E5%88%86%E4%BA%AB%E4%B8%8B%E6%88%91%E7%9A%84opengl%EF%BC%8Ccgal%EF%BC%8Cboost%E5%BA%93/" target="_blank" rel="noopener" title="cgal下载">cgal下载</a>。<br>这里只简单的说说实现切割模型的方法。<br>判断所有的顶点在面的哪一面，如果一个面的<strong>所有点</strong>都在切割面的正面，那么这个面就是在切割面的positive部分，反之，如果一个面的所有点都在切割面的负面，那么这个面就是在切割面的negative部分，其余的面就是和切割面<strong>相交</strong>了。根据这个简单的原理，我们就可以用切割面把模型分为<strong>三部分</strong>。以下是我用cgal实现的效果。<br><img alt data-src="https://c2.staticflickr.com/8/7293/27351899732_519b2ca87f_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7623/27451282835_e4faaef81a_o.png"></p><p><img alt data-src="https://c2.staticflickr.com/8/7010/27379670911_ebe4a7eace_o.png"><br>从图片来看，效果基本还行，只是切割处不光滑，但是对于这么简单的算法能实现的效果，已经不错了，性价比很高。<br>如果想进一步平滑分割处，有什么办法了？我们既然已经把模型内部的面分成三部分了，那么我们只需要计算会和切割面相交的面和切割面的交点，面和面的交点应该是一条直线，那么应该有2个交点，我们再沿着这条相交线，<strong>对模型内部的面进行分割</strong>就行了。如果分割后出现非三角面，我们还可以进行<strong>三角面片化</strong>。具体的实现也不会难如上青天。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> CGAL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
            <tag> OpenGL </tag>
            
            <tag> 三维模型处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享下我的OpenGL，CGAL，Boost库</title>
      <link href="/2013/07/30/%E5%88%86%E4%BA%AB%E4%B8%8B%E6%88%91%E7%9A%84OpenGL%EF%BC%8CCGAL%EF%BC%8CBoost%E5%BA%93/"/>
      <url>/2013/07/30/%E5%88%86%E4%BA%AB%E4%B8%8B%E6%88%91%E7%9A%84OpenGL%EF%BC%8CCGAL%EF%BC%8CBoost%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>作为在学习图形学的苦逼，刚开始弄这些库也不简单。即使会弄，也麻烦得要死。装cgal就得去找教程，按照教程安装。<br>但是如果有安装好的库之后，只需要配置vs的路径就行了。而且库可以带走，不用多次安装了。我还是有一点分享精神的，我就把我的库都分享出来吧。<br>CGAL是4.1的，Boost是1.47的，OpenGL里面有glew，还有个freeimage，不过没有glm。glm可以去opengl超级宝典的源代码里面找，不过感觉不是很需要glm，即使需要几何计算，还不如找成熟的几何计算的类。</p><p>由于这篇文章访问量较大，而且不少同学留言问过我链接失效的事情，因此再次更新百度云盘的分享链接：<br><a href="http://pan.baidu.com/s/1i5AStvB" target="_blank" rel="noopener">点此下载</a>，密码：15j6。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CGAL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2010下使用glui</title>
      <link href="/2013/06/18/VS2010%E4%B8%8B%E4%BD%BF%E7%94%A8glui/"/>
      <url>/2013/06/18/VS2010%E4%B8%8B%E4%BD%BF%E7%94%A8glui/</url>
      
        <content type="html"><![CDATA[<p>编译一个程序的时候发现glui一直链接不上去，也许是我的glui版本太低了，结果到最后发现作者设置了lib的附加路径。也许glui2.35真的不能在vs2010下使用了。我下载过好几次，都还是发现glui2.36编译不过去，最后把一个<strong>模板实例化移到全局命名空间里面</strong>才编译过去了。这里打算讲一下怎么编译对应开发平台下的代码库和编译glui2.36。<br>我下载过cximage，opencv2.2，cgal，glui等开发库，有些开发库可能一下载下来就有头文件和lib,dll了。但是大多的是下载下来一个工程。而且，这个工程的原始环境还可能和你所用的环境不一样。比如，你下载下来的是vs2005或者vs2008的工程，但是你的环境是vs2010。如果，<strong>你在vs2010下面用别人用vs2005编译好的lib就可以链接不成功</strong>，这个时候你就需要用vs2010打开工程，重新编译vs2010下的lib。一般情况是打开包含所有工程的workspace，然后点击批生成，把所有需要的lib都生成出来。具体步骤就不用细说了。<br>但是还是可能遇到其它问题，比如说glui2.36就是编译不过去，因为出现了语法问题。那么就需要发挥你的聪明才智了，经验越多，语法了解的越多，就能够编译过去。我这里再上传，我修改过的glui.236的工程，里面已经包含vs2010下面的各种lib和dll了，放心使用吧。工程和lib,dll都在msvc目录下面，头文件在include里面。<br><a href="http://pan.baidu.com/s/1o7QcL1C" target="_blank" rel="noopener" title="glui2.36">glui2.36</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Glui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用VB.NET操作二进制文件以序列化对象集合</title>
      <link href="/2013/06/05/%E4%BD%BF%E7%94%A8VB.NET%E6%93%8D%E4%BD%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BB%A5%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88/"/>
      <url>/2013/06/05/%E4%BD%BF%E7%94%A8VB.NET%E6%93%8D%E4%BD%9C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%BB%A5%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>如果是用c，c++这当然是相当熟悉的操作了，也不需要做个记录了。但是现在用的是vs2010版本的vb.net。而现在我有一个大对象，里面存储了整形，浮点，字符串，还有图片。我想将数据归档到文件里面，还有从文件中恢复出来。所以，只能使用二进制的读写方法，顺便记录图片的长度。至于要不要记录字符串的长度，只能问VB.NET了。<br>读取文件的使用BinaryReader，写文件的使用BinaryWriter。这2个对.net的string也支持二进制读写，所以只需要存储图片的长度了。图片本身当做byte[]存储。这2个类在Imports System.IO空间，都需要从FileStream创建。<br>虽说对VB.NET不熟悉，但是实现之后还是发现这个东西很好用的。以后还可以用来参考下。</p><p>存储的对象的类定义如下，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Imports System.IO</span><br><span class="line"></span><br><span class="line">Public Class Project</span><br><span class="line"></span><br><span class="line">    <span class="string">'建筑，供水，供电，结构，供暖，环境</span></span><br><span class="line"><span class="string">    Public oldValueFactor(0 To 5) As Double</span></span><br><span class="line"><span class="string">    Public oldValue(0 To 5) As Integer</span></span><br><span class="line"><span class="string">    Public newValueFactor(0 To 5) As Double</span></span><br><span class="line"><span class="string">    Public newValue(0 To 5) As Integer</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public idLen As Integer</span></span><br><span class="line"><span class="string">    Public id As String</span></span><br><span class="line"><span class="string">    Public nameLen As Integer</span></span><br><span class="line"><span class="string">    Public name As String</span></span><br><span class="line"><span class="string">    Public placeLen As Integer</span></span><br><span class="line"><span class="string">    Public place As String</span></span><br><span class="line"><span class="string">    Public situationLen As Integer</span></span><br><span class="line"><span class="string">    Public situation As String</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public oldTotal As Integer  '</span>总分</span><br><span class="line">    Public newTotal As Integer</span><br><span class="line"></span><br><span class="line">    Public oldLen As Integer</span><br><span class="line">    Public oldPic() As Byte</span><br><span class="line">    Public newLen As Integer</span><br><span class="line">    Public newPic() As Byte <span class="string">'图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public Sub New()</span></span><br><span class="line"><span class="string">        oldLen = 0</span></span><br><span class="line"><span class="string">        newLen = 0</span></span><br><span class="line"><span class="string">        Dim j As Integer</span></span><br><span class="line"><span class="string">        For j = 0 To 5</span></span><br><span class="line"><span class="string">            oldValueFactor(j) = New Double()</span></span><br><span class="line"><span class="string">            oldValue(j) = New Double()</span></span><br><span class="line"><span class="string">            newValueFactor(j) = New Double()</span></span><br><span class="line"><span class="string">            newValue(j) = New Double()</span></span><br><span class="line"><span class="string">        Next</span></span><br><span class="line"><span class="string">    End Sub</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">End Class</span></span><br></pre></td></tr></table></figure></p><p>对象类的集合类定义如下。该类支持归档到文件，从文件恢复，查找，添加，删除操作。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">Imports System.IO</span><br><span class="line"></span><br><span class="line">Public Class ProjectSet</span><br><span class="line">    Public nNum As Integer</span><br><span class="line">    <span class="string">'1000000</span></span><br><span class="line"><span class="string">    Public pros(0 To 100000) As Project</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public Sub New()</span></span><br><span class="line"><span class="string">        nNum = 0</span></span><br><span class="line"><span class="string">    End Sub</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public Sub LoadFromFile(ByVal fileName As String)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Dim Stream As FileStream</span></span><br><span class="line"><span class="string">        Dim BinaryStreamReader As BinaryReader</span></span><br><span class="line"><span class="string">        Try</span></span><br><span class="line"><span class="string">            Stream = New FileStream(fileName, FileMode.Open)</span></span><br><span class="line"><span class="string">            BinaryStreamReader = New BinaryReader(Stream)</span></span><br><span class="line"><span class="string">            nNum = BinaryStreamReader.ReadInt32()</span></span><br><span class="line"><span class="string">        Catch E As Exception</span></span><br><span class="line"><span class="string">            Return</span></span><br><span class="line"><span class="string">        End Try</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Dim i As Integer</span></span><br><span class="line"><span class="string">        For i = 0 To nNum - 1</span></span><br><span class="line"><span class="string">            pros(i) = New Project</span></span><br><span class="line"><span class="string">            Dim j As Integer</span></span><br><span class="line"><span class="string">            For j = 0 To 5</span></span><br><span class="line"><span class="string">                pros(i).oldValueFactor(j) = BinaryStreamReader.ReadDouble()</span></span><br><span class="line"><span class="string">                pros(i).oldValue(j) = BinaryStreamReader.ReadInt32()</span></span><br><span class="line"><span class="string">                pros(i).newValueFactor(j) = BinaryStreamReader.ReadDouble()</span></span><br><span class="line"><span class="string">                pros(i).newValue(j) = BinaryStreamReader.ReadInt32()</span></span><br><span class="line"><span class="string">            Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            pros(i).id = BinaryStreamReader.ReadString()</span></span><br><span class="line"><span class="string">            pros(i).name = BinaryStreamReader.ReadString()</span></span><br><span class="line"><span class="string">            pros(i).place = BinaryStreamReader.ReadString()</span></span><br><span class="line"><span class="string">            pros(i).situation = BinaryStreamReader.ReadString()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            pros(i).oldTotal = BinaryStreamReader.ReadInt32()</span></span><br><span class="line"><span class="string">            pros(i).newTotal = BinaryStreamReader.ReadInt32()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            pros(i).oldLen = BinaryStreamReader.ReadInt32()</span></span><br><span class="line"><span class="string">            pros(i).oldPic = BinaryStreamReader.ReadBytes(pros(i).oldLen)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            pros(i).newLen = BinaryStreamReader.ReadInt32()</span></span><br><span class="line"><span class="string">            pros(i).newPic = BinaryStreamReader.ReadBytes(pros(i).newLen)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        BinaryStreamReader.Close()</span></span><br><span class="line"><span class="string">        Stream.Close()</span></span><br><span class="line"><span class="string">    End Sub</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public Sub SaveToFile(ByVal fileName As String)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Dim Stream = New FileStream(fileName, FileMode.Create)</span></span><br><span class="line"><span class="string">        Dim BinaryStream As New BinaryWriter(Stream)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        BinaryStream.Write(nNum)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Dim i As Integer</span></span><br><span class="line"><span class="string">        For i = 0 To nNum - 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            Dim j As Integer</span></span><br><span class="line"><span class="string">            For j = 0 To 5</span></span><br><span class="line"><span class="string">                BinaryStream.Write(pros(i).oldValueFactor(j))</span></span><br><span class="line"><span class="string">                BinaryStream.Write(pros(i).oldValue(j))</span></span><br><span class="line"><span class="string">                BinaryStream.Write(pros(i).newValueFactor(j))</span></span><br><span class="line"><span class="string">                BinaryStream.Write(pros(i).newValue(j))</span></span><br><span class="line"><span class="string">            Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).id)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).name)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).place)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).situation)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).oldTotal)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).newTotal)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).oldLen)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).oldPic)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).newLen)</span></span><br><span class="line"><span class="string">            BinaryStream.Write(pros(i).newPic)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        BinaryStream.Close()</span></span><br><span class="line"><span class="string">        Stream.Close()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    End Sub</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public Sub AddProject(ByVal project As Project)</span></span><br><span class="line"><span class="string">        pros(nNum) = project</span></span><br><span class="line"><span class="string">        nNum += 1</span></span><br><span class="line"><span class="string">    End Sub</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public Sub DeleteProject(ByVal nIndex As Integer)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Dim i As Integer</span></span><br><span class="line"><span class="string">        For i = nIndex To nNum - 2</span></span><br><span class="line"><span class="string">            pros(i) = pros(i + 1)</span></span><br><span class="line"><span class="string">        Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        nNum -= 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    End Sub</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Public Function FindProject(ByVal id As String) As Integer</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Dim i As Integer</span></span><br><span class="line"><span class="string">        For i = 0 To nNum - 1</span></span><br><span class="line"><span class="string">            If id = pros(i).id Then</span></span><br><span class="line"><span class="string">                Return i</span></span><br><span class="line"><span class="string">            End If</span></span><br><span class="line"><span class="string">        Next</span></span><br><span class="line"><span class="string">        Return -1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    End Function</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">End Class</span></span><br></pre></td></tr></table></figure><br>上面的集合类里面定义了个大数组，是因为我对.NET不熟悉，不知道这样的对象数组定义，产生的是对象集合，还是虚的引用集合。我觉得是引用集合就不用声明数据的大小了吧，结果还是需要声明。而且，读取文件的时候还需要给每个数据项new一个Project。反正不清楚为什么是这样的原因，因为对.NET真的一点不熟悉。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C# </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用OpenCV识别直线和圆</title>
      <link href="/2013/05/27/%E4%BD%BF%E7%94%A8OpenCV%E8%AF%86%E5%88%AB%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%9C%86/"/>
      <url>/2013/05/27/%E4%BD%BF%E7%94%A8OpenCV%E8%AF%86%E5%88%AB%E7%9B%B4%E7%BA%BF%E5%92%8C%E5%9C%86/</url>
      
        <content type="html"><![CDATA[<p>过程基本分四步或者三步走。第一步，加载图片。第二步，灰度化图片。第三步，Canny边缘化，第四步，检测直线或者圆。<br>首先，说明下OpenCv表示图片的结构是IplImage。这个东西代表了很多有用的东西。接下来的几步，都有该结构的指针对应图片。<br>第一步，<strong>加载图</strong>片。可以直接加载成灰度图，或者加载成彩色图，或者加载为原有图片的格式，第二步再灰度化。<br>直接加载为灰度图，<br><code>IplImage* imgZero = cvLoadImage(szZero, CV_LOAD_IMAGE_GRAYSCALE);</code><br>加载为彩色图，则把cvLoadImage函数的第二个参数改为CV_LOAD_IMAGE_COLOR，改为CV_LOAD_IMAGE_ANYCOLOR则保持图片原有格式。<br>第二步，如果第一步不是按灰度图加载，那么在这一步需要<strong>灰度化</strong>。代码如下，<br><code>IplImage *imgGray = NULL;imgGray = cvCreateImage(cvGetSize(imgZero),IPL_DEPTH_8U,1);cvCvtColor(imgZero, imgGray ,CV_BGR2GRAY);</code></p><p>这几句代码的意思是根据原图片大小创建单通道位深为8的图片，然后把原有图片转换为创建的单通道8位深灰度图片。<br>第三步，<strong>canny处理</strong>。代码如下，<br><code>IplImage *imgCanny = cvCreateImage(cvGetSize(imgZero ),IPL_DEPTH_8U,1);cvCanny(imgGray , imgCanny, 50, 100);</code><br>这几句代码的意思是根据原图片大小创建单通道位深为8的图片，然后对灰度图片进行canny处理，处理结果存储在新建立的imgCanny图片中。<br>第四步，使用识别函数进行<strong>识别</strong>直线或者圆。<br>识别直线的函数是cvHoughLines2。识别圆的函数是cvHoughCircles。进行识别之前，先创建存储区。<br><code>CvMemStorage *storage = cvCreateMemStorage(0);</code></p><p>识别直线的代码如下，<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cvClearMemStorage(storage);</span><br><span class="line">CvPoint* line;</span><br><span class="line">CvSeq* lines;</span><br><span class="line">lines = cvHoughLines2(imgCanny, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 50, 50, 10 );</span><br><span class="line">line = (CvPoint*)cvGetSeqElem(lines, 0);</span><br><span class="line">cvLine(imgZero, line[0], line[1], CV_RGB(255,0,0), 3, CV_AA, 0 );</span><br><span class="line">cout&lt;&lt;"端点1:"&lt;&lt; line[0].x &lt;&lt; "," &lt;&lt; line[0].y&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"端点2:"&lt;&lt; line[1].y &lt;&lt; "," &lt;&lt; line[1].y&lt;&lt;endl;</span><br><span class="line">pts[1].fX = line[0].x;</span><br><span class="line">pts[1].fY = line[0].y;</span><br></pre></td></tr></table></figure><br>识别圆的代码如下，<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cvClearMemStorage(storage);</span><br><span class="line">CvSeq * cir=NULL;</span><br><span class="line">cir = cvHoughCircles(imgCanny, storage, CV_HOUGH_GRADIENT, <span class="number">1</span>, imgRecog-&gt;<span class="attribute">width</span>/<span class="number">10</span> ,<span class="number">80</span>,<span class="number">40</span>, <span class="number">50</span>);</span><br><span class="line"><span class="attribute">float</span> * p=(float *)cvGetSeqElem(cir, <span class="number">0</span>);</span><br><span class="line">CvPoint pt = cvPoint(cvRound(p[0]),cvRound(p[1]));</span><br><span class="line">cvCircle(imgRecog,pt,cvRound(p[2]),CV_RGB(0,255,0));</span><br><span class="line">cvCircle(imgRecog, pt, 5, CV_RGB(0,255,0), -1, 8, 0 );//绘制圆心</span><br><span class="line">cout&lt;&lt;"圆心："&lt;&lt;pt.x&lt;&lt;","&lt;&lt;pt.y&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"半径："&lt;&lt;p[2]&lt;&lt;endl;</span><br><span class="line">pts[0].fX = pt.x;</span><br><span class="line">pts[0].fY = pt.y;</span><br><span class="line">fR = p[2];</span><br></pre></td></tr></table></figure><br>下面再提供一个识别圆和直线的程序的完整代码。识别直线和圆的参数设置，需要自己调节。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;opencv/cv.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv/highgui.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core220.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui220.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc220.lib"</span>)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">double fX;</span><br><span class="line">double fY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point pts[4];</span><br><span class="line">double fR;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打开输出文件  </span></span><br><span class="line">ofstream outf("out.txt");    </span><br><span class="line"><span class="comment">//获取cout默认输出  </span></span><br><span class="line">streambuf *default_buf=cout.rdbuf();   </span><br><span class="line"><span class="comment">//重定向cout输出到文件  </span></span><br><span class="line">cout.rdbuf( outf.rdbuf() );  </span><br><span class="line"></span><br><span class="line">char* szZero = "仪表盘0.bmp";</span><br><span class="line">char* szOne = "仪表盘1.bmp";</span><br><span class="line">char* szRecog = "仪表盘.bmp";</span><br><span class="line">IplImage* imgZero = cvLoadImage(szZero, 1);</span><br><span class="line">if (!imgZero) return -1;</span><br><span class="line">IplImage* imgOne = cvLoadImage(szOne, 1);</span><br><span class="line">if (!imgOne) return -1;</span><br><span class="line">IplImage* imgRecog = cvLoadImage(szRecog, 1);</span><br><span class="line">if (!imgRecog) return -1;</span><br><span class="line"></span><br><span class="line">IplImage *imgEdge = NULL;</span><br><span class="line">imgEdge = cvCreateImage(cvGetSize(imgRecog),IPL_DEPTH_8U,1);</span><br><span class="line">IplImage *imgCanny = cvCreateImage(cvGetSize(imgRecog),IPL_DEPTH_8U,1);</span><br><span class="line"></span><br><span class="line">CvMemStorage *storage = cvCreateMemStorage(0);//内存采用默认大小</span><br><span class="line"></span><br><span class="line">cvCvtColor(imgZero, imgEdge,CV_BGR2GRAY);</span><br><span class="line">cvCanny(imgEdge, imgCanny, 50, 100);</span><br><span class="line"><span class="comment">//hough变化检测刻度0直线</span></span><br><span class="line">cvClearMemStorage(storage);</span><br><span class="line">CvPoint* line;</span><br><span class="line">CvSeq* lines;</span><br><span class="line">lines = cvHoughLines2(imgCanny, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 50, 50, 10 );</span><br><span class="line">line = (CvPoint*)cvGetSeqElem(lines, 0);</span><br><span class="line">cvLine(imgZero, line[0], line[1], CV_RGB(255,0,0), 3, CV_AA, 0 );</span><br><span class="line">cout&lt;&lt;"端点1:"&lt;&lt; line[0].x &lt;&lt; "," &lt;&lt; line[0].y&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"端点2:"&lt;&lt; line[1].y &lt;&lt; "," &lt;&lt; line[1].y&lt;&lt;endl;</span><br><span class="line">pts[1].fX = line[0].x;</span><br><span class="line">pts[1].fY = line[0].y;</span><br><span class="line"></span><br><span class="line">cvCvtColor(imgOne, imgEdge,CV_BGR2GRAY);</span><br><span class="line">cvCanny(imgEdge, imgCanny, 50, 100);</span><br><span class="line"><span class="comment">//hough变化检测刻度1直线</span></span><br><span class="line">cvClearMemStorage(storage);</span><br><span class="line">lines = cvHoughLines2(imgCanny, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 50, 50, 10 );</span><br><span class="line">line = (CvPoint*)cvGetSeqElem(lines, 0);</span><br><span class="line">cvLine(imgOne, line[0], line[1], CV_RGB(255,0,0), 3, CV_AA, 0 );</span><br><span class="line">cout&lt;&lt;"端点1:"&lt;&lt; line[0].x &lt;&lt; "," &lt;&lt; line[0].y&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"端点2:"&lt;&lt; line[1].y &lt;&lt; "," &lt;&lt; line[1].y&lt;&lt;endl;</span><br><span class="line">pts[2].fX = line[0].x;</span><br><span class="line">pts[2].fY = line[0].y;</span><br><span class="line"></span><br><span class="line">cvCvtColor(imgRecog, imgEdge,CV_BGR2GRAY);</span><br><span class="line">cvCanny(imgEdge, imgCanny, 50, 100);</span><br><span class="line"><span class="comment">//hough变化圆检测</span></span><br><span class="line">cvClearMemStorage(storage);</span><br><span class="line">CvSeq * cir=NULL;</span><br><span class="line">cir = cvHoughCircles(imgCanny, storage, CV_HOUGH_GRADIENT, <span class="number">1</span>, imgRecog-&gt;<span class="attribute">width</span>/<span class="number">10</span> ,<span class="number">80</span>,<span class="number">40</span>, <span class="number">50</span>);</span><br><span class="line"><span class="attribute">float</span> * p=(float *)cvGetSeqElem(cir, <span class="number">0</span>);</span><br><span class="line">CvPoint pt = cvPoint(cvRound(p[0]),cvRound(p[1]));</span><br><span class="line">cvCircle(imgRecog,pt,cvRound(p[2]),CV_RGB(0,255,0));</span><br><span class="line">cvCircle(imgRecog, pt, 5, CV_RGB(0,255,0), -1, 8, 0 );//绘制圆心</span><br><span class="line">cout&lt;&lt;"圆心："&lt;&lt;pt.x&lt;&lt;","&lt;&lt;pt.y&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"半径："&lt;&lt;p[2]&lt;&lt;endl;</span><br><span class="line">pts[0].fX = pt.x;</span><br><span class="line">pts[0].fY = pt.y;</span><br><span class="line">fR = p[2];</span><br><span class="line"></span><br><span class="line"><span class="comment">//hough变化检测指针直线</span></span><br><span class="line">lines = cvHoughLines2(imgCanny, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 50, 50, 10 );</span><br><span class="line">line = (CvPoint*)cvGetSeqElem(lines, 0);</span><br><span class="line">cvLine(imgRecog, line[0], line[1], CV_RGB(255,0,0), 3, CV_AA, 0 );</span><br><span class="line">cout&lt;&lt;"端点1:"&lt;&lt; line[0].x &lt;&lt; "," &lt;&lt; line[0].y&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;"端点2:"&lt;&lt; line[1].y &lt;&lt; "," &lt;&lt; line[1].y&lt;&lt;endl;</span><br><span class="line">pts[3].fX = line[0].x;</span><br><span class="line">pts[3].fY = line[0].y;</span><br><span class="line"></span><br><span class="line">static const double PI = atan(1.0) * 4;</span><br><span class="line">double fKZero = (pts[1].fY - pts[0].fY) / (pts[1].fX - pts[0].fX);</span><br><span class="line">double fThetaZero = 180.0 / PI * atan(fKZero);</span><br><span class="line"><span class="keyword">if</span> (pts[<span class="number">1</span>]<span class="selector-class">.fX</span>  + <span class="number">10</span> &lt; pts[<span class="number">0</span>].fX)<span class="comment">//左半部分</span></span><br><span class="line">&#123;</span><br><span class="line">fThetaZero += 180.0;</span><br><span class="line">&#125;</span><br><span class="line">fThetaZero += 360.0;</span><br><span class="line"><span class="keyword">if</span> (fThetaZero &gt; <span class="number">360.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fThetaZero -= 360.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double fKOne = (pts[2].fY - pts[0].fY) / (pts[2].fX - pts[0].fX);</span><br><span class="line">double fThetaOne = 180.0 / PI * atan(fKOne);</span><br><span class="line"><span class="keyword">if</span> (pts[<span class="number">2</span>]<span class="selector-class">.fX</span>  + <span class="number">10</span> &lt; pts[<span class="number">0</span>].fX)<span class="comment">//左半部分</span></span><br><span class="line">&#123;</span><br><span class="line">fThetaOne += 180.0;</span><br><span class="line">&#125;</span><br><span class="line">fThetaOne += 360.0;</span><br><span class="line"><span class="keyword">if</span> (fThetaOne &gt; <span class="number">360.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fThetaOne -= 360.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double fKRecog = (pts[3].fY - pts[0].fY) / (pts[3].fX - pts[0].fX);</span><br><span class="line">double fThetaRecog = 180.0 / PI * atan(fKRecog);</span><br><span class="line"><span class="keyword">if</span> (pts[<span class="number">3</span>]<span class="selector-class">.fX</span>  + <span class="number">10</span> &lt; pts[<span class="number">0</span>].fX)<span class="comment">//左半部分</span></span><br><span class="line">&#123;</span><br><span class="line">fThetaRecog += 180.0;</span><br><span class="line">&#125;</span><br><span class="line">fThetaRecog += 360.0;</span><br><span class="line"><span class="keyword">if</span> (fThetaRecog &gt; <span class="number">360.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">fThetaRecog -= 360.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char szAns[100];</span><br><span class="line">sprintf(szAns, <span class="string">"0刻度的角度为:%f,1刻度的角度为:%f,识别刻度的角度为:%f,识别结果为:%.2f"</span>,</span><br><span class="line">fThetaZero, fThetaOne, fThetaRecog, (fThetaRecog - fThetaZero) / (fThetaOne - fThetaZero));</span><br><span class="line">cout &lt;&lt; szAns &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cvNamedWindow("检测", CV_WINDOW_AUTOSIZE);</span><br><span class="line">cvShowImage("检测", imgRecog);</span><br><span class="line">cvNamedWindow("刻度0", CV_WINDOW_AUTOSIZE);</span><br><span class="line">cvShowImage("刻度0", imgZero);</span><br><span class="line">cvNamedWindow("刻度1", CV_WINDOW_AUTOSIZE);</span><br><span class="line">cvShowImage("刻度1", imgOne);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line"></span><br><span class="line">cvDestroyWindow("检测");</span><br><span class="line">cvDestroyWindow("刻度0");</span><br><span class="line">cvDestroyWindow("刻度1");</span><br><span class="line">cvReleaseImage(&amp;imgRecog);</span><br><span class="line">cvReleaseImage(&amp;imgZero);</span><br><span class="line">cvReleaseImage(&amp;imgOne);</span><br><span class="line">cvReleaseImage(&amp;imgEdge);</span><br><span class="line">cvReleaseImage(&amp;imgCanny);</span><br><span class="line">cvReleaseMemStorage(&amp;storage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再给出一个识别图片内所有直线的代码，当然不可能有这么好的效果，<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;opencv/cv.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;opencv/highgui.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_core220.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_highgui220.lib"</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib, <span class="string">"opencv_imgproc220.lib"</span>)</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char* szPic = "pic_6.jpg";</span><br><span class="line">IplImage* imgOrigin = cvLoadImage(szPic, 1);</span><br><span class="line">if (!imgOrigin) return -1;</span><br><span class="line"></span><br><span class="line">IplImage *imgEdge = NULL;</span><br><span class="line">imgEdge = cvCreateImage(cvGetSize(imgOrigin),IPL_DEPTH_8U,1);</span><br><span class="line">IplImage *imgCanny = cvCreateImage(cvGetSize(imgOrigin),IPL_DEPTH_8U,1);</span><br><span class="line"></span><br><span class="line">CvMemStorage *storage = cvCreateMemStorage(0);//内存采用默认大小</span><br><span class="line"></span><br><span class="line">cvCvtColor(imgOrigin, imgEdge,CV_BGR2GRAY);</span><br><span class="line">cvCanny(imgEdge, imgCanny, 50, 100);</span><br><span class="line"></span><br><span class="line"><span class="comment">//hough变化检测刻度0直线</span></span><br><span class="line">cvClearMemStorage(storage);</span><br><span class="line">CvPoint* line;</span><br><span class="line">CvSeq* lines;</span><br><span class="line">lines = cvHoughLines2(imgCanny, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 50, 10, 10 );</span><br><span class="line">for (int i = 0; i &lt; lines-&gt;total; ++i)</span><br><span class="line">&#123;</span><br><span class="line">line = (CvPoint*)cvGetSeqElem(lines, i);</span><br><span class="line"> cvLine(imgOrigin, line[0], line[1], CV_RGB(255,0,0), 1, CV_AA, 0 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvNamedWindow("检测", CV_WINDOW_AUTOSIZE);</span><br><span class="line">cvShowImage("检测", imgOrigin);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line">cvDestroyWindow("检测");</span><br><span class="line">cvReleaseImage(&amp;imgOrigin);</span><br><span class="line">cvReleaseImage(&amp;imgEdge);</span><br><span class="line">cvReleaseImage(&amp;imgCanny);</span><br><span class="line">cvReleaseMemStorage(&amp;storage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用OpenGL绘制太阳系</title>
      <link href="/2013/05/06/%E4%BD%BF%E7%94%A8OpenGL%E7%BB%98%E5%88%B6%E5%A4%AA%E9%98%B3%E7%B3%BB/"/>
      <url>/2013/05/06/%E4%BD%BF%E7%94%A8OpenGL%E7%BB%98%E5%88%B6%E5%A4%AA%E9%98%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>写这个程序的目的最初是给别人做个作业，最后那个人也不知道要不要，很郁闷。本来不怎么想写的，去网上下了别人的代码，后面发现完全不对头，就拿来做了大幅度的修改，不过使用了下载的图片作为纹理。<br>这个例子最大的用处是使用OpenGL怎么<strong>自动产生球体纹理</strong>，自己计算球体的纹理坐标毕竟麻烦了点，虽然也不难。当然还有加载纹理，以及光照，视角设定，特殊键处理等的方法。可以使用上下键放缩和左右键移动。由于使用的是别人的代码修改的，自己感觉一坨糟，也不想去改好了。总之，要模拟出个漂亮的太阳系没那么容易，我的这个比网上有些下载的貌似稍微强点。<br>先上张图片，再把代码和纹理都贡献了，不过得传到百度网盘了，提供链接。<br><img alt data-src="https://c1.staticflickr.com/8/7433/26841670424_a40d9b5a11_o.jpg"><br>对于靠近太阳的行星，可以按上键靠近，对于贴了地球纹理那个球体，还可以看到地球的样子了。有兴趣的完全可以把这个太阳系改得再漂亮点。<br><a href="https://pan.baidu.com/s/1qYDxEZM" target="_blank" rel="noopener">百度网盘下载</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vc内嵌wmplayer播放器(屏蔽右键，全屏，播放信息等）</title>
      <link href="/2013/04/03/vc%E5%86%85%E5%B5%8Cwmplayer%E6%92%AD%E6%94%BE%E5%99%A8(%E5%B1%8F%E8%94%BD%E5%8F%B3%E9%94%AE%EF%BC%8C%E5%85%A8%E5%B1%8F%EF%BC%8C%E6%92%AD%E6%94%BE%E4%BF%A1%E6%81%AF%E7%AD%89%EF%BC%89/"/>
      <url>/2013/04/03/vc%E5%86%85%E5%B5%8Cwmplayer%E6%92%AD%E6%94%BE%E5%99%A8(%E5%B1%8F%E8%94%BD%E5%8F%B3%E9%94%AE%EF%BC%8C%E5%85%A8%E5%B1%8F%EF%BC%8C%E6%92%AD%E6%94%BE%E4%BF%A1%E6%81%AF%E7%AD%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这应该是用vc在程序中添加视频音频播放器最方便的方法了。但是，你如果只是用vs2010或者其它版本工具插入activex控件，然后生成代码，那就不一定能够得到你想要的全部功能。<br>wmplayer貌似还有个对应的wm sdk。这个可以用com接口的形式更加底层的控制播放器。<strong>但是，如果我们能够得到相关的实现播放器功能的代码，我们也能够得到相同程度的控制。</strong>前段时间，在网上找了很久，终于找到一大堆有个wmplayer的类代码。用其中的CWMPPlayer4类绑定播放器就能够得到很强大的控制了，用这个类的成员函数可以得到其他控制和设置类的接口等。<br>用这个东西最大的缺陷是<strong>无法播放内存数据</strong>，如果是内存数据，必须生成临时文件。最大的优点是简单方便，功能强大，还可以在<strong>不同版本的windows平台兼容</strong>，只要上面有默认的wmplayer播放器。这个东西还可以<strong>播放网络数据</strong>，因为文件其实是通过url索引的。因此，在要求简单的时候，还可以用这个东西快速实现一个<strong>网络播放器</strong>。<br>下面提供wmplayer相关类的代码，<a href="https://pan.baidu.com/s/1cunwJW" target="_blank" rel="noopener">WMP</a>。</p><p>屏蔽右键和全屏都可以在PreTranslateMessage这个虚函数里面处理，比如if (pMsg-&gt;message == WM_LBUTTONDBLCLK)<br>return TRUE;返回TRUE就不会对这个消息进行处理了。屏蔽右键也可以通过调用m_mediaPlayer.put_enableContextMenu(FALSE);处理。<br>最奇葩的是屏蔽当前播放的是哪个文件的信息，居然有人奇葩到提出这样的需求。找来找去都没有这样的接口，我都直接看wmsdk的文档了，最后想出了个奇葩的办法，就是用一个static控件遮住。<br>到现在觉得，最好的操作wmplayer的方式是下载微软的<strong>wmsdk</strong>，从而直接用接口操作，可以提供最大限度的控制。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vc内嵌浏览器</title>
      <link href="/2013/03/30/vc%E5%86%85%E5%B5%8C%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2013/03/30/vc%E5%86%85%E5%B5%8C%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>至于vc内嵌浏览器的方式有很多种，vs2008就可以使用htmldialog了，使用htmlview也行，但是个人觉得还是插入activex控件，然后再绑定变量来的舒服。我就是用插入activex控件再绑定变量的方式的，记得使用vc6就会生产类CWebBrowser2，但是这个类使用起来并不是那么的舒服，所以我对它再进行了一次继承。<br>注意到，CWebBrowser2继承自CWnd，所以我们继承自CWebBrowser2得类CxExplorer就必须支持mfc里面的动态创建机制，总之这个也很简单，加几句宏就行了，原理其实也不需要弄得太清楚，把mfc的原理弄得太清楚实在太费时间了。。。<br>我创建的这个浏览器类，除了提供基类的接口外，还提供了几个方便自动填表之类操作的接口。比如，获取text的值，写text的值，点击按钮或者复选框，执行js函数等的功能，由于我基本也就只用过这些功能，所以也就弄了几个这样的接口，也没过多区关注其原理等。<br>其实，我也没学过太多的com知识，只看过一本com技术内幕的书，更别说com的模板ATL了。所以啊，很多知识也不是很了解。用内嵌浏览器也玩过几次，以前没怎么发掘它的强大应用了。。。<br>其实，内嵌浏览器很多很好的应用，比如说可以作为<strong>客户端</strong>，由于内嵌了浏览器，所以不需要实现太多的客户端逻辑，而且服务端直接写web页面就行了，不过速度要求不能太高。还有自动填写表之类的应用，还有写网页游戏的自动玩的功能应该都能发掘出来吧。。。<br>关于如何判断网页是否加载完成的方法，网上一直说用OnDocumentComplete事件，其实还可能出现网页离线的状态，但是我试了几个方法都检测不出来。所以，最好还是用<strong>OnTimer</strong>检测和设置你想要的东西。</p><p>下面提供这几个类的下载，我用的使用方式是DDX，不使用vs生成的类还可以保持代码的一致性。<a href="https://pan.baidu.com/s/1qXFPqVy" target="_blank" rel="noopener">explorer</a></p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CWebBrowser2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL使用位图纹理</title>
      <link href="/2013/03/24/OpenGL%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%9B%BE%E7%BA%B9%E7%90%86/"/>
      <url>/2013/03/24/OpenGL%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%9B%BE%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>使用位图纹理主要需要注意2个地方。1个是<strong>非二次方纹理的处理</strong>，这个可以参考我<a href="http://www.xpc-yx.com/2013/03/opengl%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%95%BF%E5%AE%BD%E9%9D%9E2%E6%AC%A1%E6%96%B9%E7%9A%84%E7%BA%B9%E7%90%86/" target="_blank" rel="noopener">上一篇文章</a>的。另外一个是需要注意<strong>位图数据的格式</strong>，24位的是BGR而不是RGB,32位的是BGRA，而不是RGBA，所以用glTexImage2D之类的函数需要注意把format改成<strong>GL_BGR_EXT</strong>或者<strong>GL_BGRA_EXT</strong>，但是internalformat必须是GL_RGB或者GL_RGBA，如果没有进行这个处理的话，颜色效果会变掉的。<br>下面我给出我的一个任务里面所实现的bitmap位图类，我加载数据的时候使用了以前实现的类CxBitmap，这个也可以从我的另一篇文章中得到。整个类还是比较简单的，你也可以修改加载文件的代码，从而不需要使用CxBitmap类。</p><p>CBitmapTex类的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> XPC_YX_BITMAPTEX_H</span><br><span class="line"><span class="number">#def</span>ine XPC_YX_BITMAPTEX_H</span><br><span class="line">#include</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine RGB16(r,g,b)   ( ((r&gt;&gt;<span class="number">3</span>) &lt;&lt; <span class="number">10</span>) + ((g&gt;&gt;<span class="number">3</span>) &lt;&lt; <span class="number">5</span>) + (<span class="selector-tag">b</span> &gt;&gt; <span class="number">3</span>) )</span><br><span class="line"><span class="number">#def</span>ine RGB24(r,g,b)   ( ((r) &lt;&lt; <span class="number">16</span>) + ((g) &lt;&lt; <span class="number">8</span>) + (b) )</span><br><span class="line"></span><br><span class="line">class CBitmapTex</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CBitmapTex() &#123; m_byData = 0; m_szTexName[0] = 0; &#125;</span><br><span class="line">    CBitmapTex(const char* pcszFileName) &#123; m_byData = 0; LoadBitmapTex(pcszFileName); &#125;</span><br><span class="line">    ~CBitmapTex() &#123; if (m_byData) free(m_byData); &#125;</span><br><span class="line">    int LoadBitmapTex(const char* pcszFileName);</span><br><span class="line">    void InitTex();</span><br><span class="line">    void SetTexture();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_nWidth;</span><br><span class="line">    int m_nHeight;</span><br><span class="line">    int m_nBytesPerPixel;</span><br><span class="line">    BYTE* m_byData;</span><br><span class="line">    char m_szTexName[MAX_PATH];</span><br><span class="line">    unsigned m_uTexName;</span><br><span class="line">    double m_fTexScaleX;</span><br><span class="line">    double m_fTexScaleY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>CBitmapTex的实现如下，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"bitmapTex.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"CxBitmap.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"tool.h"</span></span><br><span class="line">#include</span><br><span class="line">#include</span><br><span class="line">#include</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数只处理了没有压缩的格式</span></span><br><span class="line">int CBitmapTex::LoadBitmapTex(const char* pcszFileName)</span><br><span class="line">&#123;</span><br><span class="line">    CxBitmap* pBitmap = new CxBitmap;</span><br><span class="line">    int i;</span><br><span class="line">    int nBytesPerLine;</span><br><span class="line"></span><br><span class="line">    strcpy(m_szTexName, pcszFileName);</span><br><span class="line">    <span class="keyword">if</span> (pBitmap-&gt;LoadBitmap(pcszFileName) == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    m_nWidth = pBitmap-&gt;GetWidth();</span><br><span class="line">    m_nHeight = pBitmap-&gt;GetHeight();</span><br><span class="line">    m_nBytesPerPixel = pBitmap-&gt;GetBytesPerPixel();</span><br><span class="line">    m_byData = (BYTE*)malloc(m_nWidth * m_nHeight * m_nBytesPerPixel);</span><br><span class="line">    <span class="keyword">if</span> (m_byData == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    nBytesPerLine = m_nWidth * m_nBytesPerPixel;</span><br><span class="line">    <span class="keyword">if</span> (pBitmap-&gt;GetBytesPerLine() == nBytesPerLine)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拷贝数据</span></span><br><span class="line">        memcpy(m_byData, pBitmap-&gt;GetBuffer(), m_nHeight * m_nWidth * m_nBytesPerPixel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//注意文件内部的bitmap数据已经对齐,但是opengl纹理的数据不能对其,所以必须一行行拷贝</span></span><br><span class="line">    &#123;   <span class="comment">//否则会出现纹理变形</span></span><br><span class="line">        for (i = 0; i &lt; m_nHeight; ++i)         &#123;           memcpy(m_byData + i * nBytesPerLine, pBitmap-&gt;GetBuffer()</span><br><span class="line">                + i * pBitmap-&gt;GetBytesPerLine(), nBytesPerLine);//拷贝数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete pBitmap;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CBitmapTex::InitTex()</span><br><span class="line">&#123;</span><br><span class="line">    int nFormat;</span><br><span class="line">    int nWidthPowerOfTwo = ::Pow2Big(m_nWidth);</span><br><span class="line">    int nHeightPowerOfTwo = ::Pow2Big(m_nHeight);</span><br><span class="line"></span><br><span class="line">    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</span><br><span class="line">    glGenTextures(1, m_uTexName);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_uTexName);</span><br><span class="line"></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_nBytesPerPixel == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nFormat = GL_BGR_EXT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_nBytesPerPixel == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nFormat = GL_BGRA_EXT;//bitmap内部数据是bgra格式,所以输入格式必须变化下</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nWidthPowerOfTwo == m_nWidth  nHeightPowerOfTwo == m_nHeight)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输出格式必须是GL_RGB,写成GL_BGR_EXT会出现空白</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, nWidthPowerOfTwo, nHeightPowerOfTwo,</span><br><span class="line">            0, nFormat, GL_UNSIGNED_BYTE, m_byData);</span><br><span class="line">        m_fTexScaleX = m_fTexScaleY = 1.0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, nWidthPowerOfTwo, nHeightPowerOfTwo,</span><br><span class="line">        0, nFormat, GL_UNSIGNED_BYTE, NULL);</span><br><span class="line">        glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_nWidth, m_nHeight,</span><br><span class="line">        nFormat, GL_UNSIGNED_BYTE, m_byData);</span><br><span class="line">        m_fTexScaleX = 1.0 * m_nWidth / nWidthPowerOfTwo;</span><br><span class="line">        m_fTexScaleY = 1.0 * m_nHeight / nHeightPowerOfTwo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CBitmapTex::SetTexture()</span><br><span class="line">&#123;</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, m_uTexName);</span><br><span class="line">    <span class="comment">//设置纹理堆栈</span></span><br><span class="line">    glMatrixMode(GL_TEXTURE);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glScaled(m_fTexScaleX, m_fTexScaleY, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到我的实现中使用了CxBitmap类，你可以从<a href="http://www.xpc-yx.com/2013/01/%E4%BD%8D%E5%9B%BE%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%B1%BBcxbitmap/" target="_blank" rel="noopener">这篇文章</a>中得到。还使用tool.h中的一个函数Pow2Big，该然后是返回一个刚好比输入参数大的2的次方大小，实现很简单。<br>该类只需要先调用LoadBitmapTex读入数据之后，再调用InitTex初始化opengl的一些纹理设置，最后需要使用哪个纹理，就用哪个纹理对象调用SetTexture函数就行了，非常方便。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL如何使用长宽非2次方的纹理</title>
      <link href="/2013/03/24/OpenGL%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%95%BF%E5%AE%BD%E9%9D%9E2%E6%AC%A1%E6%96%B9%E7%9A%84%E7%BA%B9%E7%90%86/"/>
      <url>/2013/03/24/OpenGL%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%95%BF%E5%AE%BD%E9%9D%9E2%E6%AC%A1%E6%96%B9%E7%9A%84%E7%BA%B9%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>也许在某些显卡上面，直接用glTexImage2D是可以使用非2次方纹理的。但是在我的机子上，直接用出现<strong>运行错误</strong>了。有没有办法让我们的程序<strong>同时支持2次方纹理和非二次方纹理了，并且我们还不需要改变纹理坐标</strong>了。<br>有，我们可以判断纹理的宽和高是不是都为2次方的。如果都是，那么直接使用就行了。如果不是，我们先用<strong>glTexImage2D申请2次方的纹理</strong>，然后用<strong>glTexSubImage2D</strong>把我们的数据放进去，再计算<strong>纹理坐标的变化因子</strong>，最后用glMatrixMode进入<strong>纹理堆栈</strong>操作，用<strong>glScaled</strong>设置坐标变化因子，这一切做完之后就可以按照非二次方纹理使用了。<br>下面提供部分代码，大致可以看出操作方法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_nBytesPerPixel == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    nFormat = GL_BGR_EXT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_nBytesPerPixel == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    nFormat = GL_BGRA_EXT;//bitmap内部数据是bgra格式,所以输入格式必须变化下</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nWidthPowerOfTwo == m_nWidth  nHeightPowerOfTwo == m_nHeight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//输出格式必须是GL_RGB,写成GL_BGR_EXT会出现空白</span></span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, nWidthPowerOfTwo, nHeightPowerOfTwo, </span><br><span class="line">        0, nFormat, GL_UNSIGNED_BYTE, m_byData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, nWidthPowerOfTwo, nHeightPowerOfTwo,</span><br><span class="line">    0, nFormat, GL_UNSIGNED_BYTE, NULL);</span><br><span class="line">    glTexSubImage2D(GL_TEXTURE_2D, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_nWidth, m_nHeight,</span><br><span class="line">    nFormat, GL_UNSIGNED_BYTE, m_byData);</span><br><span class="line">    fTexScaleX = 1.0 * m_nWidth / nWidthPowerOfTwo;</span><br><span class="line">    fTexScaleY = 1.0 * m_nHeight / nHeightPowerOfTwo;</span><br><span class="line">    <span class="comment">//设置纹理堆栈</span></span><br><span class="line">    glMatrixMode(GL_TEXTURE);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glScaled(fTexScaleX, fTexScaleY, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL渲染Obj模型(模型·材质·纹理)</title>
      <link href="/2013/03/08/OpenGL%E6%B8%B2%E6%9F%93Obj%E6%A8%A1%E5%9E%8B(%E6%A8%A1%E5%9E%8B%C2%B7%E6%9D%90%E8%B4%A8%C2%B7%E7%BA%B9%E7%90%86)/"/>
      <url>/2013/03/08/OpenGL%E6%B8%B2%E6%9F%93Obj%E6%A8%A1%E5%9E%8B(%E6%A8%A1%E5%9E%8B%C2%B7%E6%9D%90%E8%B4%A8%C2%B7%E7%BA%B9%E7%90%86)/</url>
      
        <content type="html"><![CDATA[<p>这是我寒假的一个作业吧，到最后基本是在学校完成的了。这个程序主要完成的功能是读取<strong>.obj文件</strong>，顺便读取了其附带<strong>.mtl文件</strong>，以及.mtl文件附带的<strong>.tga格式的纹理</strong>(我没有处理其它格式了，因为自己下载的几个模型的纹理都是这种图片格式)。然后，用透视投影，调整视点<strong>对准模型正中央</strong>，渲染在视口里面。程序也提供了键盘上下左右旋转，上下左右移动，放大放小的功能，已经鼠标旋转模型的功能，不过鼠标旋转的效果不好。</p><p>首先要介绍下obj模型文件的格式，这个百度或者google肯定能找到不少文章。.obj文件里面主要是定义了点，线，面，当然还描述了其他元素。.mtl文件里面定义了模型的材质以及纹理的路径。我主要描述下我的代码用到的和假定的obj文件格式。<br>v 1.0  2.3 4.5 //代表一个三维点<br>v 1.0  2.3 4.5 //代表一个三维点<br>v 1.0  2.3 4.5 //代表一个三维点<br>v 1.0  2.3 4.5 //代表一个三维点<br>vn 1.0 1.0 1.0 //法线<br>vt 0.3 0.4 //纹理坐标<br>p 1 //第一个v代表的点<br>l 1 2 //第一个v和第二个v连接的直线<br>f 1//  2//  3//  4//  //1,2,3,4构成的面，没有法线和纹理<br>f 1/1/1 2/1/1 3/1/1 4/1/1  //1,2,3,4构成的面,结构是顶点索引,纹理索引,法线索引<br>我的代码基本上假定没有法线和纹理索引的时候，<strong>后面也必须带//</strong>。<br>另外一个最重要的是定义材质库的路径，mtllib xxx.mtl。<br>至于obj文件更加详细的描述，请查阅更标准的文档吧。</p><p>然后，介绍下.mtl的格式，我也只介绍我用到的东西。<br>比如下面这个材质文件的内容，<br>newmtl Arakkoa_Gray //定义材质设置的名字，一个材质库可能会出现多个材质设置<br>d 1.0 //透明度<br>Kd 1.000000 1.000000 1.000000 //模型散射颜色<br>Ka 0.250000 0.250000 0.250000 //模型环境颜色<br>Ks 0.000000 0.000000 0.000000//模型镜面颜色<br>Ke 0.000000 0.000000 0.000000//模型发射颜色<br>Ns 0.000000//模型镜面指数<br>map_Kd Arakkoa_Gray.tga//纹理路径<br>其它设置我就没有用到了。<br>至于tga图片的格式，请自行google吧。我只处理了<strong>未压缩</strong>版本的.tga纹理，格式类似于.bmp文件，处理起来也比较简单。</p><p>以下是我渲染一个魔兽世界模型的效果，<br><img alt data-src="https://c3.staticflickr.com/8/7122/27174491730_279a2a593f_o.jpg"></p><p><img alt data-src="https://c4.staticflickr.com/8/7331/26843716883_1206d1f53e_o.jpg"></p><p>基本上<strong>启用光照加上纹理</strong>之后的渲染效果还行。下面我来讲述我整个代码的结构吧。</p><p>说实话，这个程序虽然功能不多，但是也可以写出不少代码来的，虽然没多少啰嗦代码，也有近千行。我也定义了不少结构体和类。如下图，<br><img alt data-src="https://c2.staticflickr.com/8/7554/27451030815_10517061ce_o.png"><br>S开头的是结构体，主要定义了顶点，法线，纹理的数据，以及三者的索引(SVertexData)，rgb，Tga文件头。其余的，比如CPoint，CLine，CFace对应obj文件里面的p,l,f元素，这三个类里面有<strong>各自的渲染函数</strong>。<br>CObj类最复杂，里面有顶点，法线，纹理坐标的数据集合，为了方便，我使用了vector，同时用<strong>reserve预留空间</strong>。还有，点集合，线集合，面集合，材质设置的集合。CObj的渲染函数则是调用点，线，面集合里面的元素对应的渲染函数。其中，最复杂的是面的渲染函数。面的渲染函数会根据材质设置是否改变来<strong>更换材质</strong>，然后再渲染每个面，同时每个面里面也有个vector集合包含顶点等的索引，所以我的程序<strong>不仅仅支持三角形面</strong>。CObj类里面最复杂的是读取.obj模型的函数，函数写了100多行，我也没进行功能拆分了，不细说了，至于读取材质的相对简单点。<br>CMaterial就描述了我使用的集中材质设置，包括一个CTgaTex类成员等。基本上是在读取的时候初始化下材质，更换材质的时候改变下。CTgaTex主要是读取未压缩的tga文件，并且用读取的数据初始化opengl的纹理设置，更改纹理设置的时候，CMaterial会调用其更改纹理。<br>CBox类也比较复杂，因为该类关系到透视投影，视点等。我是这样考虑的，我读取模型的时候，确定包括整个模型顶点的<strong>最小长方体</strong>，存储在CBox里面。然后，CBox会求出该长方体的<strong>外接球</strong>，我再把操作的对象改变成该外接球，也就是我的透视投影啊，观察点设置，平移，放缩，旋转什么的都针对该外接球了。所以啊，我对模型操作的函数全部放置在CBox类里面了。我的透视函数是调用的gluPerspective，<strong>近平面是球的前切面，远平面是球的后切面，我的观察点是球心，视点是正对球心离开其4-10倍半径距离的点</strong>。<br>至于其余全局函数的实现就不介绍了。</p><p>给出一些关键的类定义，看了这些类定义，就知道我的代码结构了。<br>//obj的定义</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> _XPC_YX_OBJ_H</span><br><span class="line"><span class="number">#def</span>ine _XPC_YX_OBJ_H</span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"vertex.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"mtl.h"</span></span><br><span class="line">#include</span><br><span class="line">using std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点元素</span></span><br><span class="line">class CPoint</span><br><span class="line">&#123;</span><br><span class="line">    friend class CObj;</span><br><span class="line">public:</span><br><span class="line">    void Render(CObj obj);//绘制点</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int m_nVI;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线元素</span></span><br><span class="line">class CLine</span><br><span class="line">&#123;</span><br><span class="line">    friend class CObj;</span><br><span class="line">public:</span><br><span class="line">    void Render(CObj obj);//绘制点</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector m_vis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面元素</span></span><br><span class="line">class CFace</span><br><span class="line">&#123;</span><br><span class="line">    friend class CObj;</span><br><span class="line">public:</span><br><span class="line">    CFace() &#123; m_nNewMtlI = -1; &#125;</span><br><span class="line">    void Render(CObj obj);//绘制面</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector m_vds;</span><br><span class="line">    int m_nNewMtlI;//所使用新的材质索引(如果不修改材质库此索引为-1)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CBox;</span><br><span class="line"><span class="comment">//obj模型</span></span><br><span class="line">class CObj</span><br><span class="line">&#123;</span><br><span class="line">    friend class CPoint;</span><br><span class="line">    friend class CLine;</span><br><span class="line">    friend class CFace;</span><br><span class="line"></span><br><span class="line">    enum &#123;VERTEX = 0, TEXTURE = 1, NORMAL = 2&#125;;</span><br><span class="line">public:</span><br><span class="line">    CObj(CBox* pBox) &#123; m_pBox = pBox; &#125;</span><br><span class="line">    CObj(const char* pcszFileName) &#123; LoadFromFile(pcszFileName); &#125;</span><br><span class="line">    int LoadFromFile(const char* pcszFileName);//从文件加载模型</span><br><span class="line">    int LoadMaterials(const char* pcszFileName);//加载材质库</span><br><span class="line">    void Render();//绘制该模型</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    static const int VERTEX_INIT_NUM;</span><br><span class="line">    static const int POINT_INIT_NUM;</span><br><span class="line">    static const int LINE_INIT_NUM;</span><br><span class="line">    static const int FACE_INIT_NUM;</span><br><span class="line">    vector m_vs;//顶点坐标集合</span><br><span class="line">    vector m_vts;//顶点纹理坐标集合</span><br><span class="line">    vector m_vns;//顶点法线集合</span><br><span class="line">    vector m_ps;//点集合</span><br><span class="line">    vector m_ls;//线集合</span><br><span class="line">    vector m_fs;//面集合</span><br><span class="line">    vector m_ms;//材质库</span><br><span class="line">    CBox* m_pBox;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>//CBox的定义</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class CBox</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        m_fXMin = m_fYMin = m_fZMin = INT_MAX;</span><br><span class="line">        m_fXMax = m_fYMax = m_fZMax = INT_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">    void InitBoxInfo();</span><br><span class="line">    void Adjust(SVertex v) &#123; Adjust(v.fX, v.fY, v.fZ); &#125;</span><br><span class="line">    void Adjust(double fX, double fY, double fZ);</span><br><span class="line">    void LookAtBox(int nW, int nH);</span><br><span class="line">    void Big(int nPercent);</span><br><span class="line">    void Small(int nPercent);</span><br><span class="line">    void Left(int nPercent);</span><br><span class="line">    void Right(int nPercent);</span><br><span class="line">    void Up(int nPercent);</span><br><span class="line">    void Down(int nPercent);</span><br><span class="line">    bool IsInBox(SVertex vertex);</span><br><span class="line">    void Move(SVertex one, SVertex two);//移动模型</span><br><span class="line">    void Rotate(SVertex one, SVertex two);//旋转模型</span><br><span class="line">    void RotateLeft(double fTheta);</span><br><span class="line">    void RotateRight(double fTheta);</span><br><span class="line">    void RotateUp(double fTheta);</span><br><span class="line">    void RotateDown(double fTheta);</span><br><span class="line">    void SetLight();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double m_fXMin;</span><br><span class="line">    double m_fXMax;</span><br><span class="line">    double m_fYMin;</span><br><span class="line">    double m_fYMax;</span><br><span class="line">    double m_fZMin;</span><br><span class="line">    double m_fZMax;</span><br><span class="line">    SVertex m_center;//模型原本的外接球中心</span><br><span class="line">    double m_fRadius;//外接球的半径</span><br><span class="line">    double m_fDistance;//观察点与外接球的距离</span><br><span class="line">    double m_fTheta;//视角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>//材质类的定义</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> _XPC_YX_MTL_H</span><br><span class="line"><span class="number">#def</span>ine _XPC_YX_MTL_H</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"tga.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">class CObj;</span><br><span class="line"></span><br><span class="line">struct SRgb</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">float</span> fR;</span><br><span class="line">    <span class="attribute">float</span> fG;</span><br><span class="line">    <span class="attribute">float</span> fB;</span><br><span class="line">    <span class="attribute">float</span> fA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CMaterial</span><br><span class="line">&#123;</span><br><span class="line">    friend class CObj;</span><br><span class="line">public:</span><br><span class="line">    CMaterial()</span><br><span class="line">    &#123;</span><br><span class="line">        m_emission.fR = m_emission.fG = m_emission.fB = 0.0;</span><br><span class="line">        m_fTrans = 1.0;</span><br><span class="line">    &#125;</span><br><span class="line">    void InitTex();</span><br><span class="line">    void Set();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    SRgb m_ambient;//材质的环境颜色</span><br><span class="line">    SRgb m_diffuse;//</span><br><span class="line">    SRgb m_specular;</span><br><span class="line">    SRgb m_emission;</span><br><span class="line">    <span class="attribute">float</span> m_fShiness;<span class="comment">//镜面指数</span></span><br><span class="line">    <span class="attribute">float</span> m_fTrans;<span class="comment">//透明度</span></span><br><span class="line">    char m_szName[MAX_PATH];</span><br><span class="line">    char m_szTextureName[MAX_PATH];</span><br><span class="line">    CTgaTex m_tgaTex;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>//tga纹理的定义</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> _XPC_YX_TGA_H</span><br><span class="line"><span class="number">#def</span>ine _XPC_YX_TGA_H</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine RGB16(r,g,b)   ( ((r&gt;&gt;<span class="number">3</span>) &lt;&lt; <span class="number">10</span>) + ((g&gt;&gt;<span class="number">3</span>) &lt;&lt; <span class="number">5</span>) + (<span class="selector-tag">b</span> &gt;&gt; <span class="number">3</span>) )</span><br><span class="line"><span class="number">#def</span>ine RGB24(r,g,b)   ( ((r) &lt;&lt; <span class="number">16</span>) + ((g) &lt;&lt; <span class="number">8</span>) + (b) )</span><br><span class="line"></span><br><span class="line">typedef unsigned char BYTE;</span><br><span class="line"><span class="comment">//tga文件头</span></span><br><span class="line">struct STgaHeader</span><br><span class="line">&#123;</span><br><span class="line">    BYTE  byImageInfoByteCnt;    //The image information length, in byte</span><br><span class="line">    BYTE  byColorTableExist;       //0-have not color table,1-have</span><br><span class="line">    BYTE  byImageType;              //Image type,2-uncompare RGB image,10-compare RGB image</span><br><span class="line">    BYTE  byColorTableInfo[5];    //Color table information</span><br><span class="line">    unsigned short uXOrigin;</span><br><span class="line">    unsigned short uYOrigin;</span><br><span class="line">    unsigned short uWidth;</span><br><span class="line">    unsigned short uHeight;</span><br><span class="line">    unsigned char  chBitsPerPixel;  //每像素的字节数</span><br><span class="line">    unsigned char  chImageDescriptor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CTgaTex</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CTgaTex() &#123; byData = 0; m_szTexName[0] = 0; &#125;</span><br><span class="line">    CTgaTex(const char* pcszFileName) &#123; byData = 0; LoadTga(pcszFileName); &#125;</span><br><span class="line">    ~CTgaTex() &#123; if (byData) free(byData); &#125;</span><br><span class="line">    int LoadTga(const char* pcszFileName);</span><br><span class="line">    void InitTex();</span><br><span class="line">    void SetTexture();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    STgaHeader m_header;</span><br><span class="line">    BYTE* byData;</span><br><span class="line">    char m_szTexName[MAX_PATH];</span><br><span class="line">    unsigned m_uTexName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>如果你需要完整的代码，可以留言或者给我发邮件，代码写得不怎么样，不过还是尽力写好一点的了。里面肯定会有让老手觉得不规范的地方的。</p><p>由于很多人留言询问代码，为了方便，已上传百度网盘，分享地址：<a href="http://pan.baidu.com/s/1eQJ9mF4" target="_blank" rel="noopener" title="渲染obj模型">http://pan.baidu.com/s/1eQJ9mF4</a> 密码：ovnv</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纹理 </tag>
            
            <tag> 三维模型处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用OpenGL3.1及其以上版本</title>
      <link href="/2013/01/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8OpenGL3.1%E5%8F%8A%E5%85%B6%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC/"/>
      <url>/2013/01/09/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8OpenGL3.1%E5%8F%8A%E5%85%B6%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>刚开始学习图形学的时候，就看的是计算机图形学opengl版。那么，我当然也想下载最新版本的sdk。但是发现，官网上只有3.1及其以上版本的文档，无论我怎么找，都找不到相应的sdk。后面，我好像是在pudn上面找到了3.0版本的sdk。将就着用了吧，一直到今天我在看OpenGL编程指南第七版的时候，发现无法使用函数glGenBuffers。好吧，没办法，我只能去找更新版本的sdk。</p><p>还是找来找去，发现什么都找不到，但是发现opengl的扩展库倒是不少。比如，glew和glextension之类的。后面发现csdn上有篇博文说，opengl3.1及其之后的版本官方都不提供实现了，所以就找不到那些sdk。有个方法是glew，那么就用它吧。</p><p>使用glew也不是那么简单的事情，首先得下载glew，我下载了的是1.9的版本。即使配置成功了，也不一定说就能使用成功了。因为还必须初始化glew，<strong>最坑爹的是这个初始化必须在你创建窗口之后，否则一定会失败</strong>。</p><p>下面给出使用glew的示例代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"windows.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;glew.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;glut.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"><span class="selector-id">#pragma</span> comment(lib , <span class="string">"glew32.lib"</span>)</span><br><span class="line"></span><br><span class="line">const GLint WINDOW_WIDTH = 600;</span><br><span class="line">const GLint WINDOW_HEIGHT = 450;</span><br><span class="line">const GLint WINDOW_POS_X = 100;</span><br><span class="line">const GLint WINDOW_POS_Y = 100;</span><br><span class="line">const char* cszWindowTitile = "primrestart";</span><br><span class="line"></span><br><span class="line">void Display()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    glColor3f(1.0, 1.0, 1.0);</span><br><span class="line">    glRectf(0.0, 0.0, 100.0, 100.0);</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Reshape(int nW, int nH)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(0, 0, nW, nH);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0, nW, 0, nH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow(cszWindowTitile);</span><br><span class="line">    int nRet = glewInit();</span><br><span class="line">    <span class="keyword">if</span> (nRet != GLEW_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox(NULL, "glew初始化失败", "Error", MB_ICONERROR);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    Init();</span><br><span class="line">    glutDisplayFunc(Display);</span><br><span class="line">    glutReshapeFunc(Reshape);</span><br><span class="line">    glutMainLoop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该代码中可以看到，glew.h之前不能包含gl.h，否则编译不过，还有链接上glew.lib，另外最恶心的就是glewInit的正确位置，一定要在创建了窗口（函数调用glutCreateWindow)之后，否则glewInit一定会失败的，glewInit失败了的话，再使用3.1及其以上版本的函数就会出现内存错误了。</p><p>最后做下贡献，附录下我的opengl sdk，<a href="https://pan.baidu.com/s/1bS3dV4" target="_blank" rel="noopener">opengl3.0+glew1.9+一点文档</a>，基本上可以满足要求了。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> Glew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位图数字图像处理类CxBitmap</title>
      <link href="/2013/01/03/%E4%BD%8D%E5%9B%BE%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%B1%BBCxBitmap/"/>
      <url>/2013/01/03/%E4%BD%8D%E5%9B%BE%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%B1%BBCxBitmap/</url>
      
        <content type="html"><![CDATA[<p>这是我在做数字图像处理实验中实现的一个类。该类包含了很多丰富的功能。虽然写得不是太规范，不过我还是尽我的能力让它规范起来。尽可能的便于使用，也尽可能的效率高些，尽可能得增加应用场合。自认为用这个类处理位图基本上足够了。<br>该类虽说不能处理所有格式的位图，因为时间有限，没有去实现了。但是，基本上8位和24位位图能够完美处理，其它格式的会出错，因为压根没有考虑。那么，现在我来介绍下该类的功能吧。<br>首先，<strong>从文件加载位图，获取位图所有信息和数据。彩色位图灰度化(24位和8位的都可以，24位位图灰度化后会变成8位），使用内部函数计算全局阈值再二值化或者用给定阈值二值化，均值滤波，中值滤波，拉普拉斯滤波，四个方向的梯度滤波，log变换图像，exp变换图像，hough变换检测最明显的一条直线，得到像素分布统计数组，将图片直方图绘制到指定dc和矩形框内部，绘制位图到DC指定位置，拉伸绘制位图到DC指定位置，保存当前状态的图片(也就是你可以将滤波或者任何变换后的图片再保存到文件)，输出图像数据到指定文件，创建位图头部，设置位图数据等</strong>。功能还是非常丰富的，基本上可以满足很多要求，代码都经常我的认真调试，代码实现上也注意了性能和使用场合。<br>任意你对代码不满意的部分或者使用出现问题都可以email我，或者自己直接修改。我就不打算再增强它的功能或者优化其实现或者把它改得更规范点了。</p><p>类定义如下，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#ifndef</span> GRAY_BITMAP_H</span><br><span class="line"><span class="number">#def</span>ine GRAY_BITMAP_H</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine BITMAP_ID <span class="number">0</span>x4D42 <span class="comment">// universal id for a bitmap</span></span><br><span class="line"><span class="number">#def</span>ine MAX_COLORS_PALETTE <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifndef</span> SAFE_DELETE</span><br><span class="line">#define SAFE_DELETE(p) &#123; if (p) &#123; delete p; p = NULL; &#125; &#125;</span><br><span class="line">#endif</span><br><span class="line"><span class="selector-id">#ifndef</span> SAFE_DELETE_ARRAY</span><br><span class="line">#define SAFE_DELETE_ARRAY(p) &#123; if (p) &#123; delete [] p; p = NULL; &#125; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine NEIGHBOUR_SIZE (<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// this builds a 24 bit color value in 8.8.8 format </span></span><br><span class="line"><span class="number">#def</span>ine RGB24BIT(r,g,b) ((b) + ((g) &lt;&lt; <span class="number">8</span>) + ((r) &lt;&lt; <span class="number">16</span>) )</span><br><span class="line"></span><br><span class="line">class CxBitmap</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以下是操作位图的一些函数</span></span><br><span class="line">public:</span><br><span class="line">    CxBitmap();</span><br><span class="line">    ~CxBitmap();</span><br><span class="line">    int CreateBitmap(int nWidth, int nHeight, UINT nBitcount, const void* pvBits);</span><br><span class="line">    int LoadBitmap(const char* pszFileName = NULL);</span><br><span class="line">    void Draw(HDC hdc, int nStartX, int nStartY);</span><br><span class="line">    void StretchDraw(HDC hDc, int nStartX, int nStartY, int nWidth, int nHeight);</span><br><span class="line">    void DrawHistogram(HDC hDc, const RECT rect);</span><br><span class="line">    BOOL IsAvailable() &#123; return m_bLoad; &#125;</span><br><span class="line">    void SaveFile(char* pszBitmapName);</span><br><span class="line">    void WriteBuffer(char* pszFileName);</span><br><span class="line">int WriteMeshObj(const char* pcszObjFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是获取和设置位图的属性的一些函数</span></span><br><span class="line">public:</span><br><span class="line">    int GetWidth() const &#123; return bitmapinfoheader.biWidth; &#125;</span><br><span class="line">    int GetHeight() const &#123; return bitmapinfoheader.biHeight; &#125;</span><br><span class="line">    int GetBytesPerPixel() const &#123; return bitmapinfoheader.biBitCount / 8; &#125;</span><br><span class="line">    int GetBytesPerLine() const &#123; return m_nBytesPerLine; &#125;</span><br><span class="line">    BYTE* GetBuffer() const &#123; return pbyBuffer; &#125;</span><br><span class="line">BYTE* GetUnAlignBuffer() const &#123; return pbyUnAlignBuffer; &#125;</span><br><span class="line">    int GetImageSize() const &#123; return bitmapinfoheader.biSizeImage; &#125;</span><br><span class="line">    void SetBitmapName(char* pszBitmapName) &#123; strcpy(m_szBitmapName, pszBitmapName); &#125;</span><br><span class="line">    void SetBuffer(const void* pvBuffer)</span><br><span class="line">    &#123; </span><br><span class="line">        m_bReadOnly = TRUE;</span><br><span class="line">        m_bLoad = TRUE;</span><br><span class="line">        pbyBuffer = (BYTE*)pvBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL IsReadOnly() const &#123; return m_bReadOnly; &#125;</span><br><span class="line">    BOOL SetReadOnly(BOOL bReadOnly) &#123; return m_bReadOnly = bReadOnly; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是图像处理的一些函数</span></span><br><span class="line">public:</span><br><span class="line">    void ColorToGray();//把彩色图像转换为灰度图像</span><br><span class="line">    int* GetHistogram();//得到直方图统计数组(不同灰度值的像素数目)</span><br><span class="line">    int GrayToBinary(int nThreshold);</span><br><span class="line">    int GrayToBinary();</span><br><span class="line">    void MedianFilter();//中值滤波图像</span><br><span class="line">    void AverageFilter();//均值滤波</span><br><span class="line">    void LaplaceFilter();//拉普拉斯滤波</span><br><span class="line">    void GradientFilterLeft();//梯度滤波</span><br><span class="line">    void GradientFilterRight();</span><br><span class="line">    void GradientFilterUp();</span><br><span class="line">    void GradientFilterDown();</span><br><span class="line">    void LogTransfer();//对图像进行对数变换</span><br><span class="line">    void ExpTransfer();</span><br><span class="line">    void GaussFilter(int nRadius = 1);</span><br><span class="line">    <span class="comment">//用Hough变换检测二值化后图像中的一条直线(R = x*cos(theta) + y*sin(theta),theta是弧度)</span></span><br><span class="line">    void HoughLine(int* pnR, double* pfTheta);</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部用到的一些私有函数</span></span><br><span class="line">private:</span><br><span class="line">    void FlipBuffer();</span><br><span class="line">    void FreeBitmap();</span><br><span class="line">    int GetMedian(int* pnArr, int nSize);</span><br><span class="line">    void Filter(double* pfFactors, int nSize, BOOL bAve);</span><br><span class="line">    int GetThreshold(int* pnHistogram);</span><br><span class="line">    void InitPalette();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char m_szBitmapName[MAX_PATH];</span><br><span class="line">    BITMAPFILEHEADER bitmapfileheader;  // this contains the bitmapfile header</span><br><span class="line">    BITMAPINFOHEADER bitmapinfoheader;  // this is all the info including the palette</span><br><span class="line">    RGBQUAD palette[256];               // we will store the palette here</span><br><span class="line">    BOOL m_bReadOnly;</span><br><span class="line">    BYTE* pbyBuffer;</span><br><span class="line">BYTE* pbyUnAlignBuffer;</span><br><span class="line">    BYTE* pbyTmpBuffer;  //临时内存缓冲，用于滤波</span><br><span class="line">    BOOL m_bHistogram;    //是否已经获得直方图数组了</span><br><span class="line">    int* m_pnHistogram;</span><br><span class="line">    BOOL m_bLoad;     //是否已经加载图片了</span><br><span class="line">    BOOL m_bScale;    //是否已经灰度化了</span><br><span class="line">    BOOL m_bBinary;</span><br><span class="line">    int m_nBytesPerLine;</span><br><span class="line">    int m_nBytesPerPixel;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>类实现如下，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> <span class="string">"CxBitmap.h"</span></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;assert.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">CxBitmap::CxBitmap() </span><br><span class="line">&#123; </span><br><span class="line">    m_bLoad = FALSE;</span><br><span class="line">    pbyBuffer = NULL;</span><br><span class="line">    pbyTmpBuffer = NULL;</span><br><span class="line">    m_bHistogram = FALSE;</span><br><span class="line">    m_pnHistogram = NULL; </span><br><span class="line">    m_bReadOnly = FALSE;</span><br><span class="line">    m_bBinary = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CxBitmap::~CxBitmap()</span><br><span class="line">&#123;</span><br><span class="line">    FreeBitmap();</span><br><span class="line">    SAFE_DELETE(m_pnHistogram);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::FreeBitmap()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果是调用SetBuffer得到的图片,则不需要释放内存,否则会造成内存错误</span></span><br><span class="line">    if (m_bReadOnly == FALSE) SAFE_DELETE_ARRAY(pbyBuffer);</span><br><span class="line">    SAFE_DELETE_ARRAY(pbyTmpBuffer);</span><br><span class="line">    m_bLoad = FALSE;</span><br><span class="line">    m_bHistogram = FALSE;</span><br><span class="line">    m_bScale = FALSE;</span><br><span class="line">    m_bBinary = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::InitPalette()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; MAX_COLORS_PALETTE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        palette[i].rgbBlue = palette[i].rgbGreen = palette[i].rgbRed = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CxBitmap::CreateBitmap(int nWidth, int nHeight, UINT nBitcount, const void* pvBits)</span><br><span class="line">&#123;</span><br><span class="line">    FreeBitmap();</span><br><span class="line">    m_nBytesPerPixel = nBitcount / 8;</span><br><span class="line">    m_nBytesPerLine = (nWidth * nBitcount + 31) / 32 * 4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置bitmapfileheader</span></span><br><span class="line">    bitmapfileheader.bfType = BITMAP_ID;</span><br><span class="line">    bitmapfileheader.bfReserved1 = bitmapfileheader.bfReserved2 = 0;</span><br><span class="line">    bitmapfileheader.bfOffBits = sizeof(bitmapfileheader) + sizeof(bitmapinfoheader);</span><br><span class="line">    <span class="keyword">if</span> (nBitcount == <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bitmapfileheader.bfOffBits += sizeof(palette);</span><br><span class="line">        InitPalette();</span><br><span class="line">    &#125;</span><br><span class="line">    bitmapfileheader.bfSize = bitmapfileheader.bfOffBits + m_nBytesPerLine * nHeight;</span><br><span class="line">    <span class="comment">//设置bitmapinfoheader</span></span><br><span class="line">    bitmapinfoheader.biSize = sizeof(bitmapinfoheader);</span><br><span class="line">    bitmapinfoheader.biWidth = nWidth;</span><br><span class="line">    bitmapinfoheader.biHeight = nHeight;</span><br><span class="line">    bitmapinfoheader.biPlanes = 1;</span><br><span class="line">    bitmapinfoheader.biBitCount = nBitcount;</span><br><span class="line">    bitmapinfoheader.biCompression = BI_RGB;</span><br><span class="line">    bitmapinfoheader.biSizeImage = m_nBytesPerLine * nHeight;</span><br><span class="line">    bitmapinfoheader.biXPelsPerMeter = bitmapinfoheader.biYPelsPerMeter = 0;</span><br><span class="line">    bitmapinfoheader.biClrUsed = 0;</span><br><span class="line">    <span class="keyword">if</span> (nBitcount == <span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bitmapinfoheader.biClrUsed = 256;</span><br><span class="line">    &#125;</span><br><span class="line">    bitmapinfoheader.biClrImportant = 0;</span><br><span class="line">    SetBuffer(pvBits);</span><br><span class="line">    pbyTmpBuffer = new BYTE[bitmapinfoheader.biSizeImage];</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::FlipBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    int nLenOfLine = (bitmapinfoheader.biWidth * bitmapinfoheader.biBitCount) / 8;</span><br><span class="line">    BYTE* pbyTemp = new BYTE[nLenOfLine];</span><br><span class="line">    int nEnd = bitmapinfoheader.biHeight / 2 - 1;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= nEnd; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        memcpy(pbyTemp, pbyBuffer + i * nLenOfLine, nLenOfLine);</span><br><span class="line">        memcpy(pbyBuffer + i * nLenOfLine, pbyBuffer + (bitmapinfoheader.biWidth - i - 1)</span><br><span class="line">            * nLenOfLine, nLenOfLine);</span><br><span class="line">        memcpy(pbyBuffer + (bitmapinfoheader.biWidth - i - 1) * nLenOfLine, pbyTemp, nLenOfLine);</span><br><span class="line">    &#125;</span><br><span class="line">    delete [] pbyTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CxBitmap::LoadBitmap(const char* pszFileName)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int nUnAlignBytesPerLine;</span><br><span class="line"></span><br><span class="line">    FreeBitmap();</span><br><span class="line"><span class="keyword">if</span> (pszFileName != NULL)</span><br><span class="line">&#123;</span><br><span class="line">strcpy(m_szBitmapName, pszFileName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    FILE* fpBitmap = fopen(m_szBitmapName, "rb");</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fpBitmap == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nSizeOfHeader = sizeof(bitmapfileheader);</span><br><span class="line">    <span class="keyword">if</span> (nSizeOfHeader != <span class="number">14</span>)<span class="comment">//字节对齐可能会导致其变成16</span></span><br><span class="line">    &#123;</span><br><span class="line">        nSizeOfHeader = 14;</span><br><span class="line">    &#125;</span><br><span class="line">    fread(bitmapfileheader, nSizeOfHeader, 1, fpBitmap);</span><br><span class="line">    <span class="keyword">if</span> (bitmapfileheader<span class="selector-class">.bfType</span> != BITMAP_ID)<span class="comment">//检测是否是位图</span></span><br><span class="line">    &#123;</span><br><span class="line">        fclose(fpBitmap);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    fread(bitmapinfoheader, sizeof(bitmapinfoheader), 1, fpBitmap);</span><br><span class="line">    <span class="keyword">if</span> (bitmapinfoheader<span class="selector-class">.biBitCount</span> == <span class="number">8</span>)<span class="comment">//8位位图,那么需要读取调色板</span></span><br><span class="line">    &#123;</span><br><span class="line">        fread(palette, sizeof(PALETTEENTRY) * MAX_COLORS_PALETTE, 1, fpBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bitmapinfoheader<span class="selector-class">.biSizeImage</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bitmapinfoheader.biSizeImage = bitmapinfoheader.biWidth * bitmapinfoheader.biHeight</span><br><span class="line">            * bitmapinfoheader.biBitCount / 8;</span><br><span class="line">    &#125;</span><br><span class="line">    pbyBuffer = new BYTE[bitmapinfoheader.biSizeImage];</span><br><span class="line">    <span class="keyword">if</span> (pbyBuffer == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    fread(pbyBuffer, bitmapinfoheader.biSizeImage, 1, fpBitmap);</span><br><span class="line">    <span class="keyword">if</span> (bitmapinfoheader<span class="selector-class">.biHeight</span> &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bitmapinfoheader.biHeight = -bitmapinfoheader.biHeight;</span><br><span class="line">        FlipBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fpBitmap);</span><br><span class="line"></span><br><span class="line">    m_nBytesPerLine = (bitmapinfoheader.biWidth * bitmapinfoheader.biBitCount + 31) / 32 * 4;</span><br><span class="line">    m_nBytesPerPixel = bitmapinfoheader.biBitCount / 8;</span><br><span class="line">pbyUnAlignBuffer = pbyBuffer;</span><br><span class="line">nUnAlignBytesPerLine = bitmapinfoheader.biWidth * m_nBytesPerPixel;</span><br><span class="line"><span class="keyword">if</span> (m_nBytesPerLine != nUnAlignBytesPerLine)</span><br><span class="line">&#123;</span><br><span class="line">pbyUnAlignBuffer = new BYTE[nUnAlignBytesPerLine * bitmapinfoheader.biHeight];</span><br><span class="line">for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">&#123;</span><br><span class="line">memcpy(pbyUnAlignBuffer + i * nUnAlignBytesPerLine, pbyBuffer</span><br><span class="line">+ i * m_nBytesPerLine, nUnAlignBytesPerLine);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    m_bLoad = TRUE;</span><br><span class="line">    pbyTmpBuffer = new BYTE[bitmapinfoheader.biSizeImage];</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Y=0.3R+0.59G+0.11B</span></span><br><span class="line"><span class="comment">//该函数仅简单地处理24位和8位位图</span></span><br><span class="line">void CxBitmap::ColorToGray()</span><br><span class="line">&#123;</span><br><span class="line">    int nGray = 0;</span><br><span class="line">    int nRead = 0, nWrite = 0;</span><br><span class="line">    int i, j;</span><br><span class="line">    int nBytesWriteLine = (bitmapinfoheader.biWidth * 8 + 31) / 32 * 4;//灰度后每个像素只有8bits</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_bLoad  m_bScale == FALSE)<span class="comment">//如果已经加载了图片并且没有进行灰度化处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmapinfoheader<span class="selector-class">.biBitCount</span> == <span class="number">24</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bitmapfileheader.bfOffBits += sizeof(palette);</span><br><span class="line">            bitmapinfoheader.biBitCount = 8;</span><br><span class="line">            bitmapinfoheader.biClrUsed = 256;</span><br><span class="line">            bitmapinfoheader.biSizeImage = nBytesWriteLine *  bitmapinfoheader.biHeight;</span><br><span class="line">            bitmapfileheader.bfSize = bitmapfileheader.bfOffBits + bitmapinfoheader.biSizeImage;</span><br><span class="line">            InitPalette();</span><br><span class="line"></span><br><span class="line">            for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                nRead = i * m_nBytesPerLine;</span><br><span class="line">                nWrite = i * nBytesWriteLine;</span><br><span class="line">                for (j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    nGray = 11 * pbyBuffer[nRead++];</span><br><span class="line">                    nGray += 59 * pbyBuffer[nRead++];</span><br><span class="line">                    nGray += 30 * pbyBuffer[nRead++];</span><br><span class="line">                    nGray /= 100;</span><br><span class="line">                    pbyTmpBuffer[nWrite++] = nGray;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m_nBytesPerLine = nBytesWriteLine;</span><br><span class="line">            m_nBytesPerPixel = 1;</span><br><span class="line">            memcpy(pbyBuffer, pbyTmpBuffer, bitmapinfoheader.biSizeImage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bitmapinfoheader<span class="selector-class">.biBitCount</span> == <span class="number">8</span>)<span class="comment">//灰度化调色板</span></span><br><span class="line">        &#123;</span><br><span class="line">            for (i = 0; i &lt; MAX_COLORS_PALETTE; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                nGray = 11 * palette[i].rgbBlue;</span><br><span class="line">                nGray += 59 * palette[i].rgbGreen;</span><br><span class="line">                nGray += 30 * palette[i].rgbRed;</span><br><span class="line">                nGray /= 100;</span><br><span class="line">                palette[i].rgbBlue = palette[i].rgbGreen = palette[i].rgbRed = nGray;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_bScale = TRUE;</span><br><span class="line">        m_bHistogram = FALSE;//需要重新计算直方图数组</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int* CxBitmap::GetHistogram()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_bScale == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        ColorToGray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_bHistogram)</span><br><span class="line">    &#123;</span><br><span class="line">        return m_pnHistogram;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_pnHistogram == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pnHistogram = new int[MAX_COLORS_PALETTE];</span><br><span class="line">        memset(m_pnHistogram, 0, sizeof(int) * MAX_COLORS_PALETTE);</span><br><span class="line">        <span class="keyword">if</span> (m_pnHistogram == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nRead = 0;</span><br><span class="line">    int i, j;</span><br><span class="line">    int nAdd = bitmapinfoheader.biBitCount / 8;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine;</span><br><span class="line">        for (j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pnHistogram[pbyBuffer[nRead]]++;</span><br><span class="line">            nRead += nAdd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_bHistogram = TRUE;</span><br><span class="line"></span><br><span class="line">    return m_pnHistogram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::DrawHistogram(HDC hDc, const RECT rect)</span><br><span class="line">&#123;</span><br><span class="line">    double fPosX = rect.<span class="attribute">left</span>;</span><br><span class="line">    double fPosY = rect.<span class="attribute">top</span>;</span><br><span class="line">    int nWidth = rect<span class="selector-class">.right</span> - rect.<span class="attribute">left</span>;</span><br><span class="line">    int nHeight = rect<span class="selector-class">.bottom</span> - rect.<span class="attribute">top</span>;</span><br><span class="line">    int nBegX = nWidth * 0.05;</span><br><span class="line">    int nEndY = nHeight * 0.95;</span><br><span class="line">    double fWidth = 1.0 * (nWidth - nBegX) / MAX_COLORS_PALETTE;</span><br><span class="line">    const int NUM = 100;</span><br><span class="line">    const double ADD = 10 * (1.0 * nHeight) / NUM;</span><br><span class="line">    char szGrade[MAX_PATH];</span><br><span class="line">    int nTmp;</span><br><span class="line">    int i;</span><br><span class="line">    int nMaxCnt = 0;</span><br><span class="line">    int nAddScore = 10;</span><br><span class="line">    int nAddScale = 16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetHistogram() == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetTextAlign(hDc, TA_LEFT);</span><br><span class="line">    SetBkMode(hDc, TRANSPARENT);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; NUM; i += nAddScore)</span><br><span class="line">    &#123;</span><br><span class="line">        sprintf(szGrade, "%d", NUM - i);</span><br><span class="line">        TextOut(hDc, (int)fPosX, (int)fPosY, szGrade, strlen(szGrade));</span><br><span class="line">        fPosY += ADD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fPosX = nBegX;</span><br><span class="line">    for (i = 0; i &lt; MAX_COLORS_PALETTE; i += nAddScale)</span><br><span class="line">    &#123;</span><br><span class="line">        sprintf(szGrade, "%d", i);</span><br><span class="line">        TextOut(hDc, (int)fPosX, nEndY, szGrade, strlen(szGrade));</span><br><span class="line">        fPosX += fWidth * nAddScale;</span><br><span class="line">    &#125;</span><br><span class="line">    sprintf(szGrade, "%d", MAX_COLORS_PALETTE - 1);</span><br><span class="line">    TextOut(hDc, (int)fPosX, nHeight, szGrade, strlen(szGrade));</span><br><span class="line"></span><br><span class="line">    HBRUSH hOldBrush = (HBRUSH)SelectObject(hDc, GetStockObject(BLACK_BRUSH));</span><br><span class="line">    HPEN hOldPen = (HPEN)SelectObject(hDc, GetStockObject(BLACK_PEN));</span><br><span class="line">    fPosX = rect.left + nBegX;</span><br><span class="line">    fPosY = rect.<span class="attribute">top</span>;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; MAX_COLORS_PALETTE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pnHistogram[i] &gt; nMaxCnt)</span><br><span class="line">        &#123;</span><br><span class="line">            nMaxCnt = m_pnHistogram[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; MAX_COLORS_PALETTE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nTmp = nHeight * m_pnHistogram[i] / nMaxCnt;</span><br><span class="line">        Rectangle(hDc, (int)fPosX, (int)(fPosY + nEndY - nTmp),</span><br><span class="line">            (int)(fPosX + fWidth), (int)(fPosY + nEndY));</span><br><span class="line">        fPosX += fWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    SelectObject(hDc, hOldBrush);</span><br><span class="line">    SelectObject(hDc, hOldPen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CxBitmap::GetThreshold(int* pnHistogram)</span><br><span class="line">&#123;</span><br><span class="line">    double fU0, fU1;</span><br><span class="line">    double fW0, fW1;</span><br><span class="line">    int nCount;</span><br><span class="line">    int nT, nMaxT;</span><br><span class="line">    double fDevi, fMaxDevi = 0; //方差及最大方差</span><br><span class="line">    int i;</span><br><span class="line">    int nSum = 0;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; MAX_COLORS_PALETTE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nSum += pnHistogram[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (nT = 0; nT &lt; MAX_COLORS_PALETTE; nT++)</span><br><span class="line">    &#123;</span><br><span class="line">        fU0 = 0;</span><br><span class="line">        nCount = 0;</span><br><span class="line">        <span class="comment">//阈值为t时，c0组的均值及产生的概率</span></span><br><span class="line">        for (i = 0; i &lt;= nT; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fU0 += i * pnHistogram[i];</span><br><span class="line">            nCount += pnHistogram[i];</span><br><span class="line">        &#125;</span><br><span class="line">        fU0 /= nCount;</span><br><span class="line">        fW0 = 1.0 * nCount / nSum;</span><br><span class="line">        <span class="comment">//阈值为t时，c1组的均值及产生的概率</span></span><br><span class="line">        fU1 = 0;</span><br><span class="line">        for (i = nT + 1; i &lt; MAX_COLORS_PALETTE; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fU1 += i * pnHistogram[i];</span><br><span class="line">        &#125;</span><br><span class="line">        fU1 /= nSum - nCount;</span><br><span class="line">        fW1 = 1 - fW0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两类间方差</span></span><br><span class="line">        fDevi = fW0 * fW1 * (fU1 - fU0) * (fU1 - fU0);</span><br><span class="line">        <span class="comment">//记录最大的方差及最佳位置</span></span><br><span class="line">        <span class="keyword">if</span> (fDevi &gt; fMaxDevi)</span><br><span class="line">        &#123;</span><br><span class="line">            fMaxDevi = fDevi;</span><br><span class="line">            nMaxT = nT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nMaxT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CxBitmap::GrayToBinary()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(GetHistogram())</span><br><span class="line">    &#123;</span><br><span class="line">        return GrayToBinary(GetThreshold(m_pnHistogram));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二值化</span></span><br><span class="line">int CxBitmap::GrayToBinary(int nThreshold)</span><br><span class="line">&#123;</span><br><span class="line">    int nRead = 0;</span><br><span class="line"></span><br><span class="line">    if (!m_bLoad || !m_bScale)</span><br><span class="line">    &#123;</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmapinfoheader<span class="selector-class">.biBitCount</span> == <span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ColorToGray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine;</span><br><span class="line">        for (int j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pbyBuffer[nRead] &gt;= nThreshold)</span><br><span class="line">            &#123;</span><br><span class="line">                pbyBuffer[nRead] = 255;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                 pbyBuffer[nRead] = 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i == 0 || i == bitmapinfoheader.biHeight - 1</span><br><span class="line">                || j == 0 || j == bitmapinfoheader.biWidth - 1)</span><br><span class="line">            &#123;</span><br><span class="line">                pbyBuffer[nRead] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            nRead++;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    m_bBinary = TRUE;</span><br><span class="line"></span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::Draw(HDC hDc, int nStartX, int nStartY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        StretchDIBits(hDc, nStartX, nStartY, bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">            bitmapinfoheader<span class="selector-class">.biHeight</span>, <span class="number">0</span>, <span class="number">0</span>, bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">            bitmapinfoheader<span class="selector-class">.biHeight</span>, pbyBuffer, (BITMAPINFO*)bitmapinfoheader,</span><br><span class="line">            DIB_RGB_COLORS, SRCCOPY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::StretchDraw(HDC hDc, int nStartX, int nStartY, int nWidth, int nHeight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        StretchDIBits(hDc, nStartX, nStartY, nWidth, nHeight, <span class="number">0</span>, <span class="number">0</span>, bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">            bitmapinfoheader<span class="selector-class">.biHeight</span>, pbyBuffer, (BITMAPINFO*)bitmapinfoheader,</span><br><span class="line">            DIB_RGB_COLORS, SRCCOPY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::WriteBuffer(char* pszFileName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        FILE* fpWrite = fopen(pszFileName, "w");</span><br><span class="line">        int nRead = 0;</span><br><span class="line">        for (int i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nRead = i * m_nBytesPerLine;</span><br><span class="line">            for (int j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int k = 0; k &lt; m_nBytesPerPixel; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    fprintf(fpWrite, "%d ", pbyBuffer[nRead]);</span><br><span class="line">                    ++nRead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fprintf(fpWrite, "\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::SaveFile(char* pszBitmapName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        FILE* fpSave = fopen(pszBitmapName, "wb");</span><br><span class="line">        fwrite(bitmapfileheader, sizeof(bitmapfileheader), 1, fpSave);</span><br><span class="line">        fwrite(bitmapinfoheader, sizeof(bitmapinfoheader), 1, fpSave);</span><br><span class="line">        <span class="keyword">if</span> (bitmapinfoheader<span class="selector-class">.biBitCount</span> == <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fwrite(palette, sizeof(palette), 1, fpSave);</span><br><span class="line">        &#125;</span><br><span class="line">        fwrite(pbyBuffer, bitmapinfoheader.biSizeImage, 1, fpSave);</span><br><span class="line">        fclose(fpSave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int CxBitmap::GetMedian(int* pnArr, int nSize)</span><br><span class="line">&#123;</span><br><span class="line">    int nTime = nSize / 2 + 1;</span><br><span class="line">    int nTemp = 0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面进行nTime + 1次冒泡排序</span></span><br><span class="line">    while (nTime)</span><br><span class="line">    &#123;</span><br><span class="line">        nTime--;</span><br><span class="line">        nSize--;</span><br><span class="line">        for (int i = 0; i &lt; nSize; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pnArr[i] &gt; pnArr[<span class="selector-tag">i</span> + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nTemp = pnArr[i];</span><br><span class="line">                pnArr[i] = pnArr[i + 1];</span><br><span class="line">                pnArr[i + 1] = nTemp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pnArr[nSize + 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::MedianFilter()</span><br><span class="line">&#123;</span><br><span class="line">    int nRead = 0;</span><br><span class="line">    int nMedian = 0;</span><br><span class="line">    int nBytePerPixel = bitmapinfoheader.biBitCount / 8;</span><br><span class="line">    int i, j, k, m, n, nCnt;;</span><br><span class="line">    const int FILTEER_SIZE = 3;</span><br><span class="line">    int nTmpArr[FILTEER_SIZE * FILTEER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝边界到临时缓存区</span></span><br><span class="line">    memcpy(pbyTmpBuffer, pbyBuffer, m_nBytesPerLine);</span><br><span class="line">    memcpy(pbyTmpBuffer, pbyBuffer + (bitmapinfoheader.biHeight - 1) * m_nBytesPerLine,</span><br><span class="line">            m_nBytesPerLine);</span><br><span class="line">    for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine;</span><br><span class="line">        pbyTmpBuffer[nRead] = pbyBuffer[nRead];</span><br><span class="line">        pbyTmpBuffer[nRead + 1] = pbyBuffer[nRead + 1];</span><br><span class="line">        pbyTmpBuffer[nRead + 2] = pbyBuffer[nRead + 2];</span><br><span class="line"></span><br><span class="line">        nRead += nBytePerPixel * (bitmapinfoheader.biWidth - 1); </span><br><span class="line">        pbyTmpBuffer[nRead] = pbyBuffer[nRead];</span><br><span class="line">        pbyTmpBuffer[nRead + 1] = pbyBuffer[nRead + 1];</span><br><span class="line">        pbyTmpBuffer[nRead + 2] = pbyBuffer[nRead + 2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; bitmapinfoheader.biHeight - 1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine + nBytePerPixel;</span><br><span class="line">        for (j = 1; j &lt; bitmapinfoheader.biWidth - 1; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (k = 0; k &lt; m_nBytesPerPixel; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                nCnt = 0;</span><br><span class="line">                nMedian = 0;</span><br><span class="line">                for (m = 0; m &lt; FILTEER_SIZE; ++m)</span><br><span class="line">                &#123;</span><br><span class="line">                    for (n = 0; n &lt; FILTEER_SIZE; ++n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nTmpArr[nCnt++] =  pbyBuffer[nRead + (m - 1) * m_nBytesPerLine</span><br><span class="line">                            + (n -1) * nBytePerPixel];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nMedian = GetMedian(nTmpArr, nCnt);</span><br><span class="line">                pbyTmpBuffer[nRead++] = nMedian;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_bBinary = FALSE;//滤波处理之后肯定不是二值图像了</span><br><span class="line">    memcpy(pbyTmpBuffer, pbyTmpBuffer, bitmapinfoheader.biSizeImage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入滤波窗口系数和尺寸(nSize*nSize)</span></span><br><span class="line">void CxBitmap::Filter(double* pfFactors, int nSize, BOOL bAve)</span><br><span class="line">&#123;</span><br><span class="line">    double fMedian = 0;</span><br><span class="line">    int nRead = 0;</span><br><span class="line">    int nRadius = nSize / 2;//滤波窗口的半径</span><br><span class="line">    int nBytePerPixel = bitmapinfoheader.biBitCount / 8;</span><br><span class="line">    int i, j, k, m, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝边界到临时缓存区</span></span><br><span class="line">    for (i = 0; i &lt; nRadius; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        memcpy(pbyTmpBuffer + i * m_nBytesPerLine, pbyBuffer + i * m_nBytesPerLine,</span><br><span class="line">                m_nBytesPerLine);</span><br><span class="line">        memcpy(pbyTmpBuffer + (bitmapinfoheader.biHeight - 1 - i) * m_nBytesPerLine,</span><br><span class="line">                pbyBuffer + (bitmapinfoheader.biHeight - 1 - i) * m_nBytesPerLine,</span><br><span class="line">                m_nBytesPerLine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine;</span><br><span class="line">        for (j = 0; j &lt; nRadius; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nRead = i * m_nBytesPerLine + nBytePerPixel * (bitmapinfoheader.biWidth - nRadius);</span><br><span class="line">        for (j = 0; j &lt; nRadius; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = nRadius; i &lt; bitmapinfoheader.biHeight - nRadius; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine + nRadius * nBytePerPixel;</span><br><span class="line">        for (j = nRadius; j &lt; bitmapinfoheader.biWidth - nRadius; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (k = 0; k &lt; m_nBytesPerPixel; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                fMedian = 0;</span><br><span class="line">                for (m = 0; m &lt; nSize; ++m)</span><br><span class="line">                &#123;</span><br><span class="line">                    for (n = 0; n &lt; nSize; ++n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fMedian += *(pfFactors + nSize * m + n) * pbyBuffer[nRead </span><br><span class="line">                            + (m - nRadius) * m_nBytesPerLine + (n - nRadius) * nBytePerPixel];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bAve)</span><br><span class="line">                &#123;</span><br><span class="line">                    fMedian /= nSize * nSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//assert(nMedian &gt;= 0);</span></span><br><span class="line">                <span class="comment">//注意必须处理变换后不在0-255范围内的像素</span></span><br><span class="line">                <span class="keyword">if</span> (fMedian &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fMedian = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fMedian &gt; <span class="number">255</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fMedian = 255;</span><br><span class="line">                &#125;</span><br><span class="line">                pbyTmpBuffer[nRead++] = fMedian;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_bBinary = FALSE;//滤波处理之后肯定不是二值图像了</span><br><span class="line">    memcpy(pbyBuffer, pbyTmpBuffer, bitmapinfoheader.biSizeImage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8邻域滤波均值滤波</span></span><br><span class="line">void CxBitmap::AverageFilter()</span><br><span class="line">&#123;</span><br><span class="line">    const int AVE_NEIGHBOUR_SIZE = 3;</span><br><span class="line">    static double s_fAveFactors[AVE_NEIGHBOUR_SIZE][AVE_NEIGHBOUR_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(s_fAveFactors[0], AVE_NEIGHBOUR_SIZE, TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉普拉斯滤波</span></span><br><span class="line">void CxBitmap::LaplaceFilter()</span><br><span class="line">&#123;</span><br><span class="line">    static double s_flapFactors[NEIGHBOUR_SIZE][NEIGHBOUR_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;-<span class="number">1</span>,  <span class="number">9</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(s_flapFactors[0], NEIGHBOUR_SIZE, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梯度滤波</span></span><br><span class="line">void CxBitmap::GradientFilterLeft()</span><br><span class="line">&#123;</span><br><span class="line">    const int GRADIENT_NEIGHBOUR_SIZE = 3;</span><br><span class="line">    static double s_fGdFactors[GRADIENT_NEIGHBOUR_SIZE][GRADIENT_NEIGHBOUR_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(s_fGdFactors[0], GRADIENT_NEIGHBOUR_SIZE, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梯度滤波</span></span><br><span class="line">void CxBitmap::GradientFilterRight()</span><br><span class="line">&#123;</span><br><span class="line">    const int GRADIENT_NEIGHBOUR_SIZE = 3;</span><br><span class="line">    static double s_fGdFactors[GRADIENT_NEIGHBOUR_SIZE][GRADIENT_NEIGHBOUR_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">0</span>, -<span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(s_fGdFactors[0], GRADIENT_NEIGHBOUR_SIZE, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梯度滤波</span></span><br><span class="line">void CxBitmap::GradientFilterUp()</span><br><span class="line">&#123;</span><br><span class="line">    const int GRADIENT_NEIGHBOUR_SIZE = 3;</span><br><span class="line">    static double s_fGdFactors[GRADIENT_NEIGHBOUR_SIZE][GRADIENT_NEIGHBOUR_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(s_fGdFactors[0], GRADIENT_NEIGHBOUR_SIZE, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//梯度滤波</span></span><br><span class="line">void CxBitmap::GradientFilterDown()</span><br><span class="line">&#123;</span><br><span class="line">    const int GRADIENT_NEIGHBOUR_SIZE = 3;</span><br><span class="line">    static double s_fGdFactors[GRADIENT_NEIGHBOUR_SIZE][GRADIENT_NEIGHBOUR_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(s_fGdFactors[0], GRADIENT_NEIGHBOUR_SIZE, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::GaussFilter(int nRadius)</span><br><span class="line">&#123;</span><br><span class="line">    int nSize = 2 * nRadius + 1;</span><br><span class="line">    int nDis = 0;</span><br><span class="line">    const double SIGMA = 1.5;</span><br><span class="line">    const double A = 2 * SIGMA * SIGMA;</span><br><span class="line">    const double B = 1.0 / (4 * atan(1.0) * A);</span><br><span class="line">    double* pfFactors = new double[nSize * nSize];</span><br><span class="line">    double fTotal = 0.0;</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; nSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; nSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            nDis = (i - nRadius) * (i - nRadius) + (j - nRadius) * (j - nRadius);</span><br><span class="line">            pfFactors[i * nSize + j] = B * exp(-nDis / A);</span><br><span class="line">            fTotal += pfFactors[i * nSize + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; nSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; nSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">             pfFactors[i * nSize + j]  /= fTotal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(pfFactors, nSize, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete [] pfFactors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::LogTransfer()</span><br><span class="line">&#123;</span><br><span class="line">    const int C = 10;</span><br><span class="line">    int nRead = 0;</span><br><span class="line">    int nScale = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine;</span><br><span class="line">        for (int j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = 0; k &lt; m_nBytesPerPixel; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                nScale = C * log(1 + pbyBuffer[nRead]);</span><br><span class="line">                pbyBuffer[nRead++] = nScale;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CxBitmap::ExpTransfer()</span><br><span class="line">&#123;</span><br><span class="line">    const int C = 10;</span><br><span class="line">    int nRead = 0;</span><br><span class="line">    int nScale = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine;</span><br><span class="line">        for (int j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = 0; k &lt; m_nBytesPerPixel; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                nScale = C * exp(pbyBuffer[nRead]);</span><br><span class="line">                <span class="keyword">if</span> (nScale &gt; <span class="number">255</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nScale = 255;</span><br><span class="line">                &#125;</span><br><span class="line">                pbyBuffer[nRead++] = nScale;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对hough变换的定义得到的直线相对的是坐标系原点的坐标系</span></span><br><span class="line">void CxBitmap::HoughLine(int* pnR, double* pfTheta)</span><br><span class="line">&#123;</span><br><span class="line">    const double PI = 4.0 * atan(1.0);</span><br><span class="line">    double fRate = PI / 180;</span><br><span class="line">    int nWidth = GetWidth(), nHeight = GetHeight();</span><br><span class="line">    int iRMax = (int)sqrt(nWidth * nWidth + nHeight * nHeight) + 1;</span><br><span class="line">    int iThMax = 360;</span><br><span class="line">    int iTh;</span><br><span class="line">    int iR;</span><br><span class="line">    int iMax = -1;</span><br><span class="line">    int iThMaxIndex = -1;</span><br><span class="line">    int iRMaxIndex = -1;</span><br><span class="line">    int *pnArray = NULL;</span><br><span class="line">    int nPos = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_bBinary == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        GrayToBinary();</span><br><span class="line">    &#125;</span><br><span class="line">    pnArray = new int[iRMax * iThMax];//iRMax行,每一行长度是iThMax</span><br><span class="line">    memset(pnArray, 0, sizeof(int) * iRMax * iThMax);</span><br><span class="line"></span><br><span class="line">    for (int y = 0; y &lt; nHeight; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        nPos = m_nBytesPerLine * y;</span><br><span class="line">        for (int x = 0; x &lt; nWidth; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pbyBuffer[nPos] == <span class="number">255</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                for(iTh = 0; iTh &lt; iThMax; iTh++)</span><br><span class="line">                &#123;</span><br><span class="line">                    iR = (int)(x * cos(iTh * fRate) + y * sin(iTh * fRate));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(iR &gt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        pnArray[iR * iThMax + iTh]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nPos++;</span><br><span class="line">        &#125; <span class="comment">// x </span></span><br><span class="line">    &#125; <span class="comment">// y </span></span><br><span class="line"></span><br><span class="line">    for(iR = 0; iR &lt; iRMax; iR++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(iTh = 0; iTh &lt; iThMax; iTh++)</span><br><span class="line">        &#123;</span><br><span class="line">            int iCount = pnArray[iR * iThMax + iTh];</span><br><span class="line">            <span class="keyword">if</span>(iCount &gt; iMax)</span><br><span class="line">            &#123;</span><br><span class="line">                iMax = iCount;</span><br><span class="line">                iRMaxIndex = iR;</span><br><span class="line">                iThMaxIndex = iTh;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pnR = iRMaxIndex;</span><br><span class="line">    *pfTheta = fRate * iThMaxIndex;</span><br><span class="line"></span><br><span class="line">    delete [] pnArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern int Pow2Big(int nA);</span><br><span class="line">int CxBitmap::WriteMeshObj(const char* pcszObjFileName)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line">int nPos;</span><br><span class="line">char szTexFileName[MAX_PATH];</span><br><span class="line">FILE* fpFile;</span><br><span class="line"></span><br><span class="line">strcpy(szTexFileName, pcszObjFileName);</span><br><span class="line">strcat(szTexFileName, ".mtl");</span><br><span class="line">fpFile = fopen(szTexFileName, "w");</span><br><span class="line">fprintf(fpFile, "newmtl %s.mtl\n", m_szBitmapName);</span><br><span class="line">fprintf(fpFile, "map_Kd %s\n", m_szBitmapName);</span><br><span class="line">fclose(fpFile);</span><br><span class="line"></span><br><span class="line">fpFile = fopen(pcszObjFileName, "w");</span><br><span class="line"><span class="keyword">if</span> (fpFile == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fprintf(fpFile, "mtllib %s\n", szTexFileName);</span><br><span class="line"><span class="comment">//v</span></span><br><span class="line">for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">&#123;</span><br><span class="line">for (j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(fpFile, "v %d %d %d\n", j, i, 0);//v x y z</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//vt(纹理)</span></span><br><span class="line">for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">&#123;</span><br><span class="line">for (j = 0; j &lt; bitmapinfoheader.biWidth; ++j)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(fpFile, <span class="string">"vt %f %f 0.0\n"</span>, (double)(j + <span class="number">1</span>) / bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">(double)(i + 1) / bitmapinfoheader.biHeight);//vt s t</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fprintf(fpFile, "usemtl %s.mtl\n", m_szBitmapName);</span><br><span class="line"><span class="comment">//f 1//1 2//2 101//101</span></span><br><span class="line">for (i = 0; i &lt; bitmapinfoheader.biHeight - 1; ++i)</span><br><span class="line">&#123;</span><br><span class="line">for (j = 0; j &lt; bitmapinfoheader.biWidth - 1; ++j)</span><br><span class="line">&#123;</span><br><span class="line">nPos = i * bitmapinfoheader.biWidth + j;</span><br><span class="line"><span class="comment">//上三角,面标记为nPos</span></span><br><span class="line">fprintf(fpFile, <span class="string">"f %d/%d/ %d/%d/ %d/%d/ %d\n"</span>, nPos, nPos,</span><br><span class="line">nPos + bitmapinfoheader<span class="selector-class">.biWidth</span>, nPos + bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">nPos + bitmapinfoheader<span class="selector-class">.biWidth</span> + <span class="number">1</span>, nPos + bitmapinfoheader<span class="selector-class">.biWidth</span> + <span class="number">1</span>,</span><br><span class="line">nPos);</span><br><span class="line">nPos++;</span><br><span class="line"><span class="comment">//下三角</span></span><br><span class="line">fprintf(fpFile, <span class="string">"f %d/%d/ %d/%d/ %d/%d/ %d\n"</span>, nPos, nPos, nPos - <span class="number">1</span>, nPos - <span class="number">1</span>,</span><br><span class="line">nPos + bitmapinfoheader.biWidth, nPos + bitmapinfoheader.biWidth, nPos);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fclose(fpFile);</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我再演示一下使用该类得到的一些效果吧。<br>加载原图的效果，我都是用使用该类加载文件并绘制到指定位置。<br><img alt data-src="https://c2.staticflickr.com/8/7430/27379325441_7a1813b273_o.jpg"></p><p>下面这张是对一张24位彩色图像灰度化后得到灰度直方图。</p><p><img alt data-src="https://c8.staticflickr.com/8/7215/27379325591_dee18f854e_o.jpg"></p><p>对同样的图片进行某个方向梯度变换后的效果如下图，可以看到边缘都增强了。<br><img alt data-src="https://c4.staticflickr.com/8/7314/26843672643_53ae21931b_o.jpg"></p><p>再下面这张是另外一个实现进行下边缘梯度滤波再hough变换的结果，该实验的目的是检测三角形。<br><img alt data-src="https://c8.staticflickr.com/8/7299/26843673903_0af7938b59_o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CxBitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锐化空间滤波</title>
      <link href="/2013/01/03/%E9%94%90%E5%8C%96%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/"/>
      <url>/2013/01/03/%E9%94%90%E5%8C%96%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p>锐化空间滤波用来增强细节或者边缘，常用的有拉普拉斯滤波和梯度滤波。<br>拉普拉斯滤波其实就是<strong>二维离散函数的二阶差分</strong>。因为任意一张图片可以看作是二维离散函数z=f(x,y)，对其求二阶离散差分就能得到3 <em> 3的滤波窗口系数表，具体推理可以参考数字图像处理那本很经典的书籍。再用原图减去就得到了一张增强细节的图片了。<br>如果使用下列的系数那么得到的是用<em>*原图减去拉普拉斯变换的增强细节的图片</em></em>，<br>static double s_flapFactors[NEIGHBOUR_SIZE][NEIGHBOUR_SIZE] =<br>{<br>    {-1, -1, -1},<br>    {-1, 9, -1},<br>    {-1, -1, -1},<br>};</p><p>梯度滤波则用到了方向变化率之类的知识，简而言之就是在哪个方向变化最快。梯度滤波没有精确的系数表示，一般用一些系数表示来近似。比如，</p><p>{-1, 0, 1},<br>{-2, 0, 2},<br>{-1, 0, 1}</p><p>就是用来增强左边缘的，还有，</p><p>{1, 0, -1},<br>{2, 0, -2},<br>{1, 0, -1}，</p><p>{1, 2, 1},<br>{0, 0, 0},<br>{-1, -2, -1},</p><p>{-1, -2, -1},<br>{0, 0, 0},<br>{1, 2, 1}</p><p>都是用来增强其它方向的边缘，<strong>总共四个滤波系数窗口用来增强不同方向的边缘</strong>。<br>至于这些滤波的实现方法，只需要用这些滤波系数去调用我在上一篇文章给出的滤波公共函数即可。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平滑空间滤波</title>
      <link href="/2013/01/02/%E5%B9%B3%E6%BB%91%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/"/>
      <url>/2013/01/02/%E5%B9%B3%E6%BB%91%E7%A9%BA%E9%97%B4%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p>图像处理中的空间滤波主要有2种类型，平滑空间滤波和锐化空间滤波。平滑空间滤波一般用于模糊图像，比如消除散乱的噪声点等。平滑空间滤波主要有均值滤波和中值滤波，以及其余的复杂统计方法。滤波窗口的大小可以选为3<em>3或者4</em>4或者5*5等。<br>其实不同的空间滤波处理基本上就滤波窗口的系数不相同，除了均值滤波要除以滤波窗口大小以及中值滤波要特殊处理之外，那么我们可以实现一个针对特定滤波窗口实现的滤波公共函数。比如，均值滤波窗口</p><p>{1,1,1}</p><p>{1,1,1},</p><p>{1,1,1}</p><p>就是选取当前像素点周围9个点的像素值总和再除以9得到的。而中值滤波则必须得到这9个值中排行第5的值作为当前像素的值。平滑滤波的原理也比较简单。下面给出相关的代码。</p><p>滤波基础函数，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入滤波窗口系数和尺寸(nSize*nSize)</span></span><br><span class="line">void CxBitmap::Filter(double* pfFactors, int nSize, BOOL bAve)</span><br><span class="line">&#123;</span><br><span class="line">    double fMedian = 0;</span><br><span class="line">    int nRead = 0;</span><br><span class="line">    int nRadius = nSize / 2;//滤波窗口的半径</span><br><span class="line">    int nBytePerPixel = bitmapinfoheader.biBitCount / 8;</span><br><span class="line">    int i, j, k, m, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝边界到临时缓存区</span></span><br><span class="line">    for (i = 0; i &lt; nRadius; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        memcpy(pbyTmpBuffer + i * m_nBytesPerLine, pbyBuffer + i * m_nBytesPerLine,</span><br><span class="line">                m_nBytesPerLine);</span><br><span class="line">        memcpy(pbyTmpBuffer + (bitmapinfoheader.biHeight - 1 - i) * m_nBytesPerLine,</span><br><span class="line">                pbyBuffer + (bitmapinfoheader.biHeight - 1 - i) * m_nBytesPerLine,</span><br><span class="line">                m_nBytesPerLine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; bitmapinfoheader.biHeight; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine;</span><br><span class="line">        for (j = 0; j &lt; nRadius; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nRead = i * m_nBytesPerLine + nBytePerPixel * (bitmapinfoheader.biWidth - nRadius);</span><br><span class="line">        for (j = 0; j &lt; nRadius; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">            pbyTmpBuffer[nRead] = pbyBuffer[nRead++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = nRadius; i &lt; bitmapinfoheader.biHeight - nRadius; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nRead = i * m_nBytesPerLine + nRadius * nBytePerPixel;</span><br><span class="line">        for (j = nRadius; j &lt; bitmapinfoheader.biWidth - nRadius; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (k = 0; k &lt; m_nBytesPerPixel; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                fMedian = 0;</span><br><span class="line">                for (m = 0; m &lt; nSize; ++m)</span><br><span class="line">                &#123;</span><br><span class="line">                    for (n = 0; n &lt; nSize; ++n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fMedian += *(pfFactors + nSize * m + n) * pbyBuffer[nRead</span><br><span class="line">                            + (m - nRadius) * m_nBytesPerLine + (n - nRadius) * nBytePerPixel];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bAve)</span><br><span class="line">                &#123;</span><br><span class="line">                    fMedian /= nSize * nSize;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//assert(nMedian &gt;= 0);</span></span><br><span class="line">                <span class="comment">//注意必须处理变换后不在0-255范围内的像素</span></span><br><span class="line">                <span class="keyword">if</span> (fMedian &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fMedian = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fMedian &gt; <span class="number">255</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fMedian = 255;</span><br><span class="line">                &#125;</span><br><span class="line">                pbyTmpBuffer[nRead++] = fMedian;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_bBinary = FALSE;//滤波处理之后肯定不是二值图像了</span><br><span class="line">    memcpy(pbyBuffer, pbyTmpBuffer, bitmapinfoheader.biSizeImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>均值滤波函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8邻域滤波均值滤波</span></span><br><span class="line">void CxBitmap::AverageFilter()</span><br><span class="line">&#123;</span><br><span class="line">    const int AVE_NEIGHBOUR_SIZE = 3;</span><br><span class="line">    static double s_fAveFactors[AVE_NEIGHBOUR_SIZE][AVE_NEIGHBOUR_SIZE] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    assert(m_bLoad);</span><br><span class="line">    <span class="keyword">if</span> (m_bLoad)</span><br><span class="line">    &#123;</span><br><span class="line">        Filter(s_fAveFactors[0], AVE_NEIGHBOUR_SIZE, TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hough变换检测直线</title>
      <link href="/2013/01/02/Hough%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%9B%B4%E7%BA%BF/"/>
      <url>/2013/01/02/Hough%E5%8F%98%E6%8D%A2%E6%A3%80%E6%B5%8B%E7%9B%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>hough变换是图像处理里面一种检测直线等规则曲线的方法。这里介绍下检测直线的原理和实现方法，最后给出相关的代码。</p><p>先给出数学上面的里面，斜截式直线y=kx+b有两个参数k,b，注意直线方程是在笛卡儿坐标系xoy中的。任意一条直线对应于kob平面中一个点(k,b)。那么，对于xoy平面中的任意一个点肯定有无数条通过它的直线，那么直线都有对应的kob平面中的点，这些点能组成一条直线。<strong>综合起来就是，xoy平面中一条直线对应于kob平面中的一个点，xoy平面中的一个点对应于kob平面中的一条直线。</strong><br>现在有个问题是<strong>斜截式无法表示xoy平面中所有直线</strong>，那么我们希望能找到能够表示xoy平面中所有直线的参数式子。这个式子是r=x<em>cos(θ)+y</em>sin(θ)。推导过程如下：<br><img alt data-src="https://c7.staticflickr.com/8/7224/27351286542_6ddb76e445_o.jpg"><br>r为原点到直线的距离，(x0,y0)为垂足，θ为垂线和x轴正向的夹角，那么对于直线上面的任意的一个点都有<br>(x0, y0) <em> (x-x0,y-y0)=0,得到x </em> x0 - x0 <em> x0 + y </em> y0 - y0 <em> y0 = 0，即x </em> x0 + y <em> y0 = x0 </em> x0 + y0 <em> y0 = r </em> r。等式两边再除以r得到r = x <em> cos(θ) + y </em> sin(θ)。那么这个关于(θ,r)的参数式子可以表示xoy平面上所有的直线了。</p><p>现在再来讨论下如何根据这个参数式子检测直线的。<br>我们手上的只有xoy平面上的图像。而且根据我们的推理，我们的图像的原点必须在左下角，因为我们是用笛卡尔坐标系推出该参数式子的。那么，我们可以枚举图像上面每一个可能是直线上面的点(比如，我们可以对图像阈值化后，像素值为255的点就可能是直线上面的点），由于图像上的每个点对应于θor平面上面的一条曲线(这里管它是直线还是曲线了，对于检测原理没影响)，那么我们就能得到很多θor平面上的曲线。我们对每个(θ,r)点计数通过其上的曲线个数，最后选取曲线个数最大的那个点（θmax,Rmax）其对应的肯定是我们要检测的直线。至于其它的预处理，<strong>一般是梯度滤波增强边缘或者拉普拉斯增强边缘，然后弄个全局二值化，就可以用hough变换检测直线了(我这次的实验就没有平滑滤波噪声，那样会使直线变粗，使检测效果变坏）</strong>。<br>最后我给出我的检测直线的代码，并指出代码需要主要的实现点。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对hough变换的定义得到的直线相对的是坐标系原点的坐标系</span></span><br><span class="line"><span class="comment">//针对hough变换的定义得到的直线相对的是坐标系原点的坐标系</span></span><br><span class="line">void CxBitmap::HoughLine(int* pnR, double* pfTheta)</span><br><span class="line">&#123;</span><br><span class="line">    const double PI = 4.0 * atan(1.0);</span><br><span class="line">    double fRate = PI / 180;</span><br><span class="line">    int nWidth = GetWidth(), nHeight = GetHeight();</span><br><span class="line">    int iRMax = (int)sqrt(nWidth * nWidth + nHeight * nHeight) + 1;</span><br><span class="line">    int iThMax = 360;</span><br><span class="line">    int iTh;</span><br><span class="line">    int iR;</span><br><span class="line">    int iMax = -1;</span><br><span class="line">    int iThMaxIndex = -1;</span><br><span class="line">    int iRMaxIndex = -1;</span><br><span class="line">    int *pnArray = NULL;</span><br><span class="line">    int nPos = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_bBinary == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        GrayToBinary();</span><br><span class="line">    &#125;</span><br><span class="line">    pnArray = new int[iRMax * iThMax];//iRMax行,每一行长度是iThMax</span><br><span class="line">    memset(pnArray, 0, sizeof(int) * iRMax * iThMax);</span><br><span class="line"></span><br><span class="line">    for (int y = 0; y &lt; nHeight; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        nPos = m_nBytesPerLine * y;</span><br><span class="line">        for (int x = 0; x &lt; nWidth; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pbyBuffer[nPos] == <span class="number">255</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                for(iTh = 0; iTh &lt; iThMax; iTh++) &#123; iR = (int)(x * cos(iTh * fRate) + y * sin(iTh * fRate)); if(iR &gt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        pnArray[iR * iThMax + iTh]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nPos++;</span><br><span class="line">        &#125; <span class="comment">// x</span></span><br><span class="line">    &#125; <span class="comment">// y</span></span><br><span class="line"></span><br><span class="line">    for(iR = 0; iR &lt; iRMax; iR++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(iTh = 0; iTh &lt; iThMax; iTh++) &#123; int iCount = pnArray[iR * iThMax + iTh]; if(iCount &gt; iMax)</span><br><span class="line">            &#123;</span><br><span class="line">                iMax = iCount;</span><br><span class="line">                iRMaxIndex = iR;</span><br><span class="line">                iThMaxIndex = iTh;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pnR = iRMaxIndex;</span><br><span class="line">    *pfTheta = fRate * iThMaxIndex;</span><br><span class="line"></span><br><span class="line">    delete [] pnArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意nPos <strong>必须按m_nBytesPerLine对齐</strong>，因为即使是灰度图像每行的长度也不一定是图像的宽度，如果这个错了，检测结果就完全错了。另外一个是计算出来的iR值必须大于0才有效。<br>相关博文可以参考这篇关于hough变换的文章，<a href="http://www.narutoacm.com/archives/hough-transform/" target="_blank" rel="noopener" title="我也说说hough变换">我也说说hough变换</a></p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hough变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将内存中的位图数据绘制在DC上</title>
      <link href="/2012/12/26/%E5%A6%82%E4%BD%95%E5%B0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E5%9C%A8DC%E4%B8%8A/"/>
      <url>/2012/12/26/%E5%A6%82%E4%BD%95%E5%B0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%BB%98%E5%88%B6%E5%9C%A8DC%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>假如你定义了一个位图类，里面包含位图头，位图信息头，调色板，位图数据。然后你按照位图的格式将位图文件读入你的类中，现在你知道了位图的全部信息了。主要信息包含在位图信息头里面，数据则在位图数据缓冲里面。现在的问题是，在Windows下面如何将一张位图画出来，而且现在是如何从数据缓存里面绘画出位图。<br>一般情况，我们都是直接绘制在dc里面，而不是绑定到子控件，让子控件自己绘画，比如picture控件之类的，我觉得提供绘制在dc里面的接口更具有广泛性。</p><p>现在我知道两种从内存数据绘制彩色位图的2种方法。第一种麻烦一点，第二种则相当直接。<br>方法一：<br>第一步，用CreateCompatibleDC创建跟目标dc的兼容性内存dc。<br>第二步，用CreateCompatibleBitmap创建跟目标dc的兼容性位图。<br>第三步，用SelectObject将第二步创建的兼容位图选入第一步创建的兼容dc中。<br>第四步，<strong>用SetDIBits设置兼容位图的数据缓冲</strong>。<br>第五步，用BitBlt将数据从兼容内存dc绘制到目标dc。<br>第六步，删除兼容位图和兼容dc。<br>代码如下，其中buffer代表位图数据缓冲。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HDC hCompatibleDC = CreateCompatibleDC(hDc);</span><br><span class="line">HBITMAP hCompatibleBitmap = CreateCompatibleBitmap(hDc, bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">bitmapinfoheader.biHeight);</span><br><span class="line">HBITMAP hOldBitmap = (HBITMAP)SelectObject(hCompatibleDC, hCompatibleBitmap);</span><br><span class="line">SetDIBits(hDc, hCompatibleBitmap, <span class="number">0</span>, bitmapinfoheader<span class="selector-class">.biHeight</span>,</span><br><span class="line">buffer, (BITMAPINFO*)&amp;bitmapinfoheader, DIB_RGB_COLORS);</span><br><span class="line">BitBlt(hDc, nStartX, nStartY, bitmapinfoheader<span class="selector-class">.biWidth</span>, bitmapinfoheader<span class="selector-class">.biHeight</span>,</span><br><span class="line">hCompatibleDC, 0, 0, SRCCOPY);</span><br><span class="line">SelectObject(hCompatibleDC, hOldBitmap);</span><br><span class="line">DeleteObject(hCompatibleDC);</span><br><span class="line">DeleteObject(hCompatibleDC);</span><br></pre></td></tr></table></figure><p>方法二：<strong>直接调用StretchDIBits绘制位图</strong>。<br>该函数功能相当强悍，似乎专为从内存数据绘制位图到dc而生。<br>函数原型如下：<br>int StretchDIBits(<br>HDC hdc,                      // handle to DC<br>int XDest,                    // x-coord of destination upper-left corner<br>int YDest,                    // y-coord of destination upper-left corner<br>int nDestWidth,               // width of destination rectangle<br>int nDestHeight,              // height of destination rectangle<br>int XSrc,                     // x-coord of source upper-left corner<br>int YSrc,                     // y-coord of source upper-left corner<br>int nSrcWidth,                // width of source rectangle<br>int nSrcHeight,               // height of source rectangle<br>CONST VOID <em>lpBits,           // bitmap bits<br>CONST BITMAPINFO </em>lpBitsInfo, // bitmap data<br>UINT iUsage,                  // usage options<br>DWORD dwRop                   // raster operation code<br>);<br>使用也相当简单，调用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StretchDIBits(hDc, nStartX, nStartY, bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">bitmapinfoheader<span class="selector-class">.biHeight</span>, <span class="number">0</span>, <span class="number">0</span>, bitmapinfoheader<span class="selector-class">.biWidth</span>,</span><br><span class="line">bitmapinfoheader<span class="selector-class">.biHeight</span>, buffer, (BITMAPINFO*)&amp;bitmapinfoheader,</span><br><span class="line">DIB_RGB_COLORS, SRCCOPY);</span><br></pre></td></tr></table></figure><p>即可了。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针和引用的区别</title>
      <link href="/2012/12/25/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2012/12/25/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>区别一：引用必须要指代一个对象，所以<strong>引用必须初始化</strong>，但是指针不需要。</p><p>区别二：存在空指针，但是<strong>不存在空引用</strong>，引用必须要指代某个对象。</p><p>区别三：由于不存在空引用，使用引用时候<strong>不需要测试是否有效</strong>，但是使用指针则需要保证其是有效的。</p><p>区别四：指针可以改变其指向的对象，但是引用不可以，<strong>引用一被初始化后就不能改变</strong>。</p><p>区别五：重载[]操作符的时候，由于语法需要，应该<strong>返回引用</strong>而不是指针。</p><p>区别六：从概念上看，指针是一个变量，而<strong>引用则是其它变量的别名</strong>。</p><p>区别七：指针是占据内存的，但是<strong>引用则不一定会分配内存</strong>，引用只是一个别名。</p><p>区别八：对指针使用操作符和对引用使用操作符效果不同，对引用使用操作符得到的都是<strong>对所指代的对象使用操作符的结果</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SetWindowPos移动子窗口或占满桌面工作区域</title>
      <link href="/2012/12/20/SetWindowPos%E7%A7%BB%E5%8A%A8%E5%AD%90%E7%AA%97%E5%8F%A3%E6%88%96%E5%8D%A0%E6%BB%A1%E6%A1%8C%E9%9D%A2%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F/"/>
      <url>/2012/12/20/SetWindowPos%E7%A7%BB%E5%8A%A8%E5%AD%90%E7%AA%97%E5%8F%A3%E6%88%96%E5%8D%A0%E6%BB%A1%E6%A1%8C%E9%9D%A2%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>该函数原型如下，<br>BOOL SetWindowPos(<br>HWND hWnd, // handle to window<br>HWND hWndInsertAfter, // placement-order handle<br>int X, // horizontal position<br>int Y, // vertical position<br>int cx, // width<br>int cy, // height<br>UINT uFlags // window-positioning options<br>);</p><p>第一个参数是你要修改的窗口局部，第二个参数是用于修改Z order的，可以用这个参数把你的窗口弄成TopMost之类的窗口，后面四个参数很好理解，最后那个参数是一些标志，具体的请查看msdn。<br>基本上我觉得使用这个函数有些时候达不到你想要的效果原因是不知道这个函数使用的坐标系其实不是桌面坐标系，也不是当前窗口的客户区坐标系，<strong>而是父窗口的客户区坐标系</strong>。这个点可能在你移动非子窗口的时候没有什么影响，但是你想移动子窗口的时候就会出问题了，老是达不到你想要的效果那是非常烦人的，而你debug进去发现你的数据又都是对的。当你意识到该函数使用的坐标系的时候，对应的问题就都能够解决了。</p><p>我列举2个例子，一个是设置窗口为顶级窗口同时修改为覆盖整个桌面工作区，另一个是移动子窗口对话框到主对话框的客户区左上角。2个例子都在我的代码内部，后面我会提供代码下载。</p><p><strong>例子一，设置窗口为顶级窗口同时修改为覆盖整个桌面工作区。</strong><br>将下面的代码放在你的主对话框的OnInitDialog()函数内部就能够达到例子一的效果了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RECT rect;</span><br><span class="line">SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)rect, 0);</span><br><span class="line">m_nScreenWidth = rect<span class="selector-class">.right</span> - rect.<span class="attribute">left</span>;</span><br><span class="line">m_nScreenHeight = rect<span class="selector-class">.bottom</span> - rect.<span class="attribute">top</span>;</span><br><span class="line">SetWindowPos(wndTop, rect.left, rect.top, m_nScreenWidth, m_nScreenHeight, SWP_SHOWWINDOW);</span><br></pre></td></tr></table></figure><p><strong>例子二，移动子窗口对话框到主对话框的客户区左上角。</strong><br>这个例子的实现比较麻烦，首先修改子对话框的资源文件里面的属性，一定改成child类型的对话框。其次，用非模式对话框创建出子对话框，同时注意把主对话框最为其父窗口。最后只需要在child对话框的OnInitDialog()函数里面调用SetWindowPos(wndTop, 0, 0, 0, 0, SWP_NOSIZE);//移动子窗口,则坐标是相对于父窗口客户区就能达到效果了。这三个操作是缺一不可的。</p><p>代码下载地址，<a href="https://pan.baidu.com/s/1bpBgvi3" target="_blank" rel="noopener">实验二</a>。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SetWindowPos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提高多线程程序的cpu利用率</title>
      <link href="/2012/12/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84cpu%E5%88%A9%E7%94%A8%E7%8E%87/"/>
      <url>/2012/12/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84cpu%E5%88%A9%E7%94%A8%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>正如大家所知道的那样，多核多cpu越来越普遍了，而且编写多线程程序也是件很简单的事情。在Windows下面，调用CreateThread函数一次就能够以你想要的函数地址新建一个子线程运行。然后，事情确实你发现创建多线程根本没有让程序快多少，也没有提高多少cpu利用率，甚至可能让cpu利用率下降。唯一能够确定的是多线程能够避免界面假死。为什么会是这样的了。本文将举一些例子和讲述一些原因。</p><p>首先，我来讲一下多处理的一些知识。如下图所示，<br><img alt data-src="https://c2.staticflickr.com/8/7602/26843192743_1a58643141_o.png"><br>多处理器系统也只有一个待运行的线程队列，内存中也只有一个操作系统拷贝，而且也只有一个内存系统，但是会有多个cpu同时运行不同的线程。一个cpu运行一个线程，那么上图中的系统最多能在同一时间运行2个线程。其实，多处理系统需要掌握的知识不是这些，而是<strong>缓存一致性</strong>。<br>现在来解释下什么是缓存一致性。由于，还是只有一个内存系统。所有cpu都要和这个内存系统通信，但是只有一条总线，那么这无疑会造成总线紧张，限制整体的速度了。那么，你多个cpu也没多少意义了。解决这个问题的办法还是利用cpu的缓存机制，学过组成原理的同学都知道，cpu的缓存命中率还是很高的，有90%以上吧。那么，我继续利用缓存机制还是可以降低总线的频繁使用的。但是，每个cpu都有自己的缓存。如果有2个cpu的缓存存储的是同一内存数据的内容，其中一个cpu的缓存更新了，另外一个cpu的缓存也必须更新，这就是所谓的缓存一致性。编程多线程程序的一个很重要的一点就是避免因为缓存一致性引起的缓存更新风暴。<br>现在我举一个<strong>缓存更新风暴</strong>的例子。<br>如图所示的类定义，<br><a href="http://www.xpc-yx.com/2012/12/%e5%a6%82%e4%bd%95%e6%8f%90%e9%ab%98%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%a8%8b%e5%ba%8f%e7%9a%84cpu%e5%88%a9%e7%94%a8%e7%8e%87/%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e9%a3%8e%e6%9a%b4/" target="_blank" rel="noopener"><img alt="缓存一致性风暴" data-src="http://www.xpc-yx.com/wp-content/uploads/2012/12/缓存一致性风暴.png"></a><br>锁lockHttp和lockSsl中间只有8个字节，而绝大部分系统上一个缓存行是128个字节，那么这2个锁很可能就处在同一个缓存行上面。那么，最坏的情况会发生什么事情了。假设处理器P1在运行一个处理http请求的线程T1，处理器P2在运行一个处理ssl请求的线程T2，那么当T1获得锁lockHttp的时候，锁的内容就会改变，为了保持缓存一致性，就会更新P2的缓存。那么，T2要获得锁lockssl的时候，发现缓存已经失效了，就必须从内存中重新加载缓存之类。总之，这会将缓存命中率降低到90%以下，引起性能的严重降低。而且发生这种事情的原因是因为我们不了解硬件的体系结构。</p><p>多cpu不能成倍提高速度的原因是任务的某些部分是必须串行处理的。比如，矩阵乘法可以分为三个部分，初始化矩阵，相乘，返回结果。这三部分第二部分可以用多线程来处理，第一部分和第三部分则是不可以的。而且第二部分必须在第一部分完成之后，第三部分必须在第一部分完成之后。那么，无论你添加多少个处理器，最快的时间都至少是第一部分和第二部分的时间之和。这个事实好像叫做Amdahl法则。<br>如果使用多线程，那么就必须考虑线程同步，而线程同步又是导致速度降低的关键。所以下面就讲述一些方法来加快多线程程序的吞吐速度。<br><strong>方法一，把一个任务分解为多个可以子任务。</strong><br>因为总有些子任务是可以并发的，多个子任务并发执行了很可能就能够避免cpu需要io操作的完成了，而且能够提高系统的吞吐量。<br><strong>方法二，缓存多线程的共享数据。</strong><br>当你已经在使用多线程了，很多时候必须使用共享数据。如果，数据是只读的，那么可以在第一次获取后保存起来，以后就可以重复使用了。但是，第一次的获取还是无法避免的需要线程同步操作的。<br><strong>方法三，如果线程数目有限，就不要共享数据。</strong><br>做法是为每一个线程实例化一个单独的数据，其实就是为每一个线程分配一块数据使用。这样没有线程同步操作了，速度可以尽可能的提示。<br><strong>方法四，如果没办法确定线程数目到底有多少，那么使用部分共享吧。</strong><br>部分共享其实就是使用多个资源池代替一个资源池，资源池的数目得更加经验来确定。如下图所示，<br><img alt data-src="https://c2.staticflickr.com/8/7661/26843193313_87aceb0b9a_o.png"><br>最后在提一个叫做<strong>Thundering Herd的问题</strong>，该问题维基百科有定义<a href="http://en.wikipedia.org/wiki/Thundering_herd_problem" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Thundering_herd_problem</a>。大意是，当多个线程在等待一个资源的时候，如果事件等待到了，操作系统是唤醒所有等待的线程让它们自己去竞争资源了还是选择一个线程把资源给它。当然唤醒所有的线程肯定开销要大，而且所有没有抢到资源的线程还得重新进入等待状态，这无疑造成很多没必要的操作，浪费了没必要的线程上下文切换。总之，会不会存在Thundering Herd还是跟不同的操作系统有关的。万一存在Thundering Herd了，多线程可能就没那么好办了。</p><p>到现在我们知道了为什么多cpu并不能成倍提高程序的速度了。首先因为有些任务无法并行，其次即使是并行cpu之间还是有很多牵制的。本书的内容主要来自提高c++性能的编程技术一书。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的设计优化</title>
      <link href="/2012/12/17/C++%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
      <url>/2012/12/17/C++%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>设计优化是一种全局的优化，是比代码优化更难判断的东西。本文只以提高c++性能的编程技术一书的说法再自己的理解为例子。性能和灵活性本来就是相互冲突的东西。将两者结合得很好的例子一般能想到STL，但是STL在特定的场合肯定比不上专用代码的性能。比如，用stl里面的accmulate累加int能够与自己的实现效果一样，但是累加string的话就会比手动实现效果差很多。所以作者提出了个这样的观点，软件库是通用的，但是软件不是，所以没必要让软件太通用，视野应该窄一点。</p><p><strong>例子一，还是利用缓存机制。</strong><br>比如，一个web服务器经常要计算时间戳，而且是在1s内要计算不少次。由于时间戳没必要以ms进行区分，那么可以只计算一次时间戳，然后将时间戳保存起来，或者作为参数传递给后面的调用。</p><p><strong>例子二，扩展数据类型。</strong><br>比如，使用字符串的时候假如经常要计算字符串长度，那么可以定义一个结构体，内部有个成员用于保存长度。这样在很多需要长度的场合就可以避免重复计算长度了。</p><p><strong>例子三，避免公共代码陷阱。</strong><br>比如，在一个公共函数中，需要处理ipv4和ipv6两种情况，那么你就必须在函数中进行判断当前处理的是ipv4还是ipv6。但是，这种判断并不是必须的，如果你不使用公共函数的话。最重要的问题是，如果有很多这样的公共函数，那么就会出现成千上万这样其实没必要的判断，无疑对于性能是一个重大的损失。</p><p><strong>例子四，使用高效的数据结构和算法。</strong><br>当然这点需要扎实的算法知识。</p><p><strong>例子五，使用缓式计算。</strong><br>同上一篇文章中描述的一样，将计算延缓到真正需要的时候。比如，调用getpeername获得对方ip地址和调用getsockname获得本地服务器ip地址都是些昂贵的调用，那么我们还是把这些调用延迟到真正需要的时候吧。而且对方ip地址可以在accept函数调用的时候就得到了，这个时候保存起来就可以了。<br>缓式计算类似于下面的类定义，<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">    X() &#123;veryExpensive = NULL;&#125;</span><br><span class="line">    ~X() &#123; if (veryExpensive) delete veryExpensive; &#125;</span><br><span class="line">    Z* get_veryExpensive()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NULL == veryExpensive)</span><br><span class="line">        &#123;</span><br><span class="line">            set_veryExpensive();</span><br><span class="line">        &#125;</span><br><span class="line">        return veryExpensive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void set_veryExpensive</span><br><span class="line">    &#123;</span><br><span class="line">        veryExpensive = new Z;//do some expensive thing</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    Z* veryExpensive;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>例子六，避免无用计算。</strong><br>比如，很多时候memset并不是必须的，那么就应该避免，尤其memset大块内存的时候。类中对成员的默认构造函数调用有的时候也是浪费，应该使用成员初始化列表。这种情况，应该还有很多其它的例子。</p><p><strong>例子七，删除已经失效的代码。</strong><br>已经失效的代码是只不会再使用的代码，你应该将其删除掉，否则那些代码还是会造成性能损失。</p><p>总之，设计上面的优化是个太难的题目了，我觉得这本书上面很多例子都有点和代码上的优化重复了。不过，性能和灵活性确实是相反的方向，有的时候牺牲灵活性是非常必须的。&lt;/pre&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++的代码优化</title>
      <link href="/2012/12/13/C++%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
      <url>/2012/12/13/C++%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>代码优化这种东西，肯定是经验之谈，即使你对代码的执行细节理解的很清楚，没有实际的经验体会也不会对之有多大的感觉。看书本人虽然觉得是揠苗助长，但是这估计就类似于打疫苗吧。要是艾滋有疫苗现在估计就没有世界艾滋日了。所以，看看书打打疫苗还是很有好处的。<br>代码优化很多就是些避免冗余计算，但是场合不同，有些可能你都从没有考虑过需要这样的优化。我打算把我从提高c++性能的编程技术上面看到的代码优化总结一下，随便扯几下。</p><p><strong>例子一，用缓存计算结果优化循环。</strong></p><p>原始代码，<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (...; !done; ...) done = patternMatch(pat1, pat2, isCaseSenstive());</span><br></pre></td></tr></table></figure><br>优化代码,<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool isSenstive = isCaseSenstive();</span><br><span class="line">for (...; !done; ...) done = patternMatch(pat1, pat2, isSenstive);</span><br></pre></td></tr></table></figure><br>这个例子比较简单，一般情况大家都能优化循环，去掉循环内部的重复的函数调用和计算等。</p><p><strong>例子二，预先计算某些结果以优化后面的计算。</strong><br>比如，你需要将一个字符串转换为大写的，你是对字符串循环一次，循环内部调用toupper了，还是预先计算出toupper的结果，以后每次查表了。<br>优化后的代码应该是类似于这样的。<br>for (char<em> p = header; </em>p; ++p)  <em>p = uppercaseTable[</em>p];<br>你所需要做的就是在初始化时候构造出uppercaseTable这张大小为256的表，如果你需要经常做大写转换无疑能不错的提高性能。</p><p><strong>例子三，降低灵活性来换取速度。</strong><br>书上只举了一个例子，为ip地址分配内存。我们知道ip4的地址不会超过15个字节，即使ip6的地址也不是很长。如果每次，我们动态分配内存去容纳地址，这肯定是非常浪费的事情。如果你需要容纳的地址数目是有限的，那么我们完全可以静态分配数组来容纳地址。全局new和delete的操作是非常昂贵的，这不仅仅在堆内存分配过程的复制上，线程同步机制也消耗了很多cpu周期。这只是个小小的例子而已，灵活性有的时候根本没必要。</p><p><strong>例子四，用80-20规则优化常用代码路径速度。</strong><br>这个例子的内容说起来比较麻烦，其实就是利用c语言的短路逻辑判断，执行较少的代码。<br>比如，if (e1 || e2)和if (e1  e2)这样的代码。通过，优化可以提高速度。<br>假设c1为e1执行的代价，p1为e1为真的概率，c2为e1执行的代价，p2为e2为真的概率。<br>那么可以计算出if (e1 || e2)的代价期望，同样可以计算出if (e2 || e1)的代价期望，选择较小的即可了。</p><p><strong>例子五，延迟计算。</strong><br>有些计算你可能并不需要，那么就请等到你真正需要的时候再计算吧。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int route(Msg* msg)</span><br><span class="line">&#123;</span><br><span class="line">ExpensiveClass upstream(msg);</span><br><span class="line"><span class="keyword">if</span> (goingUpstream)</span><br><span class="line">&#123;</span><br><span class="line">...<span class="comment">//use upstream</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种代码明显应该把对象upstream的定义放在if内部，因为有些对象的构造和析构可能会花费很大代价。<br>不过，我好像记得有公司内部的代码规范禁止在构造函数和析构函数作有意义的初始化和释放，而是自己再写个Init和UnInit函数来代替构造函数和析构函数的本职作用。我也不知道哪样好点，如果是那样的话，本例子就对他们没有意义了。呵呵。</p><p><strong>例子六，去掉无用计算。</strong><br>例子的内容是用成员初始化列表代替成员的默认构造函数的调用，没有什么多说的。</p><p><strong>例子七，恰当利用系统的缓存机制。</strong><br>比如，下面结构体的定义。<br>struct X { int a; char b[4096]; int c;};<br>应该改成struct X { int a; int c;char b[4096]; };<br>原因是cpu缓存可能就128个字节，那么加载a的时候可能一次缓存了连在一起的128个字节。由于a和c之间距离比较远，那么c就不在缓存行里面了。如果，你需要再访问c就会造成缓存失败，就需要重新加载缓存。这种降低缓存命中率的事情确实不怎么好。但是，你也不知道编译器会不会调整内存结果，把a和c默认连在一起了。我觉得还是不要做这种假设吧，这完全是改变编程者的意图了。</p><p><strong>例子八，去掉没必要的堆内存使用，改为堆栈内存。</strong></p><p><strong>例子九，谨慎使用库。</strong><br>比如，string的使用很多情况就比默认的char数组慢很多。其内部七七八八的实现不知道做了多少工作了，而作为调用者可能你都不怎么清楚。就比如很多时候我们根部不需要线程同步，但是string的内部实行可能考虑了线程同步，那么对于我们这完全就是个浪费了。string.h内部的那些字符串操作函数，应该是没有考虑线程同步的，这个时候显然就快很多了。</p><p><strong>例子十，请打开编译器优化选项。</strong><br>因为很多编译器优化选项不是默认打开的，如果你没有打开，那么编译器是不可能为你做全力的优化的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用计数</title>
      <link href="/2012/12/11/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>/2012/12/11/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>引用计数说得直接点就是不同的对象内部共享同样的内容(内存)，同时对象能够自己跟踪自己被引用多少次，能够在没有被继续引用的时候删除自己，保证了没有内存泄漏的出现。看起来貌似java里面的垃圾回收机制了。很多事物都有两面性，引用计数也不例外。看起来牛逼的东西必然有它的弱点，总有一些地方它比不过最原始的东西。</p><p>书上说了两种极端的情况，一种是大量的对象共享少数的相同的内容，一种是同样的内容只被共享少数几次，也就是基本没多少共享。显然前者是利用引用计数的典型情况。一般来说，下面的一些条件有利于引用计数的使用。比如说，<strong>目标对象消耗大量的资源;资源的分配和释放很昂贵;高度共享:由于使用复制构造函数和赋值操作符,所以引用计数可能比较大;引用的创建和清除相对低廉</strong>。如果程序中出现大量的对象创建和释放的操作，使用引用计数的效果反而会更差，而出现大量的对象的赋值操作则适合于引用计数的使用。</p><p>一般来说主要有两种实现方式。一种是你能够修改目标类的代码的情况，一种是你不能够得到目标类代码的情况。另外，还有给这些实现加上线程同步的情况。我分别实现了相关的代码，你也可以从提高c++性能的编程计数上面找到相关的代码。</p><p>情况1的类设计图如下，</p><p><img class="alignnone" width="705" height="516" data-src="https://c2.staticflickr.com/8/7002/27173455820_014459aefd_o.png"></p><p>从类设计图中可以看到要实现一个引用计数需要额外的三个类。RCObject是存储引用计数变量的基类，RCPtr是一个智能指针类，RCBigInt类里面包含一个RCPtr成员，该类相当于BigInt的代理类，和BigInt向外提供同样的接口。BigInt的实现稍微复杂了点，你也可以用任何简单的类替换它。</p><p>代码如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class RCObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void addReference()</span><br><span class="line">    &#123;</span><br><span class="line">        ++refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    void removeReference()</span><br><span class="line">    &#123;</span><br><span class="line">        if(--refCount == 0) delete this;</span><br><span class="line">    &#125;</span><br><span class="line">    void markUnshareable()</span><br><span class="line">    &#123;</span><br><span class="line">        shareable = false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShareable() const</span><br><span class="line">    &#123;</span><br><span class="line">        return shareable;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShared() const</span><br><span class="line">    &#123;</span><br><span class="line">        return refCount &gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int refCount;</span><br><span class="line">    bool shareable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BigInt : public RCObject</span><br><span class="line">&#123;</span><br><span class="line">    friend BigInt operator+(const BigInt, const BigInt);</span><br><span class="line">public:</span><br><span class="line">    BigInt(const char*);</span><br><span class="line">    BigInt(unsigned u = 0);</span><br><span class="line">    BigInt(const BigInt);</span><br><span class="line">    BigInt operator=(const BigInt);</span><br><span class="line">    BigInt operator+=(const BigInt);</span><br><span class="line">    ~BigInt()</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* getDigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned getNdigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* digits;</span><br><span class="line">    unsigned ndigits;</span><br><span class="line">    unsigned size;</span><br><span class="line">    BigInt(const BigInt, const BigInt);</span><br><span class="line">    char fetch(unsigned i) const</span><br><span class="line">    &#123;</span><br><span class="line">        return i &lt; ndigits ? digits[i] : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = "0";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = ndigits = strlen(s);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = s[ndigits - 1 - i] - '0';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(unsigned u)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned v = u;</span><br><span class="line"></span><br><span class="line">    for (ndigits = 1; v /= 10; ++ndigits);</span><br><span class="line">    digits = new char[size = ndigits];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = u % 10;</span><br><span class="line">        u /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt copyFrom)</span><br><span class="line">&#123;</span><br><span class="line">    size = ndigits = copyFrom.ndigits;</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = copyFrom.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator+=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned max = 1 + (rhs.ndigits &gt; ndigits ? rhs.ndigits : ndigits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        char* d = new char[size = max];</span><br><span class="line">        for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[i] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete [] digits;</span><br><span class="line">        d = digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (ndigits &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[ndigits++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] += rhs.fetch(i);</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] -= 10;</span><br><span class="line">            digits[i + 1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digits[ndigits - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    size = 1 + (left.ndigits &gt; right.ndigits ? left.ndigits : right.ndigits);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    ndigits = left.ndigits;</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = left.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *this += <span class="attribute">right</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline BigInt operator+(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return BigInt(<span class="attribute">left</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    if (this == rhs) return *this;</span><br><span class="line"></span><br><span class="line">    ndigits = rhs.ndigits;</span><br><span class="line">    <span class="keyword">if</span> (ndigits &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] this;</span><br><span class="line">        digits = new char[size = ndigits];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = rhs.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream operator&lt;&lt;(ostream os, BigInt bi)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    const char* d = bi.getDigits();</span><br><span class="line"></span><br><span class="line">    for (int i = bi.getNdigits() - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        c = d[i] + '0';</span><br><span class="line">        os &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; class RCPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    RCPtr(T* realPtr = NULL) : pointee(realPtr) &#123; Init(); &#125;</span><br><span class="line">    RCPtr(const RCPtr rhs) : pointee(rhs.pointee) &#123; Init(); &#125;</span><br><span class="line">    ~RCPtr() &#123; if (pointee) pointee-&gt;removeReference(); &#125;</span><br><span class="line">    T* operator-&gt;() const &#123; return pointee; &#125;</span><br><span class="line">    T operator*() const &#123; return * pointee; &#125;</span><br><span class="line">    RCPtr operator=(const RCPtr rhs);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    T* pointee;</span><br><span class="line">    void Init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void RCPtr&lt;T&gt;::Init()</span><br><span class="line">&#123;</span><br><span class="line">    if (pointee == 0) return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pointee-&gt;isShareable() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        pointee = new T(*pointee);</span><br><span class="line">    &#125;</span><br><span class="line">    pointee-&gt;addReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; RCPtr&lt;T&gt; RCPtr&lt;T&gt;::operator=(const RCPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee != rhs.pointee)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pointee) pointee-&gt;removeReference();</span><br><span class="line">        pointee = rhs.pointee;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RCBigInt</span><br><span class="line">&#123;</span><br><span class="line">    friend RCBigInt operator+(const RCBigInt, const RCBigInt);</span><br><span class="line">public:</span><br><span class="line">    RCBigInt(const char* p) : value(new BigInt(p)) &#123;&#125;</span><br><span class="line">    RCBigInt(unsigned u = <span class="number">0</span>) : value(new BigInt(u)) &#123;&#125;</span><br><span class="line">    RCBigInt(const BigInt bi) : value(new BigInt(bi)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RCPtr&lt;BigInt&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline RCBigInt operator+(const RCBigInt <span class="attribute">left</span>, const RCBigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return RCBigInt(*(left.value) + *(right.value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        BigInt a = i;</span><br><span class="line">        BigInt b = i + 1;</span><br><span class="line">        BigInt c = i + 2;</span><br><span class="line">        BigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        RCBigInt a = i;</span><br><span class="line">        RCBigInt b = i + 1;</span><br><span class="line">        RCBigInt c = i + 2;</span><br><span class="line">        RCBigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntAssign:%d\n", n);</span><br><span class="line">    BigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntAssign:%d\n", n);</span><br><span class="line">    RCBigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int NUM = 1000000;</span><br><span class="line"></span><br><span class="line">    TestBigIntCreate(NUM);</span><br><span class="line">    TestRCBigIntCreate(NUM);</span><br><span class="line">    TestBigIntAssign(NUM);</span><br><span class="line">    TestRCBigIntAssign(NUM);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img class="alignnone" width="428" height="216" data-src="https://c2.staticflickr.com/8/7676/27415822646_2d2fc50e5e_o.png"></p><p>情况2的类设计图如下所示，</p><p><img class="alignnone" width="718" height="661" data-src="https://c2.staticflickr.com/8/7285/27415824336_727646888b_o.png"></p><p>从图中可以看到，由于无法修改BigInt的实现，引入了一个新类CounterHolder作为引用计数的中间类。该类继承自RCObject，智能指针类RCIPtr包含一个CounterHolder的指针，而CounterHolder里面才包含一个BigInt的指针。<br>这就相当于多了一次间接操作，因此在RCIBigInt的创建和删除操作中会增加时间，这可以从运行结果中可以看到。</p><p>代码如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class RCObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void addReference()</span><br><span class="line">    &#123;</span><br><span class="line">        ++refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    void removeReference()</span><br><span class="line">    &#123;</span><br><span class="line">        if(--refCount == 0) delete this;</span><br><span class="line">    &#125;</span><br><span class="line">    void markUnshareable()</span><br><span class="line">    &#123;</span><br><span class="line">        shareable = false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShareable() const</span><br><span class="line">    &#123;</span><br><span class="line">        return shareable;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShared() const</span><br><span class="line">    &#123;</span><br><span class="line">        return refCount &gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int refCount;</span><br><span class="line">    bool shareable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BigInt</span><br><span class="line">&#123;</span><br><span class="line">    friend BigInt operator+(const BigInt, const BigInt);</span><br><span class="line">public:</span><br><span class="line">    BigInt(const char*);</span><br><span class="line">    BigInt(unsigned u = 0);</span><br><span class="line">    BigInt(const BigInt);</span><br><span class="line">    BigInt operator=(const BigInt);</span><br><span class="line">    BigInt operator+=(const BigInt);</span><br><span class="line">    ~BigInt()</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* getDigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned getNdigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* digits;</span><br><span class="line">    unsigned ndigits;</span><br><span class="line">    unsigned size;</span><br><span class="line">    BigInt(const BigInt, const BigInt);</span><br><span class="line">    char fetch(unsigned i) const</span><br><span class="line">    &#123;</span><br><span class="line">        return i &lt; ndigits ? digits[i] : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = "0";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = ndigits = strlen(s);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = s[ndigits - 1 - i] - '0';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(unsigned u)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned v = u;</span><br><span class="line"></span><br><span class="line">    for (ndigits = 1; v /= 10; ++ndigits);</span><br><span class="line">    digits = new char[size = ndigits];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = u % 10;</span><br><span class="line">        u /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt copyFrom)</span><br><span class="line">&#123;</span><br><span class="line">    size = ndigits = copyFrom.ndigits;</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = copyFrom.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator+=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned max = 1 + (rhs.ndigits &gt; ndigits ? rhs.ndigits : ndigits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        char* d = new char[size = max];</span><br><span class="line">        for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[i] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete [] digits;</span><br><span class="line">        d = digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (ndigits &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[ndigits++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] += rhs.fetch(i);</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] -= 10;</span><br><span class="line">            digits[i + 1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digits[ndigits - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    size = 1 + (left.ndigits &gt; right.ndigits ? left.ndigits : right.ndigits);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    ndigits = left.ndigits;</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = left.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *this += <span class="attribute">right</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline BigInt operator+(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return BigInt(<span class="attribute">left</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    if (this == rhs) return *this;</span><br><span class="line"></span><br><span class="line">    ndigits = rhs.ndigits;</span><br><span class="line">    <span class="keyword">if</span> (ndigits &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] this;</span><br><span class="line">        digits = new char[size = ndigits];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = rhs.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream operator&lt;&lt;(ostream os, BigInt bi)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    const char* d = bi.getDigits();</span><br><span class="line"></span><br><span class="line">    for (int i = bi.getNdigits() - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        c = d[i] + '0';</span><br><span class="line">        os &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; class RCIPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    RCIPtr(T* realPtr = NULL) : counter(new CountHolder)</span><br><span class="line">    &#123;</span><br><span class="line">        counter-&gt;pointee = realPtr;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line">    RCIPtr(const RCIPtr rhs) : counter(rhs.counter) &#123; Init(); &#125;</span><br><span class="line">    ~RCIPtr() &#123; if (counter) counter-&gt;removeReference(); &#125;</span><br><span class="line">    T* operator-&gt;() const &#123; return counter-&gt;pointee; &#125;</span><br><span class="line">    T operator*() const &#123; return *(counter-&gt;pointee); &#125;</span><br><span class="line">    RCIPtr operator=(const RCIPtr rhs);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    struct CountHolder : public RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        ~CountHolder() &#123; delete pointee; &#125;</span><br><span class="line">        T* pointee;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CountHolder* counter;</span><br><span class="line">    void Init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void RCIPtr&lt;T&gt;::Init()</span><br><span class="line">&#123;</span><br><span class="line">    if (counter == 0) return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;isShareable() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = new CountHolder;</span><br><span class="line">        counter-&gt;pointee = new T(*counter-&gt;pointee);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    counter-&gt;addReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; RCIPtr&lt;T&gt; RCIPtr&lt;T&gt;::operator=(const RCIPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter != rhs.counter)</span><br><span class="line">    &#123;</span><br><span class="line">        if (counter) counter-&gt;removeReference();</span><br><span class="line">        counter = rhs.counter;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RCBigInt</span><br><span class="line">&#123;</span><br><span class="line">    friend RCBigInt operator+(const RCBigInt, const RCBigInt);</span><br><span class="line">public:</span><br><span class="line">    RCBigInt(const char* p) : value(new BigInt(p)) &#123;&#125;</span><br><span class="line">    RCBigInt(unsigned u = <span class="number">0</span>) : value(new BigInt(u)) &#123;&#125;</span><br><span class="line">    RCBigInt(const BigInt bi) : value(new BigInt(bi)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RCIPtr&lt;BigInt&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline RCBigInt operator+(const RCBigInt <span class="attribute">left</span>, const RCBigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return RCBigInt(*(left.value) + *(right.value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        BigInt a = i;</span><br><span class="line">        BigInt b = i + 1;</span><br><span class="line">        BigInt c = i + 2;</span><br><span class="line">        BigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        RCBigInt a = i;</span><br><span class="line">        RCBigInt b = i + 1;</span><br><span class="line">        RCBigInt c = i + 2;</span><br><span class="line">        RCBigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntAssign:%d\n", n);</span><br><span class="line">    BigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntAssign:%d\n", n);</span><br><span class="line">    RCBigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int NUM = 1000000;</span><br><span class="line"></span><br><span class="line">    TestBigIntCreate(NUM);</span><br><span class="line">    TestRCBigIntCreate(NUM);</span><br><span class="line">    TestBigIntAssign(NUM);</span><br><span class="line">    TestRCBigIntAssign(NUM);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img class="alignnone" width="419" height="208" data-src="https://c2.staticflickr.com/8/7155/27415823656_24fa42c5f4_o.png"></p><p>最后给出的是多线程版本的代码，在Windows下可以用临界区或者互斥体实现。互斥体实现的版本比较慢，但是临界区的版本为什么在gcc的release版本中运行出现内存错误了，而debug版本中没有问题，在vc6下运行也没有问题。</p><p>临界区版本代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class RCObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void addReference()</span><br><span class="line">    &#123;</span><br><span class="line">        ++refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    void removeReference()</span><br><span class="line">    &#123;</span><br><span class="line">        if(--refCount == 0) delete this;</span><br><span class="line">    &#125;</span><br><span class="line">    void markUnshareable()</span><br><span class="line">    &#123;</span><br><span class="line">        shareable = false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShareable() const</span><br><span class="line">    &#123;</span><br><span class="line">        return shareable;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShared() const</span><br><span class="line">    &#123;</span><br><span class="line">        return refCount &gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int refCount;</span><br><span class="line">    bool shareable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BigInt</span><br><span class="line">&#123;</span><br><span class="line">    friend BigInt operator+(const BigInt, const BigInt);</span><br><span class="line">public:</span><br><span class="line">    BigInt(const char*);</span><br><span class="line">    BigInt(unsigned u = 0);</span><br><span class="line">    BigInt(const BigInt);</span><br><span class="line">    BigInt operator=(const BigInt);</span><br><span class="line">    BigInt operator+=(const BigInt);</span><br><span class="line">    ~BigInt()</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* getDigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned getNdigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* digits;</span><br><span class="line">    unsigned ndigits;</span><br><span class="line">    unsigned size;</span><br><span class="line">    BigInt(const BigInt, const BigInt);</span><br><span class="line">    char fetch(unsigned i) const</span><br><span class="line">    &#123;</span><br><span class="line">        return i &lt; ndigits ? digits[i] : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = "0";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = ndigits = strlen(s);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = s[ndigits - 1 - i] - '0';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(unsigned u)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned v = u;</span><br><span class="line"></span><br><span class="line">    for (ndigits = 1; v /= 10; ++ndigits);</span><br><span class="line">    digits = new char[size = ndigits];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = u % 10;</span><br><span class="line">        u /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt copyFrom)</span><br><span class="line">&#123;</span><br><span class="line">    size = ndigits = copyFrom.ndigits;</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = copyFrom.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator+=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned max = 1 + (rhs.ndigits &gt; ndigits ? rhs.ndigits : ndigits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        char* d = new char[size = max];</span><br><span class="line">        for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[i] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete [] digits;</span><br><span class="line">        d = digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (ndigits &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[ndigits++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] += rhs.fetch(i);</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] -= 10;</span><br><span class="line">            digits[i + 1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digits[ndigits - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    size = 1 + (left.ndigits &gt; right.ndigits ? left.ndigits : right.ndigits);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    ndigits = left.ndigits;</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = left.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *this += <span class="attribute">right</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline BigInt operator+(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return BigInt(<span class="attribute">left</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    if (this == rhs) return *this;</span><br><span class="line"></span><br><span class="line">    ndigits = rhs.ndigits;</span><br><span class="line">    <span class="keyword">if</span> (ndigits &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] this;</span><br><span class="line">        digits = new char[size = ndigits];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = rhs.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream operator&lt;&lt;(ostream os, BigInt bi)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    const char* d = bi.getDigits();</span><br><span class="line"></span><br><span class="line">    for (int i = bi.getNdigits() - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        c = d[i] + '0';</span><br><span class="line">        os &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CriticalSectionLock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CriticalSectionLock()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CriticalSectionLock()</span><br><span class="line">    &#123;</span><br><span class="line">        DeleteCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">    void lock()</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">    void unlock()</span><br><span class="line">    &#123;</span><br><span class="line">        LeaveCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    CRITICAL_SECTION csMyCriticalSection;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename LOCK&gt; class RCIPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    RCIPtr(T* realPtr = NULL) : counter(new CountHolder)</span><br><span class="line">    &#123;</span><br><span class="line">        counter-&gt;pointee = realPtr;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line">    RCIPtr(const RCIPtr rhs) : counter(rhs.counter)</span><br><span class="line">    &#123;</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.lock();</span><br><span class="line">        Init();</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    ~RCIPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter)</span><br><span class="line">        &#123;</span><br><span class="line">            counter-&gt;key.lock();</span><br><span class="line">            counter-&gt;removeReference();</span><br><span class="line">            counter-&gt;key.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator-&gt;() const &#123; return counter-&gt;pointee; &#125;</span><br><span class="line">    T operator*() const &#123; return *(counter-&gt;pointee); &#125;</span><br><span class="line">    RCIPtr operator=(const RCIPtr rhs);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    struct CountHolder : public RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        ~CountHolder() &#123; delete pointee; &#125;</span><br><span class="line">        T* pointee;</span><br><span class="line">        LOCK key;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CountHolder* counter;</span><br><span class="line">    void Init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename LOCK&gt; void RCIPtr&lt;T, LOCK&gt;::Init()</span><br><span class="line">&#123;</span><br><span class="line">    if (counter == 0) return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;isShareable() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = new CountHolder;</span><br><span class="line">        counter-&gt;pointee = new T(*counter-&gt;pointee);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    counter-&gt;addReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename LOCK&gt;</span><br><span class="line">RCIPtr&lt;T, LOCK&gt; RCIPtr&lt;T, LOCK&gt;::operator=(const RCIPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter != rhs.counter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter)</span><br><span class="line">        &#123;</span><br><span class="line">            counter-&gt;key.lock();</span><br><span class="line">            counter-&gt;removeReference();</span><br><span class="line">            counter-&gt;key.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        counter = rhs.counter;</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.lock();</span><br><span class="line">        Init();</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RCBigInt</span><br><span class="line">&#123;</span><br><span class="line">    friend RCBigInt operator+(const RCBigInt, const RCBigInt);</span><br><span class="line">public:</span><br><span class="line">    RCBigInt(const char* p) : value(new BigInt(p)) &#123;&#125;</span><br><span class="line">    RCBigInt(unsigned u = <span class="number">0</span>) : value(new BigInt(u)) &#123;&#125;</span><br><span class="line">    RCBigInt(const BigInt bi) : value(new BigInt(bi)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RCIPtr&lt;BigInt, CriticalSectionLock&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline RCBigInt operator+(const RCBigInt <span class="attribute">left</span>, const RCBigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return RCBigInt(*(left.value) + *(right.value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        BigInt a = i;</span><br><span class="line">        BigInt b = i + 1;</span><br><span class="line">        BigInt c = i + 2;</span><br><span class="line">        BigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        RCBigInt a = i;</span><br><span class="line">        RCBigInt b = i + 1;</span><br><span class="line">        RCBigInt c = i + 2;</span><br><span class="line">        RCBigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntAssign:%d\n", n);</span><br><span class="line">    BigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntAssign:%d\n", n);</span><br><span class="line">    RCBigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int NUM = 1000000;</span><br><span class="line"></span><br><span class="line">    TestBigIntCreate(NUM);</span><br><span class="line">    TestRCBigIntCreate(NUM);</span><br><span class="line">    TestBigIntAssign(NUM);</span><br><span class="line">    TestRCBigIntAssign(NUM);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在vc6下的运行结果,</p><p><img class="alignnone" width="528" height="177" data-src="https://c2.staticflickr.com/8/7493/27415825776_1da59a6358_o.png"></p><p>从结果中可以看出RCIBigInt的赋值操作情况在性能上已经没有多少优势了，在vc6下反而更慢，这主要是因为线程同步操作的原因。</p><p>互斥体版本代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class RCObject</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void addReference()</span><br><span class="line">    &#123;</span><br><span class="line">        ++refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    void removeReference()</span><br><span class="line">    &#123;</span><br><span class="line">        if(--refCount == 0) delete this;</span><br><span class="line">    &#125;</span><br><span class="line">    void markUnshareable()</span><br><span class="line">    &#123;</span><br><span class="line">        shareable = false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShareable() const</span><br><span class="line">    &#123;</span><br><span class="line">        return shareable;</span><br><span class="line">    &#125;</span><br><span class="line">    bool isShared() const</span><br><span class="line">    &#123;</span><br><span class="line">        return refCount &gt; 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int refCount;</span><br><span class="line">    bool shareable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BigInt</span><br><span class="line">&#123;</span><br><span class="line">    friend BigInt operator+(const BigInt, const BigInt);</span><br><span class="line">public:</span><br><span class="line">    BigInt(const char*);</span><br><span class="line">    BigInt(unsigned u = 0);</span><br><span class="line">    BigInt(const BigInt);</span><br><span class="line">    BigInt operator=(const BigInt);</span><br><span class="line">    BigInt operator+=(const BigInt);</span><br><span class="line">    ~BigInt()</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char* getDigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned getNdigits() const</span><br><span class="line">    &#123;</span><br><span class="line">        return ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    char* digits;</span><br><span class="line">    unsigned ndigits;</span><br><span class="line">    unsigned size;</span><br><span class="line">    BigInt(const BigInt, const BigInt);</span><br><span class="line">    char fetch(unsigned i) const</span><br><span class="line">    &#123;</span><br><span class="line">        return i &lt; ndigits ? digits[i] : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const char* s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = "0";</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = ndigits = strlen(s);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = s[ndigits - 1 - i] - '0';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(unsigned u)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned v = u;</span><br><span class="line"></span><br><span class="line">    for (ndigits = 1; v /= 10; ++ndigits);</span><br><span class="line">    digits = new char[size = ndigits];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = u % 10;</span><br><span class="line">        u /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt copyFrom)</span><br><span class="line">&#123;</span><br><span class="line">    size = ndigits = copyFrom.ndigits;</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = copyFrom.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator+=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned max = 1 + (rhs.ndigits &gt; ndigits ? rhs.ndigits : ndigits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        char* d = new char[size = max];</span><br><span class="line">        for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            d[i] = digits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        delete [] digits;</span><br><span class="line">        d = digits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (ndigits &lt; max)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[ndigits++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] += rhs.fetch(i);</span><br><span class="line">        <span class="keyword">if</span> (digits[i] &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] -= 10;</span><br><span class="line">            digits[i + 1]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digits[ndigits - <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        --ndigits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::BigInt(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    size = 1 + (left.ndigits &gt; right.ndigits ? left.ndigits : right.ndigits);</span><br><span class="line">    digits = new char[size];</span><br><span class="line">    ndigits = left.ndigits;</span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = left.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *this += <span class="attribute">right</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline BigInt operator+(const BigInt <span class="attribute">left</span>, const BigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return BigInt(<span class="attribute">left</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::operator=(const BigInt rhs)</span><br><span class="line">&#123;</span><br><span class="line">    if (this == rhs) return *this;</span><br><span class="line"></span><br><span class="line">    ndigits = rhs.ndigits;</span><br><span class="line">    <span class="keyword">if</span> (ndigits &gt; size)</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] this;</span><br><span class="line">        digits = new char[size = ndigits];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (unsigned i = 0; i &lt; ndigits; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        digits[i] = rhs.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream operator&lt;&lt;(ostream os, BigInt bi)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    const char* d = bi.getDigits();</span><br><span class="line"></span><br><span class="line">    for (int i = bi.getNdigits() - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        c = d[i] + '0';</span><br><span class="line">        os &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MutexLock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MutexLock()</span><br><span class="line">    &#123;</span><br><span class="line">        hMutex = CreateMutex(NULL, FALSE, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    ~MutexLock()</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    void lock()</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">    &#125;</span><br><span class="line">    void unlock()</span><br><span class="line">    &#123;</span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    HANDLE hMutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename LOCK&gt; class RCIPtr</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    RCIPtr(T* realPtr = NULL) : counter(new CountHolder)</span><br><span class="line">    &#123;</span><br><span class="line">        counter-&gt;pointee = realPtr;</span><br><span class="line">        Init();</span><br><span class="line">    &#125;</span><br><span class="line">    RCIPtr(const RCIPtr rhs) : counter(rhs.counter)</span><br><span class="line">    &#123;</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.lock();</span><br><span class="line">        Init();</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    ~RCIPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter)</span><br><span class="line">        &#123;</span><br><span class="line">            counter-&gt;key.lock();</span><br><span class="line">            counter-&gt;removeReference();</span><br><span class="line">            counter-&gt;key.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T* operator-&gt;() const &#123; return counter-&gt;pointee; &#125;</span><br><span class="line">    T operator*() const &#123; return *(counter-&gt;pointee); &#125;</span><br><span class="line">    RCIPtr operator=(const RCIPtr rhs);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    struct CountHolder : public RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        ~CountHolder() &#123; delete pointee; &#125;</span><br><span class="line">        T* pointee;</span><br><span class="line">        LOCK key;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CountHolder* counter;</span><br><span class="line">    void Init();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename LOCK&gt; void RCIPtr&lt;T, LOCK&gt;::Init()</span><br><span class="line">&#123;</span><br><span class="line">    if (counter == 0) return;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counter-&gt;isShareable() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        counter = new CountHolder;</span><br><span class="line">        counter-&gt;pointee = new T(*counter-&gt;pointee);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    counter-&gt;addReference();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename LOCK&gt;</span><br><span class="line">RCIPtr&lt;T, LOCK&gt; RCIPtr&lt;T, LOCK&gt;::operator=(const RCIPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (counter != rhs.counter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter)</span><br><span class="line">        &#123;</span><br><span class="line">            counter-&gt;key.lock();</span><br><span class="line">            counter-&gt;removeReference();</span><br><span class="line">            counter-&gt;key.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        counter = rhs.counter;</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.lock();</span><br><span class="line">        Init();</span><br><span class="line">        if (rhs.counter) rhs.counter-&gt;key.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RCBigInt</span><br><span class="line">&#123;</span><br><span class="line">    friend RCBigInt operator+(const RCBigInt, const RCBigInt);</span><br><span class="line">public:</span><br><span class="line">    RCBigInt(const char* p) : value(new BigInt(p)) &#123;&#125;</span><br><span class="line">    RCBigInt(unsigned u = <span class="number">0</span>) : value(new BigInt(u)) &#123;&#125;</span><br><span class="line">    RCBigInt(const BigInt bi) : value(new BigInt(bi)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    RCIPtr&lt;BigInt, MutexLock&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline RCBigInt operator+(const RCBigInt <span class="attribute">left</span>, const RCBigInt right)</span><br><span class="line">&#123;</span><br><span class="line">    return RCBigInt(*(left.value) + *(right.value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        BigInt a = i;</span><br><span class="line">        BigInt b = i + 1;</span><br><span class="line">        BigInt c = i + 2;</span><br><span class="line">        BigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntCreate(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntCreate:%d\n", n);</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        RCBigInt a = i;</span><br><span class="line">        RCBigInt b = i + 1;</span><br><span class="line">        RCBigInt c = i + 2;</span><br><span class="line">        RCBigInt d = i + 3;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestBigIntAssign:%d\n", n);</span><br><span class="line">    BigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestRCBigIntAssign(int n)</span><br><span class="line">&#123;</span><br><span class="line">    printf("TestRCBigIntAssign:%d\n", n);</span><br><span class="line">    RCBigInt a, b, c, d;</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = c = d;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int NUM = 1000000;</span><br><span class="line"></span><br><span class="line">    TestBigIntCreate(NUM);</span><br><span class="line">    TestRCBigIntCreate(NUM);</span><br><span class="line">    TestBigIntAssign(NUM);</span><br><span class="line">    TestRCBigIntAssign(NUM);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在codeblocks配gcc的环境下的运行结果，<br><img class="alignnone" width="470" height="223" data-src="https://c2.staticflickr.com/8/7396/27415825146_64a6ce6302_o.png"></p><p>从图里面还是能看到，在Windows下用互斥体同步确实比较慢。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用STL容器的一些常识</title>
      <link href="/2012/11/28/%E4%BD%BF%E7%94%A8STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%AF%86/"/>
      <url>/2012/11/28/%E4%BD%BF%E7%94%A8STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>stl这种东西这几年确实用得不少了，大一暑假刚开始看c++primer的时候就知道有这么个东西，当时觉得非常神奇的样子。不过，我用stl最多的地方还是在做acm的一些题目的时候。很多时候为了方便，为了代码简洁性就用stl了。我还是比较喜欢stl这个东西的。</p><p>我只打算讲点简单的东西。比如大致的实现原理和使用的一些注意情况，另外讲下我对迭代器失效的理解。</p><p>vector是一个动态数组，既然是数组，那么在末尾增加和删除是很快的，复杂度是O(1)。但是，在其它位置增加和删除复杂度就跟位置有关系了，复杂度是O(n)。默认情况对vector的查找是不会应用二分的，所以你用stl里面的find查找复杂度也是O(n)。当vector的容量大小需要经常改变时候，你可以预估计容量的最大大小，然后调用reserve函数预分配一块大内存，这样就可以避免频繁的内存分配释放造成的性能损失了。</p><p>deque类似于vector。但是在头部增加和删除复杂度也是O(1)，不过我没看过stl的实现，也不知道为什么。</p><p>list的内部实现大概是双向链表。那么在任意位置的插入和删除复制度都是O(1)。对于查找的话，虽然理论复杂度也是O(n)。不过，list的查找肯定会比vector慢的，因为多了一次取地址的间接操作。而且，数组因为地址是连续的，可以来个地址的缓存。</p><p>set和map内部是用红黑树实现的。红黑树也就是一棵平衡查找树吧，大家都学过二叉平衡树，红黑树大概类似这种东西。算法导论里面有对红黑树的详细介绍，不过看得让我很头晕，而且我也不想去实现一个红黑树，光是二叉平衡树的旋转已经很无语了。反正红黑树类似二叉平衡查找树就行了。那么，红黑树的插入删除都可能改变原有结点的位置之间的关系，意思是不仅仅是破坏或者增加一个结点的位置。但是原有结点的地址肯定是没有变化的。增删查改的复杂度都是log(n)。还有，对set和map的查找要应用容器内部的成员函数find，而不是全局的stl函数find。前者是二分查找，而后者是顺序查找。</p><p>下面我讲讲我对stl迭代器失效的理解。其实，大致知道了stl容器的实现，这个问题就很好理解了。</p><p>vector是动态数组，那么插入和删除元素都会改变该元素后面元素的地址，那么先前获取的指向后面位置元素的迭代器就会失效了。而且即使你插入在最后，也可能使所有的迭代器失效，因为可能这个时候刚好vector必须增加容量来容纳你新插入的元素了。你再访问这些迭代器的话，不是访问到错误的内容就是内存错误了。</p><p>list的话，由于结点是孤立的，是用指针把所有结点串起来的，那么原有结点的地址一直都不会改变。只要不对结点进行了删除，那么原来获取的迭代器就不会失效。但是，++和—的结果可能会和原来不一致的。</p><p>deque类似于vector吧。不过，我还是不是很清楚。</p><p>set和map的话，类似于list。<strong>它们的结点地址也一直不会变化，但是插入和删除会改变整棵树的布局，所以原来的迭代器++或者—之后可能就会指向乱七八糟的东西了</strong>。但是，你获取原来的元素还是可以的。</p><p>总之，对容器进行插入和删除之后一定要注意迭代器失效的情况，最好是从写法上避免这种可能性吧，而不是利用迭代器不失效的可能性。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于函数内联的一些理解</title>
      <link href="/2012/11/22/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
      <url>/2012/11/22/%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>最近在看提高C++性能的编程技术一书，居然发现里面有三章是专门讲述内联的。看来内联在作者心中占据了非常重要的位置，内联在作者心里是最有效的改进性能的策略了。</p><p>阅读完这三章内容之后，我对内联的理解更加模糊了。因为到最后作者也说你内联性能不一定变好，你不内联性能也不一定变坏。能跟内联牵扯上关系的东西太多了。</p><p>我记得有人曾经问过我这个问题，内联和宏替换的区别是什么。当时我还是大三的时候，准备找个实习，是电面的时候被别人问到的。还是国内著名的IT企业，我就这样的水水的跟人家乱扯。现在回忆起来我好像什么也没说出来的样子。说实话，我那个时候感觉内联和宏替换区别不大，一样的对待也没什么大不了的。第三次电面的时候我就彻底悲剧了，最主要的原因还是因为C++功底不扎实。想想那个时候也挺可爱的，把简历写的那么好笑那么烂，他们居然也给我机会进到最后一轮。最后一轮我实在表现的太烂了。</p><p>那么区别到底是什么了。我说说现在的理解吧。首先，宏替换不能算编译器的时候，应该算预处理器的工作，而<strong>内联属于编译器的工作</strong>，阶段都不同了。其次，宏替换很白痴就是简单的应用些规则进行代码替换而已，而内联是很高级的功能吧，inline只是对编译器的指示，内联不内联是编译器自己的决定，有可能你不写inline函数也被内联了，不过我觉得可能性比较小，而且内联不仅仅是在调用位置替换上被调用函数的代码，<strong>编译器还会对替换之后的新代码整个进行优化，也就是能够跨越函数调用进行优化</strong>，这一点据说是内联提高性能的关键。最后，宏的可读性很差，什么机制都没有，而内联就不同，函数还是函数，参数和返回类型，<strong>编译器对函数的检查等等都还在</strong>，而宏就没有这些优待。我能说出来的也就这么些了。。。</p><p>关于什么是内联的话应该就不需要我进行解释了。内联能避免函数调用的代价这一点也不需要解释了。函数调用的代价说简单点就是保存现场，主要是一些寄存器的内容，一般会把这些寄存器的内容压栈保存起来，还有就是传递参数，参数的传递是通过改变堆栈指针达到的。函数调用完成之后还需要恢复现场，就是从栈里面恢复一些寄存器的内容，还有恢复原来的栈指针。但是，具体起来函数调用需要做些什么还是比较难说清楚的，不同的体系结构做的事情都不一样，再说写c++代码的时候谁又想过多的考虑底层具体发生了什么了。</p><p>那么来思考下为什么要使用内联和为什么又不要使用内联吧。大家都知道函数调用会造成一定的代价，既然内联可以避免这个代价那么为什么我们不用内联了。好吧，那么我们就用内联把函数调用的代价消去。那么为什么我们只内联比较小的函数了，而超过一定规模的函数就不内联了。首先，如果一个函数规模较大，那么函数调用的代价在整个代价里面的比例就较小了。其次，内联较大规模的函数会造成编译后的二进制代码增大，如果函数非叶子位置函数(只会被别的函数调用的函数)那么这个可能性更大，很可能就会到达无法忍受的地步，内联造成编译时间变长也是一方面。最后，内联也会损失某种性能，比如<strong>缓存和页交换</strong>之类的，如果是函数调用，机器可以运用指令和数据缓存之类的，但是如果是内联，那么不同的调用位置其在映像里面的位置是不一样的，那么机器是不会缓存的。所以，内联也不是能随便用的。</p><p>其实说了这么多了，我们还是不知道什么时候该内联什么时候不该内联。我们只了解到，如果函数足够小就内联吧，那么小的标准是什么，代码五行以内没有循环？什么时候不该内联，函数规模太大了？反正内联是一件太纠结的事情了，有可能你用编译器测试一下内联和不内联性能是没有变化的，因为可能编译器在幕后就内联了。</p><p>根据我所看的这本书的说法，我有一些建议。对<strong>少于五行的代码和调用频率大于80%的函数</strong>一定内联，其余的你还是仔细考虑下吧。你可以再分解调用频率大于80%的函数，使其规模变小，然后再考虑是否内联它。其实，这本书的思想还是对整个系统进行测试之后才进行内联选择，毕竟性能优化也是最后阶段的事情。你需要找出系统执行的关键路径，其实也就是执行频率最高的一些函数，根据整个系统的流程图，你就会发现<strong>一条系统执行频率最高的路径</strong>，内联应该只发生在这条路径上面。</p><p>好了，这就是我对内联的一些理解，这本书关于内联的内容实在太多了，我觉得还是下次再写一篇文章扯扯吧。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程内存池</title>
      <link href="/2012/11/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%B1%A0/"/>
      <url>/2012/11/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>如果一个内存池需要线程同步了，估计和默认的内存操作也差不了多远了。现在对内存操作的优化只是在优化线程同步操作上面了。默认的lock和unlock可能实现得过于完美，因而要求更多的cpu周期。如果选择更原子的lock和unlock实现，还是可以加快内存操作的速度的。</p><p>多线程内存池在实现上也就是在申请和释放外面包裹了一对加锁和解锁操作而已。</p><p>如果我们采用模板编程，就可以实现一个功能强悍的模板类，该模板类有两个参数，单线程内存池和锁。这样的话，可以组合出很多情况。比如说，单线程内存池有对象大小固定和不固定两种实现，锁在Windows下可以用临界区，互斥体，信号量，事件实现。这样最多可以组合出8种不同的实例化。</p><p>一般说来互斥体比临界区慢很多，在这里可以进行很好的测试。我实现了临界区和互斥体版本的锁，经过测试发现前者比后者快30多倍。因为互斥体据说是内核对象，而临界区是用户态对象，那么互斥体的使用就需要系统在用户态和内核态之间进行切换，肯定会消耗更多的时间。</p><p>互斥体版本代码如下，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; class MemoryPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MemoryPool(size_t size = EXPANSION_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        expandTheFreeList(size);</span><br><span class="line">    &#125;</span><br><span class="line">    ~MemoryPool();</span><br><span class="line">    <span class="comment">//allocate a T element from the free list.</span></span><br><span class="line">    void* alloc(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (next == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            expandTheFreeList();</span><br><span class="line">        &#125;</span><br><span class="line">        MemoryPool&lt;T&gt;* head = next;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return a T element to the free list.</span></span><br><span class="line">    void free(void* doomed)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryPool&lt;T&gt;* head = static_cast&lt; MemoryPool&lt;T&gt;* &gt; (doomed);</span><br><span class="line">        head-&gt;next = next;</span><br><span class="line">        next = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">//next element on the free list.</span></span><br><span class="line">    MemoryPool&lt;T&gt;* next;</span><br><span class="line">    <span class="comment">//if the freelist is empty, expand it by this amount.</span></span><br><span class="line">    enum &#123;EXPANSION_SIZE = 32&#125;;</span><br><span class="line">    <span class="comment">//add free elements to the free list</span></span><br><span class="line">    void expandTheFreeList(int howMany = EXPANSION_SIZE);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; MemoryPool&lt;T&gt; :: ~MemoryPool()</span><br><span class="line">&#123;</span><br><span class="line">    MemoryPool&lt;T&gt;* nextPtr = NULL;</span><br><span class="line">    while (nextPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        nextPtr = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">        delete [] nextPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void MemoryPool&lt;T&gt; :: expandTheFreeList(int howMany)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//we must allocate an object enough to contain the next pointer</span></span><br><span class="line">    size_t size = sizeof(T) &gt; sizeof(MemoryPool&lt;T&gt;*) ? sizeof(T) :</span><br><span class="line">                  sizeof(MemoryPool&lt;T&gt;*);</span><br><span class="line"></span><br><span class="line">    MemoryPool&lt;T&gt;* runner = (MemoryPool&lt;T&gt;*) new char[size];</span><br><span class="line">    next = runner;</span><br><span class="line">    for (int i = 0; i &lt; howMany; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        runner-&gt;next = (MemoryPool&lt;T&gt;*) new char[size];</span><br><span class="line">        runner = runner-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    runner-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ABClock <span class="comment">//abstract base class</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~ABClock() &#123;&#125;</span><br><span class="line">    virtual void lock() = 0;</span><br><span class="line">    virtual void unlock() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MutexLock : public ABClock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MutexLock()</span><br><span class="line">    &#123;</span><br><span class="line">        hMutex = CreateMutex(NULL, FALSE, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    ~MutexLock()</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    void lock()</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(hMutex, INFINITE);</span><br><span class="line">    &#125;</span><br><span class="line">    void unlock()</span><br><span class="line">    &#123;</span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    HANDLE hMutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename POOLTYPE, typename LOCK&gt;</span><br><span class="line">class MTMemoryPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//allocate an element from the freelist.</span></span><br><span class="line">    void* alloc(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        void* mem;</span><br><span class="line">        theLock.lock();</span><br><span class="line">        mem = stPool.alloc(size);</span><br><span class="line">        theLock.unlock();</span><br><span class="line">        return mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return an element to the freelist</span></span><br><span class="line">    void free(void* someElement)</span><br><span class="line">    &#123;</span><br><span class="line">        theLock.lock();</span><br><span class="line">        stPool.free(someElement);</span><br><span class="line">        theLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    POOLTYPE stPool;//Single-threaded pool.</span><br><span class="line">    LOCK theLock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(int <span class="selector-tag">a</span> = <span class="number">0</span>, int <span class="selector-tag">b</span> = <span class="number">1</span>) : n(a), d(b) &#123;&#125;</span><br><span class="line">    void* operator new(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        return memPool-&gt;alloc(size);</span><br><span class="line">    &#125;</span><br><span class="line">    void operator delete(void* doomed, size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        memPool-&gt;free(doomed);</span><br><span class="line">    &#125;</span><br><span class="line">    static void newMemPool()</span><br><span class="line">    &#123;</span><br><span class="line">        memPool = new MTMemoryPool&lt; MemoryPool&lt;Rational&gt;, MutexLock&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    static void deleteMemPool()</span><br><span class="line">    &#123;</span><br><span class="line">        delete memPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int n;</span><br><span class="line">    int d;</span><br><span class="line">    static MTMemoryPool&lt; MemoryPool&lt;Rational&gt;, MutexLock&gt;* memPool;</span><br><span class="line">&#125;;</span><br><span class="line">MTMemoryPool&lt; MemoryPool&lt;Rational&gt;, MutexLock&gt;* Rational::memPool = NULL;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int ARRAY_SIZE = 1000;</span><br><span class="line">    const int LOOP_TIMES = 5000;</span><br><span class="line"></span><br><span class="line">    Rational* array[ARRAY_SIZE];</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    Rational::newMemPool();</span><br><span class="line">    for (int i = 0; i &lt; LOOP_TIMES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j] = new Rational(j);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            delete array[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">    system("pause");</span><br><span class="line">    Rational::deleteMemPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，</p><p><img alt data-src="https://c2.staticflickr.com/8/7573/27396123196_0e8f1d69ee_o.png"></p><p>临界区版本代码如下，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; class MemoryPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MemoryPool(size_t size = EXPANSION_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        expandTheFreeList(size);</span><br><span class="line">    &#125;</span><br><span class="line">    ~MemoryPool();</span><br><span class="line">    <span class="comment">//allocate a T element from the free list.</span></span><br><span class="line">    void* alloc(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (next == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            expandTheFreeList();</span><br><span class="line">        &#125;</span><br><span class="line">        MemoryPool&lt;T&gt;* head = next;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return a T element to the free list.</span></span><br><span class="line">    void free(void* doomed)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryPool&lt;T&gt;* head = static_cast&lt; MemoryPool&lt;T&gt;* &gt; (doomed);</span><br><span class="line">        head-&gt;next = next;</span><br><span class="line">        next = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">//next element on the free list.</span></span><br><span class="line">    MemoryPool&lt;T&gt;* next;</span><br><span class="line">    <span class="comment">//if the freelist is empty, expand it by this amount.</span></span><br><span class="line">    enum &#123;EXPANSION_SIZE = 32&#125;;</span><br><span class="line">    <span class="comment">//add free elements to the free list</span></span><br><span class="line">    void expandTheFreeList(int howMany = EXPANSION_SIZE);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; MemoryPool&lt;T&gt; :: ~MemoryPool()</span><br><span class="line">&#123;</span><br><span class="line">    MemoryPool&lt;T&gt;* nextPtr = NULL;</span><br><span class="line">    while (nextPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        nextPtr = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">        delete [] nextPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void MemoryPool&lt;T&gt; :: expandTheFreeList(int howMany)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//we must allocate an object enough to contain the next pointer</span></span><br><span class="line">    size_t size = sizeof(T) &gt; sizeof(MemoryPool&lt;T&gt;*) ? sizeof(T) :</span><br><span class="line">                  sizeof(MemoryPool&lt;T&gt;*);</span><br><span class="line"></span><br><span class="line">    MemoryPool&lt;T&gt;* runner = (MemoryPool&lt;T&gt;*) new char[size];</span><br><span class="line">    next = runner;</span><br><span class="line">    for (int i = 0; i &lt; howMany; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        runner-&gt;next = (MemoryPool&lt;T&gt;*) new char[size];</span><br><span class="line">        runner = runner-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    runner-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ABClock <span class="comment">//abstract base class</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~ABClock() &#123;&#125;</span><br><span class="line">    virtual void lock() = 0;</span><br><span class="line">    virtual void unlock() = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CriticalSectionLock : public ABClock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CriticalSectionLock()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CriticalSectionLock()</span><br><span class="line">    &#123;</span><br><span class="line">        DeleteCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">    void lock()</span><br><span class="line">    &#123;</span><br><span class="line">        EnterCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">    void unlock()</span><br><span class="line">    &#123;</span><br><span class="line">        LeaveCriticalSection(csMyCriticalSection);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    CRITICAL_SECTION csMyCriticalSection;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename POOLTYPE, typename LOCK&gt;</span><br><span class="line">class MTMemoryPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//allocate an element from the freelist.</span></span><br><span class="line">    void* alloc(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        void* mem;</span><br><span class="line">        theLock.lock();</span><br><span class="line">        mem = stPool.alloc(size);</span><br><span class="line">        theLock.unlock();</span><br><span class="line">        return mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return an element to the freelist</span></span><br><span class="line">    void free(void* someElement)</span><br><span class="line">    &#123;</span><br><span class="line">        theLock.lock();</span><br><span class="line">        stPool.free(someElement);</span><br><span class="line">        theLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    POOLTYPE stPool;//Single-threaded pool.</span><br><span class="line">    LOCK theLock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(int <span class="selector-tag">a</span> = <span class="number">0</span>, int <span class="selector-tag">b</span> = <span class="number">1</span>) : n(a), d(b) &#123;&#125;</span><br><span class="line">    void* operator new(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        return memPool-&gt;alloc(size);</span><br><span class="line">    &#125;</span><br><span class="line">    void operator delete(void* doomed, size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        memPool-&gt;free(doomed);</span><br><span class="line">    &#125;</span><br><span class="line">    static void newMemPool()</span><br><span class="line">    &#123;</span><br><span class="line">        memPool = new MTMemoryPool&lt; MemoryPool&lt;Rational&gt;, CriticalSectionLock&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    static void deleteMemPool()</span><br><span class="line">    &#123;</span><br><span class="line">        delete memPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int n;</span><br><span class="line">    int d;</span><br><span class="line">    static MTMemoryPool&lt; MemoryPool&lt;Rational&gt;, CriticalSectionLock&gt;* memPool;</span><br><span class="line">&#125;;</span><br><span class="line">MTMemoryPool&lt; MemoryPool&lt;Rational&gt;, CriticalSectionLock&gt;* Rational::memPool = NULL;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int ARRAY_SIZE = 1000;</span><br><span class="line">    const int LOOP_TIMES = 5000;</span><br><span class="line"></span><br><span class="line">    Rational* array[ARRAY_SIZE];</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    Rational::newMemPool();</span><br><span class="line">    for (int i = 0; i &lt; LOOP_TIMES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j] = new Rational(j);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            delete array[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">    system("pause");</span><br><span class="line">    Rational::deleteMemPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，</p><p><img alt data-src="https://c2.staticflickr.com/8/7147/27430312475_c7dc864833_o.png"></p><p>两个版本的代码只在线程同步锁的实现上有差别，但是速度却相差了30多倍。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 内存池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单线程环境中对象大小可变的内存池</title>
      <link href="/2012/11/18/%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0/"/>
      <url>/2012/11/18/%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>很多系统中申请的内存大小都不是固定的，而是变化的，比如一个http服务器。http服务器获得的请求不同，不同的请求需要不同大小的内存块。那么如何构造一个可以申请不同大小内存的内存池了。其实，构造方法类似vs2008下面的debug模式中的全局new和delete的实现。思路大致是申请很多不同大小的内存块，链接起来，根据需求从内存块链的头部申请指定大小内存。<br>注意，本文代码中的内存池只<strong>在内存块链的头部申请内存，而且从不进行内存释放，一直到内存池使用完毕</strong>。这样的设计确实可以尽可能得提高全局的速度，只要能保证系统的使用过程中不会把内存耗光就行了。不过，我觉得如果耗光内存的可能性还是太大了。但是，你想想实现一个允许对象大小可变的内存池本来就不那么容易，而且得在充分考虑效率的前提下了。如果效率太差了，为什么不直接使用默认的new和delete表达式了。<br>不过，其实有一个更好的办法，我们只使用内存池一段时间，就马上删除这个内存池，再重新申请一次内存池。也就是我们不能一次使用内存池的时间太长了。困难的是我们如何确定一次使用内存池的时间，什么需要删除内存池，时间太久了也许内存会耗光的，删除频繁了点又得不到想要的效率。这些也许就需要具体情况具体对待了，也许这个内存池的实现根本不能用。</p><p>内存池代码如下，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">class MemoryChunk</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MemoryChunk(MemoryChunk* nextChunk, size_t reqSize)</span><br><span class="line">    &#123;</span><br><span class="line">        chunkSize = reqSize &gt; DEFAULT_CHUNK_SIZE ? reqSize :</span><br><span class="line">                    DEFAULT_CHUNK_SIZE;</span><br><span class="line">        next = nextChunk;</span><br><span class="line">        byteAlreadyAllocated = 0;</span><br><span class="line">        mem = new char[chunkSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MemoryChunk()</span><br><span class="line">    &#123;</span><br><span class="line">        delete [] mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void* alloc(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        void* addr = (void*)(mem + byteAlreadyAllocated);</span><br><span class="line">        byteAlreadyAllocated += size;</span><br><span class="line">        return addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要释放内存块</span></span><br><span class="line">    void free(void* doomed)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MemoryChunk* nextMemChunk() &#123; return next; &#125;</span><br><span class="line">    size_t spaceAvailable()</span><br><span class="line">    &#123;</span><br><span class="line">        return chunkSize - byteAlreadyAllocated;</span><br><span class="line">    &#125;</span><br><span class="line">    enum &#123;DEFAULT_CHUNK_SIZE = 4096&#125;;</span><br><span class="line">private:</span><br><span class="line">    MemoryChunk* next;//下一个内存块</span><br><span class="line">    char* mem;//该内存块地址</span><br><span class="line">    size_t chunkSize; //该内存块的大小</span><br><span class="line">    size_t byteAlreadyAllocated;//该内存块被申请使用的大小</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ByteMemoryPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ByteMemoryPool(size_t initSize = MemoryChunk::DEFAULT_CHUNK_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        expandStorage(initSize);</span><br><span class="line">    &#125;</span><br><span class="line">    ~ByteMemoryPool();</span><br><span class="line"></span><br><span class="line">    void* alloc(size_t reqSize)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t space = listOfMemoryChunks-&gt;spaceAvailable();</span><br><span class="line">        <span class="keyword">if</span> (space &lt; reqSize)</span><br><span class="line">        &#123;</span><br><span class="line">            expandStorage(reqSize);</span><br><span class="line">        &#125;</span><br><span class="line">        return listOfMemoryChunks-&gt;alloc(reqSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void free(void* doomed)</span><br><span class="line">    &#123;</span><br><span class="line">        listOfMemoryChunks-&gt;free(doomed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void expandStorage(size_t reqSize)</span><br><span class="line">    &#123;</span><br><span class="line">        listOfMemoryChunks = new MemoryChunk(listOfMemoryChunks, reqSize);</span><br><span class="line">    &#125;</span><br><span class="line">    MemoryChunk* listOfMemoryChunks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ByteMemoryPool::~ByteMemoryPool()</span><br><span class="line">&#123;</span><br><span class="line">    MemoryChunk* memChunk = listOfMemoryChunks;</span><br><span class="line">    while (memChunk)</span><br><span class="line">    &#123;</span><br><span class="line">        listOfMemoryChunks = memChunk-&gt;nextMemChunk();</span><br><span class="line">        delete memChunk;</span><br><span class="line">        memChunk = listOfMemoryChunks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(int <span class="selector-tag">a</span> = <span class="number">0</span>, int <span class="selector-tag">b</span> = <span class="number">1</span>) : n(a), d(b) &#123;&#125;</span><br><span class="line">    void* operator new(size_t size) &#123;return memPool-&gt;alloc(size);&#125;</span><br><span class="line">    void operator delete(void* doomed, size_t size) &#123;/*memPool-&gt;free(doomed);*/&#125;</span><br><span class="line">    static void newMemPool() &#123;memPool = new ByteMemoryPool;&#125;</span><br><span class="line">    static void deleteMemPool() &#123;delete memPool;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int n;</span><br><span class="line">    int d;</span><br><span class="line">    static ByteMemoryPool* memPool;</span><br><span class="line">&#125;;</span><br><span class="line">ByteMemoryPool* Rational::memPool = NULL;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int ARRAY_SIZE = 1000;</span><br><span class="line">    const int LOOP_TIMES = 5000;</span><br><span class="line"></span><br><span class="line">    Rational* array[ARRAY_SIZE];</span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    Rational::newMemPool();</span><br><span class="line">    for (int i = 0; i &lt; LOOP_TIMES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j] = new Rational(j);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            delete array[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">    system("pause");</span><br><span class="line">    Rational::deleteMemPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果，<br>与上一篇文章里面的二个内存池实现的运行时间相比，没有多大差别。</p><p>你可以好好的阅读下代码，或者自己重新敲一遍，就会发现这个内存池的实现确实简单明了，没有一点冗余的代码，但是又非常高效。如果我们采用<strong>使用一段时间就重新初始化内存池</strong>的方式就不会耗光内存，不过恰当的使用该内存池也不是件容易的事情。其实，我主要还是觉得这个版本的内存池实现主要应该用在<strong>一次的业务处理时间不会太长，或者说内存申请量不会太多的场景中</strong>。</p><p>本文的思路和代码主要来自提高C++性能的编程技术一书。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 内存池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单线程环境中对象大小固定的内存池</title>
      <link href="/2012/11/15/%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0/"/>
      <url>/2012/11/15/%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>内存池并不是表面意义上存储大量可分配内存的池子，如果是这样的话，new和delete对应的就是一个理论上无限大的内存池。标题中的单线程指的是该内存池实现为了加快速度没有处理线程同步，因为很多应用你明显知道不需要线程同步。固定大小指的是该内存池每次只分配或者删除固定大小的对象。</p><p>这样的内存池怎么就加快了速度了。我觉得主要有以下几个方面。</p><p>1.不需要处理线程同步，去除掉线程同步的代码后，显然速度会加快。</p><p>2.总体来看，该内存池只会扩张不会收缩，也就是向系统释放堆内存的次数减少了。事实上，该内存池总是按需操作的。</p><p>3.该内存池的new和delete操作并没有去真正申请和释放堆内存，而是向自定义的对象空闲列表申请和释放。当对象空闲列表为空的时候，才一次性申请一大片空闲对象。大家都知道堆申请和释放比较耗时，最快的栈内存。所以，这也是一个显著的方面。</p><p>以下2段代码分别展示了原始的内存操作和使用内存池后的操作，</p><p>原始情况，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line">#include</span><br><span class="line">#include</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(int <span class="selector-tag">a</span> = <span class="number">0</span>, int <span class="selector-tag">b</span> = <span class="number">1</span>) : n(a), d(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int n; // Numerator</span><br><span class="line">    int d; // Denominator</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int ARRAY_SIZE = 1000;</span><br><span class="line">    const int LOOP_TIMES = 5000;</span><br><span class="line">    Rational* array[ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    for (int i = 0; i &lt; LOOP_TIMES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j] = new Rational(j);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            delete array[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">    system("pause");</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码的运行结果，</p><p><img alt data-src="https://c2.staticflickr.com/8/7643/27430249375_aaa747666a_o.png"></p><p>内存池，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">struct NextOnFreeList</span><br><span class="line">&#123;</span><br><span class="line">    NextOnFreeList* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(int <span class="selector-tag">a</span> = <span class="number">0</span>, int <span class="selector-tag">b</span> = <span class="number">1</span>) : n(a), d(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void* operator new(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (freeList == <span class="number">0</span>)<span class="comment">// if the list is empty, fill it up.</span></span><br><span class="line">        &#123;</span><br><span class="line">            expandTheFreeList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NextOnFreeList* head = freeList;</span><br><span class="line">        freeList = head-&gt;next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void operator delete(void* doomed, size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        NextOnFreeList* head = static_cast&lt;NextOnFreeList*&gt; (doomed);</span><br><span class="line">        head-&gt;next = freeList;</span><br><span class="line">        freeList = head;</span><br><span class="line">    &#125;</span><br><span class="line">    static void newMemPool()</span><br><span class="line">    &#123;</span><br><span class="line">        expandTheFreeList();</span><br><span class="line">    &#125;</span><br><span class="line">    static void deleteMemPool();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    static void expandTheFreeList();</span><br><span class="line">    static NextOnFreeList* freeList;</span><br><span class="line">    enum &#123; EXPANSION_SIZE = 32 &#125;;</span><br><span class="line">    int n; // Numerator</span><br><span class="line">    int d; // Denominator</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NextOnFreeList* Rational::freeList = NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当空闲列表里面没有对象时，该函数才会被调用</span></span><br><span class="line">void Rational::expandTheFreeList()</span><br><span class="line">&#123;</span><br><span class="line">    size_t size = sizeof(Rational) &gt; sizeof(NextOnFreeList*) ?</span><br><span class="line">                  sizeof(Rational) : sizeof(NextOnFreeList*);</span><br><span class="line">    NextOnFreeList* runner = (NextOnFreeList*)new char[size];</span><br><span class="line">    freeList = runner;</span><br><span class="line">    for (int i = 0; i &lt; EXPANSION_SIZE; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        runner-&gt;next = (NextOnFreeList*)new char[size];</span><br><span class="line">        runner = runner-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    runner-&gt;next = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Rational::deleteMemPool()</span><br><span class="line">&#123;</span><br><span class="line">    NextOnFreeList* nextPtr = freeList;</span><br><span class="line">    while (nextPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        freeList = nextPtr-&gt;next;</span><br><span class="line">        delete [] nextPtr;</span><br><span class="line">        nextPtr = freeList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int ARRAY_SIZE = 1000;</span><br><span class="line">    const int LOOP_TIMES = 5000;</span><br><span class="line">    Rational* array[ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    Rational::newMemPool();</span><br><span class="line">    for (int i = 0; i &lt; LOOP_TIMES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j] = new Rational(j);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            delete array[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">    system("pause");</span><br><span class="line">    Rational::deleteMemPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码运行结果，</p><p><img alt data-src="https://c2.staticflickr.com/8/7327/27331465702_971345d5c7_o.png"></p><p>通过以上结果的对比可以看到时间比例为921/78，直接就快了10多倍。而且我们的内存申请和删除操作还不够频繁，如果再更频繁的场合，效率上面的提示会更加大。</p><p>下面我们来分析一下内存池实现的代码。</p><p>说来也比较简单，因为原理都已经讲清楚了。首先去除了线程同步代码，然后把内存放在对象空闲列表里面，从里面释放和删除对象，当对象空闲列表为空的时候，一次性申请一片对象。作为一个有经验的c++程序员这些代码已经足够简单了。需要注意的是，在expandTheFreeList函数里面，申请新对象的时候，需要注意大小必须是Rational和NextOnFreeList*中大小大的一个。该内存池还用到了指针类型强转，语法上面还是比较巧妙的。</p><p>由于该内存池只是针对单个的类，应用场合未免有点限制。如果我们用泛型编程实现内存池，就可以把应用场合推广了。下面将内存池的功能独立出来，用模板重新实现了下，代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line">#include</span><br><span class="line">#include</span><br><span class="line"></span><br><span class="line">template  class MemoryPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MemoryPool(size_t size = EXPANSION_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        expandTheFreeList(size);</span><br><span class="line">    &#125;</span><br><span class="line">    ~MemoryPool();</span><br><span class="line">    <span class="comment">//allocate a T element from the free list.</span></span><br><span class="line">    void* alloc(size_t size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (next == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            expandTheFreeList();</span><br><span class="line">        &#125;</span><br><span class="line">        MemoryPool* head = next;</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return a T element to the free list.</span></span><br><span class="line">    void free(void* doomed)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryPool* head = static_cast&lt; MemoryPool* &gt; (doomed);</span><br><span class="line">        head-&gt;next = next;</span><br><span class="line">        next = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="comment">//next element on the free list.</span></span><br><span class="line">    MemoryPool* next;</span><br><span class="line">    <span class="comment">//if the freelist is empty, expand it by this amount.</span></span><br><span class="line">    enum &#123;EXPANSION_SIZE = 32&#125;;</span><br><span class="line">    <span class="comment">//add free elements to the free list</span></span><br><span class="line">    void expandTheFreeList(int howMany = EXPANSION_SIZE);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template  MemoryPool :: ~MemoryPool()</span><br><span class="line">&#123;</span><br><span class="line">    MemoryPool* nextPtr = NULL;</span><br><span class="line">    while (nextPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        nextPtr = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">        delete [] nextPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template  void MemoryPool :: expandTheFreeList(int howMany)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//we must allocate an object enough to contain the next pointer</span></span><br><span class="line">    size_t size = sizeof(T) &gt; sizeof(MemoryPool*) ? sizeof(T) :</span><br><span class="line">                  sizeof(MemoryPool*);</span><br><span class="line"></span><br><span class="line">    MemoryPool* runner = (MemoryPool*) new char[size];</span><br><span class="line">    next = runner;</span><br><span class="line">    for (int i = 0; i &lt; howMany; ++i)     &#123;         runner-&gt;next = (MemoryPool*) new char[size];</span><br><span class="line">        runner = runner-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    runner-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(int <span class="selector-tag">a</span> = <span class="number">0</span>, int <span class="selector-tag">b</span> = <span class="number">1</span>) : n(a), d(b) &#123;&#125;</span><br><span class="line">    void* operator new(size_t size) &#123;return memPool-&gt;alloc(size);&#125;</span><br><span class="line">    void operator delete(void* doomed, size_t size) &#123;memPool-&gt;free(doomed);&#125;</span><br><span class="line">    static void newMemPool() &#123;memPool = new MemoryPool;&#125;</span><br><span class="line">    static void deleteMemPool() &#123;delete memPool;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int n;</span><br><span class="line">    int d;</span><br><span class="line">    static MemoryPool* memPool;</span><br><span class="line">&#125;;</span><br><span class="line">MemoryPool* Rational::memPool = NULL;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int ARRAY_SIZE = 1000;</span><br><span class="line">    const int LOOP_TIMES = 5000;</span><br><span class="line">    Rational* array[ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">    clock_t beg = clock();</span><br><span class="line">    Rational::newMemPool();</span><br><span class="line">    for (int i = 0; i &lt; LOOP_TIMES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            array[j] = new Rational(j);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; ARRAY_SIZE; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            delete array[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t end = clock();</span><br><span class="line">    printf("use %f second(s).\n", 1.0 * (end - beg) / CLOCKS_PER_SEC);</span><br><span class="line">    system("pause");</span><br><span class="line">    Rational::deleteMemPool();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如图：</p><p><img alt data-src="https://c2.staticflickr.com/8/7611/26821417364_a0b48abf91_o.png"></p><p>可以看到用模板重新实现后，速度并没有下降多少，这个例子速度下降近一倍的原因估计是与原来的实现相比多了一些函数调用吧，但是还是比不使用内存池的情况下快一个数量级。</p><p>整个代码的思路是把内存池的实现部分用一个模板类包含了，用不同的类实例化模板类，就可以对不同的类使用内存池了，泛型编程在速度和灵活性上面的结合确实是非常优美的。而且你可以看到，例子二和例子三的主函数部分完全一致，也就是保持了外部接口的统一性，只需要修改类Rational的实现即可。现在将内存池应用到不同的类也只需要在类里面添加一个针对该类的泛型内存池成员而已。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 内存池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数所造成的性能损失</title>
      <link href="/2012/11/13/%E8%99%9A%E5%87%BD%E6%95%B0%E6%89%80%E9%80%A0%E6%88%90%E7%9A%84%E6%80%A7%E8%83%BD%E6%8D%9F%E5%A4%B1/"/>
      <url>/2012/11/13/%E8%99%9A%E5%87%BD%E6%95%B0%E6%89%80%E9%80%A0%E6%88%90%E7%9A%84%E6%80%A7%E8%83%BD%E6%8D%9F%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<p>假设在一个线程同步环境中，有类似下面所示的代码段：</p><p>//进入线程同步</p><p>nNum++;</p><p>//退出线程同步</p><p>以win32为例，如我们所知，线程同步工具有临界区，互斥体，信号量。我们可以任意选择一个，为了简单很可能我们就选择了临界区。假如我们需要同步的代码非常简单，我非常建议不需要使用c++的任何功能。但是，很可能没这么幸运，很可能你的代码会被很多人修改，很可能同步的时候需要异常退出，很可能同步的里面还有点逻辑处理，很可能你在退出的时候没有释放锁。那么你就悲剧了。</p><p>C++在这里一点上就体现出了与生俱来的优势，构造函数和析构函数。假如我们把获得锁写进构造函数里面，释放锁写进析构函数里面，就能保证任意情况的退出之前都能够释放锁，从而不会造成死锁。</p><p>还有个问题是我们应该如何实现这些不同的同步工具。如果，我们分别写三个类，CCriticalSection，CMutex，CSemaphore，这三个类不是继承自同一个基类的，而且这三个类里面也没有任何的虚函数，而且我们把操作都写成内联的。那么，在效率上与直接用C相比基本没有差别。因为，所有额外的调用开销都内联了。<strong>在不丧失效率的同时保持了灵活性</strong>，这确实是非常强大的地方。</p><p>万一你说为了灵活性，需要让这三个类继承同一个基类，CBaseLock，同时需要把析构函数定义成虚的，这样就会造成很多额外的性能损失。比如，可能需要构造和析构基类对象，需要初始化虚函数指针，执行阶段需要通过虚函数指针间接调用，还有一个最重要的损失，编译器无法内联虚函数，如果虚函数比较小，那么相对于原来的情况，这是一个巨大的性能损失。某种意义上，我们可以忽视，基类对象的构造和析构，以及虚函数指针的初始化和调用时刻的间接寻址，因为这些可以其它方面的因素来抵消。</p><p><strong>但是，无法内联一个小的函数所造成的额外开销是很大的。</strong>想象一下，比如刚才几个类里面的析构函数只是释放锁这一个操作，肯定是可以内联的，但是现在写成虚函数了，就无法内联了，如果这个函数被调用很多次，比如几百万次，和原来消耗的时候相比，肯定是天壤之别了，因为原来没有函数调用开销，现在有，而且因为函数内部操作太少了，函数调用开销所占据的比例非常大，所以你的设计造成了巨大的性能损失。</p><p>本文的观点主要来自<strong>提高C++性能的编程技术</strong>一书，欢迎吐槽。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学OpenGL版第五章代码汇总</title>
      <link href="/2012/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6OpenGL%E7%89%88%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/"/>
      <url>/2012/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6OpenGL%E7%89%88%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>5.6.2 网格场景</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);</span><br><span class="line">    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw a z-axis, with cone at end</span></span><br><span class="line">void axis(double length)</span><br><span class="line">&#123;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex3d(0, 0, 0);</span><br><span class="line">    glVertex3d(0, 0, length);</span><br><span class="line">    glEnd();</span><br><span class="line">    glTranslated(0, 0, length - 0.2);//平移</span><br><span class="line">    glutWireCone(0.04, 0.2, 12, 9);</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void displayWire()</span><br><span class="line">&#123;</span><br><span class="line">    glMatrixMode(GL_PROJECTION);//设置视景体</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    glOrtho(-2.0 * 64 / 48, 2.0 * 64 / 48, -2.0, 2.0, 0.1, 100);</span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluLookAt(1.0, 1.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);</span><br><span class="line"></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glColor3d(0, 0, 0);</span><br><span class="line"></span><br><span class="line">    axis(0.5);//z-axis</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glRotated(-90, 1.0, 0, 0);</span><br><span class="line">    axis(0.5);//y-axis</span><br><span class="line">    glRotated(90.0, 0, 1.0, 0);</span><br><span class="line">    axis(0.5);//x-axis</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0.5, 0.5, 0.5);</span><br><span class="line">    glutWireCube(1.0);//线框立方体</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glColor3d(1.0, 0, 0);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(1.0, 1.0, 0);</span><br><span class="line">    glutWireSphere(0.25, 10, 8);//线框球体</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glColor3d(0, 1.0, 0);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(1.0, 0, 1.0);</span><br><span class="line">    glutWireCone(0.2, 0.5, 10, 8);//线框圆锥体</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glColor3d(0, 0, 1.0);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(1.0, 1.0, 1.0);</span><br><span class="line">    glutWireTeapot(0.2);//线框茶壶</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glColor3d(1.0, 0, 1.00);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0, 1.0, 0);</span><br><span class="line">    glutWireTorus(0.1, 0.3, 10, 10);//线框花环</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glColor3d(0, 1.0, 1.0);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(1.0, 0, 0);</span><br><span class="line">    glScaled(0.15, 0.15, 0.15);</span><br><span class="line">    glutWireDodecahedron();//线框12面体</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glColor3d(0.1, 0.5, 0.2);</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0, 1.0, 1.0);</span><br><span class="line">    glutWireCube(0.25);</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0, 0, 1.0);</span><br><span class="line">    GLUquadricObj* qobj = gluNewQuadric();//创建二次曲面对象</span><br><span class="line">    gluQuadricDrawStyle(qobj, GLU_LINE);</span><br><span class="line">    glColor3d(0.3, 0.5, 0.4);</span><br><span class="line">    gluCylinder(qobj, 0.2, 0.2, 0.4, 8, 8);//圆柱体</span><br><span class="line">    glPopMatrix();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("Transformation Test -Wireframes");</span><br><span class="line">    glutDisplayFunc(displayWire);</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.6.3 着色三维场景绘制</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glEnable(GL_LIGHTING);//enable the light source</span><br><span class="line">    glEnable(GL_LIGHT0);</span><br><span class="line">    glShadeModel(GL_SMOOTH);//光滑着色</span><br><span class="line">    glEnable(GL_DEPTH_TEST);//启用深度测试,根据坐标的远近自动隐藏被遮住的图形</span><br><span class="line">    glEnable(GL_NORMALIZE);//根据函数glNormal的设置条件，启用法向量</span><br><span class="line">    glClearColor(1.0f, 1.0f, 1.0f, 0.0f);</span><br><span class="line">    glViewport(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw thin wall with top = xz-plane, corner at origin</span></span><br><span class="line">void wall(double thickness)</span><br><span class="line">&#123;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0.5, 0.5 * thickness, 0.5);</span><br><span class="line">    glScaled(1.0, thickness, 1.0);</span><br><span class="line">    glutSolidCube(1.0);</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//table leg</span></span><br><span class="line">void tableLeg(double thick, double len)</span><br><span class="line">&#123;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0, len / 2, 0);</span><br><span class="line">    glScaled(thick, len, thick);</span><br><span class="line">    glutSolidCube(1.0);</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw one axis of the unit jack-a stretched sphere</span></span><br><span class="line">void jackPart()</span><br><span class="line">&#123;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glScaled(0.2, 0.2, 1.0);</span><br><span class="line">    glutSolidSphere(1, 15, 15);</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0, 0, 1.2);//ball on one end</span><br><span class="line">    glutSolidSphere(0.2, 15, 15);</span><br><span class="line">    glTranslated(0, 0, -2.4);</span><br><span class="line">    glutSolidSphere(0.2, 15, 15);//ball on the other end</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw a unit jact out of spheroids</span></span><br><span class="line">void jack()</span><br><span class="line">&#123;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    jackPart();</span><br><span class="line">    glRotated(90.0, 0, 1, 0);</span><br><span class="line">    jackPart();</span><br><span class="line">    glRotated(90.0, 1.0, 0, 0);</span><br><span class="line">    jackPart();</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw the table - a top and four legs</span></span><br><span class="line"><span class="comment">//绘画桌子时候，外部调用已经使原点到达桌子中间了</span></span><br><span class="line">void table(double topWid, double topThick, double legThick, double legLen)</span><br><span class="line">&#123;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0, legLen, 0);</span><br><span class="line">    glScaled(topWid, topThick, topWid);</span><br><span class="line">    glutSolidCube(1.0);//桌面</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    double dist = 0.95 * topWid / 2.0 - legThick / 2.0;</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    <span class="comment">//glTranslated(dist, 0, dist);</span></span><br><span class="line">    glTranslated(dist, 0, dist);</span><br><span class="line">    tableLeg(legThick, legLen);</span><br><span class="line">    glTranslated(0, 0, -2 * dist);</span><br><span class="line">    tableLeg(legThick, legLen);</span><br><span class="line">    glTranslated(-2 * dist, 0, 2 * dist);</span><br><span class="line">    tableLeg(legThick, legLen);</span><br><span class="line">    glTranslated(0, 0, -2 * dist);</span><br><span class="line">    tableLeg(legThick, legLen);</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void displaySolid()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置表面纹理属性</span></span><br><span class="line">    GLfloat mat_ambient[] = &#123;0.7, 0.7, 0.7, 1.0&#125;;</span><br><span class="line">    GLfloat mat_diffuse[] = &#123;0.6, 0.6, 0.6, 1.0&#125;;</span><br><span class="line">    GLfloat mat_specular[] = &#123;1.0, 1.0, 1.0, 1.0&#125;;//反射</span><br><span class="line">    GLfloat mat_shininess[] = &#123;50.0&#125;;//光</span><br><span class="line"></span><br><span class="line">    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);//环境光材质</span><br><span class="line">    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);//漫反射</span><br><span class="line">    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);//镜面反射</span><br><span class="line">    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);//光亮</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置光源属性</span></span><br><span class="line">    GLfloat lightIntensity[] = &#123;0.7, 0.7, 0.7, 1.0&#125;;</span><br><span class="line">    GLfloat lightPosition[] = &#123;2.0, 6.0, 3.0, 0.0&#125;;</span><br><span class="line">    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition);//设置光源0的位置</span><br><span class="line">    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightIntensity);//光源漫反射强度的RGBA值</span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    double winHt = 1.0; // half - height of th window</span><br><span class="line">    glOrtho(-winHt * 64 / 48.0, winHt * 64 / 48.0, -winHt, winHt, 0.1, 100.0);</span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);//设置照相机</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluLookAt(2.3, 1.3, 2, 0, 0.25, 0, 0.0, 1.0, 0.0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//start draw</span></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0.4, 0.4, 0.6);</span><br><span class="line">    glRotated(45, 0, 0, 1);</span><br><span class="line">    glScaled(0.08, 0.08, 0.08);</span><br><span class="line">    jack();//draw the jack</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0.6, 0.38, 0.5);</span><br><span class="line">    glRotated(30, 0, 1, 0);</span><br><span class="line">    glutSolidTeapot(0.08);//draw the teapot</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0.25, 0.42, 0.35);</span><br><span class="line">    glutSolidSphere(0.1, 15, 15);//draw the sphere</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glTranslated(0.4, 0, 0.4);</span><br><span class="line">    table(0.6, 0.02, 0.02, 0.3);//draw the table</span><br><span class="line">    glPopMatrix();</span><br><span class="line"></span><br><span class="line">    wall(0.02); //wall #1: in xz-plane</span><br><span class="line">    glPushMatrix();</span><br><span class="line">    glRotated(90.0, 0.0, 0.0, 1.0);</span><br><span class="line">    wall(0.02);//wall #2: in xy-plane</span><br><span class="line">    glRotated(90.0, 1.0, 0.0, 0.0);</span><br><span class="line">    wall(0.02);</span><br><span class="line">    glPopMatrix();//wall #3: in yz-plane</span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("Shaded example-3D scene");</span><br><span class="line">    glutDisplayFunc(displaySolid);</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.6.4 使用SDL从文件中读取场景描述</p><p><a href="https://pan.baidu.com/s/1nvvSLKl" target="_blank" rel="noopener">SDLDraw</a></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么需要将继承层次中类的析构函数定义成virtual的？</title>
      <link href="/2012/11/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%86%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%88%90virtual%E7%9A%84%EF%BC%9F/"/>
      <url>/2012/11/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%86%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E6%88%90virtual%E7%9A%84%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>如标题所示，如果该类没有父类也没有任何子类，把析构函数还定义成虚的，确实没多大必要吧。对象的构建和析构完全是一个入栈和出栈的过程，也就是说肯定会从父类构造到子类，也肯定会从子类析构到父类，这些都是毋容置疑的。</p><p>那么把析构函数定义成virtual有个什么意义了。确实没有多大意义，至少对于一个非delete造成的析构。无论是析构一个堆栈对象还是全局对象，编译器肯定能在编译时就做出决策了。但是，假如有人一时兴起，new了一个子类对象并且将地址存储在基类指针中。那么，你该怎么删除这个对象了，只能delete父类指针了。</p><p>问题就出在这里了。<strong>你既然delete父类指针，假如是在编译层次决策的话，编译器只能帮你调用父类的析构函数了。</strong>但是，事实上你是一个子类对象，那么子类的析构函数没有调用，假如你在子类的析构函数做了些什么释放，结果就是那个释放永远不会执行，这样就造成内存泄漏或者资源重复申请之类的。</p><p>其实，上面的这种写法就是利用多态的性质，既然要利用多态，肯定得把析构函数定义成virtual的，那么调用哪个析构函数的决策就能到运行时候再决定。如果基类的析构函数定义成virtual的话，其所有子类的析构函数当然也是virtual的，那么我们删除基类指针的时候，就能通过多态机制决定该调用子类的析构函数，也就是从子类的析构函数开始往基类的析构函数调用释放整个对象。这样就不会造成任何资源泄漏了。</p><p>以下的代码展示了这样的一种情况，注意Class CA作为基类，就需要把析构函数定义成virtual的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class CA</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">        CA(int nS = <span class="number">100</span>): nSize(nS)</span><br><span class="line">        &#123;</span><br><span class="line">            nA = new int[nSize];</span><br><span class="line">            printf("构造CA\n");</span><br><span class="line">        &#125;</span><br><span class="line">        virtual ~CA()</span><br><span class="line">        &#123;</span><br><span class="line">            delete [] nA;</span><br><span class="line">            printf("析构CA\n");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        int* nA;</span><br><span class="line">        int nSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CB : public CA</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">        CB(int nS = <span class="number">100</span>): nSize(nS)</span><br><span class="line">        &#123;</span><br><span class="line">            nB = new int[nSize];</span><br><span class="line">            printf("构造CB\n");</span><br><span class="line">        &#125;</span><br><span class="line">        ~CB()</span><br><span class="line">        &#123;</span><br><span class="line">            delete [] nB;</span><br><span class="line">            printf("析构CB\n");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        int* nB;</span><br><span class="line">        int nSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CA* pCA = new CB();</span><br><span class="line">    delete pCA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图:</p><p><img alt data-src="https://c2.staticflickr.com/8/7152/27396027096_47abe363cc_o.png">，</p><p>如果删掉CA析构函数前面的virtual，效果如图，</p><p><img alt data-src="https://c2.staticflickr.com/8/7672/27396028106_085b740b99_o.png"></p><p>你也可以实验在主函数里面定义些栈变量的CA和CB的对象，无论构造函数是否是virtual的，都能够正确的析构。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 析构函数 </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学OpenGL版第三章源代码汇总</title>
      <link href="/2012/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6OpenGL%E7%89%88%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/"/>
      <url>/2012/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6OpenGL%E7%89%88%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>写了下第三章部分作业和例子的代码，如下。</p><p>3.2节 sinc<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const <span class="attribute">float</span> PI = atan(<span class="number">1.0</span>) * <span class="number">4</span>;</span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置世界窗口</span></span><br><span class="line">void SetWindow(GLdouble <span class="attribute">left</span>, GLdouble right, GLdouble bottom, GLdouble top)</span><br><span class="line">&#123;</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(<span class="attribute">left</span>, right, bottom, top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置视口</span></span><br><span class="line">void SetViewport(GLint <span class="attribute">left</span>, GLint right, GLint bottom, GLint top)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(<span class="attribute">left</span>, bottom, right - left, top - bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//白色背景</span><br><span class="line">    glColor3f(0.0, 0.0, 1.0);</span><br><span class="line">    glLineWidth(2.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);//使视图矩形栈有效</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line">    SetViewport(0, WINDOW_WIDTH / 2, 0, WINDOW_HEIGHT);//这个函数调用在main里面一直没效果</span><br><span class="line">    glBegin(GL_LINE_STRIP);</span><br><span class="line">    for (float x = -4.0; x &lt;= 4.0; x += 0.1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fabs(x) &lt; <span class="number">1</span>e-<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            glVertex2f(0.0, 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            glVertex2f(x, sin(PI * x) / (PI* x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("The Famous Sinc Function");</span><br><span class="line">    glutDisplayFunc(myDisplay);</span><br><span class="line">    myInit();</span><br><span class="line">    SetWindow(-5.0, 5.0, -0.3, 1.0);</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.2节 放大显示<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const <span class="attribute">float</span> PI = atan(<span class="number">1.0</span>) * <span class="number">4</span>;</span><br><span class="line">int nWidth = 640;</span><br><span class="line">int nHeight = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置世界窗口</span></span><br><span class="line">void SetWindow(GLdouble <span class="attribute">left</span>, GLdouble right, GLdouble bottom, GLdouble top)</span><br><span class="line">&#123;</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(<span class="attribute">left</span>, right, bottom, top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置视口</span></span><br><span class="line">void SetViewport(GLint <span class="attribute">left</span>, GLint right, GLint bottom, GLint top)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(<span class="attribute">left</span>, bottom, right - left, top - bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//白色背景</span><br><span class="line">    glColor3f(0.0, 0.0, 1.0);</span><br><span class="line">    glLineWidth(2.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Function: hexswirl()</span></span><br><span class="line"><span class="comment">// This draws a hexagon on the screen many times.  Each new</span></span><br><span class="line"><span class="comment">// hexagon is slightly bigger than the previous one and rotated</span></span><br><span class="line"><span class="comment">// slightly so that a hexagon "swirl" is drawn.</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line">void hexSwirl()</span><br><span class="line">&#123;</span><br><span class="line">    double angle;                       //the angle of rotation</span><br><span class="line">    double angleInc = 2*3.14159265/6.0; //the angle increment</span><br><span class="line">    double inc = 5.0 / 100;               //the radius increment</span><br><span class="line">    double radius = 5.0 / 100.0;          //the radius to be used</span><br><span class="line"></span><br><span class="line">    <span class="comment">//glMatrixMode(GL_MODELVIEW);</span></span><br><span class="line">    <span class="comment">//glLoadIdentity();</span></span><br><span class="line">    <span class="comment">//clear the background</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw the hexagon swirl</span></span><br><span class="line">    for (int j = 0; j &lt;= 100; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//the angle of rotation depends on which hexagon is </span></span><br><span class="line">        <span class="comment">//being drawn.</span></span><br><span class="line">        angle = j* (3.14159265/180.0);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw one hexagon</span></span><br><span class="line">        glBegin (GL_LINE_STRIP);</span><br><span class="line">        for (int k=0; k &lt;= 6; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            angle += angleInc;</span><br><span class="line">            glVertex2d(radius * cos(angle), radius *sin(angle));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        glEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//determine the radius of the next hexagon</span></span><br><span class="line">        radius += inc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//swap buffers for a smooth change from one</span></span><br><span class="line">    <span class="comment">//frame to another</span></span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="attribute">float</span> cx = <span class="number">0.3</span>, cy = <span class="number">0.2</span>;</span><br><span class="line">    <span class="attribute">float</span> H, W, aspect = <span class="number">0.7</span>;</span><br><span class="line"></span><br><span class="line">    int frame = 50;</span><br><span class="line">    for (int i = 0; i &lt; frame; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        W *= 0.7;</span><br><span class="line">        H = W * aspect;</span><br><span class="line">        SetWindow(cx - W, cx + W, cy - H, cy + H);</span><br><span class="line">        hexSwirl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reShape(int nNewWidth, int nNewHeight)</span><br><span class="line">&#123;</span><br><span class="line">    nWidth = nNewWidth;</span><br><span class="line">    nHeight = nNewHeight;</span><br><span class="line">    SetViewport(0, nWidth, 0, nHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(nWidth, nHeight);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("hexSwirl");</span><br><span class="line">    glutDisplayFunc(myDisplay);</span><br><span class="line">    glutReshapeFunc(reShape);</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.2节 回旋的旋涡<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const <span class="attribute">float</span> PI = atan(<span class="number">1.0</span>) * <span class="number">4</span>;</span><br><span class="line">int nWidth = 640;</span><br><span class="line">int nHeight = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const int ROW = 8;</span><br><span class="line">const int COLUMU = 6;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置世界窗口</span></span><br><span class="line">void SetWindow(GLdouble <span class="attribute">left</span>, GLdouble right, GLdouble bottom, GLdouble top)</span><br><span class="line">&#123;</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(<span class="attribute">left</span>, right, bottom, top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置视口</span></span><br><span class="line">void SetViewport(GLint <span class="attribute">left</span>, GLint right, GLint bottom, GLint top)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(<span class="attribute">left</span>, bottom, right - left, top - bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//白色背景</span><br><span class="line">    glColor3f(0.0, 0.0, 1.0);</span><br><span class="line">    glLineWidth(2.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Function: hexswirl()</span></span><br><span class="line"><span class="comment">// This draws a hexagon on the screen many times.  Each new</span></span><br><span class="line"><span class="comment">// hexagon is slightly bigger than the previous one and rotated</span></span><br><span class="line"><span class="comment">// slightly so that a hexagon "swirl" is drawn.</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line">void hexSwirl()</span><br><span class="line">&#123;</span><br><span class="line">    double angle;                       //the angle of rotation</span><br><span class="line">    double angleInc = 2*3.14159265/6.0; //the angle increment</span><br><span class="line">    double inc = 5.0 / 100;               //the radius increment</span><br><span class="line">    double radius = 5.0 / 100.0;          //the radius to be used</span><br><span class="line"></span><br><span class="line">    <span class="comment">//glMatrixMode(GL_MODELVIEW);</span></span><br><span class="line">    <span class="comment">//glLoadIdentity();</span></span><br><span class="line">    <span class="comment">//clear the background</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw the hexagon swirl</span></span><br><span class="line">    for (int j = 0; j &lt;= 100; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//the angle of rotation depends on which hexagon is </span></span><br><span class="line">        <span class="comment">//being drawn.</span></span><br><span class="line">        angle = j* (3.14159265/180.0);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//draw one hexagon</span></span><br><span class="line">        glBegin (GL_LINE_STRIP);</span><br><span class="line">        for (int k=0; k &lt;= 6; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            angle += angleInc;</span><br><span class="line">            glVertex2d(radius * cos(angle), radius *sin(angle));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        glEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//determine the radius of the next hexagon</span></span><br><span class="line">        radius += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    const int  L = nWidth / ROW;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; ROW; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; COLUMU; ++j)</span><br><span class="line">        &#123; </span><br><span class="line">            if ((i + j) % 2 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                SetWindow(-0.6, 0.6, -0.6, 0.6);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                SetWindow(-0.6, 0.6, 0.6, -0.6);</span><br><span class="line">            &#125;</span><br><span class="line">            SetViewport(i * L, L + i * L, j * L, L + j * L);</span><br><span class="line">            hexSwirl();</span><br><span class="line">            <span class="comment">//for (int k = 0; k &lt;= 200000000; k++);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//swap buffers for a smooth change from one</span></span><br><span class="line">    <span class="comment">//frame to another</span></span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reShape(int nNewWidth, int nNewHeight)</span><br><span class="line">&#123;</span><br><span class="line">    nWidth = nNewWidth;</span><br><span class="line">    nHeight = nNewHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(nWidth, nHeight);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("hexSwirl");</span><br><span class="line">    glutDisplayFunc(myDisplay);</span><br><span class="line">    glutReshapeFunc(reShape);</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.4节 5花环<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const int NUM = 55000;</span><br><span class="line">const double PI = atan(1.0) * 4;</span><br><span class="line"></span><br><span class="line">struct GLintPoint</span><br><span class="line">&#123;</span><br><span class="line">    GLint x;</span><br><span class="line">    GLint y;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">class Point2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="attribute">float</span> x, y;</span><br><span class="line">    void set(float dx, float dy) &#123;x = dx; y = dy;&#125;</span><br><span class="line">    void set(Point2 p) &#123;x = p.x; y = p.y;&#125;</span><br><span class="line">    Point2(<span class="attribute">float</span> xx, float yy) &#123;x = xx, y = yy;&#125;</span><br><span class="line">    Point2() &#123;x = y = 0;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point2 curpos, cp;</span><br><span class="line"></span><br><span class="line">void moveTo(Point2 p)</span><br><span class="line">&#123;</span><br><span class="line">    cp.set(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void lineTo(Point2 p)</span><br><span class="line">&#123;</span><br><span class="line">    glBegin(GL_LINES);</span><br><span class="line">    glVertex2f(cp.x, cp.y);</span><br><span class="line">    glVertex2f(p.x, p.y);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">    cp.set(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 0.0, 0.0, 0.0);</span><br><span class="line">    glColor3f(0.0f, 1.0f, 0.0f);</span><br><span class="line">    glPointSize(4.0);//设置点的大小为4*4像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(-WINDOW_WIDTH / 2, WINDOW_WIDTH / 2, -WINDOW_HEIGHT / 2, WINDOW_HEIGHT / 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void rosette(int N, <span class="attribute">float</span> radius)</span><br><span class="line">&#123;</span><br><span class="line">    Point2* pointlist = new Point2[N];</span><br><span class="line"></span><br><span class="line">    GLfloat theta = (2.0 * PI) / N;</span><br><span class="line">    for (int c = 0; c &lt; N; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        pointlist``` stylus.set(radius * sin(c * theta), radius * cos(theta * c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            moveTo(pointlist[i]);</span><br><span class="line">            lineTo(pointlist[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    glViewport(10, 10, 640, 480);</span><br><span class="line">    rosette(5, 200);</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("花环");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.4.3 阴阳符号<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const double PI = atan(1.0) * 4;</span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const double BIG_R = 100;</span><br><span class="line">const double MID_R = 50;</span><br><span class="line">const double SML_R = 10;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(0.5, 0.5, 0.5, 0.0);</span><br><span class="line">    glColor3f(0.0, 0.0, 1.0);</span><br><span class="line">    glLineWidth(2.0);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void drawArc(double fX, double fY, double fR, double fBeg, double fEnd)</span><br><span class="line">&#123;</span><br><span class="line">    double fAdd = 0.0001;</span><br><span class="line"></span><br><span class="line">    fBeg = fBeg * PI / 180;</span><br><span class="line">    fEnd = fEnd * PI / 180;</span><br><span class="line">    <span class="keyword">if</span> (fBeg &gt; fEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(fBeg, fEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glBegin(GL_POLYGON);</span><br><span class="line">    while (fBeg &lt; fEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        glVertex2f(fX + fR * cos(fBeg), fY + fR * sin(fBeg));</span><br><span class="line">        fBeg += fAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    glColor3f(0.0, 0.0, 0.0);//黑</span><br><span class="line">    drawArc(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2, BIG_R, 0, 180);</span><br><span class="line">    glColor3f(1.0, 1.0, 1.0);//白</span><br><span class="line">    drawArc(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2, BIG_R, 180, 360);</span><br><span class="line">    glColor3f(0.0, 0.0, 0.0);//黑</span><br><span class="line">    drawArc(WINDOW_WIDTH / 2 - MID_R, WINDOW_HEIGHT / 2, MID_R, 0, 360);</span><br><span class="line">    glColor3f(1.0, 1.0, 1.0);//白</span><br><span class="line">    drawArc(WINDOW_WIDTH / 2 + MID_R, WINDOW_HEIGHT / 2, MID_R, 0, 360);</span><br><span class="line">    drawArc(WINDOW_WIDTH / 2 - MID_R, WINDOW_HEIGHT / 2, SML_R, 0, 360);</span><br><span class="line">    glColor3f(0.0, 0.0, 0.0);//黑</span><br><span class="line">    drawArc(WINDOW_WIDTH / 2 + MID_R, WINDOW_HEIGHT / 2, SML_R, 0, 360);</span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("阴阳图");</span><br><span class="line">    glutDisplayFunc(myDisplay);</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.4.4 Koch雪花<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const double PI = atan(1.0) * 4;</span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const int DEPTH = 8;</span><br><span class="line"></span><br><span class="line">struct GLdoublePoint</span><br><span class="line">&#123;</span><br><span class="line">    GLdouble fX, fY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GLdoublePoint operator + (const GLdoublePoint <span class="selector-tag">a</span>, const GLdoublePoint b)</span><br><span class="line">&#123;</span><br><span class="line">    GLdoublePoint c;</span><br><span class="line">    c.fX = a.fX + b.fX;</span><br><span class="line">    c.fY = a.fY + b.fY;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLdoublePoint operator - (const GLdoublePoint <span class="selector-tag">a</span>, const GLdoublePoint b)</span><br><span class="line">&#123;</span><br><span class="line">    GLdoublePoint c;</span><br><span class="line">    c.fX = a.fX - b.fX;</span><br><span class="line">    c.fY = a.fY - b.fY;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GLdoublePoint operator * (const GLdoublePoint a, double fScale)</span><br><span class="line">&#123;</span><br><span class="line">    GLdoublePoint c;</span><br><span class="line">    c.fX = a.fX * fScale;</span><br><span class="line">    c.fY = a.fY * fScale;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);</span><br><span class="line">    glColor3f(0.0, 0.0, 0.0);</span><br><span class="line">    glLineWidth(2.0);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void drawKoch(GLdoublePoint beg, GLdoublePoint end, int depth, bool left)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glBegin(GL_LINES);</span><br><span class="line">        glVertex2f(beg.fX, beg.fY);</span><br><span class="line">        glVertex2f(end.fX, end.fY);</span><br><span class="line">        glEnd();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GLdoublePoint pts[3];</span><br><span class="line">    GLdoublePoint vct = end - beg;</span><br><span class="line">    pts[0] = beg + (vct * (1.0 / 3.0));</span><br><span class="line">    pts[2] = beg + (vct * (2.0 / 3.0));</span><br><span class="line">    GLdoublePoint nvct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="attribute">left</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nvct.fX = -vct.fY;</span><br><span class="line">        nvct.fY = vct.fX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nvct.fX = vct.fY;</span><br><span class="line">        nvct.fY = -vct.fX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double fSize = sqrt(nvct.fX * nvct.fX + nvct.fY * nvct.fY);</span><br><span class="line">    double fLen = (fSize / 3) * (sqrt(3) / 2);</span><br><span class="line">    nvct.fX = nvct.fX / fSize * fLen;</span><br><span class="line">    nvct.fY = nvct.fY / fSize * fLen;</span><br><span class="line">    pts[1] = beg + (vct * 0.5);</span><br><span class="line">    pts[1] = pts[1] + nvct;</span><br><span class="line"></span><br><span class="line">    drawKoch(beg, pts[<span class="number">0</span>], depth - <span class="number">1</span>, <span class="attribute">left</span>);</span><br><span class="line">    drawKoch(pts[<span class="number">0</span>], pts[<span class="number">1</span>], depth - <span class="number">1</span>, <span class="attribute">left</span>);</span><br><span class="line">    drawKoch(pts[<span class="number">1</span>], pts[<span class="number">2</span>], depth - <span class="number">1</span>, <span class="attribute">left</span>);</span><br><span class="line">    drawKoch(pts[2], end, depth - 1, left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    GLdoublePoint beg, end;</span><br><span class="line">    beg.fX = WINDOW_WIDTH / 3;</span><br><span class="line">    beg.fY = WINDOW_HEIGHT / 3 * 2;</span><br><span class="line">    end.fX = (WINDOW_WIDTH / 3) * 2;</span><br><span class="line">    end.fY = WINDOW_HEIGHT / 3 * 2;</span><br><span class="line">    drawKoch(beg, end, DEPTH, true);</span><br><span class="line"></span><br><span class="line">    beg.fX = WINDOW_WIDTH / 3;</span><br><span class="line">    beg.fY = WINDOW_HEIGHT / 3 * 2;</span><br><span class="line">    end.fX = WINDOW_WIDTH / 2;</span><br><span class="line">    end.fY = WINDOW_HEIGHT / 3 * 2 - (WINDOW_WIDTH / 3) * (sqrt(3) / 2);</span><br><span class="line">    drawKoch(beg, end, DEPTH, false);</span><br><span class="line"></span><br><span class="line">    beg.fX = WINDOW_WIDTH / 2;</span><br><span class="line">    beg.fY = WINDOW_HEIGHT / 3 * 2 - (WINDOW_WIDTH / 3) * (sqrt(3) / 2);</span><br><span class="line">    end.fX = WINDOW_WIDTH / 3 * 2;</span><br><span class="line">    end.fY = WINDOW_HEIGHT / 3 * 2;</span><br><span class="line">    drawKoch(beg, end, DEPTH, false);</span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("Koch雪花");</span><br><span class="line">    glutDisplayFunc(myDisplay);</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.5.3 心脏线<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const double PI = atan(1.0) * 4;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 0.0, 0.0, 0.0);</span><br><span class="line">    glColor3f(0.0f, 1.0f, 0.0f);</span><br><span class="line">    glPointSize(4.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    double fAdd = 0.01;</span><br><span class="line">    double K = 0.4;</span><br><span class="line">    double fX, fY, fValue;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line"></span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (float fTheta = 0.0; fTheta &lt;= 360; fTheta += fAdd)</span><br><span class="line">    &#123;</span><br><span class="line">        double fAngle = fTheta / ( 2 * PI);</span><br><span class="line">        fValue = K * (1 + cos(fAngle));</span><br><span class="line">        fX = fValue * cos(fAngle);</span><br><span class="line">        fY = fValue * sin(fAngle);</span><br><span class="line">        glVertex2f(fX, fY);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("阿基米德螺线");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>玫瑰曲线<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const double PI = atan(1.0) * 4;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 0.0, 0.0, 0.0);</span><br><span class="line">    glColor3f(0.0f, 1.0f, 0.0f);</span><br><span class="line">    glPointSize(4.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    double fAdd = 0.01;</span><br><span class="line">    double K = 1;</span><br><span class="line">    double fX, fY, fValue;</span><br><span class="line">    int N = 5;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line"></span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (float fTheta = 0.0; fTheta &lt;= 360; fTheta += fAdd)</span><br><span class="line">    &#123;</span><br><span class="line">        double fAngle = fTheta / ( 2 * PI);</span><br><span class="line">        fValue = K * cos(N * fAngle);</span><br><span class="line">        fX = fValue * cos(fAngle);</span><br><span class="line">        fY = fValue * sin(fAngle);</span><br><span class="line">        glVertex2f(fX, fY);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("玫瑰曲线");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>阿基米德曲线<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const double PI = atan(1.0) * 4;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 0.0, 0.0, 0.0);</span><br><span class="line">    glColor3f(0.0f, 1.0f, 0.0f);</span><br><span class="line">    glPointSize(4.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    double fAdd = 0.01;</span><br><span class="line">    double A = 0.01;</span><br><span class="line">    double fX, fY, fValue;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line"></span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (float fTheta = 0.0; fTheta &lt;= 360; fTheta += fAdd)</span><br><span class="line">    &#123;</span><br><span class="line">        double fAngle = fTheta / ( 2 * PI);</span><br><span class="line">        fValue = A * fAngle;</span><br><span class="line">        fX = fValue * cos(fAngle);</span><br><span class="line">        fY = fValue * sin(fAngle);</span><br><span class="line">        glVertex2f(fX, fY);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("阿基米德螺线");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对数螺旋线<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const double PI = atan(1.0) * 4;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 0.0, 0.0, 0.0);</span><br><span class="line">    glColor3f(0.0f, 1.0f, 0.0f);</span><br><span class="line">    glPointSize(2.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    double fAdd = 0.01;</span><br><span class="line">    double K = 0.018;</span><br><span class="line">    double a = 0.07;</span><br><span class="line">    double fX, fY, fValue;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line"></span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (float fTheta = 0.0; fTheta &lt;= 360; fTheta += fAdd)</span><br><span class="line">    &#123;</span><br><span class="line">        double fAngle = fTheta / ( 2 * PI);</span><br><span class="line">        fValue = K * exp(a * fAngle);</span><br><span class="line">        fX = fValue * cos(fAngle);</span><br><span class="line">        fY = fValue * sin(fAngle);</span><br><span class="line">        glVertex2f(fX, fY);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("对数螺旋线");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL视口，窗口，世界窗口(裁剪区)的理解</title>
      <link href="/2012/11/07/OpenGL%E8%A7%86%E5%8F%A3%EF%BC%8C%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%B8%96%E7%95%8C%E7%AA%97%E5%8F%A3(%E8%A3%81%E5%89%AA%E5%8C%BA)%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2012/11/07/OpenGL%E8%A7%86%E5%8F%A3%EF%BC%8C%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%B8%96%E7%95%8C%E7%AA%97%E5%8F%A3(%E8%A3%81%E5%89%AA%E5%8C%BA)%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>先讲下OpenGL的坐标系。OpenGL的坐标系和Windows窗口默认的坐标系是不同的。WindowsGDi的默认原点在左上角，X向右递增，Y向下递增，而OpenGL的原点在窗口的左下角，X向右递增，Y向上递增。</p><p>OpenGL里面所谓的窗口就是我们创建出来的窗口，也叫做屏幕窗口，我们可以在这整个窗口里面绘图。而视口则是窗口的一个子区域，通过设置视口就可以把绘图区域限定为窗口的一个子区域，而这个子区域的别名就叫做视口。这个函数是<strong>glViewport。</strong>该函数原型为<br>void <strong>glViewport</strong>(GLint _x_,<br>GLint _y_,<br>GLsizei _width_,<br>GLsizei _height_)</p><p>第一个参数和第二个参数是左下角的坐标，第三个参数和第四个参数则分别是视口的宽度和高度。记住一点，OpenGL用的是笛卡尔坐标系，而我一直习惯了WindowsGDI的坐标系设置。</p><p>现在来讲解最关键的东西—-世界窗口（裁剪区）。</p><p>这个东西理解了，我们就可以通过一些设置做出一些漂亮的图形裁剪啊之类的，总之能达到一些很爽的效果。以计算机图形学OpenGL版3.2节的例子来说明，世界窗口即是能容纳sinc(x) = sin(PI<em>x) / (PI </em>x)的定义域和值域的二维矩阵。比如说，这个例子里面绘画函数的时候x的范围是[-4.0,4.0]，该函数最大值不会超过1.0，在该范围内最小值也会大于-0.3，那么我们可以设置世界窗口为[-4.0,4.0,-0.3,1.0]，四个值分别是描述了现实世界中的一个与坐标轴平行的矩形。如果把世界窗口设置为[-5.0,5.0,-0.3,1.0]，该函数的显示效果可能会更好一点，因为可以看到边界外面的部分。</p><p>现在很明显的看到，世界窗口和视口大小基本上是不一致的，那么我们要显示的图形肯定会被拉伸。这个拉伸也是很简单的按照比例尺计算出来的。可以很形象的想象下，把一个人放小显示在一个窗口里面，或者把一只蚂蚁放大显示在一个窗口里面。</p><p>附3.2节sinc源码:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>)</span><br><span class="line"></span><br><span class="line">const <span class="attribute">float</span> PI = atan(<span class="number">1.0</span>) * <span class="number">4</span>;</span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置世界窗口</span></span><br><span class="line">void SetWindow(GLdouble <span class="attribute">left</span>, GLdouble right, GLdouble bottom, GLdouble top)</span><br><span class="line">&#123;</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(<span class="attribute">left</span>, right, bottom, top);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置视口</span></span><br><span class="line">void SetViewport(GLint <span class="attribute">left</span>, GLint right, GLint bottom, GLint top)</span><br><span class="line">&#123;</span><br><span class="line">    glViewport(<span class="attribute">left</span>, bottom, right - left, top - bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//白色背景</span><br><span class="line">    glColor3f(0.0, 0.0, 1.0);</span><br><span class="line">    glLineWidth(2.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);//使视图矩形栈有效</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line">    SetViewport(0, WINDOW_WIDTH / 2, 0, WINDOW_HEIGHT);//这个函数调用在main里面一直没效果</span><br><span class="line">    glBegin(GL_LINE_STRIP);</span><br><span class="line">    for (float x = -4.0; x &lt;= 4.0; x += 0.1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fabs(x) &lt; <span class="number">1</span>e-<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            glVertex2f(0.0, 1.0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            glVertex2f(x, sin(PI * x) / (PI* x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line"></span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("The Famous Sinc Function");</span><br><span class="line">    glutDisplayFunc(myDisplay);</span><br><span class="line">    myInit();</span><br><span class="line">    SetWindow(-5.0, 5.0, -0.3, 1.0);</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果如图，</p><p><img alt data-src="https://c2.staticflickr.com/8/7292/27153717460_4c258e9ddc_o.png"></p><p>由于我设置了视口为左半窗口，可以明显的看到，函数曲线挤压在左边了。注意，在主函数里面设置视口一直没有效果，我也不知道为什么。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学OpenGL版第二章源代码汇总</title>
      <link href="/2012/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6OpenGL%E7%89%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/"/>
      <url>/2012/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6OpenGL%E7%89%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>最近在用这本书学习计算机图形学，发现这本书在网上基本找不到配套的代码，找到的也是乱七八糟的，很不爽的那种，或者根本是语言初学者对着敲的。故打算把自己写的每个例子贡献出来。</p><p>散乱点图:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const int NUM = 1000;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(4.0);//设置点的大小为4*4像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (int i = 0; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        glVertex2i(rand() % WINDOW_WIDTH, rand() % WINDOW_HEIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("散乱点图");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Sierpinski垫片<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const int NUM = 55000;</span><br><span class="line"></span><br><span class="line">struct GLintPoint</span><br><span class="line">&#123;</span><br><span class="line">    GLint x;</span><br><span class="line">    GLint y;</span><br><span class="line">&#125;; </span><br><span class="line">GLintPoint pts[3] = &#123;&#123;10, 10&#125;, &#123;600, 10&#125;, &#123;300, 600&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(4.0);//设置点的大小为4*4像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void drawDot(GLintPoint pt)</span><br><span class="line">&#123;</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    glVertex2i(pt.x, pt.y);</span><br><span class="line">    glEnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sierpinskiRender()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    int nIndex = rand() % 3;</span><br><span class="line">    GLintPoint pt = pts[nIndex];</span><br><span class="line"></span><br><span class="line">    drawDot(pt);</span><br><span class="line">    for (int i = 0; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nIndex = rand() % 3;</span><br><span class="line">        pt.x = (pt.x + pts[nIndex].x) / 2;</span><br><span class="line">        pt.y = (pt.y + pts[nIndex].y) / 2;</span><br><span class="line">        drawDot(pt);</span><br><span class="line">    &#125;</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("Sierpinski垫片");</span><br><span class="line">    glutDisplayFunc(sierpinskiRender);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>绘制函数曲线:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment( linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span> ) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const double PI = atan(1.0) * 4.0; </span><br><span class="line">GLdouble A, B, C, D;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(2.0);//设置点的大小为2*2像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">    A = WINDOW_WIDTH / 4.0;</span><br><span class="line">    B = 0.0;</span><br><span class="line">    C = D = WINDOW_HEIGHT / 2.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    GLdouble fAdd = 0.001;</span><br><span class="line"></span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (GLdouble x = 0.0; x &lt; 4.0; x += fAdd)</span><br><span class="line">    &#123;</span><br><span class="line">        GLdouble fValue = exp(-x) * cos(2 * PI * x);</span><br><span class="line">        glVertex2d(A * x + B, C * fValue + D);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("Dot Plot of a Function");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>画矩形:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const int NUM = 8;</span><br><span class="line">const int BOARD_WIDTH = WINDOW_WIDTH / NUM;</span><br><span class="line">const int BOARD_HEIGHT = WINDOW_HEIGHT / NUM;</span><br><span class="line">const GLfloat r1 = 0.0, g1 = 0.0, b1 = 0.0;</span><br><span class="line">const GLfloat r2 = 1.0, g2 = 1.0, b2 = 1.0;</span><br><span class="line"></span><br><span class="line">struct GLintPoint</span><br><span class="line">&#123;</span><br><span class="line">    GLint x;</span><br><span class="line">    GLint y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(2.0);//设置点的大小为2*2像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据中心,高和宽绘画矩形</span></span><br><span class="line">void drawRectangleCenter(GLintPoint center, double fWidth, double fHeight)</span><br><span class="line">&#123;</span><br><span class="line">    glRectf(center<span class="selector-class">.x</span> - fWidth / <span class="number">2.0</span>, center<span class="selector-class">.y</span> - fHeight / <span class="number">2.0</span>,</span><br><span class="line">            center.x + fWidth / 2.0, center.y + fHeight / 2.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据左上角,高和宽高比绘画矩形</span></span><br><span class="line">void drawRectangleCornersize(GLintPoint topleft, double fHeight, double fScale)</span><br><span class="line">&#123;</span><br><span class="line">    glRectf(topleft.x, topleft.y, topleft.x + fHeight * fScale, topleft.y + fHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    GLintPoint center, topleft;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; NUM; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((i + j) % 2 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                glColor3f(r1, g1, b1);</span><br><span class="line">                center.x = i * BOARD_WIDTH + BOARD_WIDTH / 2.0;</span><br><span class="line">                center.y = j * BOARD_HEIGHT + BOARD_HEIGHT / 2.0;</span><br><span class="line">                drawRectangleCenter(center, BOARD_WIDTH, BOARD_HEIGHT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                glColor3f(r2, g2, b2);</span><br><span class="line">                topleft.x = i * BOARD_WIDTH;</span><br><span class="line">                topleft.y = j * BOARD_HEIGHT;</span><br><span class="line">                drawRectangleCornersize(topleft, BOARD_HEIGHT, BOARD_HEIGHT * 1.0 / BOARD_WIDTH);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("画矩形");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>画棋盘:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const int NUM = 8;</span><br><span class="line">const int BOARD_WIDTH = WINDOW_WIDTH / NUM;</span><br><span class="line">const int BOARD_HEIGHT = WINDOW_HEIGHT / NUM;</span><br><span class="line">const GLfloat r1 = 0.0, g1 = 0.0, b1 = 0.0;</span><br><span class="line">const GLfloat r2 = 1.0, g2 = 1.0, b2 = 1.0;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(2.0);//设置点的大小为2*2像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    for (int i = 0; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; NUM; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((i + j) % 2 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                glColor3f(r1, g1, b1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                glColor3f(r2, g2, b2);</span><br><span class="line">            &#125;</span><br><span class="line">            glRecti(i * BOARD_WIDTH, j * BOARD_HEIGHT,</span><br><span class="line">                    i * BOARD_WIDTH + BOARD_WIDTH, j * BOARD_HEIGHT + BOARD_HEIGHT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("棋盘");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>根据不同长宽比画矩形:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 400;</span><br><span class="line">const int WINDOW_HEIGHT = 400;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const int MAX = 100000;</span><br><span class="line">double R = 1.7;</span><br><span class="line"></span><br><span class="line">struct GLintPoint</span><br><span class="line">&#123;</span><br><span class="line">    GLint x;</span><br><span class="line">    GLint y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(2.0);//设置点的大小为2*2像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line"></span><br><span class="line">    double fWidth, fHeight;</span><br><span class="line">    <span class="keyword">if</span> (R &gt; <span class="number">1.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fWidth = WINDOW_WIDTH;</span><br><span class="line">        fHeight = fWidth / R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fHeight = WINDOW_HEIGHT;</span><br><span class="line">        fWidth = fHeight * R;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    glRectf(0.0, 0.0, fWidth, fHeight);</span><br><span class="line">    R = (rand() % MAX) * 1.0 / (MAX / 10.0);</span><br><span class="line"></span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("不同长宽比");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>鼠标和键盘:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line">const int NUM = 1000;</span><br><span class="line"></span><br><span class="line">struct GLintPoint</span><br><span class="line">&#123;</span><br><span class="line">    GLint x, y;</span><br><span class="line">&#125;;</span><br><span class="line">GLintPoint corner[2];</span><br><span class="line">bool bSelect = false;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(4.0);//设置点的大小为4*4像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">    glLineWidth(4.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line"></span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bSelect)</span><br><span class="line">    &#123;</span><br><span class="line">        glBegin(GL_QUADS);</span><br><span class="line">        glVertex2i(corner[0].x, corner[0].y);</span><br><span class="line">        glVertex2i(corner[0].x, corner[1].y);</span><br><span class="line">        glVertex2i(corner[1].x, corner[1].y);</span><br><span class="line">        glVertex2i(corner[1].x, corner[0].y);</span><br><span class="line">        glEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myMouse(int <span class="selector-tag">button</span>, int state, int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">button</span> == GLUT_LEFT_BUTTON  state == GLUT_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        corner[0].x = x;</span><br><span class="line">        corner[0].y = WINDOW_HEIGHT - y;</span><br><span class="line">        bSelect = true;</span><br><span class="line">    &#125;</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标在窗口上面移动并且没有按钮按下</span></span><br><span class="line">void myPassiveMotion(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    corner[1].x = x;</span><br><span class="line">    corner[1].y = WINDOW_HEIGHT - y;</span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myKeyboard(unsigned char key, int mouseX, int mouseY)</span><br><span class="line">&#123;</span><br><span class="line">    switch (key)</span><br><span class="line">    &#123;</span><br><span class="line">    case <span class="string">'P'</span>:</span><br><span class="line">    case <span class="string">'p'</span>:</span><br><span class="line">        glBegin(GL_POINTS);</span><br><span class="line">        glVertex2i(mouseX, WINDOW_HEIGHT - mouseY);</span><br><span class="line">        glEnd();</span><br><span class="line">        glutSwapBuffers();</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case <span class="string">'Q'</span>:</span><br><span class="line">    case <span class="string">'q'</span>:</span><br><span class="line">        exit(-1);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("Rubber Rect Demo");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    glutMouseFunc(myMouse);</span><br><span class="line">    glutPassiveMotionFunc(myPassiveMotion);</span><br><span class="line">    glutKeyboardFunc(myKeyboard);</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>菜单:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150; </span><br><span class="line"></span><br><span class="line">enum COLOR</span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE, WHITE</span><br><span class="line">&#125;;</span><br><span class="line"><span class="attribute">float</span> angle = <span class="number">0.0</span>;</span><br><span class="line"><span class="attribute">float</span> red = <span class="number">1.0</span>, blue = <span class="number">1.0</span>, green = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//清屏</span><br><span class="line">    glLoadIdentity();</span><br><span class="line"></span><br><span class="line">    glRotatef(angle, 0.0, 1.0, 0.0);</span><br><span class="line">    glColor3f(red, green, blue);</span><br><span class="line">    glBegin(GL_TRIANGLES);//下面的画点坐标为什么是这么设置的了?</span><br><span class="line">    glVertex3f(-0.5, -0.5, 1.0);</span><br><span class="line">    glVertex3f(0.5, 0.0, 0.0);</span><br><span class="line">    glVertex3f(0.0, 0.5, 2.0);</span><br><span class="line">    glEnd();</span><br><span class="line">    angle++;</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myMenuEvents(int option)</span><br><span class="line">&#123;</span><br><span class="line">    switch (option)</span><br><span class="line">    &#123;</span><br><span class="line">    case RED: red = 1.0; green = blue = 0.0; break;</span><br><span class="line">    case GREEN: green = 1.0; red = blue = 0.0; break;</span><br><span class="line">    case BLUE: blue = 1.0; red = green = 0.0; break;</span><br><span class="line">    case WHITE: red = green = blue = 1.0; break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("Menu Test");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    glutIdleFunc(myDisplay);</span><br><span class="line">    glutCreateMenu(myMenuEvents);</span><br><span class="line">    glutAddMenuEntry("Red", RED);</span><br><span class="line">    glutAddMenuEntry("Blue", BLUE);</span><br><span class="line">    glutAddMenuEntry("Green", GREEN);</span><br><span class="line">    glutAddMenuEntry("Black", WHITE);</span><br><span class="line">    glutAttachMenu(GLUT_RIGHT_BUTTON);</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>姜饼人:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const int M = 40;</span><br><span class="line">const int L = 3;</span><br><span class="line">const int TIMES = 1000000;</span><br><span class="line"></span><br><span class="line">struct GLintPoint</span><br><span class="line">&#123;</span><br><span class="line">    GLint x, y;</span><br><span class="line">&#125;;</span><br><span class="line">GLintPoint p, q;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(2.0);//设置点的大小为2*2像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">    p.x = 121;</span><br><span class="line">    p.y = 115;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (int i = 0; i &lt; TIMES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q.x = M * (1 + 2 * L) - p.y + abs(p.x - L * M);</span><br><span class="line">        q.y = p.x;</span><br><span class="line">        p = q;</span><br><span class="line">        glVertex2f(p.x, p.y);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("姜饼人");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在VC下面学习OpenGL</title>
      <link href="/2012/11/06/%E5%9C%A8VC%E4%B8%8B%E9%9D%A2%E5%AD%A6%E4%B9%A0OpenGL/"/>
      <url>/2012/11/06/%E5%9C%A8VC%E4%B8%8B%E9%9D%A2%E5%AD%A6%E4%B9%A0OpenGL/</url>
      
        <content type="html"><![CDATA[<p>先贴一个OpenGL程序的代码,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;windows.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/gl.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glu.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;gl/glut.h&gt;</span><br><span class="line"><span class="selector-id">#pragma</span> comment(linker, <span class="string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span>) <span class="comment">//设置连接器选项</span></span><br><span class="line"></span><br><span class="line">const int WINDOW_WIDTH = 640;</span><br><span class="line">const int WINDOW_HEIGHT = 480;</span><br><span class="line">const int WINDOW_POS_X = 300;</span><br><span class="line">const int WINDOW_POS_Y = 150;</span><br><span class="line">const int NUM = 1000;</span><br><span class="line"></span><br><span class="line">void myInit()</span><br><span class="line">&#123;</span><br><span class="line">    glClearColor(1.0, 1.0, 1.0, 0.0);//设置背景颜色为亮白</span><br><span class="line">    glColor3f(0.0f, 0.0f, 0.0f);//设置绘图颜色为黑色</span><br><span class="line">    glPointSize(4.0);//设置点的大小为4*4像素</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluOrtho2D(0.0, WINDOW_WIDTH, 0.0, WINDOW_HEIGHT);//以上三句话合起伙是设置窗口的坐标系</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay()</span><br><span class="line">&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);//清屏</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    for (int i = 0; i &lt; NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        glVertex2i(rand() % WINDOW_WIDTH, rand() % WINDOW_HEIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();//送往设备显示</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    glutInit(argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//设置显示模式</span><br><span class="line">    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);</span><br><span class="line">    glutInitWindowPosition(WINDOW_POS_X, WINDOW_POS_Y);</span><br><span class="line">    glutCreateWindow("散乱点图");</span><br><span class="line">    glutDisplayFunc(myDisplay);//注册重绘回调函数</span><br><span class="line">    myInit();</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    glutMainLoop();//进入消息循环</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序只是创建一个窗口，然后在里面画一些随机的点。效果如图所示，</p><p><img alt data-src="https://c6.staticflickr.com/8/7386/26822942093_22d5d37726_o.jpg"></p><p>说实话这个程序非常简单，在主函数里面只是设置了窗口大小和位置，然后创建了个窗口，做了些初始化，并且为窗口设置了显示回调函数。初始化函数里面都有注释，显示回调函数里面只是一直在随机画点而已。</p><p>说实话，仅仅是使用最基本的opengl画图确实太简单了，也没什么多说的，如果你熟悉Windows程序设计和C++语言，只是换个库而已，真正需要学习的是计算机图形学。我觉得OpenGL相对于DirectX简洁明了很多了，所以才选择了计算机图形学OpenGL版这本书来学习图形学的。下面来简要介绍下OpenGL的库组成吧。</p><p>OpenGL库分为四个部分，GL和GLU，GLUT以及GLUI。GL和GLU都是用于绘图的，只是第一个是基本库，第二个是一些高级的绘图函数。GLUT库主要包含一些管理窗口和菜单的函数，GLUI则是一些高级的界面管理部分，比如各种复杂的按钮和菜单。</p><p>我觉得如果在VC下面建立控制台工程，然后设置链接命令去掉控制台窗口，再在main函数下执行OpenGL操作，这个过程不仅简洁而且感觉效果也不错。现在看来，OpenGL确实是一个比较美观的东西，至少相对于我用了几年的MFC来说。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Console工程下如何不显示控制台黑窗口只显示Windows窗口</title>
      <link href="/2012/11/06/Console%E5%B7%A5%E7%A8%8B%E4%B8%8B%E5%A6%82%E4%BD%95%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%BB%91%E7%AA%97%E5%8F%A3%E5%8F%AA%E6%98%BE%E7%A4%BAWindows%E7%AA%97%E5%8F%A3/"/>
      <url>/2012/11/06/Console%E5%B7%A5%E7%A8%8B%E4%B8%8B%E5%A6%82%E4%BD%95%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6%E5%8F%B0%E9%BB%91%E7%AA%97%E5%8F%A3%E5%8F%AA%E6%98%BE%E7%A4%BAWindows%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>本文是以OpenGL的代码为例子的。计算机图形学OpenGL版上面的例子都是控制台模式的，如果不进行设置，运行的时候会先出现黑窗口再出现Windows窗口。</p><p>其实要去除控制台窗口非常简单，只需要修改工程设置，把子系统改成Windows，程序的入口点改成mainCRTStartup。</p><p>下面我先把几中解决办法列举出来，再解释下我的理解。</p><p>方法一：在程序中加入一句#pragma comment(linker, “/subsystem:\”windows\” /entry:\”mainCRTStartup\””)，建议加在include的后面。</p><p>方法二：修改工程设置。</p><p>对于vc6，地方在Project-&gt;setting-&gt;Link-&gt;Project Options。</p><p>点开后的界面如图，<br><img alt data-src="https://c2.staticflickr.com/8/7311/26822691403_8a9e32a9b9_o.png"></p><p>在右下角的Project Options里面找到/subsytem:,并把其后面其后面的参数改成为windows,然后再找到/entry:，把其后面的值改成”mainCRTStartup”，如果找不到就添加，最后的效果是/subsystem:windows /entry:”mainCRTStartup”。</p><p>对于vs2008，地方在项目-&gt;属性-&gt;链接器，</p><p>然后在左边选中高级，如图所示，<br><img alt data-src="https://c2.staticflickr.com/8/7339/26822691883_876f4aac50_o.png"></p><p>在最上面的入口点输入mainCRTStartup，再选中系统，如图所示，</p><p><img alt data-src="https://c2.staticflickr.com/8/7323/26822692733_cb9da04a2a_o.png"></p><p>在最上面的子系统选择Windows即可了。</p><p>为什么这样设置下就可以了了。<strong>主要是因为Windows系统下有几种子系统，一种是控制台，一种是窗口子系统</strong>，如果建立了控制台工程肯定是要创建控制台子系统程序了，建立了Windows Application和MFC之类的工程则是窗口子系统了。<strong>不同的子系统会链接不同的主函数</strong>，控制台的会链接main,窗口的会链接WinMain，如果不匹配肯定会链接失败。</p><p>现在我们使用OpenGL编程，又建立的是控制台工程，如果不进行设置肯定会出现黑窗口的，所以我们把工程的子系统改成Windows，但是我们不想改主函数为WinMain了，因为这样会很麻烦，所以我们再把程序入口改成mainCRTStartup。同样如果是win32 App工程下，我们可以把子系统改成控制台，再设置程序入口为WinMainCRTStartup，应该就会得到相反的效果了。</p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Begin Graphics With OpenGL(在vc6和vs2008下使用OpenGL进行编程)</title>
      <link href="/2012/11/04/Begin%20Graphics%20With%20OpenGL(%E5%9C%A8vc6%E5%92%8Cvs2008%E4%B8%8B%E4%BD%BF%E7%94%A8OpenGL%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A8%8B)/"/>
      <url>/2012/11/04/Begin%20Graphics%20With%20OpenGL(%E5%9C%A8vc6%E5%92%8Cvs2008%E4%B8%8B%E4%BD%BF%E7%94%A8OpenGL%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A8%8B)/</url>
      
        <content type="html"><![CDATA[<p>首先，我们需要安装好VC6或者VS2008，然后获取OpenGL的开发包。剩下的一件麻烦事情就是配置了。</p><p>如果你找不到合适的开发包，可以从我这里下载，里面开发包和查询手册，可是我辛苦收集好的哦。地址：<a href="https://pan.baidu.com/s/1bpp181T" target="_blank" rel="noopener">OpenGL SDK</a></p><p>在你下载好的开发包里面，会出现三个目录，分别是include和lib,system32。include里面当然是OpenGL的头文件了，那么lib则是动态链接时候的导入库了，system32里面是几个dll，dll你知道该放在哪里吧，放在你的程序同一个目录下，或者干脆放在系统目录下，即c盘下面的system32目录。开发包里面有个txt文件简要说明了如何设置include和lib，下面我要用图示详细说明vc6和vs2008下的设置方法。</p><p><strong>vc6下的设置</strong>，<br>step1:<br>Tools-&gt;Options-&gt;directories<br><img alt data-src="https://c2.staticflickr.com/8/7197/26820703294_b85f12cc03_o.png"></p><p>step2:<br>在Show Directories For选型卡里面选择include files<br>然后,在下面的directories里面添加一个新项，然后选择opengl的include目录，再用右上角的箭头上移到最上面。</p><p>step3:<br>在Show Directories For选型卡里面选择Library files<br>然后,在下面的directories里面添加一个新项，然后选择opengl的lib目录，再用右上角的箭头上移到最上面。</p><p>step4:<br>把opengl开发包里面的system32文件下面的dll全部拷贝的C:\WINDOWS\system32下面，当然不同的系统这个目录不同，<br>不过这都是系统目录。</p><p>现在你就可以用vc6下使用opengl学习图形学了。。。</p><p><strong>vs2008下的设置</strong>,<br>step1:<br>工具-&gt;选项，打开如图所示的对话框，<img alt data-src="https://c2.staticflickr.com/8/7197/26820701964_e3f17c8253_o.png"><br>点开左边的项目和解决方案，选择里面的vc++目录。</p><p>step2:<br>类似vc6下面的设置，在右边的显示一下内容的目录选项卡中选择包含文件，再在下面的列表框里面添加一个新的目录作为新的include目录。目录的路径设置同vc6，就是开发包的include文件夹。</p><p>step3:<br>类似vc6下面的设置，在右边的显示一下内容的目录选项卡中选择库文件，再在下面的列表框里面添加一个新的目录作为新的lib目录。目录的路径设置同vc6，就是开发包的lib文件夹。</p><p>step4:<br>同样是拷贝dll到系统目录下。</p><p>至此基本解决了，无论是哪种外部库的设置都是如果搞一下就ok了，无论是哪个版本的vs，基本上设置的地方差别不大。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3264 Balanced Lineup St算法建立Rmq</title>
      <link href="/2012/10/25/poj%203264%20Balanced%20Lineup%20St%E7%AE%97%E6%B3%95%E5%BB%BA%E7%AB%8BRmq/"/>
      <url>/2012/10/25/poj%203264%20Balanced%20Lineup%20St%E7%AE%97%E6%B3%95%E5%BB%BA%E7%AB%8BRmq/</url>
      
        <content type="html"><![CDATA[<p>ST算法可以说就是个二维的动态规划，黑书上有解释。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_I = 50010;</span><br><span class="line">const int MAX_J = 20;</span><br><span class="line"></span><br><span class="line">int nMax[MAX_I][MAX_J];</span><br><span class="line">int nMin[MAX_I][MAX_J];</span><br><span class="line">int nArr[MAX_I];</span><br><span class="line">int nN, nQ;</span><br><span class="line"></span><br><span class="line">void InitRmq(int nN)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nMax[i][0] = nMin[i][0] = nArr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j = 1; (1 &lt;&lt; j) &lt;= nN; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nMax[i][j] = max(nMax[i][j - <span class="number">1</span>],</span><br><span class="line">                             nMax[i + (1 &lt;&lt; (j - 1))][j - 1]);</span><br><span class="line">            nMin[i][j] = min(nMin[i][j - <span class="number">1</span>],</span><br><span class="line">                             nMin[i + (1 &lt;&lt; (j - 1))][j - 1]);                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Query(int nA, int nB)</span><br><span class="line">&#123;</span><br><span class="line">    int k = (int)(log(1.0 * nB - nA + 1) / log(2.0));</span><br><span class="line">    int nBig = max(nMax[nA][k], nMax[nB - (1 &lt;&lt; k) + 1][k]);</span><br><span class="line">    int nSml = min(nMin[nA][k], nMin[nB - (1 &lt;&lt; k) + 1][k]);</span><br><span class="line">    return nBig - nSml;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nQ) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d", &amp;nArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        InitRmq(nN);</span><br><span class="line">        for (int i = 0; i &lt; nQ; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int nA, nB;</span><br><span class="line">            scanf("%d%d", &amp;nA, &amp;nB);</span><br><span class="line">            printf("%d\n", Query(nA, nB));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 3068 最长回文 Manacher算法</title>
      <link href="/2012/10/24/hdu%203068%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%20Manacher%E7%AE%97%E6%B3%95/"/>
      <url>/2012/10/24/hdu%203068%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%20Manacher%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>该题就是求一个字符串的最长回文子串，就是一个满足本身是回文的最长的子串。<br>该题貌似可以用后缀数组和扩展kmp做，但是好像后缀数组貌似会tle，改学了下一个专门的叫Manacher算法的东西。。。<br>这又是一个线性改良算法。找到有篇文章写的不错，链接如下：<br><a href="http://www.felix021.com/blog/read.php?2040" target="_blank" rel="noopener">http://www.felix021.com/blog/read.php?2040</a>。<br>该算法说起来也不是太复杂，比较容易看懂的那种，当然是接触过其它字符串算法的前提下了。记得以前就看了看，硬是没看懂，想不到现在这么快就明白了。<br>该算法需要额外的O(N)空间。说起来是空间换时间吧。<br>大概的思路是先预处理字符串，使其成为一个长度一定为偶数的串。而且第一个字符是’$’，假设’$’没有在原串出现过。然后再在原来的每个字符前面加上’#’，最后再加个<br>‘#’。比如，abc就变成了$#a#b#c#。现在再对新的字符串进行处理。<br>开一个新的数组nRad[MAX]，nRad[i]表示新串中第i个位置向左边和向右边同时扩展并且保持对称的最大距离。如果求出了nRad数组后，有一个结论，nRad[i]-1恰好表示原串对应的位置能够扩展的回文子串长度。这个的证明，应该比较简单，因为新串基本上是原串的2倍了，而且新串每一个有效字符两侧都有插入的#，这个找个例子看下就知道是这样了。<br>最重要的是如何求出nRad数组。<br>求这个数组的算法也主要是利用了一些间接的结论优化了nRad[i]的初始化值。比如我们求nRad[i]的时候，如果知道了i以前的nRad值，而且知道了前面有一个位置id，能够最大的向两边扩展距离max。那么有一个结论，nRad[i] 能够初始化为min(nRad[2*id - i], max - i)，然后再进行递增。关键是如何证明这个，这个的证明，对照图片就很清楚了。<br>证明如下：<br>当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，<br>以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]，见下图。<br><img alt data-src="https://c2.staticflickr.com/8/7049/27312602222_9f02e36521_o.png"></p><p>当 P[j] &gt; mx - i 的时候，以S[j]为中心的回文子串不完全包含于以S[id]为中心的回文子串中，但是基于<br>对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会<br>扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。<br><img alt data-src="https://c2.staticflickr.com/8/7322/27312603572_34d229d8e5_o.png"><br>这个就说明得很清楚了。。。</p><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX = 110010 * 2;</span><br><span class="line">char szIn[MAX];</span><br><span class="line">char szOut[MAX];</span><br><span class="line">int nRad[MAX];</span><br><span class="line"></span><br><span class="line">int Proc(char* pszIn, char* pszOut)</span><br><span class="line">&#123;</span><br><span class="line">    int nLen = 1;</span><br><span class="line"></span><br><span class="line">    *pszOut++ = '$';</span><br><span class="line">    while (*pszIn)</span><br><span class="line">    &#123;</span><br><span class="line">        *pszOut++ = '#';</span><br><span class="line">        nLen++;</span><br><span class="line">        *pszOut++ = *pszIn++;</span><br><span class="line">        nLen++;</span><br><span class="line">    &#125;</span><br><span class="line">    *pszOut++ = '#';</span><br><span class="line">    *pszOut = '\0';</span><br><span class="line"></span><br><span class="line">    return nLen + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Manacher(int* pnRad, char* pszStr, int nN)</span><br><span class="line">&#123;</span><br><span class="line">    int nId = 0, nMax = 0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pnRad[0] = 1;</span></span><br><span class="line">    for (int i = 0; i &lt; nN; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span> (nMax &gt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            pnRad[i] = min(pnRad[2 * nId - i], nMax - i);</span><br><span class="line">        &#125;</span><br><span class="line">        else pnRad[i] = 1;</span><br><span class="line"></span><br><span class="line">        while (pszStr[<span class="selector-tag">i</span> + pnRad[i]] == pszStr[<span class="selector-tag">i</span> - pnRad[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            ++pnRad[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pnRad[i] + <span class="selector-tag">i</span> &gt; nMax)</span><br><span class="line">        &#123;</span><br><span class="line">            nMax = pnRad[i] + i;</span><br><span class="line">            nId = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%s"</span>, szIn) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nLen = Proc(szIn, szOut);</span><br><span class="line">        Manacher(nRad, szOut, nLen);</span><br><span class="line">        int nAns = 1;</span><br><span class="line">        for (int i = 0; i &lt; nLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = max(nRad[i], nAns);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nAns - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3294 Life Forms 后缀数组求至少出现在K个字符串中的最长公共子串</title>
      <link href="/2012/10/24/poj%203294%20Life%20Forms%20%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%B1%82%E8%87%B3%E5%B0%91%E5%87%BA%E7%8E%B0%E5%9C%A8K%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/"/>
      <url>/2012/10/24/poj%203294%20Life%20Forms%20%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%B1%82%E8%87%B3%E5%B0%91%E5%87%BA%E7%8E%B0%E5%9C%A8K%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>此题就是给出N个字符串，然后求一个最长的子串，它至少出现在N/2+1个字符串中，如果有多个这样的子串，按字典序输出，如果没有这样的子串，输出?。<br>此题是罗穗骞论文里面的例11，他有讲述具体的解法。要用后缀数组做这样的题真不容易，用后缀数组就感觉是一件非常纠结的事情了。<br>这个题的解法还是那种模式化的思路。把N个字符串连接成一个，注意中间加不出现在任何一个字符串中的分隔符，然后建立sa数组和height数组等。最后二分答案，根据答案，即子串的长度对height数组进行分组，分组的思路还是罗穗骞论文里面例3的思路，即从到后枚举height数组，把连续大于等于答案的值放做一组，一旦小于答案那么就是新的分组。这个题需要找到一些分组，其中的后缀是能够出现在N个原串中，这个分组的公共前缀就是sa[i]开始的nMid个字符了(nMid是二分时候获得的子串长度)。由于这个题需要按字典序输出多个满足要求的子串，所以麻烦了点。需要在Check函数里面记录这些子串，而且输出答案的时候需要排序，再unique，由于是按height数组的顺序查找的，而sa[i]已经排好序了，所以排序答案的过程可以省略，但是必须unique。想下Check函数里面遍历height数组的过程就知道可能出现重复的子串。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX_N = 110;</span><br><span class="line">const int MAX_L = 1010;</span><br><span class="line">const int MAX = MAX_N * MAX_L;</span><br><span class="line">int nAns;</span><br><span class="line">char szStr[MAX_L];</span><br><span class="line">char szAns[MAX][MAX_L];</span><br><span class="line">char* pszAns[MAX];</span><br><span class="line">int nNum[MAX];</span><br><span class="line">int nLoc[MAX];</span><br><span class="line">bool bVis[MAX_N];</span><br><span class="line">int sa[MAX], rank[MAX], <span class="attribute">height</span>[MAX];</span><br><span class="line">int wa[MAX], wb[MAX], wv[MAX], wd[MAX];</span><br><span class="line">bool CmpStr(const char* pszOne, const char* pszTwo)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(pszOne, pszTwo) &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line">bool EqualStr(const char* pszOne, const char* pszTwo)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(pszOne, pszTwo) == 0;</span><br><span class="line">&#125;</span><br><span class="line">int cmp(int* r, int a, int b, int l)</span><br><span class="line">&#123;</span><br><span class="line">    return r[a] == r[b]  r[a + l] == r[b + l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倍增算法,r为待匹配数组,n为总长度,m为字符串范围</span></span><br><span class="line">void da(int* r, int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, p, *x = wa, *y = wb;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; m; ++i) wd[i] = 0;</span><br><span class="line">    for (i = 0; i &lt; n; ++i) wd[x[i] = r[i]]++;</span><br><span class="line">    for (i = 1; i &lt; m; ++i) wd[i] += wd[i - 1];</span><br><span class="line">    for (i = n - 1; i &gt;= 0; --i) sa[--wd[x[i]]] = i;</span><br><span class="line"></span><br><span class="line">    for (j = 1, p = 1; p &lt; n; j *= 2, m = p)</span><br><span class="line">    &#123;</span><br><span class="line">        for (p = 0, i = n - j; i &lt; n; ++i) y[p++] = i;</span><br><span class="line">        for (i = 0; i &lt; n; ++i) if (sa[i] &gt;= j) y[p++] = sa[i] - j;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; ++i) wv[i] = x[y[i]];</span><br><span class="line">        for (i = 0; i &lt; m; ++i) wd[i] = 0;</span><br><span class="line">        for (i = 0; i &lt; n; ++i) wd[wv[i]]++;</span><br><span class="line">        for (i = 1; i &lt; m; ++i) wd[i] += wd[i - 1];</span><br><span class="line">        for (i = n - 1; i &gt;= 0; --i) sa[--wd[wv[i]]] = y[i];</span><br><span class="line"></span><br><span class="line">        swap(x, y);</span><br><span class="line">        for (p = 1, x[sa[0]] = 0, i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x[sa[i]] = cmp(y, sa[i - 1], sa[i], j)? p - 1 : p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求height数组</span></span><br><span class="line">void calHeight(int* r, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k = 0;</span><br><span class="line">    for (i = 1; i &lt;= n; ++i) rank[sa[i]] = i;</span><br><span class="line">    for (i = 0; i &lt; n; height[rank[i++]] = k)</span><br><span class="line">    &#123;</span><br><span class="line">        if (k) --k;</span><br><span class="line">        for(j = sa[rank[i] - 1]; r[i + k] == r[j + k]; k++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool Check(int nMid, int nN, int nK)</span><br><span class="line">&#123;</span><br><span class="line">    int nCnt = 0;</span><br><span class="line">    int nNo = 0;</span><br><span class="line"></span><br><span class="line">    memset(bVis, false, sizeof(bVis));</span><br><span class="line">    for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="attribute">height</span>[i] &lt; nMid)</span><br><span class="line">        &#123;</span><br><span class="line">            nCnt = 0;</span><br><span class="line">            memset(bVis, false, sizeof(bVis));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bVis[nLoc[sa[<span class="selector-tag">i</span> - <span class="number">1</span>]]])</span><br><span class="line">            &#123;</span><br><span class="line">                ++nCnt;</span><br><span class="line">                bVis[nLoc[sa[i - 1]]] = true;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!bVis[nLoc[sa[i]]])</span><br><span class="line">            &#123;</span><br><span class="line">                ++nCnt;</span><br><span class="line">                bVis[nLoc[sa[i]]] = true;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nCnt == nK)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j = 0; j &lt; nMid; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    szAns[nNo][j] = nNum[sa[i] + j];</span><br><span class="line">                &#125;</span><br><span class="line">                szAns[nNo][nMid] = 0;</span><br><span class="line">                ++nNo;</span><br><span class="line">                nCnt = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nNo &gt; 0) nAns = nNo;</span><br><span class="line">    return nNo &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    bool bFirst = true;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        if (bFirst) bFirst = false;</span><br><span class="line">        else putchar('\n');</span><br><span class="line"></span><br><span class="line">        int nEnd = 300;</span><br><span class="line">        int nP = 0;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s", szStr);</span><br><span class="line">            int nLen = strlen(szStr);</span><br><span class="line">            for (int j = 0; j &lt; nLen; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                nNum[nP] = szStr[j];</span><br><span class="line">                nLoc[nP++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            nNum[nP] = nEnd;</span><br><span class="line">            nLoc[nP++] = nEnd++;</span><br><span class="line">        &#125;</span><br><span class="line">        nNum[nP] = 0;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nN == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%s\n\n", szStr);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        da(nNum, nP + 1, 500);//500是估计的字符集大小</span><br><span class="line">        calHeight(nNum, nP);</span><br><span class="line"></span><br><span class="line">        int nLeft = 1, nRight = strlen(szStr);</span><br><span class="line">        int nTemp = 0, nMid;</span><br><span class="line">        int nK = nN / 2 + 1;</span><br><span class="line">        nAns = 0;</span><br><span class="line">        while (nLeft &lt;= nRight)</span><br><span class="line">        &#123;</span><br><span class="line">            nMid = (nLeft + nRight) &gt;&gt; 1;</span><br><span class="line">            <span class="keyword">if</span> (Check(nMid, nP, nK))</span><br><span class="line">            &#123;</span><br><span class="line">                nTemp = nMid;</span><br><span class="line">                nLeft = nMid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else nRight = nMid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nTemp == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("?\n");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 0; i &lt; nAns; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pszAns[i] = szAns[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//sort(pszAns, pszAns + nAns, CmpStr);</span></span><br><span class="line">            nAns = unique(pszAns, pszAns + nAns, EqualStr) - pszAns;</span><br><span class="line">            for (int i = 0; i &lt; nAns; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                printf("%s\n", pszAns[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1226 Substrings 后缀数组</title>
      <link href="/2012/10/23/poj%201226%20Substrings%20%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2012/10/23/poj%201226%20Substrings%20%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>求N个字符串最长的公共子串。这题数据比较水，暴力第一个字符串的子串也可以过。初学后缀数组，有很多不明白的东西，此题后缀数组的代码在网上也是一把抓。<br>说实话我确实还不懂后缀数组，但是后缀数组太强大了，只能硬着头皮照着葫芦画瓢了。贴下代码方便以后查阅吧。。。<br>感觉后缀数组的应用最主要的还是height数组，看懂倍增算法排序后缀已经非常困难了。然后再理解height数组怎么用也不是一件容易的事情。然后貌似height数组最关键的用法是枚举某一个长度的子串时候，比如长度为k，能够用这个k对height数组进行分组，这个罗穗骞的论文里面有个求不重叠最长重复子串的例子说明了这个height数组分组的思路，不过我现在还是不怎么理解。。。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 110;</span><br><span class="line">const int MAX_L = MAX_N * MAX_N;</span><br><span class="line">char szStr[MAX_N];</span><br><span class="line">int nNum[MAX_L];</span><br><span class="line">int nLoc[MAX_L];</span><br><span class="line">bool bVisit[MAX_N];</span><br><span class="line">int sa[MAX_L], rank[MAX_L], <span class="attribute">height</span>[MAX_L];</span><br><span class="line">int wa[MAX_L], wb[MAX_L], wv[MAX_L], wd[MAX_L];</span><br><span class="line"></span><br><span class="line">int cmp(int* r, int a, int b, int l)</span><br><span class="line">&#123;</span><br><span class="line">    return r[a] == r[b]  r[a + l] == r[b + l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倍增算法,r为待匹配数组,n为总长度,m为字符串范围</span></span><br><span class="line">void da(int* r, int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, p, *x = wa, *y = wb;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; m; ++i) wd[i] = 0;</span><br><span class="line">    for (i = 0; i &lt; n; ++i) wd[x[i] = r[i]]++;</span><br><span class="line">    for (i = 1; i &lt; m; ++i) wd[i] += wd[i - 1];</span><br><span class="line">    for (i = n - 1; i &gt;= 0; --i) sa[--wd[x[i]]] = i;</span><br><span class="line"></span><br><span class="line">    for (j = 1, p = 1; p &lt; n; j *= 2, m = p)</span><br><span class="line">    &#123;</span><br><span class="line">        for (p = 0, i = n - j; i &lt; n; ++i) y[p++] = i;</span><br><span class="line">        for (i = 0; i &lt; n; ++i) if (sa[i] &gt;= j) y[p++] = sa[i] - j;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; ++i) wv[i] = x[y[i]];</span><br><span class="line">        for (i = 0; i &lt; m; ++i) wd[i] = 0;</span><br><span class="line">        for (i = 0; i &lt; n; ++i) wd[wv[i]]++;</span><br><span class="line">        for (i = 1; i &lt; m; ++i) wd[i] += wd[i - 1];</span><br><span class="line">        for (i = n - 1; i &gt;= 0; --i) sa[--wd[wv[i]]] = y[i];</span><br><span class="line"></span><br><span class="line">        swap(x, y);</span><br><span class="line">        for (p = 1, x[sa[0]] = 0, i = 1; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x[sa[i]] = cmp(y, sa[i - 1], sa[i], j)? p - 1 : p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求height数组</span></span><br><span class="line">void calHeight(int* r, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k = 0;</span><br><span class="line">    for (i = 1; i &lt;= n; ++i) rank[sa[i]] = i;</span><br><span class="line">    for (i = 0; i &lt; n; height[rank[i++]] = k)</span><br><span class="line">    &#123;</span><br><span class="line">        if (k) --k;</span><br><span class="line">        for(j = sa[rank[i] - 1]; r[i + k] == r[j + k]; k++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Check(int nMid, int nLen, int nN)</span><br><span class="line">&#123;</span><br><span class="line">    int nCnt = 0;</span><br><span class="line"></span><br><span class="line">    memset(bVisit, false, sizeof(bVisit));</span><br><span class="line">    for (int i = 2; i &lt;= nLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nMid &gt; <span class="attribute">height</span>[i])</span><br><span class="line">        &#123;</span><br><span class="line">            nCnt = 0;</span><br><span class="line">            memset(bVisit, false, sizeof(bVisit));</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bVisit[nLoc[sa[<span class="selector-tag">i</span> - <span class="number">1</span>]]])</span><br><span class="line">        &#123;</span><br><span class="line">            bVisit[nLoc[sa[i - 1]]] = true;</span><br><span class="line">            ++nCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bVisit[nLoc[sa[i]]])</span><br><span class="line">        &#123;</span><br><span class="line">            bVisit[nLoc[sa[i]]] = true;</span><br><span class="line">            ++nCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nCnt == nN) return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        int nN;</span><br><span class="line">        int nEnd = 300;</span><br><span class="line">        int nP = 0;</span><br><span class="line">        scanf("%d", nN);</span><br><span class="line">        for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s", szStr);</span><br><span class="line">            char* pszStr;</span><br><span class="line">            for (pszStr = szStr; *pszStr; ++pszStr)</span><br><span class="line">            &#123;</span><br><span class="line">                nLoc[nP] = i;</span><br><span class="line">                nNum[nP++] = *pszStr;</span><br><span class="line">            &#125;</span><br><span class="line">            nLoc[nP] = nEnd;</span><br><span class="line">            nNum[nP++] = nEnd++;</span><br><span class="line"></span><br><span class="line">            reverse(szStr, szStr + strlen(szStr));</span><br><span class="line">            for (pszStr = szStr; *pszStr; ++pszStr)</span><br><span class="line">            &#123;</span><br><span class="line">                nLoc[nP] = i;</span><br><span class="line">                nNum[nP++] = *pszStr;</span><br><span class="line">            &#125;</span><br><span class="line">            nLoc[nP] = nEnd;</span><br><span class="line">            nNum[nP++] = nEnd++;</span><br><span class="line">        &#125;</span><br><span class="line">        nNum[nP] = 0;</span><br><span class="line"></span><br><span class="line">        da(nNum, nP + 1, nEnd);</span><br><span class="line">        calHeight(nNum, nP);</span><br><span class="line"></span><br><span class="line">        int nLeft = 1, nRight = strlen(szStr), nMid;</span><br><span class="line">        int nAns = 0;</span><br><span class="line">        while (nLeft &lt;= nRight)</span><br><span class="line">        &#123;</span><br><span class="line">            nMid = (nLeft + nRight) / 2;</span><br><span class="line">            <span class="keyword">if</span> (Check(nMid, nP, nN))</span><br><span class="line">            &#123;</span><br><span class="line">                nLeft = nMid + 1;</span><br><span class="line">                nAns = nMid;</span><br><span class="line">            &#125;</span><br><span class="line">            else nRight = nMid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3691 DNA repair AC自动机 + dp</title>
      <link href="/2012/10/21/poj%203691%20DNA%20repair%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%20+%20dp/"/>
      <url>/2012/10/21/poj%203691%20DNA%20repair%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%20+%20dp/</url>
      
        <content type="html"><![CDATA[<p>题意是给定一系列模式串。然后给出一个文本串，问至少改变文本串里面多少个字符可以使文本串不包含任何一个模式串。<br>还是先建立Trie图，然后在Trie图上面进行dp。dp的思路也不是很复杂。dp[i][j]的意思是长度为i的文本串需要改变dp[i][j]个字符顺利到达状态j。需要注意的是长度为i的时候，对应的字符串中的第i-1个字符。刚开始一直没发现这个bug。而且注意中途不能转移到匹配成功的状态上去，多加几个条件控制即可了。。。转移方程，dp[i][j] = min(dp[i][j], dp[i-1][nNext] + szText[i-1] != k)，其中nNext是从状态j可以转移到的非匹配成功的状态，k代表的当前边的权。</p><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 61;</span><br><span class="line">const int MAX_L = 31;</span><br><span class="line">const int MAX_D = 4;</span><br><span class="line">const int INF = 1110;</span><br><span class="line">char chHash[256];</span><br><span class="line">char szPat[MAX_L];</span><br><span class="line"></span><br><span class="line">void InitHash()</span><br><span class="line">&#123;</span><br><span class="line">    chHash['A'] = 0;</span><br><span class="line">    chHash['G'] = 1;</span><br><span class="line">    chHash['C'] = 2;</span><br><span class="line">    chHash['T'] = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Trie</span><br><span class="line">&#123;</span><br><span class="line">    Trie* fail;</span><br><span class="line">    Trie* next[MAX_D];</span><br><span class="line">    bool flag;</span><br><span class="line">    int no;</span><br><span class="line">&#125;;</span><br><span class="line">int nP;</span><br><span class="line">Trie* pRoot;</span><br><span class="line">Trie tries[MAX_N * MAX_L];</span><br><span class="line"></span><br><span class="line">Trie* NewNode()</span><br><span class="line">&#123;</span><br><span class="line">    memset(tries[nP], 0, sizeof(Trie));</span><br><span class="line">    tries[nP].no = nP;</span><br><span class="line">    return tries[nP++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitTrie(Trie* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    nP = 0;</span><br><span class="line">    pRoot = NewNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(Trie* pRoot, char* pszPat)</span><br><span class="line">&#123;</span><br><span class="line">    Trie* pNode = pRoot;</span><br><span class="line">    while (*pszPat)</span><br><span class="line">    &#123;</span><br><span class="line">        int idx = chHash[*pszPat];</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;next[idx] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode-&gt;next[idx] = NewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode-&gt;next[idx];</span><br><span class="line">        ++pszPat;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildAC(Trie* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    pRoot-&gt;fail = NULL;</span><br><span class="line">    queue&lt;Trie*&gt; qt;</span><br><span class="line">    qt.push(pRoot);</span><br><span class="line"></span><br><span class="line">    while (!qt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Trie* front = qt.front();</span><br><span class="line">        qt.pop();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; MAX_D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Trie* pNode = front-&gt;fail;</span><br><span class="line">                while (pNode &amp;&amp; pNode-&gt;next[i] == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    pNode = pNode-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">                front-&gt;next[i]-&gt;fail = pNode? pNode-&gt;next[i] : pRoot;</span><br><span class="line">                front-&gt;next[i]-&gt;flag |= front-&gt;next[i]-&gt;fail-&gt;flag;</span><br><span class="line">                qt.push(front-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front-&gt;next[i] = front == pRoot? pRoot : front-&gt;fail-&gt;next[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int nChange[INF][INF];</span><br><span class="line">char szText[INF];</span><br><span class="line"></span><br><span class="line">int Solve()</span><br><span class="line">&#123;</span><br><span class="line">    int nLen = strlen(szText);</span><br><span class="line">    for (int i = 0; i &lt;= nLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; nP; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            nChange[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int i, j, k;</span><br><span class="line">    nChange[0][0] = 0;</span><br><span class="line">    for (i = 1; i &lt;= nLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; nP; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (tries[j].flag) continue;</span><br><span class="line">            if (nChange[i - 1][j] == INF) continue;</span><br><span class="line">            for (k = 0; k &lt; MAX_D; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                int nNext = tries[j].next[k] - tries;</span><br><span class="line">                if (tries[nNext].flag) continue;</span><br><span class="line">                <span class="comment">//trie是边权树,所以i是从1到len,而且当前字符是szText[i-1]</span></span><br><span class="line">                int nTemp = nChange[i - 1][j] + (k != chHash[szText[i - 1]]);</span><br><span class="line">                nChange[i][nNext] = min(nChange[i][nNext], nTemp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nAns = INF;</span><br><span class="line">    for (i = 0; i &lt; nP; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tries[i].flag)</span><br><span class="line">            nAns = min(nAns, nChange[nLen][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns == INF? -1 : nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    int nCase = 1;</span><br><span class="line"></span><br><span class="line">    InitHash();</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        InitTrie(pRoot);</span><br><span class="line">        while (nN--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s", szPat);</span><br><span class="line">            Insert(pRoot, szPat);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildAC(pRoot);</span><br><span class="line">        scanf("%s", szText);</span><br><span class="line">        printf("Case %d: %d\n", nCase++, Solve());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1625 Censored! AC自动机 + DP + 大数加法</title>
      <link href="/2012/10/20/poj%201625%20Censored!%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%20+%20DP%20+%20%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"/>
      <url>/2012/10/20/poj%201625%20Censored!%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%20+%20DP%20+%20%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这个题与poj2778dna sequence解法基本一致。只是这个题的答案没有取模，而且文本串不太长。问题是不取模的话就只能输出实际的答案了，就只能用大数了。<br>而且用大数的话，再用矩阵冥可能就会超时之类的。<br>这类题还可以用除矩阵冥外的另外一种解法，就是直接dp即可。二维状态，第一维代表文本串长度，第二维代表在AC自动机中的状态。比如dp[i][j]代表长度为i的文本串，转移到Trie图中节点j时候满足不包含任何模式串的答案。剩下的是如何转移状态。转移的话也是考虑next指针数组，设next = tries[j].next[k]，那么有dp[i+1][next] =dp[i+1][next] + dp[i][j]，从0到字母集合大小N枚举k即可。<br>这个题有一个易错的地方，就是字母集合可能是ascii码在128到256的范围内。而char的范围可能是-128到127或者0到255，这个是根据编译器不同的。所以，直接用字符串数组读入数据后需要再处理下。可以直接将每个字符加128后再处理。<br>另外，getchar返回的是int，但是与gets之类的函数获得的值的差别也不是那么确定的了。觉得getchar除了对eof之外其余都返回正值。但是，如果char是有符号的话，scanf或者gets之类得到的char数组里面可能就包含负值了。。。<br>这个可以生成随机文件，再用getchar读入并用%d输出其返回值验证下。验证程序如下：注释掉的部分是生成随机文件的部分。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char ch;</span><br><span class="line">    freopen("in.txt", "r", stdin);</span><br><span class="line">    <span class="comment">//freopen("in.txt", "w", stdout);</span></span><br><span class="line">    int nNum = 100;</span><br><span class="line">    int nCh;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        printf("%d\n", nCh = getchar());</span><br><span class="line">    &#125;</span><br><span class="line">    while (nCh != EOF);</span><br><span class="line">    <span class="comment">/*while (nNum--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        putchar(rand() % 256);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该题的代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_D = 256;</span><br><span class="line">const int MAX_N = 51;</span><br><span class="line">const int MAX_M = 51;</span><br><span class="line">const int MAX_P = 11;</span><br><span class="line">struct Trie</span><br><span class="line">&#123;</span><br><span class="line">    Trie* fail;</span><br><span class="line">    Trie* next[MAX_D];</span><br><span class="line">    int no;</span><br><span class="line">    bool flag;</span><br><span class="line">&#125;;</span><br><span class="line">Trie tries[MAX_P * MAX_P];</span><br><span class="line">int nP;</span><br><span class="line">int nN, nM;</span><br><span class="line">Trie* pRoot;</span><br><span class="line">int nHash[MAX_D];</span><br><span class="line">char szPat[MAX_M];</span><br><span class="line"></span><br><span class="line">Trie* NewNode()</span><br><span class="line">&#123;</span><br><span class="line">    memset(tries[nP], 0, sizeof(Trie));</span><br><span class="line">    tries[nP].no = nP;</span><br><span class="line">    return tries[nP++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitTrie(Trie* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    nP = 0;</span><br><span class="line">    pRoot = NewNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(Trie* pRoot, char* pszPat)</span><br><span class="line">&#123;</span><br><span class="line">    Trie* pNode = pRoot;</span><br><span class="line">    while (*pszPat)</span><br><span class="line">    &#123;</span><br><span class="line">        int idx = nHash[*pszPat];</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;next[idx] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode-&gt;next[idx] = NewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode-&gt;next[idx];</span><br><span class="line">        ++pszPat;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildAC(Trie* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    pRoot-&gt;fail = NULL;</span><br><span class="line">    queue&lt;Trie*&gt; qt;</span><br><span class="line">    qt.push(pRoot);</span><br><span class="line"></span><br><span class="line">    while (!qt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Trie* front = qt.front();</span><br><span class="line">        qt.pop();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Trie* pNode = front;</span><br><span class="line">                while (pNode &amp;&amp; pNode-&gt;next[i] == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    pNode = pNode-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">                front-&gt;next[i]-&gt;fail = pNode? pNode-&gt;next[i] : pRoot;</span><br><span class="line">                front-&gt;next[i]-&gt;flag |= front-&gt;next[i]-&gt;fail-&gt;flag;</span><br><span class="line">                qt.push(front-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front-&gt;next[i] = front-&gt;fail-&gt;next[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int MAX_L = 200;</span><br><span class="line">struct BigInt</span><br><span class="line">&#123;</span><br><span class="line">    int nD[MAX_L];</span><br><span class="line">    BigInt()</span><br><span class="line">    &#123;</span><br><span class="line">        Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    void Clear()</span><br><span class="line">    &#123;</span><br><span class="line">        memset(nD, 0, sizeof(nD));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Print()</span><br><span class="line">    &#123;</span><br><span class="line">        int i = MAX_L - 1;</span><br><span class="line">        while (!nD[i] &amp;&amp; i)--i;</span><br><span class="line">        while (<span class="selector-tag">i</span> &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            putchar(nD[i] + '0');</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int operator[](int idx) const</span><br><span class="line">    &#123;</span><br><span class="line">        return nD[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int operator[](int idx)</span><br><span class="line">    &#123;</span><br><span class="line">        return nD[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BigInt bi[MAX_M][MAX_D];</span><br><span class="line"></span><br><span class="line">BigInt operator+(const BigInt one, const BigInt two)</span><br><span class="line">&#123;</span><br><span class="line">    BigInt ret;</span><br><span class="line"></span><br><span class="line">    for (int i = 0, nAdd = 0; i &lt; MAX_L; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ret[i] = one[i] + two[i] + nAdd;</span><br><span class="line">        nAdd = ret[i] / 10;</span><br><span class="line">        ret[i] %= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Solve()</span><br><span class="line">&#123;</span><br><span class="line">    BigInt ans;</span><br><span class="line">    for (int i = 0; i &lt;= nM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; nP; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            bi[i][j].Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bi[0][0][0] = 1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= nM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; nP; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (tries[j].flag) continue;</span><br><span class="line">            for (int k = 0; k &lt; nN; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                int nNext = tries[j].next[k] - tries;</span><br><span class="line">                <span class="keyword">if</span> (tries[nNext]<span class="selector-class">.flag</span> == false)</span><br><span class="line">                &#123;</span><br><span class="line">                    bi[i][nNext] = bi[i][nNext] + bi[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nP; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans + bi[nM][i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans.Print();</span><br><span class="line">    printf("\n");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d%d%*c"</span>, &amp;nN, &amp;nM, &amp;nT) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nCh;</span><br><span class="line">        int nTmp = 0;</span><br><span class="line">        memset(nHash, 0, sizeof(nHash));</span><br><span class="line">        while (nCh = getchar(), nCh != <span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nHash[nCh])</span><br><span class="line">            &#123;</span><br><span class="line">                nHash[nCh] = nTmp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InitTrie(pRoot);</span><br><span class="line">        while (nT--)</span><br><span class="line">        &#123;</span><br><span class="line">            gets(szPat);</span><br><span class="line">            Insert(pRoot, szPat);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("1");</span><br><span class="line">        BuildAC(pRoot);</span><br><span class="line">        printf("2");</span><br><span class="line">        Solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1509 Glass Beads 字符串最小表示</title>
      <link href="/2012/10/19/poj%201509%20Glass%20Beads%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA/"/>
      <url>/2012/10/19/poj%201509%20Glass%20Beads%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>赤裸裸的字符串最小表示题。所谓字符串最小表示指的是给定一个字符串，假设其可以循环移位，问循环左移多少位能够得到最小的字符串。<br>算法即是周源的最小表示法，搜索可以找到相关论文和ppt。<br>该算法其实也不是太复杂，思路可以这样理解。假设原字符串为s，设s1 = s + s; s2 = s1循环左移1位;现在处理s1和s2，实际写程序的时候可以通过下标偏移和取模得到s1和s2，而并不需要生成。<br>处理过程是这样的，设i和j分别指向s1和s2的开头。我们的目的是找到这样的i和j，假设k是s的长度，满足条件s1[i,i+k-1] = s2[j,j+k-1] 并且s1[i,i+k-1] 是所有满足条件的字符串中最小的字符串，如果有多个这样的s1[i,i+k-1] 那么我们希望i最小。<br>其实这个算法主要是做了一个优化，从而把时间搞成线性的。比如，对于当前的i和j，我们一直进行匹配，也就是s1[i,i+k] = s2[j,j+k] 一直满足，突然到了一个位置s1[i+k] != s2[j+k]了，现在我们需要改变i和j了。但是，我们不能只是++i或者++j。而是根据s1[i+k]&gt;s2[j+k]的话i =i + k + 1，否则j = j + k + 1。这样的瞬移i或者j就能够保证复杂度是线性的了。<br>问题是如何证明可以这样的瞬移。其实，说穿了也很简单。因为s1[i,i+k - 1] = s2[j,j+k -1]是满足的，只是到了s1[i+k]和s2[j+k]才出现问题了。假如s1[i+k]&gt;s2[j+k]，那么我们改变i为区间[i+1,i+k]中任何一个值m都不可能得到我们想要的答案，这是因为我们总可以在s2中找到相应的比s1[m,m+k-1]小的字符串s2[j+m-i,j+m-i+k-1]，因为有s1[i+k]&gt;s2[j+k]。同样对于s1[i+k]&lt;s2[j+k]的情况。<br>文字可能描述的不是很清楚。看PPT能够根据图进行分析。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int GetMin(string str)</span><br><span class="line">&#123;</span><br><span class="line">    int nSize = str.size();</span><br><span class="line">    int i = 0, j = 1, k = 0;</span><br><span class="line"></span><br><span class="line">    while (<span class="selector-tag">i</span> &lt; nSize &amp;&amp; j &lt; nSize &amp;&amp; k &lt; nSize)</span><br><span class="line">    &#123;</span><br><span class="line">        char chDif = str[(i + k) % nSize]</span><br><span class="line">                     - str[(j + k) % nSize];</span><br><span class="line">        if (!chDif) ++k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            if (chDif &gt; 0) i = i + k + 1;</span><br><span class="line">            else j = j + k + 1;</span><br><span class="line">            if (i == j) ++j;</span><br><span class="line">            k = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return min(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string str;</span><br><span class="line">    int nN;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nN);</span><br><span class="line">    while (nN--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        printf("%d\n", GetMin(str) + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hnu 2243 考研路茫茫——单词情结 AC自动机+矩阵冥累加和</title>
      <link href="/2012/10/18/hnu%202243%20%E8%80%83%E7%A0%94%E8%B7%AF%E8%8C%AB%E8%8C%AB%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E6%83%85%E7%BB%93%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA+%E7%9F%A9%E9%98%B5%E5%86%A5%E7%B4%AF%E5%8A%A0%E5%92%8C/"/>
      <url>/2012/10/18/hnu%202243%20%E8%80%83%E7%A0%94%E8%B7%AF%E8%8C%AB%E8%8C%AB%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E6%83%85%E7%BB%93%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA+%E7%9F%A9%E9%98%B5%E5%86%A5%E7%B4%AF%E5%8A%A0%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>这个题目更奇葩。据说是上一个题的加强版。题意是给定M个模式串，然后给定长度L，问不超过L的文本至少含有一个模式的情况的总种数。<br>还是用模式串建立Trie图，根据Trie图建立起路径长度为1的矩阵M。<br>总情况数目为26^1+26^2+…+26^L。不含模式串的情况总数为矩阵N = M^1+M^2+M^3+…+M^L的第一行之和。总情况数目减去不含模式串的情况就是答案。<br>这里用到了矩阵的一些算法，比如快速冥，还有快速冥求和。但是，我用了操作符重载，最悲剧的是重载后的操作符没有优先级，而我还当作有优先级的在用，所以悲剧了。。。一直样例都过不去。。。唉，最后才发现了这个问题。。。写了260行左右的代码，前面的一部分代码可以当作矩阵操作的模板了。。。Trie图的也不错，过几天估计得打印下来用了。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef unsigned long long INT;</span><br><span class="line">const int MAX_D = 26;</span><br><span class="line">const int MAX_L = 10;</span><br><span class="line">const int MAX_N = 10;</span><br><span class="line">char szPat[MAX_L];</span><br><span class="line"></span><br><span class="line">const int MAX_S = 31;</span><br><span class="line">struct Matrix</span><br><span class="line">&#123;</span><br><span class="line">    int nSize;</span><br><span class="line">    INT nD[MAX_S][MAX_S];</span><br><span class="line">    Matrix(int nS)</span><br><span class="line">    &#123;</span><br><span class="line">        Clear(nS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix operator = (const Matrix m)</span><br><span class="line">    &#123;</span><br><span class="line">        nSize = m.nSize;</span><br><span class="line">        for (int i = 0; i &lt; nSize; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; nSize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                nD[i][j] = m.nD[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void Clear(int nS)</span><br><span class="line">    &#123;</span><br><span class="line">        nSize = nS;</span><br><span class="line">        memset(nD, 0, sizeof(nD));</span><br><span class="line">    &#125;</span><br><span class="line">    void Unit()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nSize; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; nSize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                nD[i][j] = (i == j ? 1 : 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Matrix operator+(const Matrix A, const Matrix B)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix C(A.nSize);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; A.nSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; A.nSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            C.nD[i][j] = A.nD[i][j] + B.nD[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix operator*(const Matrix nA, const Matrix nB)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix nC(nB.nSize);</span><br><span class="line">    for (int i = 0; i &lt; nA.nSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; nA.nSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = 0; k &lt; nA.nSize; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                nC.nD[i][j] += nA.nD[i][k] * nB.nD[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix operator^(Matrix B, INT nExp)</span><br><span class="line">&#123;</span><br><span class="line">    Matrix ans(B.nSize);</span><br><span class="line"></span><br><span class="line">    ans.Unit();</span><br><span class="line">    while (nExp)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nExp % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans * B;</span><br><span class="line">        &#125;</span><br><span class="line">        B = B * B;</span><br><span class="line">        nExp &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求base^1+base^2++base^N</span></span><br><span class="line">Matrix SumPowMatrix(Matrix base, INT nN)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nN == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix ans = SumPowMatrix(base, nN / 2);</span><br><span class="line">    ans = ans + ((base^(nN / 2)) * ans);//重载运算符保证不了优先级</span><br><span class="line">    if (nN % 2)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans + (base^nN);//没优先级啊,必须加括号,查错2个小时了</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Trie</span><br><span class="line">&#123;</span><br><span class="line">    Trie* next[MAX_D];</span><br><span class="line">    Trie* fail;</span><br><span class="line">    int no;</span><br><span class="line">    bool flag;</span><br><span class="line">&#125;;</span><br><span class="line">Trie tries[MAX_L * MAX_N];</span><br><span class="line">int nP;</span><br><span class="line">Trie* pRoot;</span><br><span class="line"></span><br><span class="line">Trie* NewNode()</span><br><span class="line">&#123;</span><br><span class="line">    memset(tries[nP], 0, sizeof(Trie));</span><br><span class="line">    tries[nP].no = nP;</span><br><span class="line">    return tries[nP++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitTrie(Trie* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    nP = 0;</span><br><span class="line">    pRoot = NewNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(Trie* pRoot, char* pszPat)</span><br><span class="line">&#123;</span><br><span class="line">    Trie* pNode = pRoot;</span><br><span class="line">    while (*pszPat)</span><br><span class="line">    &#123;</span><br><span class="line">        int idx = *pszPat - 'a';</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;next[idx] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode-&gt;next[idx] = NewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode-&gt;next[idx];</span><br><span class="line">        ++pszPat;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildAC(Trie* pRoot, Matrix M)</span><br><span class="line">&#123;</span><br><span class="line">    pRoot-&gt;fail = NULL;</span><br><span class="line">    queue&lt;Trie*&gt; qt;</span><br><span class="line">    qt.push(pRoot);</span><br><span class="line"></span><br><span class="line">    M.Clear(nP);</span><br><span class="line">    while (!qt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Trie* front = qt.front();</span><br><span class="line">        qt.pop();</span><br><span class="line">        for (int i = 0; i &lt; MAX_D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Trie* pNode = front-&gt;fail;</span><br><span class="line">                while (pNode &amp;&amp; pNode-&gt;next[i] == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    pNode = pNode-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">                front-&gt;next[i]-&gt;fail = pNode? pNode-&gt;next[i] : pRoot;</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;next[i]-&gt;fail-&gt;flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    front-&gt;next[i]-&gt;flag = true;</span><br><span class="line">                &#125;</span><br><span class="line">                qt.push(front-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front-&gt;next[i] = front == pRoot? pRoot : front-&gt;fail-&gt;next[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里必须要加上front-&gt;flag为false的判断么?加不加会生成不同的矩阵</span></span><br><span class="line">            <span class="keyword">if</span> (!front-&gt;next[i]-&gt;flag)</span><br><span class="line">            &#123;</span><br><span class="line">                ++M.nD[front-&gt;no][front-&gt;next[i]-&gt;no];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    INT nL;</span><br><span class="line">    Matrix M(0);</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%I64u"</span>, &amp;nN, &amp;nL) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InitTrie(pRoot);</span><br><span class="line">        while (nN--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s", szPat);</span><br><span class="line">            Insert(pRoot, szPat);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildAC(pRoot, M);</span><br><span class="line"></span><br><span class="line">        Matrix tmp(1);</span><br><span class="line">        tmp.nD[0][0] = 26;</span><br><span class="line">        tmp = SumPowMatrix(tmp, nL);</span><br><span class="line">        INT nAns = tmp.nD[0][0];</span><br><span class="line">        Matrix msum = SumPowMatrix(M, nL);</span><br><span class="line">        for (int i = 0; i &lt; msum.nSize; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns -= msum.nD[0][i];</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%I64u\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2778 DNA Sequence AC自动机+矩阵快速冥</title>
      <link href="/2012/10/18/poj%202778%20DNA%20Sequence%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA+%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%86%A5/"/>
      <url>/2012/10/18/poj%202778%20DNA%20Sequence%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA+%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%86%A5/</url>
      
        <content type="html"><![CDATA[<p>题意很简单，假定文本集就是A,C,T,G，给定M个模式串，问你长度为N的文本不出现这些模式串的可能性到底有多少种。。。<br>确实非常不直观的样子。。。<br>解法是先学学AC自动机，建立起Trie图，根据trie图可以得到长度为1的路径矩阵，然后再快速冥得到长度为N的路径矩阵。<br>说起来都非常纠结，没学过AC自动机更加无法理解。学AC自动机之前据说得先学Trie树和KMP才好理解。学AC自动机搞Trie图就花费了近2天了，然后弄懂这个题又是一天，好在基本明白了。马上快比赛了，从长春换到金华也不知道是好是坏。。。还是弱菜啊。。。<br>贴下我的Trie图+快速冥(直接二分了,没有写成数论里面那种算法)…<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long INT;</span><br><span class="line">const int MOD = 100000;</span><br><span class="line">const int MAX_P = 100;</span><br><span class="line">const int MAX_D = 4;</span><br><span class="line">int nIdx[256];</span><br><span class="line">char szPat[MAX_P];</span><br><span class="line">INT nMatrix[MAX_P][MAX_P];</span><br><span class="line">INT B[MAX_P][MAX_P];</span><br><span class="line">INT A[MAX_P][MAX_P];</span><br><span class="line"></span><br><span class="line">void InitIdx()</span><br><span class="line">&#123;</span><br><span class="line">    nIdx['A'] = 0;</span><br><span class="line">    nIdx['C'] = 1;</span><br><span class="line">    nIdx['T'] = 2;</span><br><span class="line">    nIdx['G'] = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Trie</span><br><span class="line">&#123;</span><br><span class="line">    Trie* fail;</span><br><span class="line">    Trie* next[MAX_D];</span><br><span class="line">    int no;</span><br><span class="line">    bool flag;</span><br><span class="line">    Trie()</span><br><span class="line">    &#123;</span><br><span class="line">        fail = NULL;</span><br><span class="line">        memset(next, 0, sizeof(next));</span><br><span class="line">        no = 0;</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Trie tries[MAX_D * MAX_P];</span><br><span class="line">int nP;</span><br><span class="line">Trie* pRoot;</span><br><span class="line"></span><br><span class="line">Trie* NewNode()</span><br><span class="line">&#123;</span><br><span class="line">    memset(tries[nP], 0, sizeof(Trie));</span><br><span class="line">    tries[nP].no = nP;</span><br><span class="line">    return tries[nP++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InitTrie(Trie* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    nP = 0;</span><br><span class="line">    pRoot = NewNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(char* pszPat)</span><br><span class="line">&#123;</span><br><span class="line">    Trie* pNode = pRoot;</span><br><span class="line"></span><br><span class="line">    while (*pszPat)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;next[nIdx[*pszPat]] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode-&gt;next[nIdx[*pszPat]] = NewNode();</span><br><span class="line">        &#125;</span><br><span class="line">        pNode = pNode-&gt;next[nIdx[*pszPat]];</span><br><span class="line">        ++pszPat;</span><br><span class="line">    &#125;</span><br><span class="line">    pNode-&gt;flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int BuildAC(Trie* pRoot)</span><br><span class="line">&#123;</span><br><span class="line">    memset(nMatrix, 0, sizeof(nMatrix));</span><br><span class="line"></span><br><span class="line">    pRoot-&gt;fail = NULL;</span><br><span class="line">    queue&lt;Trie*&gt; qt;</span><br><span class="line">    qt.push(pRoot);</span><br><span class="line">    while (!qt.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Trie* front = qt.front();</span><br><span class="line">        qt.pop();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; MAX_D; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Trie* pNode = front-&gt;fail;</span><br><span class="line">                while (pNode &amp;&amp; pNode-&gt;next[i] == NULL)</span><br><span class="line">                &#123;</span><br><span class="line">                    pNode = pNode-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">                front-&gt;next[i]-&gt;fail = pNode? pNode-&gt;next[i] : pRoot;</span><br><span class="line">                <span class="keyword">if</span> (front-&gt;next[i]-&gt;fail-&gt;flag == true)</span><br><span class="line">                &#123;</span><br><span class="line">                    front-&gt;next[i]-&gt;flag = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                qt.push(front-&gt;next[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                front-&gt;next[i] = front == pRoot? pRoot : front-&gt;fail-&gt;next[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next[i]-&gt;flag == false)</span><br><span class="line">            &#123;</span><br><span class="line">                nMatrix[front-&gt;no][front-&gt;next[i]-&gt;no]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nP;//节点总个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MultyMatrix(INT A[][MAX_P], INT B[][MAX_P], INT C[][MAX_P], int nSize)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; nSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; nSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            INT nSum = 0;</span><br><span class="line">            for (int k = 0; k &lt; nSize; ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                nSum = (nSum + A[i][k] * B[k][j]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            C[i][j] = nSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CopyMatrix(INT A[][MAX_P], INT B[][MAX_P], int nSize)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; nSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; nSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i][j] = B[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MatrixPower(INT M[][MAX_P], int nSize, INT nP)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nP == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CopyMatrix(A, M, nSize);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MatrixPower(M, nSize, nP / 2);</span><br><span class="line">    MultyMatrix(A, A, B, nSize);</span><br><span class="line">    if (nP % 2)</span><br><span class="line">    &#123;</span><br><span class="line">        MultyMatrix(B, M, A, nSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CopyMatrix(A, B, nSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INT nM, nN;</span><br><span class="line"></span><br><span class="line">    InitIdx();</span><br><span class="line">    while (scanf(<span class="string">"%I64d%I64d"</span>, &amp;nM, &amp;nN) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InitTrie(pRoot);</span><br><span class="line">        while (nM--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s", szPat);</span><br><span class="line">            Insert(szPat);</span><br><span class="line">        &#125;</span><br><span class="line">        int nSize = BuildAC(pRoot);</span><br><span class="line"></span><br><span class="line">        MatrixPower(nMatrix, nSize, nN);</span><br><span class="line">        INT nAns = 0;</span><br><span class="line">        for (int i = 0; i &lt; nSize; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = (nAns + A[0][i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%I64d\n", nAns % MOD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hnu 10076 Jimmy&#39;s Riddles DFA</title>
      <link href="/2012/10/12/hnu-10076-jimmys-riddles-dfa/"/>
      <url>/2012/10/12/hnu-10076-jimmys-riddles-dfa/</url>
      
        <content type="html"><![CDATA[<p>句子的语法匹配。这个用DFA确实可以很方便做出来，用递归判断之类的应该也可以。感觉用dfa只需要保证状态转换图对了，基本上就不会出bug了，但是其它的方法去匹配这种类似正则表达式的字符串就容易出错多了。</p><p>百度百科的DFA定义如下：<br>英文全称：Deterministic Finite Automaton, 简写：DFA<br>DFA定义：一个确定的有穷自动机（DFA）M是一个五元组：M=（K，Σ，f，S，Z）其中<br>① K是一个有穷集，它的每个元素称为一个状态；<br>② Σ是一个有穷字母表，它的每个元素称为一个输入符号，所以也称Σ为输入符号字母表；<br>③ f是转换函数，是K×Σ→K上的映射，即，如 f（ki，a）=kj，（ki∈K，kj∈K）就意味着，<br>当前状态为ki，输入符为a时，将转换为下一个状态kj，我们把kj称作ki的一个后继状态；<br>④ S ∈ K是唯一的一个初态；<br>⑤ Z⊂K是一个终态集，终态也称可接受状态或结束状态。<sup></sup><br>该题的状态转换图：<br><img alt data-src="https://c2.staticflickr.com/8/7609/26803884313_f0a5f126d3_o.png"><br>现在再根据状态转换图，写一个模拟转换关系的匹配就非常方便了。。。<br>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;string&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;sstream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string strNouns[<span class="number">8</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"tom"</span>, <span class="string">"jerry"</span>, <span class="string">"goofy"</span>, <span class="string">"mickey"</span>,</span><br><span class="line">    <span class="string">"jimmy"</span>, <span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"mouse"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool IsNoun(string str)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 8; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == strNouns[i])</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsVerb(string str)</span><br><span class="line">&#123;</span><br><span class="line">    return str == "hate" || str == "love"</span><br><span class="line">           || str == "know" || str == "like"</span><br><span class="line">           || str == "hates" || str == "loves"</span><br><span class="line">           || str == "knows" || str == "likes";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsArticle(string str)</span><br><span class="line">&#123;</span><br><span class="line">    return str == "a" || str == "the";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CheckState(vector&lt;string&gt; vs)</span><br><span class="line">&#123;</span><br><span class="line">    if (vs.empty()) return false;</span><br><span class="line"></span><br><span class="line">    int nState = 0;</span><br><span class="line">    for (int i = 0; i &lt; vs.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("nState:%d, str:%s\n", nState, vs[i].c_str());</span></span><br><span class="line">        switch (nState)</span><br><span class="line">        &#123;</span><br><span class="line">        case <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (IsArticle(vs[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (IsNoun(vs[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 2;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (IsNoun(vs[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 2;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (vs[i] == <span class="string">"and"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (IsVerb(vs[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 3;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        case <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (IsArticle(vs[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 4;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (IsNoun(vs[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 5;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        case <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> (IsNoun(vs[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 5;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        case <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">if</span> (vs[i] == <span class="string">"and"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 3;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vs[i] == <span class="string">","</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nState = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nState == 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line"></span><br><span class="line">    scanf("%d%*c", &amp;nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; vs;</span><br><span class="line">        string line, str;</span><br><span class="line"></span><br><span class="line">        getline(cin, line);</span><br><span class="line">        stringstream ss(line);</span><br><span class="line">        while (ss &gt;&gt; str)</span><br><span class="line">        &#123;</span><br><span class="line">            vs.push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%s\n", CheckState(vs) ? "YES I WILL" : "NO I WON'T");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3764 The xor-longest Path 字典树 + Xor</title>
      <link href="/2012/10/12/poj%203764%20The%20xor-longest%20Path%20%E5%AD%97%E5%85%B8%E6%A0%91%20+%20Xor/"/>
      <url>/2012/10/12/poj%203764%20The%20xor-longest%20Path%20%E5%AD%97%E5%85%B8%E6%A0%91%20+%20Xor/</url>
      
        <content type="html"><![CDATA[<p>这题意思很简单。求一棵树里面的一条路径，使得其异或权(就是将路径里面所有边的权值异或起来)最大。<br>这个题有两步。第一步是假定根为节点0，求出根到其它节点的异或距离，保存在数组xor里面，这个dfs一下即可。然后，用xor[i]^xor[j]就能代表节点i到节点j的路径。这个结论可以这么看。如果，i和j之间的路径经过根节点，那么上面的结论肯定是正确的。如果，该路径不经过根，那么xor[i]和xor[j]必定保护从根到某个节点的相同的一段子路径，根据异或的性质，这段子路径会被消掉，所以这个结论也是这确的。。。<br>第二步就是枚举，xor[i]^xor[j]使得结果最大了。如果直接暴力，平方的算法肯定会超时的。<br>由于每个值可以表示成2进制，如果把其它xor值都保存在字典树里面，用当前的xor[i]去字典树<br>里面，一遍就可以找到异或最大值。<br>另外，由于树的点数太多，只能用邻接表，用vector模拟邻接表果断超时了。。。改成静态链表才过。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX = 100010;</span><br><span class="line">int nXor[MAX];</span><br><span class="line">bool bVis[MAX];</span><br><span class="line">int nFirst[MAX];</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int nE;</span><br><span class="line">    int nW;</span><br><span class="line">    int nNext;</span><br><span class="line">&#125;;</span><br><span class="line">Edge egs[MAX * 2];</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    Node* pSons[2];</span><br><span class="line">&#125;;</span><br><span class="line">Node nodes[MAX * 32];</span><br><span class="line">Node* pRoot = nodes[0];</span><br><span class="line">int nNew;</span><br><span class="line"></span><br><span class="line">void GetBCode(int nL, int* nBCode, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    nLen = 0;</span><br><span class="line">    while (nLen &lt;= <span class="number">30</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nBCode[nLen++] = nL % 2;</span><br><span class="line">        nL &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nBCode, nBCode + nLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(int nL)</span><br><span class="line">&#123;</span><br><span class="line">    int nLen = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int nBCode[32];</span><br><span class="line"></span><br><span class="line">    GetBCode(nL, nBCode, nLen);</span><br><span class="line">    Node* pNode = pRoot;</span><br><span class="line"></span><br><span class="line">    while (<span class="selector-tag">i</span> &lt; nLen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;pSons[nBCode[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;pSons[nBCode[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            memset(nodes + nNew, 0, sizeof(nodes[nNew]));</span><br><span class="line">            pNode-&gt;pSons[nBCode[i]] = nodes + nNew;</span><br><span class="line">            pNode = nodes + nNew;</span><br><span class="line">            ++nNew;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindMax(int nL)</span><br><span class="line">&#123;</span><br><span class="line">    int nLen = 0;</span><br><span class="line">    int nAns = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int nBCode[32];</span><br><span class="line">    Node* pNode = pRoot;</span><br><span class="line"></span><br><span class="line">    GetBCode(nL, nBCode, nLen);</span><br><span class="line">    while (<span class="selector-tag">i</span> &lt; nLen)</span><br><span class="line">    &#123;</span><br><span class="line">        int nBest = (nBCode[i] == 0 ? 1 : 0);</span><br><span class="line">        int nBad = (nBCode[i] == 0 ? 0 : 1);</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;pSons[nBest])</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = 2 * nAns + nBest;</span><br><span class="line">            pNode = pNode-&gt;pSons[nBest];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;pSons[nBad])</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = 2 * nAns + nBad;</span><br><span class="line">            pNode = pNode-&gt;pSons[nBad];</span><br><span class="line">        &#125;</span><br><span class="line">        else break;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nAns ^ nL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Dfs(int nV, int nL)</span><br><span class="line">&#123;</span><br><span class="line">    nXor[nV] = nL;</span><br><span class="line">    bVis[nV] = true;</span><br><span class="line">    for (int e = nFirst[nV]; e != -1; e = egs[e].nNext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bVis[egs[e].nE])</span><br><span class="line">        &#123;</span><br><span class="line">            Dfs(egs[e].nE, nL ^ egs[e].nW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    int nU, nV, nW;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i) nFirst[i] = -1;</span><br><span class="line">        for (int i = 1, j = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d%d", &amp;nU, &amp;nV, &amp;nW);</span><br><span class="line">            egs[j].nE = nV;</span><br><span class="line">            egs[j].nW = nW;</span><br><span class="line">            egs[j].nNext = nFirst[nU];</span><br><span class="line">            nFirst[nU] = j++;</span><br><span class="line">            egs[j].nE = nU;</span><br><span class="line">            egs[j].nW = nW;</span><br><span class="line">            egs[j].nNext = nFirst[nV];</span><br><span class="line">            nFirst[nV] = j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memset(bVis, false, sizeof(bool) * nN);</span><br><span class="line">        Dfs(0, 0);</span><br><span class="line"></span><br><span class="line">        memset(nodes[0], 0, sizeof(Node));</span><br><span class="line">        nNew = 1;</span><br><span class="line">        int nAns = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = max(nAns, FindMax(nXor[i]));</span><br><span class="line">            Insert(nXor[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1182 食物链 并查集</title>
      <link href="/2012/10/10/poj%201182%20%E9%A3%9F%E7%89%A9%E9%93%BE%20%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2012/10/10/poj%201182%20%E9%A3%9F%E7%89%A9%E9%93%BE%20%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>这是并查集最后一题，据说也是最经典的一题。经常前面几题的训练，这题的思路很快就能想出来了.只需要对每个节点附加一个信息表示离根节点的距离，并且距离是模3循环的。注意合并时候保持距离变化的正确性。而且合并有2种情况，距离相同合并和距离不同合并。分别对应于题目描述中的1和2操作。<br>关键还是FindSet里面对距离nDis数组里面的修改，前面一直写错这个，wa了好几次，还是看队友代码才一眼发现我又把这里写错了。。。当前距离的更新还是等于当前距离加上前一个节点的距离再模3，类似于前面几题的更新方法。<br>这种将有关系的节点放在一个并查集里面，再给每个节点附加其它信息描述其它关系的做法，确实比较有效。。。并查集是应用于不相交集合的数据结构，看来某个时候却有妙用啊。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX = 50010;</span><br><span class="line">int nN, nK;</span><br><span class="line">int nSets[MAX];</span><br><span class="line">int nDis[MAX];</span><br><span class="line"></span><br><span class="line">void MakeSets(int nN)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nSets[i] = i;</span><br><span class="line">        nDis[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindSet(int nI)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nSets[nI] != nI)</span><br><span class="line">    &#123;</span><br><span class="line">        int nPre = nSets[nI];</span><br><span class="line">        nSets[nI] = FindSet(nSets[nI]);</span><br><span class="line">        nDis[nI] = (nDis[nPre] + nDis[nI]) % 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return nSets[nI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nAns = 0;</span><br><span class="line">    int nOper, nX, nY;</span><br><span class="line"></span><br><span class="line">    scanf("%d%d", &amp;nN, &amp;nK);</span><br><span class="line">    MakeSets(nN);</span><br><span class="line">    while (nK--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d%d%d", &amp;nOper, &amp;nX, &amp;nY);</span><br><span class="line">        if (nX &gt; nN || nY &gt; nN || nOper == 2  nX == nY)</span><br><span class="line">        &#123;</span><br><span class="line">            ++nAns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nOper == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                int nA = FindSet(nX);</span><br><span class="line">                int nB = FindSet(nY);</span><br><span class="line">                <span class="keyword">if</span> (nA == nB)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nDis[nX] != nDis[nY])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ++nAns;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nSets[nB] = nA;</span><br><span class="line">                    nDis[nB] = (nDis[nX] - nDis[nY] + 3) % 3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                int nA = FindSet(nX);</span><br><span class="line">                int nB = FindSet(nY);</span><br><span class="line">                <span class="keyword">if</span> (nA == nB)</span><br><span class="line">                &#123;</span><br><span class="line">                    if ((nDis[nX] + 1) % 3 != nDis[nY])</span><br><span class="line">                    &#123;</span><br><span class="line">                        ++nAns;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nSets[nB] = nA;</span><br><span class="line">                    nDis[nB] = (nDis[nX] + 1 - nDis[nY] + 3) % 3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf("%d\n", nAns);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1988 Cube Stacking 并查集</title>
      <link href="/2012/10/10/poj%201988%20Cube%20Stacking%20%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2012/10/10/poj%201988%20Cube%20Stacking%20%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>也是个题意比较奇葩的题目。有2个操作，1个是把一个元素所在的栈，放到另外1个元素所在的栈面。另外一个操作是统计某个元素下面有多少个元素(当然是在同一个栈中）。貌似，需要记录每个元素下面的元素是什了，既然要记录这个就不能用并查集的路径压缩了。不压缩路径的话，肯定会超时的。怎么办了。。。<br>其实，可以这么考虑，以每个栈的栈底元素作为并查集的代表元素。压缩路径后，每个元素或者是根元素或者其父亲元素就是根元素。所以，另外对每个节点附加个信息代表该节点的高度，栈底元素高度为0。再附加个信息代表每个并查集元素总数目，这样就可以在合并集合时候修改信息，并且压缩路径也能保证答案正确。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX = 30010;</span><br><span class="line">int nSets[MAX];</span><br><span class="line">int nNum[MAX];</span><br><span class="line">int nRank[MAX];</span><br><span class="line"></span><br><span class="line">void MakeSets(int nN)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nSets[i] = i;</span><br><span class="line">        nNum[i] = 1;</span><br><span class="line">        nRank[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindSet(int nI)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nSets[nI] != nI)</span><br><span class="line">    &#123;</span><br><span class="line">        int nPre = nSets[nI];</span><br><span class="line">        nSets[nI] = FindSet(nSets[nI]);</span><br><span class="line">        nRank[nI] += nRank[nPre];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nSets[nI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Move(int nX, int nY)</span><br><span class="line">&#123;</span><br><span class="line">    int nA = FindSet(nX);</span><br><span class="line">    int nB = FindSet(nY);</span><br><span class="line">    <span class="comment">//printf("nA:%d,nB:%d\n", nA, nB);</span></span><br><span class="line">    <span class="keyword">if</span> (nA != nB)</span><br><span class="line">    &#123;</span><br><span class="line">        nSets[nA] = nB;</span><br><span class="line">        nRank[nA] += nNum[nB];</span><br><span class="line">        nNum[nB] += nNum[nA];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nP;</span><br><span class="line">    char szOper[10];</span><br><span class="line">    int nX, nY;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nP);</span><br><span class="line">    MakeSets(MAX);</span><br><span class="line">    while (nP--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%s", szOper);</span><br><span class="line">        <span class="keyword">if</span> (szOper[<span class="number">0</span>] == <span class="string">'M'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d", &amp;nX, &amp;nY);</span><br><span class="line">            Move(nX, nY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d", &amp;nX);</span><br><span class="line">            FindSet(nX);</span><br><span class="line">            printf("%d\n", nRank[nX]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1984 Navigation Nightmare 并查集</title>
      <link href="/2012/10/09/poj%201984%20Navigation%20Nightmare%20%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2012/10/09/poj%201984%20Navigation%20Nightmare%20%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>并查集应用的变形。题目意思是一个图中，只有上下左右四个方向的边。给出这样的一些边，求任意指定的2个节点之间的距离。<br>有可能当前给出的信息，没有涉及到要求的2个节点，或者只涉及到了1个节点，那么肯定无法确定它们的距离。或者根据已经给出的边只知道这2个节点在不同的联通分量里面，那么其距离也是无法确定的，根据题目要求，输出-1。<br>问题是如果能够确定它们在一个联通分量里面，如何确定它们的距离了。这个题的关键在于，只有上下左右四个方向的边，假设每个节点都有一个坐标的话，那么它们相对于代表该联通分量节点的坐标肯定是固定的，那么就不需要考虑图里面有环之类的情况了。这样就可以很方便的应用并查集来解了。<br>利用并查集，给每个节点附加其它信息，即相对于代表该并查集的节点的坐标（x，y）。在FindSet里面求出坐标，在UnionSet里面修改合并后新加入的另外一个集合的根节点的坐标即可。<br>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 40010;</span><br><span class="line">int nN, nM;</span><br><span class="line">int nSets[MAX_N];</span><br><span class="line">int nX[MAX_N];</span><br><span class="line">int nY[MAX_N];</span><br><span class="line">char szInput[MAX_N][100];</span><br><span class="line"></span><br><span class="line">void MakeSets(int nNum)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; nNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nSets[i] = i;</span><br><span class="line">        nX[i] = nY[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindSets(int nI)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nSets[nI] != nI)</span><br><span class="line">    &#123;</span><br><span class="line">        int nPre = nSets[nI];</span><br><span class="line">        nSets[nI] = FindSets(nSets[nI]);</span><br><span class="line">        nX[nI] += nX[nPre];</span><br><span class="line">        nY[nI] += nY[nPre];</span><br><span class="line">    &#125;</span><br><span class="line">    return nSets[nI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UnionSets(int nBeg, int nEnd, int dx, int dy)</span><br><span class="line">&#123;</span><br><span class="line">    int nA = FindSets(nBeg);</span><br><span class="line">    int nB = FindSets(nEnd);</span><br><span class="line">    <span class="keyword">if</span> (nA != nB)</span><br><span class="line">    &#123;</span><br><span class="line">        nSets[nB] = nA;//把集合B合并到集合A中</span><br><span class="line">        nX[nB] = nX[nBeg] + dx - nX[nEnd];//因为方向逆过来了,所以是减去</span><br><span class="line">        nY[nB] = nY[nBeg] + dy - nY[nEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nBeg, nEnd, nL;</span><br><span class="line">    char szDir[10];</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d%*c"</span>, &amp;nN, &amp;nM) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MakeSets(nN);</span><br><span class="line">        for (int i = 0; i &lt; nM; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            fgets(szInput[i], 100, stdin);</span><br><span class="line">        &#125;</span><br><span class="line">        int nK;</span><br><span class="line">        int nF1, nF2, nI;</span><br><span class="line">        scanf("%d", nK);</span><br><span class="line">        int nCur = 0;</span><br><span class="line">        while (nK--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d%d", nF1, nF2, nI);</span><br><span class="line">            for (int i = nCur; i &lt; nI; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                sscanf(szInput[i], <span class="string">"%d%d%d%s"</span>, &amp;nBeg,</span><br><span class="line">                       &amp;nEnd, &amp;nL, szDir);</span><br><span class="line">                int dx = 0, dy = 0;</span><br><span class="line">                switch (szDir[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                case <span class="string">'N'</span>:</span><br><span class="line">                    dy += nL;</span><br><span class="line">                    break;</span><br><span class="line">                case <span class="string">'S'</span>:</span><br><span class="line">                    dy -= nL;</span><br><span class="line">                    break;</span><br><span class="line">                case <span class="string">'E'</span>:</span><br><span class="line">                    dx += nL;</span><br><span class="line">                    break;</span><br><span class="line">                case <span class="string">'W'</span>:</span><br><span class="line">                    dx -= nL;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                UnionSets(nBeg, nEnd, dx, dy);</span><br><span class="line">            &#125;</span><br><span class="line">            nCur = nI;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FindSets(nF1) != FindSets(nF2))</span><br><span class="line">            &#123;</span><br><span class="line">                printf("-1\n");</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                printf(<span class="string">"%d\n"</span>, abs(nX[nF1] - nX[nF2])</span><br><span class="line">                       + abs(nY[nF1] - nY[nF2]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1703 Find them, Catch them 并查集</title>
      <link href="/2012/10/08/poj%201703%20Find%20them,%20Catch%20them%20%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2012/10/08/poj%201703%20Find%20them,%20Catch%20them%20%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>并查集应用的变形。<br>给出的是2个节点是敌对关系的信息，最后询问任意2个节点的关系。根据这些信息，<br>节点之间可能是敌对的，也可能不是的（因为敌人的敌人就是朋友），也可能给出的<br>信息根本描述不了它们的关系。<br>看起来跟原始的并查集应用差远了。。。<br>有个比较直接的做法，那么就是把不在一个集合的节点直接用并查集合并在一起。这样的话，<br>如果询问的2个节点在同一个并查集里面，那么它们之间的关系是确定的，否则无法确定它们的<br>关系。<br>现在还有一个问题是，在同一个并查集里面的2个节点是敌对关系还是朋友关系。。。<br>可以给每个节点另外附加个信息，记录其距离并查集根节点的距离。如果，询问的2个节点距离<br>其根节点的距离都是奇数或者都是偶数，那么这2个节点是朋友关系，否则是敌对关系。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 100010;</span><br><span class="line">int nSets[MAX_N];</span><br><span class="line">int nDis[MAX_N];</span><br><span class="line"></span><br><span class="line">int nN, nM;</span><br><span class="line"></span><br><span class="line">void MakeSets(int nNum)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; nNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nSets[i] = i;</span><br><span class="line">        nDis[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindSet(int nI)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nSets[nI] != nI)</span><br><span class="line">    &#123;</span><br><span class="line">        int nPre = nSets[nI];</span><br><span class="line">        nSets[nI] = FindSet(nSets[nI]);</span><br><span class="line">        nDis[nI] = (nDis[nI] + nDis[nPre]) % 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return nSets[nI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UnionSet(int nI, int nJ)</span><br><span class="line">&#123;</span><br><span class="line">    int nA = FindSet(nI);</span><br><span class="line">    int nB = FindSet(nJ);</span><br><span class="line">    <span class="keyword">if</span> (nA != nB)</span><br><span class="line">    &#123;</span><br><span class="line">        nSets[nA] = nB;</span><br><span class="line">        nDis[nA] = (nDis[nI] + nDis[nJ] + 1) % 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line"></span><br><span class="line">    scanf("%d", nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d%d", nN, nM);</span><br><span class="line">        MakeSets(nN);</span><br><span class="line">        char szOper[10];</span><br><span class="line">        int nA, nB;</span><br><span class="line">        while (nM--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s%d%d", szOper, &amp;nA, &amp;nB);</span><br><span class="line">            <span class="keyword">if</span> (szOper[<span class="number">0</span>] == <span class="string">'D'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                UnionSet(nA, nB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                int nX = FindSet(nA);</span><br><span class="line">                int nY = FindSet(nB);</span><br><span class="line">                <span class="keyword">if</span> (nX == nY)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nDis[nA] == nDis[nB])</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf("In the same gang.\n");</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        printf("In different gangs.\n");</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    printf("Not sure yet.\n");</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1006 Biorhythms 中国剩余定理</title>
      <link href="/2012/10/03/poj%201006%20Biorhythms%20%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2012/10/03/poj%201006%20Biorhythms%20%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>此题本来模拟即可，但是注意有容易出错的地方。<br>这题主要是可以用中国剩余定理来做。<br>根据题意可以抽象出这样的模型。给出三个数A,B,C分别是模23,28,33后的余数，求最小的数字<br>使得其模23,28,33分别为A,B,C，并且要大于给定的数字D。<br>中国剩余定理很好的解决了这种余数问题。令模数为Ni,余数为Ai,设Mi = N1<em>N2</em>…<em>Ni-1</em>Ni+1<em>…</em>Nn，<br>那么答案一定满足形式ans = <span>Σ</span>Ai<em>Mi</em>(Mi对Ni的乘法逆) % N。(N为所有Ni的乘积)。<br>很明显，由于ans的第i项有Mi因子，所以模N1-Ni-1和Ni+1-Nn肯定是0，而Ai<em>Mi</em>(Mi对Ni的乘法逆) %Ni就是Ai。这样就满足了要求。<br>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int Egcd(int nN, int nM, int nX, int nY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nM == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nX = 1, nY = 0;</span><br><span class="line">        return nN;</span><br><span class="line">    &#125;</span><br><span class="line">    int nRet = Egcd(nM, nN % nM, nX, nY);</span><br><span class="line">    int nT = nX;</span><br><span class="line">    nX = nY;</span><br><span class="line">    nY = nT - (nN / nM) * nY;</span><br><span class="line">    return nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nA, nB, nC, nD;</span><br><span class="line">    int nDays = 21252;</span><br><span class="line">    int nCase = 1;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d%d%d"</span>, &amp;nA, &amp;nB, &amp;nC, &amp;nD),</span><br><span class="line">            nA != -1 || nB != -1 || nC != -1 || nD != -1)</span><br><span class="line">    &#123;</span><br><span class="line">        int nFirst = 0;</span><br><span class="line">        nA %= 23;</span><br><span class="line">        nB %= 28;</span><br><span class="line">        nC %= 33;</span><br><span class="line">        int nM1= 28 * 33, nM2 = 23 * 33, nM3 = 23 * 28;</span><br><span class="line">        int nN1, nN2, nN3, nTemp;</span><br><span class="line">        Egcd(23, nM1, nTemp, nN1);</span><br><span class="line">        Egcd(28, nM2, nTemp, nN2);</span><br><span class="line">        Egcd(33, nM3, nTemp, nN3);</span><br><span class="line">        nFirst = (nA * nM1 * nN1 + nB * nM2 * nN2 + nC * nM3 * nN3) % nDays;</span><br><span class="line">        while (nFirst &lt;= nD)nFirst += nDays;</span><br><span class="line">        printf(<span class="string">"Case %d: the next triple peak occurs in %d days.\n"</span>,</span><br><span class="line">               nCase++, nFirst - nD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2406 Power Strings kmp的妙用</title>
      <link href="/2012/09/30/poj%202406%20Power%20Strings%20kmp%E7%9A%84%E5%A6%99%E7%94%A8/"/>
      <url>/2012/09/30/poj%202406%20Power%20Strings%20kmp%E7%9A%84%E5%A6%99%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这个题是求一个字符串的最小重复单元的重复次数，那么求出最小重复单元的长度即可。这个题有3种方法，方法一：直接枚举长度为[1,len/2]内的子串，暴力就过了。方法二：将原串重复一次形成一个新串，用原串去匹配新串，但是得从第二个位置开始匹配，第一次成功匹配的位置减一就代表最小重复单元的长度。方法三：利用kmp的next函数，如果len能够整除len-next[len]，那么len-next[len]就代表最小重复单元的长度。<br>方法一明显是对的，数据不强的情况下就能水过了。方法二也不是那么容易想到的，不过将原串扩展为2倍的做法也不是太奇葩，比如判断2个循环串是否相等就可以用这个办法做。<br>方法三就比较难理解了。<br>方法三的理解：<br>next[len]代表的是str的最长前缀(使得这个前缀与同样长度的后缀相等)的长度。所谓的next<br>数组就是长度为1-len的str的满足上述描述的最长前缀的长度。如果len是len-next[len]的倍数，假设m= len-next[len] ，那么str[1-m] = str[m-2 <em> m]，以此类推下去，m肯定是str的最小重复单元的长度。假如len不是len-next[len]的倍数， 如果前缀和后缀重叠，那么最小重复单元肯定str本身了，如果前缀和后缀不重叠，那么str[m - 2 </em> m] != str[len-m,len]，所以str[1-m]!= str[m - 2 * m] ,最终肯定可以推理出最小重复单元是str本身，因为只要不断递增m证明即可。</p><p>方法三的代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char szStr[1000010];</span><br><span class="line">int nNext[1000010];</span><br><span class="line"></span><br><span class="line">void GetNext(char* szStr, int nLen, int* nNext)</span><br><span class="line">&#123;</span><br><span class="line">    nNext[0] = -1;</span><br><span class="line">    for (int i = 1, j = -1; i &lt; nLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while (j &gt; -<span class="number">1</span>  szStr[i] != szStr[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            j = nNext[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (szStr[i] == szStr[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        nNext[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%s"</span>, szStr), strcmp(szStr, <span class="string">"."</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        int nLen = strlen(szStr);</span><br><span class="line"></span><br><span class="line">        GetNext(szStr, nLen, nNext);</span><br><span class="line">        if (nLen % (nLen - nNext[nLen - 1] - 1))</span><br><span class="line">        &#123;</span><br><span class="line">            printf("1\n");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d\n", nLen / (nLen - nNext[nLen - 1] - 1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3461 Oulipo Rabin-Karp 字符串匹配</title>
      <link href="/2012/09/28/poj%203461%20Oulipo%20Rabin-Karp%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/2012/09/28/poj%203461%20Oulipo%20Rabin-Karp%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>裸的字符串匹配，子串最长10,000，母串最长1,000,000。<br>求子串在母串中出现的次数。<br>如果子串长度较小，那么直接RK匹配即可，hash值相同时候，直接比较字符串是否相同。<br>但是这个题的子串太长了，还比较字符串会超时，如果不比较字符串理论上是错误的，虽然<br>出错的概率很小，而且概率还是跟模数的选择以及运算时候是否溢出有关。<br>刚开始用了int，发现一直wa了，估计就是运算时候就超int了，取模没起到作用。模数的选<br>择能够提高正确率。Rabin-Karp 字符串匹配虽然比较好写，也很容易理解，但是适用情况感<br>觉不是很广，比如子串太长了，处理就麻烦了，舍弃子串比较也不是很好。<br>但是子串不长的话，Rabin-Karp 字符串匹配还是很不错的。<br>相比而言，这个题用kmp应该会好很多。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt; </span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long INT;</span><br><span class="line">char szStrM[1000010];</span><br><span class="line">char szStrS[10010];</span><br><span class="line">const INT MOD = 16381 * 4733 + 1;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%s%s", szStrS, szStrM);</span><br><span class="line">        INT nMatch = szStrS[0] - 'A';</span><br><span class="line">        INT nPowN = 1;</span><br><span class="line">        int nSizeS = 1;</span><br><span class="line">        char* pszStr = szStrS + 1;</span><br><span class="line">        while (*pszStr)</span><br><span class="line">        &#123;</span><br><span class="line">            nMatch = (26 * nMatch + *pszStr - 'A') % MOD;</span><br><span class="line">            nPowN = (nPowN * 26) % MOD;</span><br><span class="line">            ++nSizeS;</span><br><span class="line">            ++pszStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//prINTf("match:%d\n", nMatch);</span></span><br><span class="line"></span><br><span class="line">        int nSizeM = strlen(szStrM);</span><br><span class="line">        INT nKey = 0;</span><br><span class="line">        for (int i = 0; i &lt; nSizeS; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nKey = (26 * nKey + szStrM[i] - 'A') % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//prINTf("key:%d\n", nKey);</span></span><br><span class="line"></span><br><span class="line">        int nAns = 0;</span><br><span class="line">        for (int i = 0; i &lt;= nSizeM - nSizeS; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//prINTf("key:%d\n", nKey);</span></span><br><span class="line">            <span class="keyword">if</span> (nKey == nMatch)</span><br><span class="line">               <span class="comment">//  memcpy(szStrS, szStrM + i, nSizeS) == 0)</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++nAns;</span><br><span class="line">            &#125;</span><br><span class="line">            nKey = (26 * (nKey - nPowN * (szStrM[i] - 'A')) % MOD</span><br><span class="line">                    + szStrM[i + nSizeS] - 'A') % MOD;</span><br><span class="line">            nKey = (nKey + MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf("%d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1200 Crazy Search 字符串hash</title>
      <link href="/2012/09/27/poj%201200%20Crazy%20Search%20%E5%AD%97%E7%AC%A6%E4%B8%B2hash/"/>
      <url>/2012/09/27/poj%201200%20Crazy%20Search%20%E5%AD%97%E7%AC%A6%E4%B8%B2hash/</url>
      
        <content type="html"><![CDATA[<p>这个题是求一个字符串里面出现了多少个长度为N的不同子串，同时给出了母串里面不同字符<br>的个数NC。<br>保存子串到set里面直接暴力肯定超时了。这个题有个利用字符串hash的解法，虽然理论上有<br>bug，但是能过这个题。<br>利用给出的NC，对长度为N的字符串，将其当作NC进制的数字，求出其值，对值进行hash，<br>求出不同的hash位置个数。<br>这个算法其实类似于Karp-Rabin字符串匹配算法。不过，Karp-Rabin算法做了点改进，对<br>进制为D的字符串求值的时候为了防止溢出会模一个素数，而且不会每次都迭代求下一个子串的<br>值，而是从当前子串的值直接递推出下一个字符的值。怎么递推了，其实很简单，就是当前值去<br>掉最高位再乘以D(相当于左移一位,不过是D进制的，不能直接用&lt;&lt;符号)，再加上新的最低位。<br>Karp-Rabin算法应该主要在于设计出合理的hash算法，比如，用取模hash函数的话，得保<br>证hash表足够大，否则冲突太多，速度就不会怎么好了。比如这个题，hash表小了就AC不了了。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">const int MAX = 13747347;</span><br><span class="line">int nHash[MAX];</span><br><span class="line">char szStr[17000001];</span><br><span class="line">int nN, nNC;</span><br><span class="line">int nW[200];</span><br><span class="line"></span><br><span class="line">void Insert(int nKey)</span><br><span class="line">&#123;</span><br><span class="line">    int nPos = nKey;</span><br><span class="line">    while (nHash[nPos] != -<span class="number">1</span>  nHash[nPos] != nKey)</span><br><span class="line">    &#123;</span><br><span class="line">        nPos = (nPos + 1) % MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    nHash[nPos] = nKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Find(int nKey)</span><br><span class="line">&#123;</span><br><span class="line">    int nPos = nKey;</span><br><span class="line">    while (nHash[nPos] != -<span class="number">1</span> &amp;&amp; nHash[nPos] != nKey)</span><br><span class="line">    &#123;</span><br><span class="line">        nPos = (nPos + 1) % MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    return nHash[nPos] != -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d%s"</span>, &amp;nN, &amp;nNC, szStr) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(nW, 0, sizeof(nW));</span><br><span class="line">        memset(nHash, -1, sizeof(nHash));</span><br><span class="line">        int nNum = 0;</span><br><span class="line">        int nSize = 0;</span><br><span class="line">        for (char* pszStr = szStr; *pszStr; ++pszStr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nW[*pszStr])</span><br><span class="line">            &#123;</span><br><span class="line">                nW[*pszStr] = ++nNum;</span><br><span class="line">            &#125;</span><br><span class="line">            ++nSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nKey = 0;</span><br><span class="line">        int nAns = 0;</span><br><span class="line">        int nPowN = 1;</span><br><span class="line">        for (int j = 0; j &lt; nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            nKey = (nKey * nNC + nW[szStr[j]]) % MAX;</span><br><span class="line">            nPowN *= nNC;</span><br><span class="line">        &#125;</span><br><span class="line">        nPowN /= nNC;</span><br><span class="line">        <span class="keyword">if</span> (!Find(nKey))</span><br><span class="line">        &#123;</span><br><span class="line">            Insert(nKey);</span><br><span class="line">            nAns++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = nN; i &lt; nSize; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nKey = (nNC * (nKey - nPowN * nW[szStr[i - nN]])</span><br><span class="line">                    + nW[szStr[i]]) % MAX;</span><br><span class="line">            nKey = (nKey + MAX) % MAX;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Find(nKey))</span><br><span class="line">            &#123;</span><br><span class="line">                Insert(nKey);</span><br><span class="line">                nAns++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf("%d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1811 Prime Test 数论 素数测试</title>
      <link href="/2012/09/24/poj%201811%20Prime%20Test%20%E6%95%B0%E8%AE%BA%20%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/"/>
      <url>/2012/09/24/poj%201811%20Prime%20Test%20%E6%95%B0%E8%AE%BA%20%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef unsigned long long LL;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">5000000</span>)</span><br><span class="line">bool bPrime[MAX];</span><br><span class="line">void InitPrime()</span><br><span class="line">&#123;</span><br><span class="line">    int nMax = sqrt((double)MAX) + 1;</span><br><span class="line">    bPrime[0] = bPrime[1] = true;</span><br><span class="line">    for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 2 * i; j &lt; MAX; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                bPrime[j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL multAndMod(LL <span class="selector-tag">a</span>, LL <span class="selector-tag">b</span>, LL n)</span><br><span class="line">&#123;</span><br><span class="line">    LL tmp = 0;</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="selector-tag">b</span> &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = (tmp + a) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a &lt;&lt; 1) % n;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算a^u%n</span></span><br><span class="line">LL ModExp(LL <span class="selector-tag">a</span>, LL u, LL n)</span><br><span class="line">&#123;</span><br><span class="line">    LL d = 1;</span><br><span class="line">    a %= n;</span><br><span class="line">    while (u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d = multAndMod(d, a, n);</span><br><span class="line">        &#125;</span><br><span class="line">        a = multAndMod(a, a, n);</span><br><span class="line">        u &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return d % n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断nN是不是合数</span></span><br><span class="line">bool Witness(LL <span class="selector-tag">a</span>, LL nN)</span><br><span class="line">&#123;</span><br><span class="line">    LL u = nN - 1, t = 0;//将nN-1表示为u*2^t</span><br><span class="line">    while (u % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        u &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    LL x0 = ModExp(a, u, nN);//x是a^u</span><br><span class="line">    LL x1;</span><br><span class="line">    for (int i = 1; i &lt;= t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x1 = multAndMod(x0, x0, nN);</span><br><span class="line">        <span class="keyword">if</span> (x1 == <span class="number">1</span> &amp;&amp; x0 != nN - <span class="number">1</span> &amp;&amp; x0 != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        x0 = x1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x1 != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//素数测试</span></span><br><span class="line">bool MillerRabin(LL nN)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//if (nN &lt; MAX)return !bPrime[nN];</span></span><br><span class="line">    const int TIME = 10;</span><br><span class="line">    for (int i = 0; i &lt; TIME; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a = rand() % (nN - 1) + 1;</span><br><span class="line">        <span class="keyword">if</span> (Witness(<span class="selector-tag">a</span>, nN))</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">LL gcd(LL <span class="selector-tag">a</span>, LL b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &lt; b)swap(a, b);</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        LL t = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t % b;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启发式寻找nN的因子</span></span><br><span class="line">LL PollardRho(LL n, LL c)</span><br><span class="line">&#123;</span><br><span class="line">    LL i = 1, t = 2;</span><br><span class="line">    LL x, y;</span><br><span class="line">    LL ans;</span><br><span class="line">    srand(time(NULL));  </span><br><span class="line">    y = x = rand() % n;</span><br><span class="line">    while(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        x = (multAndMod(x, x, n) + c) % n;</span><br><span class="line">        ans = gcd(y - x, n);</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">1</span> &amp;&amp; ans &lt; n)</span><br><span class="line">            return ans;</span><br><span class="line">        <span class="keyword">if</span>(x == y)</span><br><span class="line">            return n;</span><br><span class="line">        <span class="keyword">if</span>(t == i)</span><br><span class="line">        &#123;</span><br><span class="line">            y = x;</span><br><span class="line">            t &lt;&lt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL FindMin(LL nN, LL c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf("nN:%I64u\n", nN);</span></span><br><span class="line">    if (MillerRabin(nN) || nN &lt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return nN;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p = nN;</span><br><span class="line">    while (p &gt;= nN) p = PollardRho(p, c--);</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">p</span> &gt; <span class="number">1</span>)</span><br><span class="line">        p = FindMin(p, c);//分解p的最小因子</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">p</span> &lt; nN)</span><br><span class="line">    &#123;</span><br><span class="line">        LL q = nN / p;</span><br><span class="line">        q = FindMin(q, c);//找到q的最小因子</span><br><span class="line">        p = min(p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nTest;</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    <span class="comment">//InitPrime();</span></span><br><span class="line">    scanf("%d", &amp;nTest);</span><br><span class="line">    while (nTest--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL nN;</span><br><span class="line">        scanf("%I64u", &amp;nN);</span><br><span class="line">        if (nN &gt; 2 &amp;&amp; nN % 2 == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("2\n");</span><br><span class="line">        &#125;</span><br><span class="line">        else if (nN == 2 || MillerRabin(nN))</span><br><span class="line">        &#123;</span><br><span class="line">            printf("Prime\n");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("%I64u\n", FindMin(nN, 181));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 4294 Multiple 数论 + bfs</title>
      <link href="/2012/09/18/hdu%204294%20Multiple%20%E6%95%B0%E8%AE%BA%20+%20bfs/"/>
      <url>/2012/09/18/hdu%204294%20Multiple%20%E6%95%B0%E8%AE%BA%20+%20bfs/</url>
      
        <content type="html"><![CDATA[<p>这是前天成都网赛的题，比赛时候确实一点思路也没有。比完之后看了人家的解题报告，还是不会怎么搜出答案，太弱了。<br>题意是给出N,K，求M，使得M是N的正倍数，而且M用K进制表示后所需要的不同数字(0,1,2,3,…,k-1)最少，如果有多组这样的情况，求出最小的M。很数学的题意。<br>用到了一个结论，就是任意数字的正倍数均可以用不超过2个不同数字的数得到。<br>证明如下：<br>任意数M % N 总共有N种结果，假如有N+1个不同的M，那么肯定有2个M对N取模后的结果是相同，这个是所谓鸽巢原理。那么，我取a,aa,aaa,…,aaaaaaaaaa….，总共N+1个，同样满足上面的结论。那么我取那2个对N取模相同的数字相减得到数字aaaaa…000….，这个数字肯定是N的倍数。<br>综合上面的证明，只能得到2个数字肯定能表示N的倍数。但是不能说形式就是aaaaa…000….。</p><p>到了这里我还是一点思路都没有，一点都不知道怎么搜索。。。<br>想了1个多小时，无头绪，问过了这题的同学，还是无头绪。看解题报告，他们的代码写得太牛了，完全看不懂，无头绪。也许也是我对bfs理解太浅，才看不懂他们的搜索代码。而且，我连可以搜索的地方都没有找到，都不知道搜什么了。<br>想了好久，昨天吃饭的时候，终于发现可以对余数进行搜索。<br>对于任意的N，其余数就是范围是[0, N -1]。这个其实就可以代表状态了，或者代表bfs中的点了。从当前余数转移到其它余数的是MOD <em> K +  A 或者 MOD </em> K + B，如果要转移到得余数以前没被搜过，那就可以转移过去。这个刚好就是一个优化了。也可以看成是子问题了。但是，dfs完全不行。刚开始用dfs，绝对的超时。<br>用dfs也是我对思路理解不深，侥幸认为能过。。。后面发现，这题完全和bfs吻合。[0, N -1]刚好代表N个点，我要通过从外面的一个点，最短的遍历到点0，可以bfs或者最短路算法。这题我觉得还有个难点就是保存答案，因为答案最长的长度可能是N(N&lt;=10000)，所以把答案直接放到节点里面肯定不行的。但是，我还仔细看过算法导论。因此想到了可以利用bfs搜索出来的那颗树或者最短路算法跑出来的那颗树，从目标节点逆序寻找答案，找到出发节点之后，再把答案reverse一下就行了。<br>这题还得注意0不能是N的倍数，所以注意bfs(0,i)这种情况的处理。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 10010;</span><br><span class="line">int nOut[MAX_N];</span><br><span class="line">int nOLen;</span><br><span class="line">int nAns[MAX_N];</span><br><span class="line">int nALen;</span><br><span class="line">bool bMod[MAX_N];</span><br><span class="line">int nFather[MAX_N];</span><br><span class="line">int nChoose[MAX_N];</span><br><span class="line">int nN;</span><br><span class="line">int nK;</span><br><span class="line">bool bFind;</span><br><span class="line"></span><br><span class="line">int Cmp(int* A, int nLA, int* B, int nLB)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nLA != nLB)</span><br><span class="line">    &#123;</span><br><span class="line">        return nLA - nLB;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nLA; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">        &#123;</span><br><span class="line">            return A[i] - B[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Bfs(int nA, int nB)</span><br><span class="line">&#123;</span><br><span class="line">    memset(bMod, false, sizeof(bMod));</span><br><span class="line">    queue&lt;int&gt; que;</span><br><span class="line">    que.push(0);</span><br><span class="line">    int nTemp;</span><br><span class="line">    bool bFirst = true;</span><br><span class="line">    bFind = false;</span><br><span class="line"></span><br><span class="line">    if (nA &gt; nB)swap(nA, nB);</span><br><span class="line">    <span class="comment">//printf("nA:%d, nB:%d\n", nA, nB);</span></span><br><span class="line">    while (!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("nMod:%d\n", que.front());</span></span><br><span class="line">        int nMod = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (nMod == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            if (bFirst)bFirst = false;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                bFind = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nTemp = (nMod * nK + nA) % nN;</span><br><span class="line">        <span class="keyword">if</span> (!(nMod == <span class="number">0</span>  nA == <span class="number">0</span>)  !bMod[nTemp])</span><br><span class="line">        &#123;</span><br><span class="line">            nFather[nTemp] = nMod;</span><br><span class="line">            nChoose[nTemp] = nA;</span><br><span class="line">            que.push(nTemp);</span><br><span class="line">            bMod[nTemp] = true;</span><br><span class="line">            <span class="comment">//printf("nTemp:%d\n", nTemp);</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (nA == nB)continue;</span><br><span class="line">        nTemp = (nMod * nK + nB) % nN;</span><br><span class="line">        <span class="keyword">if</span> (!bMod[nTemp])</span><br><span class="line">        &#123;</span><br><span class="line">            nFather[nTemp] = nMod;</span><br><span class="line">            nChoose[nTemp] = nB;</span><br><span class="line">            que.push(nTemp);</span><br><span class="line">            bMod[nTemp] = true;</span><br><span class="line">            <span class="comment">//printf("nTemp:%d\n", nTemp);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bFind)</span><br><span class="line">    &#123;</span><br><span class="line">        int nF = 0;</span><br><span class="line">        nALen = 0;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">            nAns[nALen++] = nChoose[nF];</span><br><span class="line">            nF = nFather[nF];</span><br><span class="line">        &#125;</span><br><span class="line">        while (nF);</span><br><span class="line">        reverse(nAns, nAns + nALen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nK) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bool bOk = false;</span><br><span class="line">        nOLen = 0;</span><br><span class="line">        for (int i = 1; i &lt; nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Bfs(i, i);</span><br><span class="line">            <span class="keyword">if</span> (bFind)</span><br><span class="line">            &#123;</span><br><span class="line">                if (nOLen == 0 || Cmp(nOut, nOLen, nAns, nALen) &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    nOLen = nALen;</span><br><span class="line">                    memcpy(nOut, nAns, sizeof(int) * nALen);</span><br><span class="line">                &#125;</span><br><span class="line">                bOk = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bOk)</span><br><span class="line">            for (int i = 0; i &lt; nK; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j = i + 1; j &lt; nK; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    Bfs(i, j);</span><br><span class="line">                    <span class="keyword">if</span> (bFind)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (nOLen == 0 || Cmp(nOut, nOLen, nAns, nALen) &gt; 0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nOLen = nALen;</span><br><span class="line">                            memcpy(nOut, nAns, sizeof(int) * nALen);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        for (int k = 0; k &lt; nOLen; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d", nOut[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("\n");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3468 A Simple Problem with Integers 线段树成段延迟更新</title>
      <link href="/2012/09/16/poj%203468%20A%20Simple%20Problem%20with%20Integers%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%88%90%E6%AE%B5%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0/"/>
      <url>/2012/09/16/poj%203468%20A%20Simple%20Problem%20with%20Integers%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%88%90%E6%AE%B5%E5%BB%B6%E8%BF%9F%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>用线段树成段更新不能立即全部更新，必须搞延迟操作。其实，就是针对每个节点，另外搞一个域表示延迟<br>更新的数目。然后，在更新操作和查找操作的时候都把父亲节点的延迟域往2个儿子走。<br>这个题是要成段增加值，所以在写PushDown函数的时候要注意，只能给儿子节点加上父亲节点压过来的值乘以儿子区间的长度。这题貌似用树状数组也可以做，不过解法肯定意思不是那么直白的。不过速度肯定会快。<br>树状数组解法：<a href="http://kenby.iteye.com/blog/962159" target="_blank" rel="noopener">http://kenby.iteye.com/blog/962159</a><br>线段树网上流行的解法都是开最多节点数目4倍的数组。以位置1作为根，每个位置其实代表的是一个区间。某人位置1代表1-N或者0-(N-1)区间，具体看题目了。那么2就代表区间1-(1+N)/2，3就代表区间(1+N)/2+1 - N了。<br>至于lazy标记还是搞个大数组，意义和线段树数组一样，搞清楚之后写起来都比较简单，最重要的是变形来解决一些要求奇怪的题目。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long INT;</span><br><span class="line"></span><br><span class="line">const INT MAX_N = 100010;</span><br><span class="line">const INT INF = 0x7ffffffffffffffLL;</span><br><span class="line">INT nTree[MAX_N &lt;&lt; 2];</span><br><span class="line">INT nAdd[MAX_N &lt;&lt; 2];</span><br><span class="line">INT nN, nQ;</span><br><span class="line"></span><br><span class="line">void PushUp(INT nRt)</span><br><span class="line">&#123;</span><br><span class="line">    nTree[nRt] = nTree[nRt &lt;&lt; 1] + nTree[nRt &lt;&lt; 1 | 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildTree(INT nL, INT nR, INT nRt)</span><br><span class="line">&#123;</span><br><span class="line">    nAdd[nRt] = 0;</span><br><span class="line">    <span class="keyword">if</span> (nL == nR)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%I64d", nTree[nRt]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INT nMid = (nL + nR) &gt;&gt; 1;</span><br><span class="line">    BuildTree(nL, nMid, nRt &lt;&lt; 1);</span><br><span class="line">    BuildTree(nMid + 1, nR, nRt &lt;&lt; 1 | 1);</span><br><span class="line">    PushUp(nRt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushDown(INT nL, INT nR, INT nRt)</span><br><span class="line">&#123;</span><br><span class="line">    INT nMid = (nL + nR) &gt;&gt; 1;</span><br><span class="line">    INT nLs = nRt &lt;&lt; 1;</span><br><span class="line">    INT nRs = nLs | 1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nAdd[nRt])</span><br><span class="line">    &#123;</span><br><span class="line">        nAdd[nLs] += nAdd[nRt];</span><br><span class="line">        nAdd[nRs] += nAdd[nRt];</span><br><span class="line">        nTree[nLs] += (nMid - nL + 1) * nAdd[nRt];</span><br><span class="line">        nTree[nRs] += (nR - nMid) * nAdd[nRt];</span><br><span class="line">        nAdd[nRt] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Update(INT nL, INT nR, INT nRt, INT nX, INT nY, INT nV)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nL &gt;= nX &amp;&amp; nR &lt;= nY)</span><br><span class="line">    &#123;</span><br><span class="line">        nTree[nRt] += nV * (nR - nL + 1);</span><br><span class="line">        nAdd[nRt] += nV;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PushDown(nL, nR, nRt);</span><br><span class="line">    INT nMid = (nL + nR) &gt;&gt; 1;</span><br><span class="line">    if (nX &lt;= nMid) Update(nL, nMid, nRt &lt;&lt; 1, nX, nY, nV);</span><br><span class="line">    if (nY &gt; nMid) Update(nMid + 1, nR, nRt &lt;&lt; 1 | 1, nX, nY, nV);</span><br><span class="line">    PushUp(nRt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT Query(INT nL, INT nR, INT nRt, INT nX, INT nY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nL &gt;= nX &amp;&amp; nR &lt;= nY)</span><br><span class="line">    &#123;</span><br><span class="line">        return nTree[nRt];</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(nL, nR, nRt);</span><br><span class="line">    INT nAns = 0;</span><br><span class="line">    INT nMid = (nL + nR) &gt;&gt; 1;</span><br><span class="line">    if (nX &lt;= nMid) nAns += Query(nL, nMid, nRt &lt;&lt; 1, nX, nY);</span><br><span class="line">    if (nY &gt; nMid) nAns += Query(nMid + 1, nR, nRt &lt;&lt; 1 | 1, nX, nY);</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INT nTemp;</span><br><span class="line">    while (scanf(<span class="string">"%I64d%I64d"</span>, &amp;nN, &amp;nQ) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BuildTree(1, nN, 1);</span><br><span class="line"></span><br><span class="line">        while (nQ--)</span><br><span class="line">        &#123;</span><br><span class="line">            char szCmd[10];</span><br><span class="line">            INT nX, nY, nV;</span><br><span class="line">            scanf("%s", szCmd);</span><br><span class="line">            <span class="keyword">if</span> (szCmd[<span class="number">0</span>] == <span class="string">'Q'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf("%I64d%I64d", &amp;nX, &amp;nY);</span><br><span class="line">                printf("%I64d\n", Query(1, nN, 1, nX, nY));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                scanf("%I64d%I64d%I64d", &amp;nX, &amp;nY, &amp;nV);</span><br><span class="line">                Update(1, nN, 1, nX, nY, nV);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2886 Who Gets the Most Candies? 约瑟夫环和反素数</title>
      <link href="/2012/09/14/poj%202886%20Who%20Gets%20the%20Most%20Candies%20%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E5%92%8C%E5%8F%8D%E7%B4%A0%E6%95%B0/"/>
      <url>/2012/09/14/poj%202886%20Who%20Gets%20the%20Most%20Candies%20%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E5%92%8C%E5%8F%8D%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>直接模拟约瑟夫环是N^2，况且这题每次移动的距离和方向都是不确定的，只能模拟，如果加快查找和移动的话，可以提高速度，果断用线段树维护当前位置前面有多少个人。<br>至于反素数指的是求一个小于等于N的数字，使得其因子个数在1-N中是最大的。这个利用一个必要条件暴力搜索即可。</p><p><div>其实就是利用下面这2个性质搜索的。 性质一:一个反素数的质因子必然是从2开始连续的质数。性质二:p=2^t1<em>3^t2</em>5^t3*7^t4…..必然t1&gt;=t2&gt;=t3&gt;=….。</div></p><p>代码如下：&lt;/div&gt;<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int nPrime[16] = &#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53&#125;;</span><br><span class="line">int nAns;</span><br><span class="line">int nCN;</span><br><span class="line">const int MAX_N = 500010;</span><br><span class="line"><span class="comment">//nPow不会超过20</span></span><br><span class="line">void InitBest(int nCur, int nI, int nMax, int nN, int nNum)</span><br><span class="line">&#123;</span><br><span class="line">    if (nCur &gt; nN) return;</span><br><span class="line">    if (nNum &gt; nCN)&#123;nAns = nCur;nCN = nNum;&#125;</span><br><span class="line">    if (nNum == nCN)&#123;nAns = min(nAns, nCur);&#125;</span><br><span class="line">    for (int i = 1; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nCur *= nPrime[nI];</span><br><span class="line">        if (nCur &gt; nN)return;//不加这句优化会超时</span><br><span class="line">        <span class="keyword">if</span> (nI &lt; <span class="number">15</span>)</span><br><span class="line">        InitBest(nCur, nI + 1, i, nN, nNum * (i + 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char szNames[MAX_N][10];</span><br><span class="line">int nValue[MAX_N];</span><br><span class="line">int nTree[MAX_N &lt;&lt; 2];</span><br><span class="line">void PushUp(int nRt)</span><br><span class="line">&#123;</span><br><span class="line">    nTree[nRt] = nTree[nRt &lt;&lt; 1] + nTree[nRt &lt;&lt; 1 | 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BuildTree(int nL, int nR, int nRt, int nV)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nL == nR)</span><br><span class="line">    &#123;</span><br><span class="line">        nTree[nRt] = nV;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int nMid = (nL + nR) &gt;&gt; 1;</span><br><span class="line">    BuildTree(nL, nMid, nRt &lt;&lt; 1, nV);</span><br><span class="line">    BuildTree(nMid + 1, nR, nRt &lt;&lt; 1 | 1, nV);</span><br><span class="line">    PushUp(nRt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Add(int nL, int nR, int nRt, int nP, int nV)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nL == nR)</span><br><span class="line">    &#123;</span><br><span class="line">        nTree[nRt] += nV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        int nMid = (nL + nR) &gt;&gt; 1;</span><br><span class="line">        if (nP &lt;= nMid)Add(nL, nMid, nRt &lt;&lt; 1, nP, nV);</span><br><span class="line">        else Add(nMid + 1, nR, nRt &lt;&lt; 1 | 1, nP, nV);</span><br><span class="line">        PushUp(nRt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Query(int nL, int nR, int nRt, int nSum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nL == nR)</span><br><span class="line">    &#123;</span><br><span class="line">        return nL;</span><br><span class="line">    &#125;</span><br><span class="line">    int nMid = (nL + nR) &gt;&gt; 1;</span><br><span class="line">    int nLs = nRt &lt;&lt; 1;</span><br><span class="line">    int nRs = nLs | 1;</span><br><span class="line">    if (nTree[nLs] &gt;= nSum) return Query(nL, nMid, nLs, nSum);</span><br><span class="line">    else return Query(nMid + 1, nR, nRs, nSum - nTree[nLs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//InitBest(1, 0, 15);</span></span><br><span class="line">    int nN, nK;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nK) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nK--;</span><br><span class="line">        nAns = 2;</span><br><span class="line">        nCN = 0;</span><br><span class="line">        InitBest(1, 0, 20, nN, 1);</span><br><span class="line">        <span class="comment">//printf("ans:%d cn:%d\n", nAns, nCN);</span></span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s%d", szNames[i], nValue[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BuildTree(0, nN - 1, 1, 1);</span><br><span class="line">        int nTotal = nN;</span><br><span class="line">        int nPos;</span><br><span class="line">        for (int i = 0; i &lt; nAns; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nPos = Query(0, nN - 1, 1, nK + 1);</span><br><span class="line">            <span class="comment">//printf("nK:%d %s %d\n", nK, szNames[nPos], nValue[nPos]);</span></span><br><span class="line">            nTotal--;</span><br><span class="line">            Add(0, nN - 1, 1, nPos, -1);</span><br><span class="line">            if (!nTotal)break;</span><br><span class="line">            <span class="keyword">if</span> (nValue[nPos] &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nK = (nK - 1 + nValue[nPos] + nTotal) % nTotal;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nK = ((nK + nValue[nPos]) % nTotal + nTotal) % nTotal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%s %d\n", szNames[nPos], nCN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 约瑟夫环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 2492 Ping pong 树状数组</title>
      <link href="/2012/09/12/hdu%202492%20Ping%20pong%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2012/09/12/hdu%202492%20Ping%20pong%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>此题是求一个数字序列中，长度为3的子序列(a,b,c)，且满足条件a&lt;=b&lt;=c或者c&lt;=b&lt;=a的子序列的个数。<br>明显枚举每个b，求每个b左边的a的个数和右边c的个数，以及左边c的个数和右边a的个数，然后累加左右乘积求和即可。刚开始只求了满足条件a&lt;=b&lt;=c的部分，而且忘记用64位了。wa了几次。求左边a的个数其实就是求小于等于b的数字的个数，这个刚好可以用树状数组或者线段树求。具体见代码。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long INT;</span><br><span class="line">const INT MAX_N =  100010;</span><br><span class="line">const INT N = 20010;</span><br><span class="line">INT nN;</span><br><span class="line">INT nNum[N];</span><br><span class="line">INT nTree[MAX_N + 10];</span><br><span class="line">INT nLeft[2][N], nRight[2][N];</span><br><span class="line"></span><br><span class="line">INT LowBit(INT nI)</span><br><span class="line">&#123;</span><br><span class="line">    return nI  &amp; (-nI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Add(INT nI, INT nAdd)</span><br><span class="line">&#123;</span><br><span class="line">    while (nI &lt;= MAX_N)</span><br><span class="line">    &#123;</span><br><span class="line">        nTree[nI] += nAdd;</span><br><span class="line">        nI += LowBit(nI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT Query(INT nPos)</span><br><span class="line">&#123;</span><br><span class="line">    INT nAns = 0;</span><br><span class="line">    while (nPos &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nAns += nTree[nPos];</span><br><span class="line">        nPos -= LowBit(nPos);</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INT nT;</span><br><span class="line"></span><br><span class="line">    scanf("%I64d", &amp;nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%I64d", &amp;nN);</span><br><span class="line">        memset(nTree, 0, sizeof(nTree));</span><br><span class="line">        for (INT i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%I64d", nNum[i]);</span><br><span class="line">            nLeft[0][i] = Query(nNum[i]);</span><br><span class="line">            nLeft[1][i] = Query(MAX_N) - Query(nNum[i] - 1);</span><br><span class="line">            Add(nNum[i], 1);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(nTree, 0, sizeof(nTree));</span><br><span class="line">        for (INT i = nN; i &gt;= 1; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            nRight[0][i] = Query(MAX_N) - Query(nNum[i] - 1);</span><br><span class="line">            nRight[1][i] = Query(nNum[i]);</span><br><span class="line">            Add(nNum[i], 1);</span><br><span class="line">        &#125;</span><br><span class="line">        INT nAns = 0;</span><br><span class="line">        for (INT i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns += nLeft[0][i] * nRight[0][i] + nLeft[1][i] * nRight[1][i];</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%I64d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 3584 Cube 三维树状数组</title>
      <link href="/2012/09/10/hdu%203584%20Cube%20%E4%B8%89%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2012/09/10/hdu%203584%20Cube%20%E4%B8%89%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>这个题意思是翻转一个01立方体。翻转多次后再查询某个点的值。<br>还是利用上一篇文章的思想，把翻转操作转换为单点更新操作。把查询操作转换为利用树状数组查询和的方式。这样每次操作的复杂度都是logN的3次。而直接翻转立方体的复杂度是N的3次。<br>这个题最麻烦的地方是空间想象能力。因为要翻转8个点才能完成一次立方体翻转。比如，翻转(x,y,z)相当于以该点作为左上角做一个无限立方体，把该立方体翻转。这样就会翻转多余的部分，那么需要把多翻转的部分翻转回来。最后的思考结果发现，只要对每个顶点翻转一次即可。至于为什么这样，自己去计算重复翻转的部分就会明白了。刚好确实是把每个点翻转了一次。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 110;</span><br><span class="line">int nSum[MAX_N + 10][MAX_N + 10][MAX_N + 10];</span><br><span class="line">int nN, nM;</span><br><span class="line"></span><br><span class="line">int LowBit(int nPos)</span><br><span class="line">&#123;</span><br><span class="line">    return nPos &amp; (-nPos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Add(int nX, int nY, int nZ)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = nX; i &lt;= nN; i += LowBit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = nY; j &lt;= nN; j += LowBit(j))</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = nZ; k &lt;= nN; k += LowBit(k))</span><br><span class="line">            &#123;</span><br><span class="line">                nSum[i][j][k]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Query(int nX, int nY, int nZ)</span><br><span class="line">&#123;</span><br><span class="line">    int nAns = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = nX; i &gt; 0; i -= LowBit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = nY; j &gt; 0; j -= LowBit(j))</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = nZ; k &gt; 0; k -= LowBit(k))</span><br><span class="line">            &#123;</span><br><span class="line">                nAns += nSum[i][j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCmd;</span><br><span class="line">    int nX, nY, nZ;</span><br><span class="line">    int nX1, nY1, nZ1;</span><br><span class="line">    int nX2, nY2, nZ2;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nM) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(nSum, 0, sizeof(nSum));</span><br><span class="line">        while (nM--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d", &amp;nCmd);</span><br><span class="line">            <span class="keyword">if</span> (nCmd == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf("%d%d%d", &amp;nX, &amp;nY, &amp;nZ);</span><br><span class="line">                printf("%d\n", Query(nX, nY, nZ) % 2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                scanf("%d%d%d%d%d%d", &amp;nX1, &amp;nY1, &amp;nZ1, &amp;nX2, &amp;nY2, &amp;nZ2);</span><br><span class="line">                if (nX1 &gt; nX2)swap(nX1, nX2);</span><br><span class="line">                if (nY1 &gt; nY2)swap(nY1, nY2);</span><br><span class="line">                if (nZ1 &gt; nZ2)swap(nZ1, nZ2);</span><br><span class="line">                Add(nX1, nY1, nZ1);</span><br><span class="line"></span><br><span class="line">                Add(nX2 + 1, nY1, nZ1);</span><br><span class="line">                Add(nX1, nY2 + 1, nZ1);</span><br><span class="line">                Add(nX1, nY1, nZ2 + 1);</span><br><span class="line"></span><br><span class="line">                Add(nX1, nY2 + 1, nZ2 + 1);</span><br><span class="line">                Add(nX2 + 1, nY1, nZ2 + 1);</span><br><span class="line">                Add(nX2 + 1, nY2 + 1, nZ1);</span><br><span class="line"></span><br><span class="line">                Add(nX2 + 1, nY2 + 1, nZ2 + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 1556 Color the ball 树状数组</title>
      <link href="/2012/09/06/hdu%201556%20Color%20the%20ball%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2012/09/06/hdu%201556%20Color%20the%20ball%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>这个题的意思是给定一个长为N的区间。不断的给某个子区间[A,B]中的每个点涂一次色。最后问每个点的涂色次数。<br>这个题貌似可以扩展到多维的情况，但是多维的情况下必须用树状数组求和以加快速度，一维的情况直接求和即可。<br>假如，第一次涂色是对区间[A,B]涂色一次，可以让nNum[nA]++,nNum[nB+1]—即可。因为这样对于区间[0,nA-1]的任意值i有都要nNum[1]+nNum[2]+…+nNum[i] = 0。而对于区间[nA,nB]的任意值i有nNum[1]+nNum[2]+…+nNum[i] = 0。对于区间[nB+1, nN]的任意值i有nNum[1]+nNum[2]+…+nNum[i] = 0。那么重复多次了。如果上述求和nNum[1]+nNum[2]+…+nNum[i] 刚好代表每个结点i的涂色次数，那么这个题就可解了。<br>用例子验证一下，发现肯定是这样的。证明略了。至于树状数组网上一大堆资料。树状数组模板单一，敲代码太方便了。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int nNum[100000 + 10];</span><br><span class="line">int nN;</span><br><span class="line">int LowBit(int nI)</span><br><span class="line">&#123;</span><br><span class="line">    return nI &amp; (-nI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Add(int nI, int nAdd)</span><br><span class="line">&#123;</span><br><span class="line">    while (nI &lt;= nN)</span><br><span class="line">    &#123;</span><br><span class="line">        nNum[nI] += nAdd;</span><br><span class="line">        nI += LowBit(nI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetSum(int nI)</span><br><span class="line">&#123;</span><br><span class="line">    int nAns = 0;</span><br><span class="line"></span><br><span class="line">    while (nI &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nAns += nNum[nI];</span><br><span class="line">        nI -= LowBit(nI);</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nA, nB;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(nNum, 0, sizeof(nNum));</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d", nA, nB);</span><br><span class="line">            Add(nA, 1);</span><br><span class="line">            Add(nB + 1, -1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d%s", GetSum(i), i == nN ? "\n" : " ");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3255 Roadblocks 次短路</title>
      <link href="/2012/09/03/poj%203255%20Roadblocks%20%E6%AC%A1%E7%9F%AD%E8%B7%AF/"/>
      <url>/2012/09/03/poj%203255%20Roadblocks%20%E6%AC%A1%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>这个题是求次短路。有个不错的解法，是根据一个结论，替换调最短路里面的一条边肯定能得到次短路。<br>那么，只要枚举所有边就可以了。比如，假设开始点为s，目标点是d，设最短路为dis(s,d)。对于边(u,v)，dis(s, u) + w(u, v) + dis(v, d) 大于dis(s, d)，则该路径就可能是次短路。求出最小的大于dis(s,d)的值就可以了。方式是从s开始和从d开始进行2次单源多终点最短路径算法。然后枚举边即可。<br>该算法可以这样理解。因为替换最短路径里面的边，路径的长度只会变大或者不变。如果存在让更短路径变小的边，这本身就与最短路径是矛盾的。所以替换2条或者更多的边只会让路径变得更大。因此，只需考虑替换一条边的情况即可。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_N = 5000 + 10;</span><br><span class="line">struct Edge</span><br><span class="line">&#123;</span><br><span class="line">    int nE;</span><br><span class="line">    int nDis;</span><br><span class="line">    Edge(int e, int d):nE(e), nDis(d) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; graph[MAX_N];</span><br><span class="line">bool bVisit[MAX_N];</span><br><span class="line">int nSDis[MAX_N];</span><br><span class="line">int nEDis[MAX_N];</span><br><span class="line"></span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    int nDis;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (const Node node) const</span><br><span class="line">    &#123;</span><br><span class="line">        return nDis &gt; node.nDis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int ShortestPath(int nS, int nE, int* nDis, int nN)</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line">    memset(bVisit, false, sizeof(bVisit));</span><br><span class="line">    for (int i = 1; i &lt;= nN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nDis[i] = 0x7fffffff;</span><br><span class="line">    &#125;</span><br><span class="line">    nDis[nS] = 0;</span><br><span class="line">    Node head;</span><br><span class="line">    head.nDis = 0, head.nN = nS;</span><br><span class="line">    pq.push(head);</span><br><span class="line"></span><br><span class="line">    while (pq.empty() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        Node head = pq.<span class="attribute">top</span>();</span><br><span class="line">        pq.pop();</span><br><span class="line">        int nU = head.nN;</span><br><span class="line">        if (bVisit[nU]) continue;</span><br><span class="line">        bVisit[nU] = true;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; graph[nU].size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int nV = graph[nU][i].nE;</span><br><span class="line">            int nLen = head.nDis + graph[nU][i].nDis;</span><br><span class="line">            <span class="keyword">if</span> (nLen &lt; nDis[nV])</span><br><span class="line">            &#123;</span><br><span class="line">                nDis[nV] = nLen;</span><br><span class="line">                Node node;</span><br><span class="line">                node.nDis = nLen;</span><br><span class="line">                node.nN = nV;</span><br><span class="line">                pq.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nDis[nE];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Second(int nS, int nE, int nN)</span><br><span class="line">&#123;</span><br><span class="line">    int nShortest = ShortestPath(nS, nE, nSDis, nN);</span><br><span class="line">    ShortestPath(nE, nS, nEDis, nN);</span><br><span class="line"></span><br><span class="line">    int nAns = 0x7fffffff;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; graph[i].size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            int nU = i;</span><br><span class="line">            int nV = graph[i][j].nE;</span><br><span class="line">            int nLen = nSDis[i] + graph[i][j].nDis + nEDis[nV];</span><br><span class="line">            <span class="keyword">if</span> (nLen != nShortest)</span><br><span class="line">            &#123;</span><br><span class="line">                nAns = min(nAns, nLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN, nR;</span><br><span class="line">    int nA, nB, nD;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nR) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            graph[i].<span class="attribute">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (nR--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d%d", &amp;nA, &amp;nB, &amp;nD);</span><br><span class="line">            graph[nA].push_back(Edge(nB, nD));</span><br><span class="line">            graph[nB].push_back(Edge(nA, nD));</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", Second(1, nN, nN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2823 Sliding Window 单调队列</title>
      <link href="/2012/09/02/poj%202823%20Sliding%20Window%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2012/09/02/poj%202823%20Sliding%20Window%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>这道题的意思是给定一个长N的整数序列，用一个大小为K的窗口从头开始覆盖，问第1-第N-K次窗口里面最大的数字和最小的数字。刚开始还以为优先级队列可以做，发现无法删除最前面的元素。估计用线段树这个题也是可以解得。用这个题学了下单调队列。<br>单调队列正如其名，是一个从小到大排序的队列，而且能够保证所有的元素入队列一次出队列一次，所以平摊到每个元素的复杂度就是O(1)。<br>对于这个题单调队列的使用。以序列1 3 -1 -3 5 3 6 7举例。<br>1）元素类型：一个结构体，包含数字大小和位置，比如(1，1），（3，2）。<br>2）插入操作：从队尾开始查找，把队尾小于待插入元素的元素全部删除，再加入待插入的元素。这个操作最坏的情况下是O(n)，但是我们采用聚集分析的方法，知道每个元素最多删除一次，那么N个元素删除N次，平摊到每一次操作的复杂度就是O(1)了。<br>3）删除队首元素：比如本文给的那个题，窗口一直往后移动，每一次移动都会删除一个元素，所以很可能队首会是要删除的元素，那么每次移动窗口的元素要进行一次检查，如果队首元素失效的话，就删掉队首元素。<br>代码的实现，我是包装deque实现了一个模版类。速度很不好，居然跑了11s多才过，幸亏给了12s的时间，看status又500多ms就过了的。估计数组实现会快很多。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;deque&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="number">#def</span>ine MAX_N (<span class="number">1000000</span> + <span class="number">100</span>)</span><br><span class="line">int nNum[MAX_N];</span><br><span class="line">int nN, nK;</span><br><span class="line"></span><br><span class="line">struct Small</span><br><span class="line">&#123;</span><br><span class="line">    int nValue;</span><br><span class="line">    int nIndex;</span><br><span class="line">    Small(int nV, int index):nValue(nV), nIndex(index) &#123;&#125;</span><br><span class="line">    bool operator &lt; (const Small a) const</span><br><span class="line">    &#123;</span><br><span class="line">        return nValue &lt; a.nValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Big</span><br><span class="line">&#123;</span><br><span class="line">    int nValue;</span><br><span class="line">    int nIndex;</span><br><span class="line">    Big(int nV, int index):nValue(nV), nIndex(index) &#123;&#125;</span><br><span class="line">    bool operator &lt; (const Big a) const</span><br><span class="line">    &#123;</span><br><span class="line">        return nValue &gt; a.nValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单调队列</span></span><br><span class="line">template &lt;typename T&gt; class Monoque</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;T&gt; dn;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void Insert(T node)</span><br><span class="line">    &#123;</span><br><span class="line">        int nPos = dn.size() - 1;</span><br><span class="line">        while (nPos &gt;=<span class="number">0</span>  node &lt; dn[nPos])</span><br><span class="line">        &#123;</span><br><span class="line">            --nPos;</span><br><span class="line">            dn.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        dn.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Top()</span><br><span class="line">    &#123;</span><br><span class="line">        return dn.front().nValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Del(int nBeg, int nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dn.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            if (dn.front().nIndex &lt; nBeg || dn.front().nIndex &gt; nEnd)</span><br><span class="line">            &#123;</span><br><span class="line">                dn.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nK) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d", &amp;nNum[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Monoque&lt;Small&gt; minQ;</span><br><span class="line">        Monoque&lt;Big&gt; maxQ;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            minQ.Insert(Small(nNum[i], i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; nN - nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d ", minQ.Top());</span><br><span class="line">            minQ.Insert(Small(nNum[i + nK], i + nK));</span><br><span class="line">            minQ.Del(i + 1, i + nK);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", minQ.Top());</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            maxQ.Insert(Big(nNum[i], i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; nN - nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d ", maxQ.Top());</span><br><span class="line">            maxQ.Insert(Big(nNum[i + nK], i + nK));</span><br><span class="line">            maxQ.Del(i + 1, i + nK);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", maxQ.Top());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>poj 3093 Margaritas on the River Walk</title>
      <link href="/2012/08/30/poj-3093-margaritas-on-the-river-walk/"/>
      <url>/2012/08/30/poj-3093-margaritas-on-the-river-walk/</url>
      
        <content type="html"><![CDATA[<p>这是一个动态规划题，据说是背包问题的变形。我动态规划做得很少，解法一直按照算法导论的思想分解重叠子问题。<br>题意是用钱尽可能多的买物品，每种物品买一个，问有多少种买法。<br>我也想不出这是什么背包问题的变形，没做过几个背包问题，也没看过背包九讲。还是坚持认为正确的用状态描述成子问题就一定能解题的。今天和队友在做专题时候做到这个题，我一直做了一上午都没出来。<br>后面发现了个性质就可以直接转换为类似最简单的背包问题了。排序物品价值，从最大物品开始分解子问题，用剩余物品数和钱描述问题的状态。<strong>当前物品是否必须取，是根据当前的钱把剩下的物品全买了之后剩下的钱还是否大于当前物品的价值，如果大于就必须买，否则可以买或者不买。</strong><br><strong>为了正确描述问题的状态，必须事先排序价值数组，因为排序之后可以保证不能买当前物品的时候一定不能买前面的物品，那么我们对前面物品的处理就是正确的了。</strong>至此可以进行最简单的子问题分解了。到最后物品处理完之后（物品数为0），如果钱一点都没减少，那么(0, M) = 0，否则(0, M) = 1。注意这个边界处理，否则会wa。所以，需要先对价值数组排序，并计算出表示前N个物品价值和的数组。<br>做不出来的时候，翻了下别人的解法，一头雾水。看来还是算法导论的思想指导意义大多了。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt; </span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long INT;</span><br><span class="line">INT nAns[40][1010];</span><br><span class="line">INT nValue[100];</span><br><span class="line">INT nSum[100];</span><br><span class="line">INT nN, nM;</span><br><span class="line"></span><br><span class="line">INT GetAns(INT nNum, INT nMoney)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nAns[nNum][nMoney] == -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nNum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns[nNum][nMoney] = 1;</span><br><span class="line">            <span class="keyword">if</span> (nMoney == nM)</span><br><span class="line">            &#123;</span><br><span class="line">                nAns[nNum][nMoney] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            INT nRet = 0;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nMoney - nSum[nNum - <span class="number">1</span>] &gt;= nValue[nNum])</span><br><span class="line">            &#123;</span><br><span class="line">                nRet = GetAns(nNum - 1, nMoney - nValue[nNum]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nMoney &gt;= nValue[nNum])</span><br><span class="line">                &#123;</span><br><span class="line">                    nRet += GetAns(nNum - 1, nMoney - nValue[nNum]);</span><br><span class="line">                &#125;</span><br><span class="line">                nRet += GetAns(nNum - 1, nMoney);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nAns[nNum][nMoney] = nRet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns[nNum][nMoney];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INT nT;</span><br><span class="line"></span><br><span class="line">    scanf("%I64d", &amp;nT);</span><br><span class="line">    for (INT i = 1; i &lt;= nT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%I64d%I64d", &amp;nN, &amp;nM);</span><br><span class="line">        for (INT j = 1; j &lt;= nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%I64d", nValue[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(nAns, -1, sizeof(nAns));</span><br><span class="line">        sort(nValue + 1, nValue + nN + 1);</span><br><span class="line">        nSum[0] = 0;</span><br><span class="line">        for (INT j = 1; j &lt;= nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            nSum[j] = nSum[j - 1] + nValue[j];</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%I64d %I64d\n", i, GetAns(nN, nM));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2065 SETI</title>
      <link href="/2012/08/06/poj-2065-seti/"/>
      <url>/2012/08/06/poj-2065-seti/</url>
      
        <content type="html"><![CDATA[<p>题意比较纠结，搜索了把题意。<br>给你一个素数P(P&lt;=30000)和一串长为n的字符串str[]。字母 ‘*’ 代表0，字母a-z分别代表1-26，这n个字符所代表的数字分别代表f(1)、f(2)….f(n)。定义: f (k) = ∑<sub>0&lt;=i&lt;=n-1</sub>a<sub>i</sub>k<sup>i</sup> (mod p) (1&lt;=k&lt;=n,0&lt;=ai&lt;P)，求a0、a1…..an-1。题目保证肯定有唯一解。<br>解题思路：高斯消元。根据上面的公式显然可以列出有n个未知数的n个方程式：</p><p><div>   a0*1^0 + a1*1^1+a2*1^2+........+an-1*1^(n-1) = f(1)</div></p><p><div>   a0*2^0 + a1*2^1+a2*2^2+........+an-1*2^(n-1) = f(2)</div></p><p><div>   ..............</div></p><p><div>   a0*n^0 + a1*n^1+a2*n^2+........+an-1*n^(n-1) = f(n)</div></p><p><div>   然后采用高斯消元法来解上面的方程组即可。<br>典型的高斯消元题，只是多了个modP，因此计算过程中可能需要扩展欧几里德算法。</div></p><p>说下所谓的高斯消元的思路，其实可以参看维基百科，<div><a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B6%88%E5%8E%BB%E6%B3%95</a>，<br>大致过程是一直消变量。比如刚开始，消第一个变量，消完之后只让第一个方程含有第一个变量，然后消第二个变量，消完之后只让第二个方程含第二个变量，以此下去让最后的方程含最后一个变量，而且最后一个方程中对于前N-1个变量的系数都是0，这样就能解出这N个变量了。<br>关于自由元指的是这个变量可以取任何值，得出这样的结论是在消变量的过程中发现该变量的在第row个方程到第N方程中的系数都是0了，所以可以取任何值。判断无解的方式是，第row+1到第N个方程在高斯消元之后所有的系数必定是0，所以方程的值也必须是0。<br>求方程的解得过程是从N个解开始逆推，第N-1个方程也就包含2个变量了，第N个变量和第N-1个变量，以此下去，就可以解出方程组了。<br>具体的可以参照维基百科和代码仔细分析。还有演算法笔记上也有高斯消元的解释。</div></p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">70</span> + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">int nMatrix[MAX][MAX];</span><br><span class="line">int nAns[MAX];</span><br><span class="line">void InitMatrix(char* szStr, int nN, int nP)</span><br><span class="line">&#123;</span><br><span class="line">    memset(nMatrix, 0, sizeof(nMatrix));</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nMatrix[i][nN] = (szStr[i] == '*' ? 0 : szStr[i] - 'a' + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int nTemp = 1;</span><br><span class="line">        for (int j = 0; j &lt; nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            nMatrix[i][j] = nTemp;</span><br><span class="line">            nTemp = (nTemp * (i + 1)) % nP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int egcd(int nA, int nB, int nX, int nY)</span><br><span class="line">&#123;</span><br><span class="line">    if (nA &lt; nB)swap(nA, nB);</span><br><span class="line">    <span class="keyword">if</span> (nB == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nX = 1, nY = 0;</span><br><span class="line">        return nA;</span><br><span class="line">    &#125;</span><br><span class="line">    int nRet = egcd(nB, nA % nB, nX, nY);</span><br><span class="line">    int nT = nX;</span><br><span class="line">    nX = nY;</span><br><span class="line">    nY = nT - (nA / nB) * nY;</span><br><span class="line">    return nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Gauss(int nN, int nP)</span><br><span class="line">&#123;</span><br><span class="line">    int nR, nC;</span><br><span class="line">    for (nR = nC = 0; nR &lt; nN  nC &lt; nN; ++nR, ++nC)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nMatrix[nR][nC] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = nR + 1; i &lt; nN; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nMatrix[i][nC])</span><br><span class="line">                &#123;</span><br><span class="line">                    for (int j = nC; j &lt;= nN; ++j)</span><br><span class="line">                    &#123;</span><br><span class="line">                        swap(nMatrix[nR][j], nMatrix[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nMatrix[nR][nC] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nR--;    //自由元</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int nA = nMatrix[nR][nC];</span><br><span class="line">        for (int i = nR + 1; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nMatrix[i][nC])</span><br><span class="line">            &#123;</span><br><span class="line">                int nB = nMatrix[i][nC];</span><br><span class="line">                for (int j = nC; j &lt;= nN; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    nMatrix[i][j] = (nMatrix[i][j] * nA - nMatrix[nR][j] * nB) % nP;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = nR; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nMatrix[i][nN])</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;//无解</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nX, nY;</span><br><span class="line">    for (int i = nN - 1; i &gt;= 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        int nSum = 0;</span><br><span class="line">        for (int j = i + 1; j &lt; nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            nSum = (nSum + nMatrix[i][j] * nAns[j]) % nP;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nSum = (nMatrix[i][nN] - nSum + nP * nP) % nP;</span><br><span class="line"></span><br><span class="line">        egcd(nP, (nMatrix[i][i] + nP) % nP, nX, nY);</span><br><span class="line">        nY = (nY + nP) % nP;</span><br><span class="line">        nAns[i] = (nY * nSum + nP) % nP;//第i个解</span><br><span class="line">    &#125;</span><br><span class="line">    return 1 &lt;&lt; (nN - nR);//返回解的个数,本题有唯一解</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        int nP;</span><br><span class="line">        int nN;</span><br><span class="line">        char szStr[MAX];</span><br><span class="line">        scanf("%d%s", nP, szStr);</span><br><span class="line">        nN = strlen(szStr);</span><br><span class="line">        InitMatrix(szStr, nN, nP);</span><br><span class="line">        Gauss(nN, nP);</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d%s", nAns[i], i == nN - 1 ? "\n" : " ");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高斯消元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3243 Clever Y 扩展离散对数</title>
      <link href="/2012/08/05/poj%203243%20Clever%20Y%20%E6%89%A9%E5%B1%95%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
      <url>/2012/08/05/poj%203243%20Clever%20Y%20%E6%89%A9%E5%B1%95%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>这个是求扩展离散对数问题。_X<sup>Y</sup> mod Z = K，给出X，Z，K，求Y。<br>_当Z是素数的时候直接用baby-step算法即可了。但是，模数不是素数的情况怎么办了。<br>方程a^X = b % c，可以进行一系列的转化。假设d = gcd(a,c)，由a^(x-1)  <em> a = b % c，知道a^(x-1)要存在必须满足gcd(a,c) | b，如果满足这个条件，那么我们可以在方程2边同时除以d，方程是不变的。因为a^x = b + k </em> c，再除以公约数d，得到方程a^(x-1) <em> a / d = b / d + k </em> c / d。根据以上推论，我们可以不断的除以d，直到gcd(a,c)=1。<br>假设我们除了k次，那么方程转化为a^(x-k) <em> a^k/d^k = b / d^k + k </em> c / d^k。令d = a^k/d^k，b’ = b / d^k，c’ = c / d^k，x’ = x - k，方程转化为a^x’ <em> d = b’ % c’，得到a^x’ = b’ </em> d^-1 % c’。<br>现在直接用baby-step解方程a^x’ = b’ * (d^-1) % c’即可。注意到x=x’+k，如果存在x小于k的解，那么x’小于0，但是由baby-step是不会求负的次数的，所以需要先枚举一下是否存在小于k的解，由于输入的数据不会超过10^9的，假设k不超过50进行枚举即可了。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long INT;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">1000000</span>)</span><br><span class="line">INT nData[MAX];</span><br><span class="line">INT nKey[MAX];</span><br><span class="line"></span><br><span class="line">INT HashPos(INT key)</span><br><span class="line">&#123;</span><br><span class="line">    return ((unsigned)(key ^ 0xA5A5A5A5)) % MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void HashAdd(INT key, INT data)</span><br><span class="line">&#123;</span><br><span class="line">    INT nPos = HashPos(key);</span><br><span class="line">    while (nData[nPos] != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nPos = (nPos + 1) % MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    nData[nPos] = data;</span><br><span class="line">    nKey[nPos] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT HashQuery(INT key)</span><br><span class="line">&#123;</span><br><span class="line">    INT nPos = HashPos(key);</span><br><span class="line">    while (nData[nPos] != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nKey[nPos] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            return nData[nPos];</span><br><span class="line">        &#125;</span><br><span class="line">        nPos = (nPos + 1) % MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT MultMod(INT nA, INT nB, INT nC)</span><br><span class="line">&#123;</span><br><span class="line">    INT nAns = 0;</span><br><span class="line">    while (nB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nB  <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = (nAns + nA) % nC;</span><br><span class="line">        &#125;</span><br><span class="line">        nA = (2 * nA) % nC;</span><br><span class="line">        nB &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT PowerMod(INT nA, INT nX, INT nC)</span><br><span class="line">&#123;</span><br><span class="line">    INT nAns = 1;</span><br><span class="line">    nA %= nC;</span><br><span class="line">    while (nX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nX  <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = MultMod(nAns, nA, nC); </span><br><span class="line">        &#125;</span><br><span class="line">        nA = MultMod(nA, nA, nC);</span><br><span class="line">        nX &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT gcd(INT nA, INT nB)</span><br><span class="line">&#123;</span><br><span class="line">    if (nA &lt; nB)swap(nA, nB);</span><br><span class="line">    while (nB)</span><br><span class="line">    &#123;</span><br><span class="line">        INT nT = nA;</span><br><span class="line">        nA = nB;</span><br><span class="line">        nB = nT % nB;</span><br><span class="line">    &#125;</span><br><span class="line">    return nA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//d = nA * nX + nB * nY(nA &gt; nB, nA是模数)</span></span><br><span class="line">INT egcd(INT nA, INT nB, INT nX, INT nY)</span><br><span class="line">&#123;</span><br><span class="line">    if (nA &lt; nB)swap(nA, nB);</span><br><span class="line">    <span class="keyword">if</span> (nB == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nX = 1;</span><br><span class="line">        nY = 0;</span><br><span class="line">        return nA;</span><br><span class="line">    &#125;</span><br><span class="line">    INT nRet = egcd(nB, nA % nB, nX, nY);</span><br><span class="line">    INT nT = nX;</span><br><span class="line">    nX = nY;</span><br><span class="line">    nY = nT - (nA / nB) * nY;</span><br><span class="line">    return nRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT GetAns(INT nA, INT nB, INT nC)</span><br><span class="line">&#123;</span><br><span class="line">    if (nC == 0)return -1;</span><br><span class="line">    <span class="comment">//先枚举0-50,扩展baby-step的过程可能会漏掉这些解</span></span><br><span class="line">    INT nTemp = 1;</span><br><span class="line">    nB %= nC;</span><br><span class="line">    for (INT i = 0; i &lt;= 50; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nTemp == nB)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        nTemp = MultMod(nTemp, nA, nC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果nC不是素数,那么方程nA^x = nB + k*nC</span></span><br><span class="line">    <span class="comment">//可以不到除以gcd(nC,nA)</span></span><br><span class="line">    <span class="comment">//如果gcd(nC,nA)|nB不成立,方程无解，</span></span><br><span class="line">    <span class="comment">//这个由a*x=b%c有解必须满足gcd(a,c)|b一样</span></span><br><span class="line">    INT d;</span><br><span class="line">    INT nD = 1;//nD最后是A^k次,k是nC中因子d的次数</span><br><span class="line">    INT k = 0;</span><br><span class="line">    while ((d = gcd(nC, nA)) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        nC /= d;</span><br><span class="line">        if (nB % d)return -1;</span><br><span class="line">        nB /= d;</span><br><span class="line">        nD = MultMod(nD, nA / d, nC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在方程转化为nA^(x-k) * nA^k/d^k = nB/d^k % nC/d^k</span></span><br><span class="line">    <span class="comment">//其实就是方程2侧除以d^k次而已,这样的做法与原方程是等价的</span></span><br><span class="line">    <span class="comment">//令nD = nA^k/d^k,则nA^x'*nD = nB' % nC',</span></span><br><span class="line">    <span class="comment">//解该方程,那么x=x'+k</span></span><br><span class="line">    <span class="comment">//注意,如果x&lt;k,那么x'为负数,baby-step无法求出,故在函数开头进行枚举</span></span><br><span class="line">    memset(nKey, -1, sizeof(nKey));</span><br><span class="line">    memset(nData, -1, sizeof(nData));</span><br><span class="line">    INT nM = ceil(sqrt(1.0 * nC));</span><br><span class="line">    nTemp = 1;</span><br><span class="line">    for (INT j = 0; j &lt;= nM; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        HashAdd(nTemp, j);</span><br><span class="line">        nTemp = MultMod(nTemp, nA, nC);</span><br><span class="line">    &#125;</span><br><span class="line">    INT nK = PowerMod(nA, nM, nC);</span><br><span class="line">    for (int i = 0; i &lt;= nM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        INT x, y;</span><br><span class="line">        egcd(nC, nD, x, y);//y = nD^-1,nD = nD*(nA^m)^i</span><br><span class="line">        y = (y + nC) % nC;//这句话是必须的,y很可能就是负数</span><br><span class="line">        INT nR = MultMod(y, nB, nC);//nR=nB*nD^-1</span><br><span class="line">        int j = HashQuery(nR);</span><br><span class="line">        <span class="keyword">if</span> (j != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return nM * i + j + k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nD = MultMod(nD, nK, nC);</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INT nA, nB, nC;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%I64d%I64d%I64d"</span>, &amp;nA, &amp;nC, &amp;nB), nA + nB + nC)</span><br><span class="line">    &#123;</span><br><span class="line">        INT nAns = GetAns(nA, nB, nC);</span><br><span class="line">        <span class="keyword">if</span> (nAns == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("No Solution\n");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("%I64d\n", nAns);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3696 The Luckiest number</title>
      <link href="/2012/08/02/poj-3696-the-luckiest-number/"/>
      <url>/2012/08/02/poj-3696-the-luckiest-number/</url>
      
        <content type="html"><![CDATA[<p>这个题很奇葩了。题意是给出个数字L，假如存在一个数K使得L <em> K = 888…，求888…的最小长度，如果不存在这样的K，那么输出0。我是什么思路也没有了，拖了几天了，数论搞死我了，只能找答案了。<br>我看到个比较靠谱的推法。首先，888… = 111… </em> 8=(10^0+10^1+…+10^m-1) <em> 8=(10^m - 1) / 9 </em> 8，PS：m代表888…的长度。<br>好吧，终于化成指数了，现在有8 <em> (10^m-1)/9=K </em> L，最小的m就是我们要求的答案啦。</p><p>方式1：<br>=&gt; 8 <em> (10^m-1) = 9 </em> k <em> L<br>=&gt; 8 / d </em> (10^m-1) = 9 <em> k </em> L / d，d=gcd(8,9L)<br>=&gt; 10^m-1 = 0 % 9 <em> L / gcd(8, 9L) = 0 % 9 </em> L/gcd(8,L)，(由于gcd(8/d,9L/d)=1，那么10^m-1必然是9 <em> L / d的倍数了)。<br>=&gt; 10^m = 1 % 9 </em> L / gcd(8,L)<br>方式2：<br>=&gt; 8 <em> (10^m-1)/9 = 0 % L<br>=&gt; 8 </em> (10^m-1) = 0 % 9 <em> L(这步的推出，比如x/9 = k </em> n，那么x = 9 <em> k </em> n了，显然成立)<br>=&gt; 10^m-1 = 0 % 9 <em> L / gcd(9 </em> L,8)，假如，d = gcd(9 <em> L,8)，那么有8 / d </em> (10^m - 1) = k <em> 9 </em> L/d，因为8/d不可能是9 <em> L / d的倍数，所以10^m-1必定是9 </em> L / d的倍数，所以10^m-1 = 0 % 9 <em> L / gcd(9 </em> L,8))，=&gt;，10^m - 1 = 0 % 9 <em> L / gcd(L, 8),<br>(因为gcd(9,8)=1)。<br>=&gt; 10^m = 1 % 9 </em> L/gcd(8, L)</p><p>至此，2种方式都推出了，10^m = 1 % 9 <em> L / gcd(8,L) 。<br>那么怎么解答这个问题了，这个就用到了欧拉定理了。令p = 9 </em> L / gcd(8,L)，那么有10^m = 1 % p。由欧拉定理知,Z <em> p中所有的数字a均满足a^euler(p) = 1 % p。那么，10只要是p的乘法群中就肯定有解了。如果，10不在Z </em> p中了，肯定是无解的。证明如下：<br>由a^x = 1%p，可以得到a^(x-1) <em> a=1%p，要a^(x-1)存在，那么gcd(a,p)|1，那么gcd(a,p)必须是1。综上所述，要满足式子a^m=1%p，必须gcd(p,a)=1，即a必须是p的乘法群中的数字。现在的问题是求最小的m，由欧拉定理知道a^euler(p)=1%p，m再大就开始循环了。但是m可能会更小。比如，我们现在知道最小的m是min，那么有a^min=1%p，因为要满足a^euler(p)=1%p，那么a^euler(p)肯定能变换成(a^min)^k,至于k是多少就不知道了，当然也可以求出来。那么min就是euler(p)的一个因子，而且是最小的一个满足a^min=1%p的因子了。<br>现在就可以通过枚举euler(p)的因子，找到最小的因子min满足式子a^min = 1 % p就能解决本问题了。注意求a^m%p肯定是通过算法导论上面那种方法的,O(32)或者O(64)的复杂度，还有a </em> b%m也需要自己模拟，因为可能a * b就溢出了。<br>代码如下，貌似代码还可以通过其它的改进加快速度。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long INT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10^m = 1 % (9*L / gcd(8, L)),求最小m</span></span><br><span class="line"><span class="comment">//p = 9 * L / gcd(8,L)</span></span><br><span class="line"><span class="comment">//gcd(p,10) != 1则p有2或者5的因子,2^m=1%p或者</span></span><br><span class="line"><span class="comment">//5^m=1%p无解,原式无解</span></span><br><span class="line"><span class="comment">//if(p)素数,m=euler(p) = p - 1</span></span><br><span class="line"><span class="comment">//否则,m一定是euler(p)的最小满足等式的因子</span></span><br><span class="line"><span class="comment">//因为(10^m)^n = 10^euler(p) = 1%p</span></span><br><span class="line">INT gcd(INT <span class="selector-tag">a</span>, INT b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &lt; b)swap(a, b);</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        INT t = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t % b;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT Euler(INT nN)</span><br><span class="line">&#123;</span><br><span class="line">    INT nAns = 1;</span><br><span class="line">    INT nMax = sqrt((double)nN) + 1;</span><br><span class="line">    for (INT i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nN % i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            nAns *= i - 1;</span><br><span class="line">            nN /= i;</span><br><span class="line">            while (nN % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                nAns *= i;</span><br><span class="line">                nN /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nN != 1)nAns *= nN - 1;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT MultMod(INT <span class="selector-tag">a</span>, INT <span class="selector-tag">b</span>, INT mod)</span><br><span class="line">&#123;</span><br><span class="line">    INT ans = 0;</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="selector-tag">b</span>  <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = (ans + a) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (2 * a) % mod;</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT ExpMod(INT base, INT exp, INT mod)</span><br><span class="line">&#123;</span><br><span class="line">    INT ans = 1;</span><br><span class="line">    base %= mod;</span><br><span class="line">    while (exp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp  <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = MultMod(ans, base, mod);</span><br><span class="line">        &#125;</span><br><span class="line">        base = MultMod(base, base, mod);</span><br><span class="line">        exp &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INT GetAns(INT p)</span><br><span class="line">&#123;</span><br><span class="line">    INT u = Euler(p);</span><br><span class="line">    INT nMax = sqrt((double)u) + 1;</span><br><span class="line">    INT nAns = u;</span><br><span class="line">    for (INT i = 1; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (u % i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ExpMod(<span class="number">10</span>, <span class="selector-tag">i</span>, p) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nAns = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ExpMod(<span class="number">10</span>, u / <span class="selector-tag">i</span>, p) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nAns = min(nAns, u / i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    INT nL;</span><br><span class="line">    INT nCase = 1;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%I64d"</span>, &amp;nL), nL)</span><br><span class="line">    &#123;</span><br><span class="line">        INT p = 9 * nL / gcd(nL, 8);</span><br><span class="line">        <span class="keyword">if</span> (gcd(<span class="selector-tag">p</span>, <span class="number">10</span>) != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("Case %I64d: 0\n", nCase++);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("Case %I64d: %I64d\n", nCase++, GetAns(p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 10392 - Factoring Large Numbers</title>
      <link href="/2012/08/01/uva-10392-factoring-large-numbers/"/>
      <url>/2012/08/01/uva-10392-factoring-large-numbers/</url>
      
        <content type="html"><![CDATA[<p>此题的意思是分解大数字，数字的范围是Longlong级别的，好像不能暴力的样子。但是，题目给出了个条件，最多只有一个因子的大小超过1000000。哈哈，这就是暴点啊。既然，如此直接枚举1000000以内的因子就行了，剩余的部分如果大于10的6次肯定是N的因子了，就不用暴力了。如果小于10的6次肯定是1啦，因为2-1000000的因子都被处理了啊。<br>这样这个题就不会超时了。确实，暴力是需要技巧的。还要注意uva上要用%lld输入。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">typedef long long LL;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">6000000</span>)</span><br><span class="line">bool bPrime[MAX];</span><br><span class="line">int nPrime[MAX];</span><br><span class="line">int nNum;</span><br><span class="line"></span><br><span class="line">void InitPrime()</span><br><span class="line">&#123;</span><br><span class="line">    LL nMax = sqrt(MAX) + 1;</span><br><span class="line">    bPrime[0] = bPrime[1] = true;</span><br><span class="line">    for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 2 * i; j &lt; MAX; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                bPrime[j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 2; i &lt; MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bPrime[i])</span><br><span class="line">            nPrime[nNum++] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsPrime(LL nN)</span><br><span class="line">&#123;</span><br><span class="line">    if (nN &lt; MAX) return !bPrime[nN];</span><br><span class="line">    LL nMax = sqrt((double)nN) + 1;</span><br><span class="line">    for (LL j = 0, i = nPrime[j]; i &lt;= nMax; ++j, i = nPrime[j])</span><br><span class="line">    &#123;</span><br><span class="line">        if (nN % i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    LL nN;</span><br><span class="line"></span><br><span class="line">    InitPrime();</span><br><span class="line">    while (scanf(<span class="string">"%lld"</span>, &amp;nN), nN &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nN &lt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%-lld\n\n", nN);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int nMax = sqrt((double)nN)+ 1;</span><br><span class="line">        for (LL i = 2; i &lt;= 1000000  i &lt;= nMax; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            while (nN % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                printf("    %-lld\n", i);</span><br><span class="line">                nN /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nN &lt; <span class="number">6000000</span>  IsPrime(nN))</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nN != <span class="number">1</span>)</span><br><span class="line">            printf("    %-lld\n", nN);</span><br><span class="line">        printf("\n");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2480 Longge&#39;s problem</title>
      <link href="/2012/07/31/poj-2480-longges-problem/"/>
      <url>/2012/07/31/poj-2480-longges-problem/</url>
      
        <content type="html"><![CDATA[<p>题意就是给出个数n，求Σgcd(i,n)(1&lt;=i&lt;=n)。感觉好奇葩的题目，数论的题确实比较难想，没看出跟欧拉函数有什么关系。很纠结，没心情没时间继续想了。看了discussion，然后又去搜了下答案，发现有个哥们也得非常不错，就看了下思路了。<br>这个题的解法是枚举i(1&lt;=i&lt;=n)，如果i|n，那么答案加上euler(n/i) <em> i。其实ans = Σi </em> euler(n/i)(i&lt;=i&lt;=n而且i|n)。意思是从1到n的所有数字i，如果i是n的因子，那么计算 i <em> euler(n/i)，加入答案中，euler是欧拉函数的意思。<br>为什么是这样的了。比如，1到n中有m个数字和n拥有公共的最大因子i，那么就需要把m </em> i加入答案中。问题是如何计算m的个数。因为gcd(m,n) = i，可以得到gcd(m/i,n/i)=1，那么m/i就是n/i的乘法群中的数字了，那么一共存在euler(n/i)个m/i了，那么就可以推出m的个数就是euler(n/i)。</p><p>代码如下:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">6000000</span>)</span><br><span class="line">bool bPrime[MAX];</span><br><span class="line"></span><br><span class="line">void InitPrime()</span><br><span class="line">&#123;</span><br><span class="line">    int nMax = sqrt((double)MAX) + 1;</span><br><span class="line">    bPrime[0] = bPrime[1] = true;</span><br><span class="line">    for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 2 * i; j &lt; MAX; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                bPrime[j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsPrime(long long nN)</span><br><span class="line">&#123;</span><br><span class="line">    if (nN &lt; MAX)return !bPrime[nN];</span><br><span class="line">    long long nMax = sqrt((double)nN) + 1;</span><br><span class="line">    for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nN % i == 0)</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long Euler(long long nN)</span><br><span class="line">&#123;</span><br><span class="line">    long long nAns = 1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("nN:%I64d,", nN);</span></span><br><span class="line">    if (IsPrime(nN))nAns = nN - 1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        for (int i = 2; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nN % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                nAns *= i - 1;</span><br><span class="line">                nN /= i;</span><br><span class="line">                while (nN % i == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    nAns *= i;</span><br><span class="line">                    nN /= i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (IsPrime(nN))</span><br><span class="line">                &#123;</span><br><span class="line">                    nAns *= nN - 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("nAns:%I64d\n", nAns);</span></span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long nN;</span><br><span class="line"></span><br><span class="line">    InitPrime();</span><br><span class="line">    while (scanf(<span class="string">"%I64d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        long long nAns = 0;</span><br><span class="line">        long long nMax = sqrt((double)nN) + 1e-8;</span><br><span class="line">        for (long long i = 1; i &lt;= nMax; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nN % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("i:%I64d\n", i);</span></span><br><span class="line">                nAns += i * Euler(nN / i);</span><br><span class="line">                if (i * i != nN)</span><br><span class="line">                    nAns += (nN / i) * Euler(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%I64d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1284 Primitive Roots</title>
      <link href="/2012/07/25/poj-1284-primitive-roots/"/>
      <url>/2012/07/25/poj-1284-primitive-roots/</url>
      
        <content type="html"><![CDATA[<p>这个题是求原根的个数。所谓原根，意思是给定一个数n，存在数g，g^j能够产生乘法群Zn<em>中所有的数字。即g^j = {x|x与n互质,1&lt;=x&lt;n}。如果n是奇素数p(大于2的素数)，那么满足g^j={1,2,…,p-1}。<br>这个题目要求求原根的个数。由费马定理由,对任意1&lt;=x&lt;p，即Zp</em>中的数字，都由x^(p-1) = 1 % p。从费马定理可以看出，再往下计算就开始循环了。那么有,x^i%p(1&lt;=i&lt;p) = {1, 2, 3,…,p-1},意思是能够生成Zp<em>中的所有数字。<br>根据上面的那个式子可以得到，x^i%(p-1)(1&lt;=i&lt;p) = {0, 1, 2,…,p-2}。 如果由gcd(x,p-1) = 1,那么必然存在某个x^i，使得x^i</em>x = (p-1)%p。<br>因此可以得到，原根的个数是p-1的乘法群中元素的个数，也就是欧拉函数(p-1)。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">5000000</span>)</span><br><span class="line">bool bPrime[MAX];</span><br><span class="line">void InitPrime()</span><br><span class="line">&#123;</span><br><span class="line">    int nMax = sqrt((double)MAX) + 1;</span><br><span class="line">    bPrime[0] = bPrime[1] = true;</span><br><span class="line">    for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 2 * i; j &lt; MAX; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                bPrime[j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool IsPrime(int nN)</span><br><span class="line">&#123;</span><br><span class="line">    if (nN &lt; MAX)return !bPrime[nN];</span><br><span class="line">    int nMax = sqrt((double)nN) + 1;</span><br><span class="line">    for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nN % i == 0)</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    InitPrime();</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nN--;</span><br><span class="line">        int nAns = 1;</span><br><span class="line">        <span class="keyword">if</span> (IsPrime(nN))</span><br><span class="line">        &#123;</span><br><span class="line">            nAns = nN - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 2; i &lt;= nN; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                if (nN % i == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    nAns *= i - 1;</span><br><span class="line">                    nN /= i;</span><br><span class="line">                    while (nN % i == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nAns *= i;</span><br><span class="line">                        nN /= i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (IsPrime(nN))</span><br><span class="line">                    &#123;</span><br><span class="line">                        nAns *= nN - 1;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2417 Discrete Logging</title>
      <link href="/2012/07/22/poj-2417-discrete-logging/"/>
      <url>/2012/07/22/poj-2417-discrete-logging/</url>
      
        <content type="html"><![CDATA[<p>这是个求离散对数的问题。以前学密码学基础的时候也接触过，但是没想到acm里面还会有这样的习题。问题的意思是给定素数P，给出方程a^x = b % p，注意有模的方程等式2边都是取模数的意思。解这样的方程有一个固定的算法，叫做baby-step算法。但是，注意限定条件是p必须是素数。<br>下面的图描述了这个算法：<br><img alt data-src="https://c5.staticflickr.com/8/7132/27134956060_0a46748ab7_o.jpg"><br><img alt data-src="https://c1.staticflickr.com/8/7278/26802327624_ce592b5e96_o.jpg"><br>意思很清楚，就是假设x = i <em> m + j，那么方程可以转化为b</em>(a^-m)^i  = a^j % p。先计算出右边的值，存储在一张表里面，然后从小到大枚举左边的i（0&lt;=i&lt;m)，率先满足等式的就是最小的解x。<br>poj上面这个题用map存储(a^j,j)对的时候会超时，改成hash表存储才能过，额，毕竟理论复杂度不是一个数量级的。我的hash表是开了2个数组，一个键，一个值，用来相互验证，槽冲突的话，一直往后找位置。感觉这样的做法没有链式hash复杂度平均的样子。<br>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">1000000</span>)</span><br><span class="line">long long nData[MAX];</span><br><span class="line">long long nKey[MAX];</span><br><span class="line">long long egcd(long long <span class="selector-tag">a</span>, long long <span class="selector-tag">b</span>, long long x, long long y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">b</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    long long ret = egcd(b, a % b, x, y);</span><br><span class="line">    long long t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long GetPos(long long key)</span><br><span class="line">&#123;</span><br><span class="line">    return (key ^ 0xA5A5A5A5) % MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Add(long long key, long long data)</span><br><span class="line">&#123;</span><br><span class="line">    long long nPos = GetPos(key);</span><br><span class="line">    while (nData[nPos] != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nPos = (nPos + 1) % MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    nData[nPos] = data;</span><br><span class="line">    nKey[nPos] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Query(int key)</span><br><span class="line">&#123;</span><br><span class="line">    int nPos = GetPos(key);</span><br><span class="line"></span><br><span class="line">    while (nData[nPos] != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nKey[nPos] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            return nData[nPos];</span><br><span class="line">        &#125;</span><br><span class="line">        nPos = (nPos + 1) % MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long long BabyStep(long long nA, long long nB, long long nP)</span><br><span class="line">&#123;</span><br><span class="line">    long long nM = ceil(sqrt((double)(nP - 1)));</span><br><span class="line">    long long x, y;</span><br><span class="line">    egcd(nP, nA, x, y);//y是nA%p的乘法逆</span><br><span class="line">    y = (y + nP) % nP;</span><br><span class="line">    long long nTemp = 1;</span><br><span class="line">    long long c = 1;//c是nA的—m次</span><br><span class="line">    memset(nData, -1, sizeof(nData));</span><br><span class="line">    memset(nKey, -1, sizeof(nKey));</span><br><span class="line">    for (long long j = 0; j &lt; nM; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        Add(nTemp, j);</span><br><span class="line">        nTemp = (nTemp * nA) % nP;</span><br><span class="line">        c = (c * y) % nP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long long r = nB;</span><br><span class="line">    for (int i = 0; i &lt; nM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        long long j = Query(r);</span><br><span class="line">        <span class="keyword">if</span> (j != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return i * nM + j;</span><br><span class="line">        &#125;</span><br><span class="line">        r = (r * c) % nP;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long nP, nB, nN;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%I64d%I64d%I64d"</span>, &amp;nP, &amp;nB, &amp;nN) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        long long nAns = BabyStep(nB, nN, nP);</span><br><span class="line">        if (nAns == -1)printf("no solution\n");</span><br><span class="line">        else printf("%I64d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 408 - Uniform Generator</title>
      <link href="/2012/07/20/uva-408-uniform-generator/"/>
      <url>/2012/07/20/uva-408-uniform-generator/</url>
      
        <content type="html"><![CDATA[<p>这是今天想通的一个数论题，还是挺有意思的，想出来的那一瞬间yeah了一下，可是我悲剧的粗心习惯，还是交了3次才过，nm数中间空格都错了，又忘记打空行，明明字符串从25列开始，中间是4个空格的，我nc的打了5个空格，就pe了，还有不仔细看输出要求，没有输出空行，最近真没状态啊。<br>其实，这个题想通了就很简单了，还是数论里面的群的概念，就是加法群的生成群啊，打着随机数的幌子而已。由于又没有限定种子，限定对答案也没有影响，假设种子是0，那么数列可以表示为a <em> step，数列要能够生成0 - mod-1中所有的数字，那么就有a </em> step = b % mod(0&lt;=b&lt;mod)。<br>哈哈，上面那个式子就是a <em> x = b % n这个线性同余方程了，只是有很多b了。要方程有解，不是需要满足条件gcd(a,n) | b么，意思b是gcd(a,n)的整数倍了。但是0 &lt;= b &lt; n啊，b会是1了，那么gcd(a,n)一定是1了哦。那么直接判断gcd(step,mod)是否为1就行了，哈哈。<br>关于线性同余方程a</em>x=b%n，要有解的条件gcd(a,n)|b的解释，还是参看算法导论或者其它资料吧。。。</p><p>代码就非常简单了，如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int <span class="selector-tag">a</span>, int b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &lt; b)swap(a, b);</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        int t = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t % b;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nStep, nMod;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nStep, &amp;nMod) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%10d%10d    %s\n\n"</span>, nStep, nMod,</span><br><span class="line">               gcd(nStep, nMod) == 1 ? "Good Choice" : "Bad Choice");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2115 C Looooops 线性同余方程</title>
      <link href="/2012/07/18/poj%202115%20C%20Looooops%20%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/"/>
      <url>/2012/07/18/poj%202115%20C%20Looooops%20%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>这个题目就是解线性同余方程，(a + n<em>c) % 2的k次 = b % 2的k次。既然以前是学信安的，对数论本来就不排斥，最近还好好看了下算法导论。这个方程转换为n</em>c = (b-a) % 2的k次。根据数论的知识，  ax = b%n，需要保证gcd(a,n)|b，意思b是gcd(a,n)的倍数，这个一下子也很难解释清楚啊，不满足这个条件，就是没解了。还有，如果有解的话，解的个数就是d = gcd(a,n)。而且其中一个解是x0 = x’(b/ d)，其中x’是用扩展欧几里德算法求出来的，满足关系式a<em>x’+n</em>y’=d。<br>但是这个题不仅仅用到数论的这些知识，因为必须求满足条件的最小解，而如果有解的话是d个，而且满足解x = x0 + i(b/d)，（1&lt;=i&lt;=d)。既然要求最小的解，那么对解mod(n/d)即可了，因为它们之间的差都是n/d的倍数。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展欧几里德算法</span></span><br><span class="line"><span class="comment">//d = a * x + b * y，d是a和b的最大公约数</span></span><br><span class="line">long long egcd(long long <span class="selector-tag">a</span>, long long <span class="selector-tag">b</span>, long long x, long long y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">b</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">        y = 0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        long long nRet = egcd(b, a % b, x, y);</span><br><span class="line">        long long t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t - (a / b) * y;</span><br><span class="line">        return nRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long nA, nB, nC, nK;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%I64d%I64d%I64d%I64d"</span>, &amp;nA, &amp;nB, &amp;nC, &amp;nK),</span><br><span class="line">            nA || nB || nC || nK)</span><br><span class="line">    &#123;</span><br><span class="line">        long long x, y;</span><br><span class="line">        long long n = pow((double)2, (double)nK) + 1e-8;</span><br><span class="line">        long long d = egcd(n, nC, x, y);</span><br><span class="line">        long long b = (nB - nA + n) % n;</span><br><span class="line">        if (b % d)//如果d | b失败</span><br><span class="line">        &#123;</span><br><span class="line">            printf("FOREVER\n");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf("y:%I64d, b:%I64d, d:%I64d n:%I64d\n", y, b, d, n);</span></span><br><span class="line">            y = (y + n) % n;</span><br><span class="line">            long long ans = (y * (b / d)) % (n / d);</span><br><span class="line">            printf("%I64d\n", ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1401 Factorial</title>
      <link href="/2012/07/16/poj-1401-factorial/"/>
      <url>/2012/07/16/poj-1401-factorial/</url>
      
        <content type="html"><![CDATA[<p>这个题目是求N！后面有多少个0，注意N可能最大到10的9次。哈哈，直接枚举1-N有多少个2和5的因子，然后取小的值肯定会超时的。但是，我还是试了下，果断超时了。<br>那就只有想数学结论了，果断想到1-N中能被2整除的数字有N / 2。哈哈，再往后思考下，发现1-N中能被4整除的数字有N / 4个，再往后就是N / 8，一直到N 除以2的某个次方为0为止，那么把所有的值加起来就是2的因子的个数了。求5的因子的个数也是这样的方法了。<br>很明显，5的因子的个数一定会小于等于2的因子的个数。那么直接求5的因子的个数就行了。由于，N / 5的时候用到了向下取整，所以不能用等比数列求和公式，怎么把答案弄成一个公式，还不知道了。<br>PS：其实我这种思路的灵感来自于筛选素数的方法了。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int GetAns(int nN)</span><br><span class="line">&#123;</span><br><span class="line">    int nAns = 0;</span><br><span class="line">    while (nN)</span><br><span class="line">    &#123;</span><br><span class="line">        nAns += nN / 5;</span><br><span class="line">        nN /= 5;</span><br><span class="line">    &#125;</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        int nN;</span><br><span class="line">        scanf("%d", &amp;nN);</span><br><span class="line">        printf("%d\n", GetAns(nN));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>poj 2407 Relatives 欧拉函数</title>
      <link href="/2012/07/15/poj%202407%20Relatives%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
      <url>/2012/07/15/poj%202407%20Relatives%20%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>这个题一看就知道是求欧拉函数。欧拉函数描述的正式题意。欧拉函数的理解可以按照算法导论上面的说法，对0-N-1进行筛选素数。那么公式n∏(1-1/p)，其中p是n的素数因子，就可以得到直观的理解了。但是计算的时候，会将这个式子变形下，得到另外一个形式。<br>如图所示：<br><img alt data-src="https://c7.staticflickr.com/8/7391/27312399622_2da18641db_o.jpg"><br>但是这个题，需要考虑下，有可能n是个大素数，直接进行因子分解的话会超时的。怎么办了，只能在分解的时候判断n是不是已经成为素数了，如果是素数，答案再乘以n-1就行了。为了加快判断，我用5mb的空间搞了个素数表，大于5000000的数字只能循环判断了。</p><p>代码如下，注意求欧拉函数的代码部分：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">5000000</span>)</span><br><span class="line">bool bPrime[MAX];//false表示素数</span><br><span class="line"></span><br><span class="line">void InitPrime()</span><br><span class="line">&#123;</span><br><span class="line">    bPrime[0] = bPrime[1] = true;</span><br><span class="line">    int nMax = sqrt((double)MAX) + 1;</span><br><span class="line">    for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bPrime[i])</span><br><span class="line">            for (int j = i * 2; j &lt; MAX; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                bPrime[j] = true;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsPrime(int nN)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nN &lt; MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        return !bPrime[nN];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        int nMax = sqrt((double)nN) + 1;</span><br><span class="line">        for (int i = 2; i &lt;= nMax; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nN % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line"></span><br><span class="line">    InitPrime();</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nN == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("0\n");</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int nAns = 1;</span><br><span class="line">        for (int i = 2; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (IsPrime(nN))</span><br><span class="line">            &#123;</span><br><span class="line">                nAns *= nN - 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nN % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                nAns *= i - 1;</span><br><span class="line">                nN /= i;</span><br><span class="line">                while (nN % i == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    nAns *= i;</span><br><span class="line">                    nN /= i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1730 Perfect Pth Powers</title>
      <link href="/2012/07/13/poj-1730-perfect-pth-powers/"/>
      <url>/2012/07/13/poj-1730-perfect-pth-powers/</url>
      
        <content type="html"><![CDATA[<p>通过这道题确实体会到A掉数学题确实还是需要经验了，不能猜对哪个地方会丧失精度的话，会一直wa的。其实，这道题我只想出了一半。<br>题意是 a的p次方 = n，其中n是32位整数，a和p都是整数，求满足条件的最大p。好吧，虽然我是在学数论，但是看到这题，我还是想起了取对数。那么可以得到，p = ln(n) / ln(a)。既然要求最大的p，那么a最小即可了。那么直接从2开始枚举a不就可以了么。<br>可是直接枚举a的话肯定会超时的，因为a的范围太大了，比如n的是个大素数，a的范围就是2-n了，一定超时了。然后，我又想出另外一种方法，对n分解因子，p就是所有因子的指数的最大公约数。呵呵，第二种方法更加会无情的超时，由于int范围很大，实现搞个素数表也不可能。还是感觉时间不多了，就不多想了，然后搜了下，发现一句话，意识是枚举p。顿时觉得开朗起来，因为p最多是32。由前面可以得到ln(a) = ln(n) / p。那么只要从32到1枚举p，保证a是整数即可。<br>后面发现这样精度难于控制，各种原因反正过不了题，看网上的代码，改成计算指数的形式了。因为 a = n的(1/p)次，这个可以用pow函数算出来，如果a是整数，那么再计算pow(a,p)就会是n了。最难控制的是精度了，还有说n是负数的情况。不知道为什么直接处理负数答案一直不对，只好把负数变为正数，同时判断p不能是偶数。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double fN;//用double就不会溢出了,负数就可以直接转换为正数了</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%lf"</span>, &amp;fN), fN)</span><br><span class="line">    &#123;</span><br><span class="line">        bool bFlag = false;</span><br><span class="line">        double fP = 31.0;</span><br><span class="line">        <span class="keyword">if</span> (fN &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fP = 32.0;</span><br><span class="line">            fN = -fN;</span><br><span class="line">            bFlag = true;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        while (fP &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//必须加上一个精度,防止往下误差</span></span><br><span class="line">            double fA = pow(fN, 1.0 / fP) + 1e-8;</span><br><span class="line">            <span class="comment">//fA必须转换为int,因为一点点误差,pow之后就会放大很多</span></span><br><span class="line">            double fTemp = pow((int)fA, fP);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//必须对负数特殊判断,不可能出现偶数的p</span></span><br><span class="line">            if (fabs(fN - fTemp) &lt; 1e-8  (!bFlag || ((int)fP) % 2))</span><br><span class="line">            &#123;</span><br><span class="line">                printf("%.f\n", fP);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            fP -= 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu 3627 Giant For</title>
      <link href="/2012/07/11/hdu-3627-giant-for/"/>
      <url>/2012/07/11/hdu-3627-giant-for/</url>
      
        <content type="html"><![CDATA[<p>这个题是对可排序数据的实时增加删除查找，那天做比赛的时候一点都不会，想来想去觉得平衡树可以做，但是写平衡树是件很难的事情。<br>后面知道线段数可以做，虽然数据的范围很大，但是可以在全部读入数据后排序再离散化，然后进行线段树的操作，具体的代码没有写。<br>今天队友在网上发现一种用map和set可以水掉这题的方法。原来，这个方法最主要的使用了map和set里面的upper_bound操作，以前居然忘记了这个东西了。既然这样，map和set也可以查前驱和后继了，但是注意low_bound查到的是小于等于的键。这个代码，注意是用了一个map&lt; int, set &gt; 集合把坐标都存起来了，进行添加删除和查找后继的操作。由于查找需要查找的元素是既比x大又比y大的元素，就比较麻烦，需要循环x往后查找，但是这样就无情的超时了。然后，有一个优化，记录y的数目，那么当出现很大的y的时候，就不需要查找了，然后才过了这个题。但是，数据变成很大的y对应的x很小的话，那么绝对过不了这个题了，只能用线段树做了。<br>现在觉得用map和set查找前驱和后继确实能水掉一些题啊。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;map&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;set&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">map&lt; int, set&lt;int&gt; &gt; ms;//存储x,y</span><br><span class="line">map&lt; int, set&lt;int&gt; &gt;::iterator it;</span><br><span class="line">map&lt;int, int&gt; my;//存储y的数目</span><br><span class="line">set&lt;int&gt;::iterator msit;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    int nCase = 1;</span><br><span class="line">    char szCmd[10];</span><br><span class="line">    int nX, nY;</span><br><span class="line">    int nTemp;</span><br><span class="line"></span><br><span class="line">    while(scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nCase &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("\n");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf("Case %d:\n", nCase++);</span><br><span class="line">        ms.<span class="attribute">clear</span>();</span><br><span class="line">        my.<span class="attribute">clear</span>();</span><br><span class="line">        while (nN--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s", szCmd);</span><br><span class="line">            scanf("%d%d", &amp;nX, &amp;nY);</span><br><span class="line">            <span class="keyword">if</span> (szCmd[<span class="number">0</span>] == <span class="string">'a'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                if (my.find(nY) == my.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    my[nY] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    my[nY]++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (ms.find(nX) == ms.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    ms[nX].insert(nY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    msit = ms[nX].find(nY);</span><br><span class="line">                    if (msit == ms[nX].end())//会出现重复的数据</span><br><span class="line">                    &#123;</span><br><span class="line">                        ms[nX].insert(nY);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (szCmd[<span class="number">0</span>] == <span class="string">'r'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ms[nX].erase(nY);</span><br><span class="line">                <span class="keyword">if</span>(ms[nX].size() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ms.erase(nX);</span><br><span class="line">                &#125;</span><br><span class="line">                my[nY]--;</span><br><span class="line">                <span class="keyword">if</span> (my[nY] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    my.erase(nY);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (szCmd[<span class="number">0</span>] == <span class="string">'f'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                if (my.upper_bound(nY) == my.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    printf("-1\n");</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                while (true)</span><br><span class="line">                &#123;</span><br><span class="line">                    it = ms.upper_bound(nX);</span><br><span class="line">                    if (it == ms.end())//比nX大的不存在</span><br><span class="line">                    &#123;</span><br><span class="line">                        printf("-1\n");</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nTemp = it-&gt;first;</span><br><span class="line">                    msit = ms[nTemp].upper_bound(nY);</span><br><span class="line">                    if (msit == ms[nTemp].end())//比nY大的不存在</span><br><span class="line">                    &#123;</span><br><span class="line">                        nX = nTemp;</span><br><span class="line">                        continue;//那么增加x,继续往后查</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        printf("%d %d\n", nTemp, *msit);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>poj 2551 Ones and poj 2262 Goldbach&#39;s Conjecture</title>
      <link href="/2012/07/09/poj-2551-ones-and-poj-2262-goldbachs-conjecture/"/>
      <url>/2012/07/09/poj-2551-ones-and-poj-2262-goldbachs-conjecture/</url>
      
        <content type="html"><![CDATA[<p>第一个题用到了同余的性质，这是数论里面最基本的性质，但是做题时候不一定能够自己发现。题意是n <em> m = 11111…，给出n，用一个m乘以n得到的答案全是1组成的数字，问1最小的个数是多少。可以转换为n </em> m = (k <em> 10+1)，那么可以得到(k </em> 10+1)%n==0。<br>当然最开始的k是1，那么我们不断的增长k = （10 * k + 1）。看增长多少次，就是有多少个1了。因为要避免溢出，所以需要不断%n。因为同余的性质，所以可以保证%n之后答案不变。<br>第二个用到素数筛选法。素数筛选法的原理是筛去素数的倍数，由于是从小循环到大的，所以当前的值没被筛掉的话，则一定是素数，这个判断导致复杂度不是n的平方。</p><p>poj 2551 代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nCnt = 1;</span><br><span class="line">        int nTemp = 1;</span><br><span class="line">        while (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nTemp % nN == 0)break;</span><br><span class="line">            else nTemp = (nTemp * 10 + 1) % nN;</span><br><span class="line">            ++nCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nCnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>poj 2262 代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">1000000</span> + <span class="number">10</span>)</span><br><span class="line">bool bPrime[MAX];</span><br><span class="line">void InitPrime()</span><br><span class="line">&#123;</span><br><span class="line">    memset(bPrime, true, sizeof(bPrime));</span><br><span class="line">    bPrime[0] = bPrime[1] = false;</span><br><span class="line">    for (int i = 2; i &lt;= MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bPrime[i])</span><br><span class="line">            for (int j = 2 * i; j &lt;= MAX; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                bPrime[j] = false;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line"></span><br><span class="line">    InitPrime();</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        int i;</span><br><span class="line">        for (i = 2; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i % 2 &amp;&amp; (nN - i) % 2 &amp;&amp; bPrime[i] &amp;&amp; bPrime[nN - i])</span><br><span class="line">            &#123;</span><br><span class="line">                printf("%d = %d + %d\n", nN, i, nN - i);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="selector-tag">i</span> == nN)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("Goldbach's conjecture is wrong.\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2187 Beauty Contest</title>
      <link href="/2012/07/07/poj-2187-beauty-contest/"/>
      <url>/2012/07/07/poj-2187-beauty-contest/</url>
      
        <content type="html"><![CDATA[<p>这个题我是按照discussion里面的说法，先求凸包，然后枚举过的。因为开始先把求凸包算法里面的用到了数组名搞混了，无故wa了好多次。后面求凸包换了种算法过了。结果发现bug是搞混了数组名，然后把前面wa掉的代码下载下来，改好之后也都过了。<br>这个题主要是凸包算法需要处理有重复点，有多点共线之类的情况。那个按极角排序后，再求凸包的算法，对共点共线处理的不是很好，不过那个算法也过了这个题。有个直接按坐标排序后，再求上凸包和下凸包的算法，可以处理共点共线的情况。这个算法比较优美啊，既不需要找y坐标最小的点，也不需要按极角排序，直接按坐标排序下，然后求凸包即可。<br>这个算法的一点解释：<a href="http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull" target="_blank" rel="noopener">http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull</a><br>另外，演算法笔记：<a href="http://www.csie.ntnu.edu.tw/~u91029/ConvexHull.html#a3" target="_blank" rel="noopener">http://www.csie.ntnu.edu.tw/~u91029/ConvexHull.html#a3</a>上也有提到这个算法，我也是从这上面看到的。<br>这个算法可以假设是Graham排序基准点在无限远处，于是夹角大小的比较可以直接按水平坐标比较。</p><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    bool operator&lt;(const Point p) const</span><br><span class="line">    &#123;</span><br><span class="line">        return x &lt; p.x || x == p.x  y &lt; p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Point pts[50100];</span><br><span class="line">Point pcs[50100];</span><br><span class="line">int nN;</span><br><span class="line">int nM;</span><br><span class="line">inline int SDis(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Convex()</span><br><span class="line">&#123;</span><br><span class="line">    sort(pts, pts + nN);</span><br><span class="line"></span><br><span class="line">    nM = 0;</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while(nM &gt;= <span class="number">2</span>  Cross(pcs[nM - <span class="number">2</span>], pcs[nM - <span class="number">1</span>], pts[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nM--;</span><br><span class="line">        &#125;</span><br><span class="line">        pcs[nM++] = pts[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i= nN - 2, t = nM + 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        while (nM &gt;= t  Cross(pcs[nM - <span class="number">2</span>], pcs[nM - <span class="number">1</span>], pts[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nM--;</span><br><span class="line">        &#125;</span><br><span class="line">        pcs[nM++] = pts[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nM--;//起点会被重复包含</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d", pts[i].x, pts[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        Convex();</span><br><span class="line">        int nMax = -1;</span><br><span class="line">        for (int i = 0; i &lt; nM; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; nM; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                nMax = max(nMax, SDis(pcs[i], pcs[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用旋转卡壳算法来求最远点对，此题的完整代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    bool operator &lt; (const Point p)const</span><br><span class="line">    &#123;</span><br><span class="line">        return x &lt; p.x || x == p.x  y &lt; p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入点集合,输出凸包</span></span><br><span class="line">void Convex(vector&lt;Point&gt; <span class="keyword">in</span>, vector&lt;Point&gt; out)</span><br><span class="line">&#123;</span><br><span class="line">    int nN = in.size();</span><br><span class="line">    int nM = 0;</span><br><span class="line"></span><br><span class="line">    sort(in.begin(), in.end());</span><br><span class="line">    out.<span class="attribute">resize</span>(nN);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while (nM &gt;= <span class="number">2</span>  Cross(out[nM - <span class="number">2</span>], out[nM - <span class="number">1</span>], <span class="keyword">in</span>[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nM--;</span><br><span class="line">        &#125;</span><br><span class="line">        out[nM++] = in[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = nN - 2, t = nM + 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        while (nM &gt;= t  Cross(out[nM - <span class="number">2</span>], out[nM - <span class="number">1</span>], <span class="keyword">in</span>[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nM--;</span><br><span class="line">        &#125;</span><br><span class="line">        out[nM++] = in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    out.<span class="attribute">resize</span>(nM);</span><br><span class="line">    out.pop_back();//起始点重复</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SDis(Point <span class="selector-tag">a</span>,Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int RC(vector&lt;Point&gt; vp)</span><br><span class="line">&#123;</span><br><span class="line">    int nP = 1;</span><br><span class="line">    int nN = vp.size();</span><br><span class="line">    vp.push_back(vp[0]);</span><br><span class="line">    int nAns = 0;</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while (Cross(vp[i], vp[<span class="selector-tag">i</span> + <span class="number">1</span>], vp[nP + <span class="number">1</span>]) &gt; Cross(vp[i], vp[<span class="selector-tag">i</span> + <span class="number">1</span>], vp[nP]))</span><br><span class="line">        &#123;</span><br><span class="line">            nP = (nP + 1) % nN;</span><br><span class="line">        &#125;</span><br><span class="line">        nAns = max(nAns, max(SDis(vp[i], vp[nP]), SDis(vp[i + 1], vp[nP + 1])));</span><br><span class="line">    &#125;</span><br><span class="line">    vp.pop_back();</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    vector&lt;Point&gt; in, out;</span><br><span class="line">    Point p;</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        in.clear(), out.clear();</span><br><span class="line">        while (nN--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d", p.x, p.y);</span><br><span class="line">            in.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        Convex(in, out);</span><br><span class="line"></span><br><span class="line">        printf("%d\n", RC(out));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于旋转卡壳的算法描述，网上有很多资料，比如，<a href="http://www.cppblog.com/staryjy/archive/2010/09/25/101412.html尤其关于这个求最远点对的。" target="_blank" rel="noopener">http://www.cppblog.com/staryjy/archive/2010/09/25/101412.html尤其关于这个求最远点对的。</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3525 Most Distant Point from the Sea</title>
      <link href="/2012/07/05/poj-3525-most-distant-point-from-the-sea/"/>
      <url>/2012/07/05/poj-3525-most-distant-point-from-the-sea/</url>
      
        <content type="html"><![CDATA[<p>这个题的题意是给定一个凸多边形表示的海岛，求海岛离大海最远的距离。可以转化为一个凸多边形内部最多能够放入一个多大的圆。<br>显然可以对圆的半径进行二分，但是怎么确定圆心了。确定是否存在圆心，可以把原来的凸多边形往内部移动r（圆的半径）的距离之后，再对新的多边形求半平面交，如果半平面交存在（是个点即可），那么当前大小的圆能够放入。<br>求半平面交的算法可以用上一篇中的 N * N 复杂度的基本算法。<br>本题还涉及到一个知识，就是如何把一条直线往逆时针方向或者顺时针方向移动R的距离。其实，可以根据单位圆那种思路计算。因为相当于以原来直线上的一点为圆心，以r为半径做圆，而且与原来的直线成90的夹角，那么后来点的坐标是（(x0 + cos(PI / 2 +θ ))，（y0 + sin(PI / 2 + θ))），转化一下就是(x0 - sinθ，y0 + cosθ)。那么直接可以求出dx = (vp[i].y - vp[(i + 1) % nN].y) *  fR / fDis，dy = (vp[(i + 1) % nN].x - vp[i].x) *  fR / fDis，fDis是线段的长度。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double fPre = 1e-8;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x,y;</span><br><span class="line">    Point()&#123;&#125;</span><br><span class="line">    Point(const Point p)&#123;x = p.x, y = p.y;&#125;</span><br><span class="line">    Point(double fX, double fY):x(fX), y(fY)&#123;&#125;</span><br><span class="line">    Point operator+(const Point p)</span><br><span class="line">    &#123;</span><br><span class="line">        x += p.x;</span><br><span class="line">        y += p.y;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    Point operator+=(const Point p)</span><br><span class="line">    &#123;</span><br><span class="line">        return *this = *this + p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point operator-(const Point p)</span><br><span class="line">    &#123;</span><br><span class="line">        x -= p.x;</span><br><span class="line">        y -= p.y;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    Point operator*(double fD)</span><br><span class="line">    &#123;</span><br><span class="line">        x *= fD;</span><br><span class="line">        y *= fD;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef vector&lt;Point&gt; Polygon;</span><br><span class="line">int DblCmp(double fD)</span><br><span class="line">&#123;</span><br><span class="line">    return fabs(fD) &lt; fPre ? 0 : (fD &gt; 0 ? 1 : -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point Intersection(Point a1, Point a2, Point b1, Point b2)</span><br><span class="line">&#123;</span><br><span class="line">    Point a = a2 - a1;</span><br><span class="line">    Point b = b2 - b1;</span><br><span class="line">    Point s = b1 - a1;</span><br><span class="line">    return a1 + a * (Cross(b, s) / Cross(b, a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polygon Cut(Polygon pg, Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    Polygon pgRet;</span><br><span class="line">    int nN = pg.size();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        double fC = Cross(a, b, pg[i]);</span><br><span class="line">        double fD = Cross(a, b, pg[(i + 1) % nN]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DblCmp(fC) &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pgRet.push_back(pg[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (DblCmp(fC * fD) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pgRet.push_back(Intersection(a, b, pg[i], pg[(i + 1) % nN]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("pgRet number:%d\n", pgRet.size());</span></span><br><span class="line">    return pgRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Dis(Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回半平面的顶点个数</span></span><br><span class="line">int HalfPlane(Polygon vp, double fR)</span><br><span class="line">&#123;</span><br><span class="line">    Polygon pg;</span><br><span class="line">    pg.push_back(Point(-1e9, -1e9));</span><br><span class="line">    pg.push_back(Point(1e9, -1e9));</span><br><span class="line">    pg.push_back(Point(1e9, 1e9));</span><br><span class="line">    pg.push_back(Point(-1e9, 1e9));</span><br><span class="line">    int nN = vp.size();</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        double fDis = Dis(vp[i], vp[(i + 1) % nN]);</span><br><span class="line">        double dx = (vp[i].y - vp[(i + 1) % nN].y) * fR / fDis;</span><br><span class="line">        double dy = (vp[(i + 1) % nN].x - vp[i].x) * fR / fDis;</span><br><span class="line">        Point a = vp[i], b = vp[(i + 1) % nN], c(dx, dy);</span><br><span class="line">        a += c;</span><br><span class="line">        b += c;</span><br><span class="line">        <span class="comment">//printf("%f %f %f %f\n", a.x, a.y, b.x, b.y);</span></span><br><span class="line">        pg = Cut(pg, a, b);</span><br><span class="line">        <span class="keyword">if</span> (pg.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pg.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    vector&lt;Point&gt; vp;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        vp.<span class="attribute">clear</span>();</span><br><span class="line">        Point p;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;p.x, &amp;p.y);</span><br><span class="line">            vp.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        double fMin = 0.0, fMax = 10000.0;</span><br><span class="line">        while (DblCmp(fMin - fMax))</span><br><span class="line">        &#123;</span><br><span class="line">            double fMid = (fMin + fMax) / 2;</span><br><span class="line">            int nRet = HalfPlane(vp, fMid);</span><br><span class="line">            <span class="comment">//printf("fMid:%f, nRet:%d\n", fMid, nRet);</span></span><br><span class="line">            <span class="keyword">if</span> (nRet == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fMax = fMid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fMin = fMid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%.6f\n", fMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3130 How I Mathematician Wonder What You Are!</title>
      <link href="/2012/07/03/poj-3130-how-i-mathematician-wonder-what-you-are/"/>
      <url>/2012/07/03/poj-3130-how-i-mathematician-wonder-what-you-are/</url>
      
        <content type="html"><![CDATA[<p>半平面交的一个题，也是求多边形的核心。求出这个好像也可以用于解决一些线性规划问题。我用的是N * N的基本算法，每加入一条直线，就对原来求出的半平面交进行处理，产生新的核心。<br>代码参照台湾的一个网站演算法笔记上的内容和代码。表示这个网站巨不错，求凸包的算法也参照了这个网站上的内容和代码。半平面交的地址：<a href="http://www.csie.ntnu.edu.tw/~u91029/Half-planeIntersection.html#a4" target="_blank" rel="noopener">http://www.csie.ntnu.edu.tw/~u91029/Half-planeIntersection.html#a4</a></p><p>代码思路主要是：先读入所有的多边形顶点，放入一个vector（vp）里面，然后对多边形的每条边求一个半平面。刚开始的时候，用一个vector（Polygon）保存代表上下左右四个无限远角的四个点，表示原始的半平面。然后，用读入的多边形的每条边去切割原来的半平面。<br>切割的过程是，如果原来（Polygon）中的点在当前直线的指定一侧，那么原来的点还是有效的。如果原来的点和它相邻的下一个点与当前直线相交，那么还需要把交点加入Polygon集合。<br>还有求交点的方法比较奇葩，类似于黑书上面的那种根据面积等分的方法。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double fPre = 1e-8;</span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x;</span><br><span class="line">    double y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(double fX, double fY)</span><br><span class="line">    &#123;</span><br><span class="line">        x = fX, y = fY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef vector&lt;Point&gt; Polygon;</span><br><span class="line">typedef pair&lt;Point, Point&gt; Line;</span><br><span class="line">Point operator+(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    Point t;</span><br><span class="line">    t.x = a.x + b.x;</span><br><span class="line">    t.y = a.y + b.y;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point operator-(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    Point t;</span><br><span class="line">    t.x = a.x - b.x;</span><br><span class="line">    t.y = a.y - b.y;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point operator*(Point <span class="selector-tag">a</span>, double fD)</span><br><span class="line">&#123;</span><br><span class="line">    Point t;</span><br><span class="line">    t.x = a.x * fD;</span><br><span class="line">    t.y = a.y * fD;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DblCmp(double fD)</span><br><span class="line">&#123;</span><br><span class="line">    return fabs(fD) &lt; fPre ? 0 : (fD &gt; 0 ? 1 : -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3点叉积</span></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向量叉积</span></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求直线交点的一种简便方法</span></span><br><span class="line"><span class="comment">//平行四边形面积的比例等于高的比例</span></span><br><span class="line">Point Intersection(Point a1, Point a2, Point b1, Point b2)</span><br><span class="line">&#123;</span><br><span class="line">    Point a = a2 - a1;</span><br><span class="line">    Point b = b2 - b1;</span><br><span class="line">    Point s = b1 - a1;</span><br><span class="line"></span><br><span class="line">    return a1 + a * (Cross(b, s) / Cross(b, a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Polygon HalfPlane(Polygon pg, Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    Polygon pgTmp;</span><br><span class="line">    int nN = pg.size();</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        double fC = Cross(a, b, pg[i]);</span><br><span class="line">        double fD = Cross(a, b, pg[(i + 1) % nN]);</span><br><span class="line">        <span class="keyword">if</span> (DblCmp(fC) &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pgTmp.push_back(pg[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (fC * fD &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            pgTmp.push_back(Intersection(a, b, pg[i], pg[(i + 1) % nN]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pgTmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    Point p;</span><br><span class="line">    vector&lt;Point&gt; vp;</span><br><span class="line">    Polygon pg;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        vp.<span class="attribute">clear</span>();</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;p.x, &amp;p.y);</span><br><span class="line">            vp.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">        pg.<span class="attribute">clear</span>();</span><br><span class="line">        pg.push_back(Point(-1e9, 1e9));</span><br><span class="line">        pg.push_back(Point(-1e9, -1e9));</span><br><span class="line">        pg.push_back(Point(1e9, -1e9));</span><br><span class="line">        pg.push_back(Point(1e9, 1e9));</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pg = HalfPlane(pg, vp[i], vp[(i + 1) % nN]);</span><br><span class="line">            <span class="keyword">if</span> (pg.size() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                printf("0\n");</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pg.size())</span><br><span class="line">        &#123;</span><br><span class="line">            printf("1\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>poj 1584 A Round Peg in a Ground Hole</title>
      <link href="/2012/06/30/poj-1584-a-round-peg-in-a-ground-hole/"/>
      <url>/2012/06/30/poj-1584-a-round-peg-in-a-ground-hole/</url>
      
        <content type="html"><![CDATA[<p>这个题需要多个计算几何算法。第一个是判断一系列点是否能够构成凸多边形，第二个是判断一个点是否在一个简单多边形内部，第三个是求一个点到一条线段（或者说直线）的距离，第四个是判断一个圆是否则一个凸多边形内部。<br>其实，我是要判断一个圆是否则一个凸多边形内部而用到算法二和三。其实，有不需要判断圆心是否则多边形内部的算法。算法一的思想，求所有边的偏转方向，必须都是逆时针或者顺时针偏转。算法二则是我前面发的那篇改进弧长法判断点和多边形的关系，算法三尤其简单，直线上面取2点，用叉积求出这三点构成的三角形面积的2倍，再除以底边。算法四则是先判断圆心在多边形内部，然后判断圆心到所有边的距离要大于圆的半径。<br>贴出代码，纯粹为了以后作为模版使用等，防止遗忘，方便查找，其实现在也能手敲出来了。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const double fPre = 1e-8;</span><br><span class="line">int DblCmp(double fD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fabs(fD) &lt; fPre)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return fD &gt; 0 ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x, y;</span><br><span class="line">    bool operator == (const Point p)</span><br><span class="line">    &#123;</span><br><span class="line">        return DblCmp(x - p.x) == 0  DblCmp(y - p.y) == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point operator-(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    Point p;</span><br><span class="line">    p.x = a.x - b.x;</span><br><span class="line">    p.y = a.y - b.y;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsConvexPolygon(vector&lt;Point&gt; vp)</span><br><span class="line">&#123;</span><br><span class="line">    int nN = vp.size();</span><br><span class="line">    int nDirection = 0;</span><br><span class="line">    bool bLine = true;//避免所有点共线</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int nTemp = DblCmp(Cross(vp[i], vp[(i + 1) % nN], vp[(i + 2) % nN]));</span><br><span class="line">        <span class="keyword">if</span> (nTemp)</span><br><span class="line">        &#123;</span><br><span class="line">            bLine = false;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这次的方向和上次的方向必须是相同的或者是3点和3点以上共线的情况</span></span><br><span class="line">        if (nDirection * nTemp &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        nDirection = nTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    return bLine == false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetQuadrant(Point p)</span><br><span class="line">&#123;</span><br><span class="line">    return p.x &gt;= 0 ? (p.y &gt;= 0 ? 0 : 3) : (p.y &gt;= 0 ? 1 : 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsPtInPolygon(vector&lt;Point&gt; vp, Point p)</span><br><span class="line">&#123;</span><br><span class="line">    int nN = vp.size();</span><br><span class="line">    int nA1, nA2, nSum = 0;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    nA1 = GetQuadrant(vp[0] - p);</span><br><span class="line">    for (i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int j = (i + 1) % nN;</span><br><span class="line">        <span class="keyword">if</span> (vp[i] == p)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        int nC = DblCmp(Cross(p, vp[i], vp[j]));</span><br><span class="line">        int nT1 = DblCmp((vp[i].x - p.x) * (vp[j].x - p.x));</span><br><span class="line">        int nT2 = DblCmp((vp[i].y - p.y) * (vp[j].y - p.y));</span><br><span class="line">        <span class="keyword">if</span> (!nC  nT1 &lt;= <span class="number">0</span>  nT2 &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        nA2 = GetQuadrant(vp[j] - p);</span><br><span class="line">        switch ((nA2 - nA1 + 4) % 4)</span><br><span class="line">        &#123;</span><br><span class="line">        case <span class="number">1</span>:</span><br><span class="line">            nSum++;</span><br><span class="line">            break;</span><br><span class="line">        case <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (nC &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nSum += 2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nSum -= 2;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case <span class="number">3</span>:</span><br><span class="line">            nSum--;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        nA1 = nA2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (i &lt; nN || nSum)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double PtDis(Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((a.x - b.x) * (a.x - b.x) + (b.y - a.y) * (b.y - a.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//点p到直线ab的距离</span></span><br><span class="line"><span class="comment">//h = (2 * Spab) / |ab|</span></span><br><span class="line">double GetDis(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point p)</span><br><span class="line">&#123;</span><br><span class="line">    return fabs(Cross(a, b, p)) / PtDis(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsCircleInPolygon(vector&lt;Point&gt; vp, Point <span class="selector-tag">p</span>, double fR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsPtInPolygon(vp, p))</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nN = vp.size();</span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (GetDis(vp[i], vp[(i + 1) % nN], p) &lt; fR)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    double fR, fPx, fPy;</span><br><span class="line">    vector&lt;Point&gt; vp;</span><br><span class="line">    Point p;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%lf%lf%lf"</span>, &amp;nN, &amp;fR, &amp;fPx, &amp;fPy), nN &gt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vp.<span class="attribute">clear</span>();</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;p.x, &amp;p.y);</span><br><span class="line">            vp.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsConvexPolygon(vp))</span><br><span class="line">        &#123;</span><br><span class="line">            p.x = fPx;</span><br><span class="line">            p.y = fPy;</span><br><span class="line">            <span class="keyword">if</span> (IsCircleInPolygon(vp, <span class="selector-tag">p</span>, fR))</span><br><span class="line">            &#123;</span><br><span class="line">                printf("PEG WILL FIT\n");</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                printf("PEG WILL NOT FIT\n");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("HOLE IS ILL-FORMED\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>poj 1265 Area</title>
      <link href="/2012/06/28/poj-1265-area/"/>
      <url>/2012/06/28/poj-1265-area/</url>
      
        <content type="html"><![CDATA[<p>此题用到了几个知识，一个是求多边形面积的公式。然后是，根据顶点都在整点上求多边形边界上的顶点数目的方法。最后一个是pick定理。根据前面2个信息和pick定理算出在多边形内部的整点的个数。<br>求多边形面积的方法还是叉积代表有向面积的原理，把原点看做另外的一个点去分割原来的多边形为N个三角形，然后把它们的有向面积加起来。<br>判断边界上点的个数是根据Gcd（dx,dy)代表当前边上整数点的个数的结论。这个结论的证明其实也比较简单，假设dx = a，dy = b。初始点是x0，y0，假设d = Gcd（a，b）。那么边上的点可以被表示为（x0 + k <em> (a / d)，y0 + k </em> （b / d))。为了使点是整数点，k必须是整数，而且0 求多边形内部点的个数用的是pick定理。面积 = 内部点 + 边界点 / 2 - 1。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">100</span> + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point pts[MAX];</span><br><span class="line"></span><br><span class="line">int nN;</span><br><span class="line">const int IN = 1;</span><br><span class="line">const int EAGE = 2;</span><br><span class="line">const int OUT = 3;</span><br><span class="line">const double fPre = 1e-8;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double GetArea()</span><br><span class="line">&#123;</span><br><span class="line">    double fArea = 0.0;</span><br><span class="line">    Point ori = &#123;0.0, 0.0&#125;;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fArea += Cross(ori, pts[i], pts[(i + 1) % nN]);</span><br><span class="line">    &#125;</span><br><span class="line">    return fabs(fArea) * 0.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int gcd(int nX, int nY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nX &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nX = -nX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nY &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nY = -nY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nX &lt; nY)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(nX, nY);</span><br><span class="line">    &#125;</span><br><span class="line">    while (nY)</span><br><span class="line">    &#123;</span><br><span class="line">        int nT = nY;</span><br><span class="line">        nY = nX % nY;</span><br><span class="line">        nX = nT;</span><br><span class="line">    &#125;</span><br><span class="line">    return nX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line">    int nI, nE;</span><br><span class="line">    double fArea;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nT);</span><br><span class="line">    int dx ,dy;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= nT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d", &amp;nN);</span><br><span class="line">        nI = nE = 0;</span><br><span class="line">        pts[0].x = pts[0].y = 0;</span><br><span class="line">        for (int j = 1; j &lt;= nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d", &amp;dx, &amp;dy);</span><br><span class="line">            pts[j].x = pts[j - 1].x + dx;</span><br><span class="line">            pts[j].y = pts[j - 1].y + dy;</span><br><span class="line">            nE += gcd(dx, dy);</span><br><span class="line">        &#125;</span><br><span class="line">        fArea = GetArea();</span><br><span class="line">        nI = (fArea + 1) - nE / 2;</span><br><span class="line">        printf("Scenario #%d:\n%d %d %.1f\n\n", i, nI, nE, fArea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zoj 1081 Points Within - 改进弧长法判断点和简单多边形的关系</title>
      <link href="/2012/06/26/zoj%201081%20Points%20Within%20-%20%E6%94%B9%E8%BF%9B%E5%BC%A7%E9%95%BF%E6%B3%95%E5%88%A4%E6%96%AD%E7%82%B9%E5%92%8C%E7%AE%80%E5%8D%95%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2012/06/26/zoj%201081%20Points%20Within%20-%20%E6%94%B9%E8%BF%9B%E5%BC%A7%E9%95%BF%E6%B3%95%E5%88%A4%E6%96%AD%E7%82%B9%E5%92%8C%E7%AE%80%E5%8D%95%E5%A4%9A%E8%BE%B9%E5%BD%A2%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>转角法判断点和多边形的关系大家都知道，原理比较简单，在多边形内扫过的转角一定是360度，在边界上和外面则不一定。<br>实现起来也比较麻烦，浮点误差比较大，而且还要考虑些特殊情况。<br>在网上找到一种叫做改进弧长法的算法，原理和转角法类似，但是做了很多重要的改进。比如，计算转角改成了计算叉积，根据叉积决定旋转方向，还要根据计算下一个点的象限决定偏转多少，每次偏转的都是90度的倍数。该算法可以方便判断出点在多边形内，还是边界上，还是在多边形外面。</p><p>摘自别人对该算法的描述如下：<br>首先从该书中摘抄一段弧长法的介绍：“弧长法要求多边形是有向多边形，一般规定沿多边形的正向，边的左侧为多边形的内侧域。以被测点为圆心作单位圆，将全部有向边向单位圆作径向投影，并计算其中单位圆上弧长的代数和。若代数和为0，则点在多边形外部；若代数和为2π则点在多边形内部；若代数和为π，则点在多边形上。”<br>按书上的这个介绍，其实弧长法就是转角法。但它的改进方法比较厉害：将坐标原点平移到被测点P，这个新坐标系将平面划分为4个象限，对每个多边形顶点P ，只考虑其所在的象限，然后按邻接顺序访问多边形的各个顶点P，分析P和P[i+1]，有下列三种情况：<br>（1）P[i+1]在P的下一象限。此时弧长和加π/2；<br>（2）P[i+1]在P的上一象限。此时弧长和减π/2；<br>（3）P[i+1]在Pi的相对象限。首先计算f=y[i+1]<em>x-x[i+1]</em>y（叉积），若f=0，则点在多边形上；若f<0，弧长和减π；若f>0，弧长和加π。<br>最后对算出的代数和和上述的情况一样判断即可。实现的时候还有两点要注意，第一个是若P的某个坐标为0时，一律当正号处理；第二点是若被测点和多边形的顶点重合时要特殊处理。</0，弧长和减π；若f></p><p>以上就是书上讲解的内容，其实还存在一个问题。那就是当多边形的某条边在坐标轴上而且两个顶点分别在原点的两侧时会出错。如边(3,0)-(-3,0)，按以上的处理，象限分别是第一和第二，这样会使代数和加π/2，有可能导致最后结果是被测点在多边形外。而实际上被测点是在多边形上（该边穿过该点）。对于这点，我的处理办法是：每次算P和P[i+1]时，就计算叉积和点积，判断该点是否在该边上，是则判断结束，否则继续上述过程。这样牺牲了时间，但保证了正确性。<br>具体实现的时候，由于只需知道当前点和上一点的象限位置，所以附加空间只需O(1)。实现的时候可以把上述的“π/2”改成1，“π”改成2，这样便可以完全使用整数进行计算。不必考虑顶点的顺序，逆时针和顺时针都可以处理，只是最后的代数和符号不同而已。整个算法编写起来非常容易。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">100</span> + <span class="number">10</span>)</span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point pts[MAX];</span><br><span class="line">const int OUT = 0;</span><br><span class="line">const int IN = 1;</span><br><span class="line">const int EDGE = 2;</span><br><span class="line">const double fPre = 1e-8;</span><br><span class="line"></span><br><span class="line">int DblCmp(double fD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fabs(fD) &lt; fPre)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return fD &gt; 0 ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetQuadrant(Point p)</span><br><span class="line">&#123;</span><br><span class="line">    return DblCmp(p.x) &gt;= 0 ? (DblCmp(p.y) &gt;= 0 ? 0 : 3) :</span><br><span class="line">               (DblCmp(p.y) &gt;= 0 ? 1 : 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int PtInPolygon(Point* pts, int nN, Point p)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    for (j = 0; j &lt; nN; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        pts[j].x -= p.x;</span><br><span class="line">        pts[j].y -= p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    int nA1, nA2;</span><br><span class="line">    int nSum = 0;</span><br><span class="line">    nA1 = GetQuadrant(pts[0]);</span><br><span class="line">    for (i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        k = (i + 1) % nN;</span><br><span class="line">        <span class="keyword">if</span> (DblCmp(pts[k].x) == <span class="number">0</span>  DblCmp(pts[k].y) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            break;//与顶点重合</span><br><span class="line">        &#125;</span><br><span class="line">        int nC = DblCmp(Det(pts[i]<span class="selector-class">.x</span>, pts[i]<span class="selector-class">.y</span>,</span><br><span class="line">                            pts[k].x, pts[k].y));</span><br><span class="line">        if (!nC  DblCmp(pts[i].x * pts[k].x) &lt;= 0</span><br><span class="line">                 DblCmp(pts[i].y * pts[k].y) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;//边上</span><br><span class="line">        &#125;</span><br><span class="line">        nA2 = GetQuadrant(pts[k]);</span><br><span class="line">        if ((nA1 + 1) % 4 == nA2)</span><br><span class="line">        &#123;</span><br><span class="line">            nSum += 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((nA1 + 2) % 4 == nA2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nC &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nSum += 2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nSum -= 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((nA1 + 3) % 4 == nA2)</span><br><span class="line">        &#123;</span><br><span class="line">            nSum -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        nA1 = nA2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (j = 0; j &lt; nN; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        pts[j].x += p.x;</span><br><span class="line">        pts[j].y += p.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">i</span> &lt; nN)</span><br><span class="line">    &#123;</span><br><span class="line">        return EDGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nSum)<span class="comment">//逆时针nSum == 4, 顺时针nSum == -4</span></span><br><span class="line">    &#123;</span><br><span class="line">        return IN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return OUT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN, nM;</span><br><span class="line">    int nCase = 1;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nM), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nCase &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("\n");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;pts[i].x, &amp;pts[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("Problem %d:\n", nCase++);</span><br><span class="line">        for (int i = 0; i &lt; nM; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Point p;</span><br><span class="line">            scanf("%lf%lf", p.x, p.y);</span><br><span class="line">            <span class="keyword">if</span> (PtInPolygon(pts, nN, p))</span><br><span class="line">            &#123;</span><br><span class="line">                printf("Within\n");</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                printf("Outside\n");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>poj 3348 Cows</title>
      <link href="/2012/06/24/poj-3348-cows/"/>
      <url>/2012/06/24/poj-3348-cows/</url>
      
        <content type="html"><![CDATA[<p>这个题用到2个计算几何算法。求解凸包和简单多边形面积。凸包算法详细解释见算法导论。求解多边形面积的思想是将多边形分解为三角形，一般是假设按顺序取多边形上面连续的2点与原点组合成一个三角形，依次下去用叉积求有向面积之和，最后取绝对值即可。注意，这些点必须是在多边形上逆时针或者顺时针给出的，而求出凸包刚好给了这样的一系列点。<br>凸包代码，其实先找出一个y坐标最小的点，再对剩下的所有点按极角排序。然后对排序后的点进行一个二维循环即可。二维循环的解释是当加入新的点进入凸包集合时候，如果与以前加入的点形成的偏转方向不一致，那么前面那些点都需要弹出集合。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="number">#def</span>ine MAX_N (<span class="number">10000</span> + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x, y;</span><br><span class="line">    bool operator &lt;(const Point p) const</span><br><span class="line">    &#123;</span><br><span class="line">        return y &lt; p.y || y == p.y  x &lt; p.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point pts[MAX_N];</span><br><span class="line">int nN;</span><br><span class="line">Point ans[MAX_N];</span><br><span class="line">int nM;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CrossCmp(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    double cs = Cross(pts[0], a, b);</span><br><span class="line">    return cs &gt; 0 || cs == 0  a.x &lt; b.x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Scan()</span><br><span class="line">&#123;</span><br><span class="line">    nM = 0;</span><br><span class="line">    sort(pts + 1, pts + nN, CrossCmp);//对所有点按极角排序,逆时针偏转</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第0-2个点，其实不会进入第二重循环的</span></span><br><span class="line">    <span class="comment">//从第3个点开始，就依次检查与凸包中前面点形成的边的偏转方向</span></span><br><span class="line">    <span class="comment">//如果不是逆时针偏转，则弹出该点</span></span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while (nM &gt;= <span class="number">2</span>  Cross(ans[nM - <span class="number">2</span>], ans[nM - <span class="number">1</span>], pts[i]) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nM--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[nM++] = pts[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double GetArea()</span><br><span class="line">&#123;</span><br><span class="line">    double fAns = 0.0;</span><br><span class="line">    Point ori = &#123;0.0, 0.0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; nM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fAns += Cross(ori, ans[i], ans[(i + 1) % nM]);</span><br><span class="line">    &#125;</span><br><span class="line">    return fabs(fAns) * 0.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;pts[i].x, &amp;pts[i].y);</span><br><span class="line">            <span class="keyword">if</span> (pts[i] &lt; pts[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(pts[i], pts[0]);//pts[0]是y坐标最小的点</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Scan();//扫描出凸包</span><br><span class="line">        double fArea = GetArea();</span><br><span class="line">        printf("%d\n", (int)(fArea / 50));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 凸包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 3714 Raid and hdu 1007 Quoit Design</title>
      <link href="/2012/06/22/poj-3714-raid-and-hdu-1007-quoit-design/"/>
      <url>/2012/06/22/poj-3714-raid-and-hdu-1007-quoit-design/</url>
      
        <content type="html"><![CDATA[<p>典型的最近点对算法的应用，不过这个题多了个限制条件，就是点分为2类，最短距离必须在不同的类之间。为了满足这个限制，只需要把同类别点直接的距离都当作INF处理即可。<br>最近点对的算法，算导上面说是nlogn的。但是这个复杂度实现起来略微麻烦点，有一种实现方法是n<em>logn</em>logn的，其只对x坐标进行了排序。n<em>logn的算法需要对x和y分量分别进行排序，还需要用到其它的辅助数组。<br>第一个题我用了n</em>logn算法实现了，第二个题则用了n<em>logn</em>logn算法实现了。但是时间上相差不大，因为第一个算法每次进行分治时候消耗的O(n)时间也有几次。第二个算法分治时候，需要再次排序的时间也不一定很多，因为可能数据量不够大。<br>算法的本质就是二分按照X排序好的点数组，n<em>logn</em>logn变成n*logn的关键是预先对y也排序好一个点数组，因为按y排序好的点数组，在分治后的合并中要用到。算法更详细的解释请参照算法导论。<br>poj 3714 代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX_N (100000 * 2 + 10)</span><br><span class="line">const double FINF = 1LL &lt;&lt; 60;</span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x, y;</span><br><span class="line">    int nKind;</span><br><span class="line">&#125;;</span><br><span class="line">Point pts[MAX_N], ptsY[MAX_N], ptsTemp[MAX_N];</span><br><span class="line">Point ptsSave[MAX_N];</span><br><span class="line">int nNum;</span><br><span class="line">bool CmpX(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CmpY(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Dis(Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">a</span><span class="selector-class">.nKind</span> == <span class="selector-tag">b</span>.nKind)</span><br><span class="line">    &#123;</span><br><span class="line">        return FINF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double FindMinDis(Point pts[], Point ptsY[], Point ptsTemp[], int nBeg, int nEnd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nBeg == nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        return FINF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nBeg + <span class="number">1</span> == nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        return Dis(pts[nBeg], pts[nEnd]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nBeg + <span class="number">2</span> == nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        return min(min(Dis(pts[nBeg], pts[nBeg + <span class="number">1</span>]), Dis(pts[nBeg], pts[nEnd])),</span><br><span class="line">                   Dis(pts[nBeg + 1], pts[nEnd]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        memcpy(ptsSave + nBeg, ptsY + nBeg, sizeof(Point) * (nEnd - nBeg + 1));//保存当前的Y坐标顺序</span><br><span class="line">        int nMid = (nBeg + nEnd) / 2;</span><br><span class="line">        int nL = nBeg;</span><br><span class="line">        int nR = nMid + 1;</span><br><span class="line">        for (int i = nBeg; i &lt;= nEnd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptsY[i]<span class="selector-class">.x</span> - pts[nMid]<span class="selector-class">.x</span> &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ptsTemp[nL++] = ptsY[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ptsTemp[nR++] = ptsY[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        double fAns = min(FindMinDis(pts, ptsTemp, ptsY, nBeg, nMid),</span><br><span class="line">                          FindMinDis(pts, ptsTemp, ptsY, nMid + 1, nEnd));</span><br><span class="line">        int nK = 1;</span><br><span class="line"></span><br><span class="line">        for (int i = nBeg; i &lt;= nEnd; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fabs(ptsSave[i]<span class="selector-class">.x</span> - pts[nMid].x) &lt;= fAns)</span><br><span class="line">            &#123;</span><br><span class="line">                ptsTemp[nK++] = ptsSave[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; nK; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ptsTemp[j]<span class="selector-class">.y</span> - ptsTemp[i]<span class="selector-class">.y</span> &gt; fAns)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                fAns = min(fAns, Dis(ptsTemp[i], ptsTemp[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return fAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nT;</span><br><span class="line">    int nN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("%f", FINF);</span></span><br><span class="line">    scanf("%d", &amp;nT);</span><br><span class="line">    while (nT--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d", &amp;nN);</span><br><span class="line">        nNum = nN * 2;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;pts[i].x, &amp;pts[i].y);</span><br><span class="line">            pts[i].nKind = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = nN; i &lt; nNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;pts[i].x, &amp;pts[i].y);</span><br><span class="line">            pts[i].nKind = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        memcpy(ptsY, pts, sizeof(Point) * nNum);</span><br><span class="line">        sort(pts, pts + nNum, CmpX);</span><br><span class="line">        sort(ptsY, ptsY + nNum, CmpY);</span><br><span class="line">        printf("%.3f\n", FindMinDis(pts, ptsY, ptsTemp, 0, nNum - 1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>hdu 1007 代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">100000</span> + <span class="number">10</span>)</span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point pts[MAX];</span><br><span class="line">Point ptsTemp[MAX];</span><br><span class="line">const double FINF = 1LL &lt;&lt; 60;</span><br><span class="line">bool CmpX(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CmpY(const Point <span class="selector-tag">a</span>, const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Dis(Point <span class="selector-tag">a</span>, Point b)</span><br><span class="line">&#123;</span><br><span class="line">    return sqrt((a.x - b.x) * (a.x - b.x) + (b.y - a.y) * (b.y - a.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Find(int nL, int nH)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nL == nH)</span><br><span class="line">    &#123;</span><br><span class="line">        return FINF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nL + <span class="number">1</span> == nH)</span><br><span class="line">    &#123;</span><br><span class="line">        return Dis(pts[nL], pts[nH]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nL + <span class="number">2</span> == nH)</span><br><span class="line">    &#123;</span><br><span class="line">        return min(Dis(pts[nL], pts[nL + <span class="number">1</span>]), </span><br><span class="line">                   min(Dis(pts[nL], pts[nH]), Dis(pts[nH], pts[nL + 1])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        int nMid = (nL + nH) / 2;</span><br><span class="line">        double fAns = min(Find(nL, nMid), Find(nMid + 1, nH));</span><br><span class="line">        int nK = 0;</span><br><span class="line">        for (int i = nL; i &lt;= nH; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fabs(pts[i]<span class="selector-class">.x</span> - pts[nMid].x) &lt;= fAns)</span><br><span class="line">            &#123;</span><br><span class="line">                ptsTemp[nK++] = pts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ptsTemp, ptsTemp + nK, CmpY);</span><br><span class="line">        for (int i = 0; i &lt; nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; nK; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ptsTemp[j]<span class="selector-class">.y</span> - ptsTemp[i]<span class="selector-class">.y</span> &gt;= fAns)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                fAns = min(fAns, Dis(ptsTemp[j], ptsTemp[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return fAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf", &amp;pts[i].x, &amp;pts[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(pts, pts + nN, CmpX);</span><br><span class="line">        printf("%.2f\n", Find(0, nN -1) * 0.5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最近点对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 1269 Intersecting Lines</title>
      <link href="/2012/06/20/poj-1269-intersecting-lines/"/>
      <url>/2012/06/20/poj-1269-intersecting-lines/</url>
      
        <content type="html"><![CDATA[<p>题目意思是给出2条直线，然后判断其是否相交，平行，还是重合。刚开始以为是判断2条线段的关系，用了黑书的模板写了，发现连样例都过不了。后面改了很多才过了。先判断2条直线所在的向量是否平行，这个可以判断这2个向量的叉积是否为0，然后再判断线段是否重合，可以选3点判断叉积是否为0。如果向量不平行的话，直接求交点。求交点的公式是用了黑书里面的方法，先求出2个叉积代表2个三角形的有向面积，然后根据定比分点的关系（面积的比例等于交点分其中一条线段的比例）可以推出计算公式。<br>有叉积和点积这2个工具确实能方便的解决很多问题。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    double fX;</span><br><span class="line">    double fY;</span><br><span class="line">&#125;;</span><br><span class="line">Point beg[2], end[2];</span><br><span class="line">int nN;</span><br><span class="line">const double fPrecision = 1e-8;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Cross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.fX - a.fX, b.fY - a.fY, c.fX - a.fX, c.fY - a.fY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DblCmp(double fD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fabs(fD) &lt; fPrecision)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return (fD &gt; 0 ? 1 : -1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double DotDet(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fX2 + fY1 * fY2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double Dot(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return DotDet(b.fX - a.fX, b.fY - a.fY, c.fX - a.fX, c.fY - a.fY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int BetweenCmp(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c)</span><br><span class="line">&#123;</span><br><span class="line">    return DblCmp(Dot(a, b, c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int SegCross(Point <span class="selector-tag">a</span>, Point <span class="selector-tag">b</span>, Point c, Point d, Point p)</span><br><span class="line">&#123;</span><br><span class="line">    double s1, s2, s3, s4;</span><br><span class="line">    int d1, d2, d3, d4;</span><br><span class="line">    d1 = DblCmp(s1 = Cross(a, b, c));</span><br><span class="line">    d2 = DblCmp(s2 = Cross(a, b, d));</span><br><span class="line">    d3 = DblCmp(s3 = Cross(c, d, a));</span><br><span class="line">    d4 = DblCmp(s4 = Cross(c, d, b));</span><br><span class="line"></span><br><span class="line">    Point e, f;</span><br><span class="line">    e.fX = a.fX - b.fX;</span><br><span class="line">    e.fY = a.fY - b.fY;</span><br><span class="line">    f.fX = c.fX - d.fX;</span><br><span class="line">    f.fY = c.fY - d.fY;</span><br><span class="line">    <span class="keyword">if</span> (DblCmp(Det(e<span class="selector-class">.fX</span>, e<span class="selector-class">.fY</span>, f<span class="selector-class">.fX</span>, f.fY)) == <span class="number">0</span>)<span class="comment">//2个向量共线</span></span><br><span class="line">    &#123;</span><br><span class="line">        if (d1 * d2 &gt; 0  d3 * d4 &gt; 0)//不在同一条直线上</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2条直线相交</span></span><br><span class="line">    p.fX = (c.fX * s2 - d.fX * s1) / (s2 - s1);</span><br><span class="line">    p.fY = (c.fY * s2 - d.fY * s1) / (s2 - s1);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf("INTERSECTING LINES OUTPUT\n");</span><br><span class="line">        Point p;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf%lf%lf%lf", &amp;beg[0].fX, &amp;beg[0].fY, &amp;end[0].fX, &amp;end[0].fY);</span><br><span class="line">            scanf("%lf%lf%lf%lf", &amp;beg[1].fX, &amp;beg[1].fY, &amp;end[1].fX, &amp;end[1].fY);</span><br><span class="line">            int nRet = SegCross(beg[0], end[0], beg[1], end[1], p);</span><br><span class="line">            <span class="keyword">if</span> (nRet == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                printf("NONE\n");</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nRet == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                printf("POINT %.2f %.2f\n", p.fX, p.fY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                printf("LINE\n");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("END OF OUTPUT\n");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直线相交 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>poj 2653 Pick-up sticks</title>
      <link href="/2012/06/17/poj-2653-pick-up-sticks/"/>
      <url>/2012/06/17/poj-2653-pick-up-sticks/</url>
      
        <content type="html"><![CDATA[<p>这是一个计算几何的题目。题意是，按顺序给一系列的线段，问最终哪些线段处在顶端。只需要穷举判断，当前的线段会与哪些线段有交点即可。也就是暴力求解，但是线段数目N有10的5次方，平方算法是不能过的。这个题能过的原因是题目描述里面说了，top的stick不会超过1000个。那么修改下暴力的方式题目就能过了。<br>从小到大枚举每个棍子，判断它是否与后面的棍子相交，如果相交直接把当前棍子的top属性置为false，然后break内层循环。这样就不会超时了，暴力也是需要技巧的，这句话说的很对啊。<br>判断2条线段是否相交的算法直接按照黑书上的模板代码写了，那个模板代码还不错吧。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX_N (<span class="number">100000</span> + <span class="number">10</span>)</span><br><span class="line">struct POS</span><br><span class="line">&#123;</span><br><span class="line">    double fX;</span><br><span class="line">    double fY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">POS begs[MAX_N], ends[MAX_N];</span><br><span class="line">bool bAns[MAX_N];</span><br><span class="line">int nN;</span><br><span class="line">const double fPrecision = 1e-8;</span><br><span class="line"></span><br><span class="line">double Det(double fX1, double fY1, double fX2, double fY2)</span><br><span class="line">&#123;</span><br><span class="line">    return fX1 * fY2 - fX2 * fY1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以a作为公共点,计算叉积</span></span><br><span class="line">double Cross(POS <span class="selector-tag">a</span>, POS <span class="selector-tag">b</span>, POS c)</span><br><span class="line">&#123;</span><br><span class="line">    return Det(b.fX - a.fX, b.fY - a.fY, c.fX - a.fX, c.fY - a.fY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DblCmp(double fD)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fabs(fD) &lt; fPrecision)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return fD &gt; 0 ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">bool IsSegCross(int nI, int nJ)</span><br><span class="line">&#123;</span><br><span class="line">    return (DblCmp(Cross(begs[nI], ends[nI], begs[nJ]))</span><br><span class="line">            ^ DblCmp(Cross(begs[nI], ends[nI], ends[nJ]))) == -<span class="number">2</span></span><br><span class="line">            (DblCmp(Cross(begs[nJ], ends[nJ], begs[nI]))</span><br><span class="line">               ^ DblCmp(Cross(begs[nJ], ends[nJ], ends[nI]))) == -2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(<span class="string">"%lf%lf%lf%lf"</span>, &amp;begs[i]<span class="selector-class">.fX</span>, &amp;begs[i]<span class="selector-class">.fY</span>,</span><br><span class="line">                  &amp;ends[i].fX, &amp;ends[i].fY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memset(bAns, true, sizeof(bAns));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暴力也是需要技巧的</span></span><br><span class="line">        for (int i = 1; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = i + 1; j &lt;= nN; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (IsSegCross(<span class="selector-tag">i</span>, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    bAns[i] = false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf("Top sticks:");</span><br><span class="line">        bool bPre = false;</span><br><span class="line">        for (int i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bAns[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (bPre)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(",");</span><br><span class="line">                &#125;</span><br><span class="line">                bPre = true;</span><br><span class="line">                printf(" %d", i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(".\n");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直线相交 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 657 - The die is cast</title>
      <link href="/2012/06/16/uva-657-the-die-is-cast/"/>
      <url>/2012/06/16/uva-657-the-die-is-cast/</url>
      
        <content type="html"><![CDATA[<p>这个题不错，居然需要在dfs里面写bfs。题意类似于图像识别里面，搜索一张图像里面的某个指定区域里面有几个斑点，题意里面的斑点是指色子。</p><p><div><br>30 15<br>…………………………<br>…………………………<br> ……………<em>…………..<br>…<em>**</em></em>……<strong><em>*…………<br>…</em>X*</strong>…..<strong>X*</strong>………..<br> …<strong>*</strong>….<strong>*X</strong>…………<br> …<strong><em>X</em>…..**</strong>………….<br> …<strong>*</strong>…….<em>…………..<br> …………………………<br> ……..**</em>……..<strong>**</strong>…..<br> …….<strong>X**</strong>…..<em>X**X</em>…..<br> ……<strong><em>*</em></strong>……<strong>**</strong>…..<br>…..<strong>**X</strong>…….<em>X**X</em>…..<br>……..<strong><em>……..<em>*</em></em></strong>…..<br>…………………………<br>比如上面这个30 <em> 15的图片里面，一共有四个区域，</em>作为区域的底色，然后是求区域里面有多少个X的块。这个题单纯dfs的话，很没办法，因为无法一次性把连接在一起的X都搜索了。比如，<br>5 5</div></p><p><div>XXX*XXXX*X.....X***XXX***的时候，dfs很明显就会出现问题，因为会先离开X块，再次回到X块，计数就会出现问题了。因此只能遇到X的时候，进行一次bfs，将与其相连接的X全部搜索掉。。。并且找到与当前X块相连接的一个*的位置，如果有这样的位置，就继续进行dfs。</div><br>&lt;/div&gt;<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int nW, nH;</span><br><span class="line">char szData[100][100];</span><br><span class="line">bool bVisit[100][100];</span><br><span class="line">int nNum;</span><br><span class="line">int nDice[100];</span><br><span class="line">int nAdd[4][2] = &#123;&#123;0, -1&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;;</span><br><span class="line"></span><br><span class="line">bool IsPosOk(int <span class="selector-tag">i</span>, int j)</span><br><span class="line">&#123;</span><br><span class="line">    return i &gt;= 0  i &lt; nH  j &gt;= 0  j &lt; nW;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct POS</span><br><span class="line">&#123;</span><br><span class="line">    int nI;</span><br><span class="line">    int nJ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool Bfs(int nI, int nJ)</span><br><span class="line">&#123;</span><br><span class="line">    bool bRet = false;</span><br><span class="line">    queue&lt;POS&gt; qp;</span><br><span class="line">    POS pos = &#123;nI, nJ&#125;;</span><br><span class="line">    int i = nI, j = nJ;</span><br><span class="line"></span><br><span class="line">    qp.push(pos);</span><br><span class="line">    while (qp.empty() == false)</span><br><span class="line">    &#123;</span><br><span class="line">        POS head = qp.front();</span><br><span class="line">        qp.pop();</span><br><span class="line"></span><br><span class="line">        for (int m = 0; m &lt; 4; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            int nNextI = head.nI + nAdd[m][0];</span><br><span class="line">            int nNextJ = head.nJ + nAdd[m][1];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IsPosOk(nNextI, nNextJ)  bVisit[nNextI][nNextJ] == false)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (szData[nNextI][nNextJ] == <span class="string">'X'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bVisit[nNextI][nNextJ] = true;</span><br><span class="line">                    POS pos = &#123;nNextI, nNextJ&#125;;</span><br><span class="line">                    qp.push(pos);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (szData[nNextI][nNextJ] == <span class="string">'*'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bRet = true;</span><br><span class="line">                    nI = nNextI;//   这里是返回新的dfs位置</span><br><span class="line">                    nJ = nNextJ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int <span class="selector-tag">i</span>, int j, int nNum)</span><br><span class="line">&#123;</span><br><span class="line">    bVisit[i][j] = true;</span><br><span class="line">    <span class="keyword">if</span> (szData[i][j] == <span class="string">'X'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nDice[nNum]++;</span><br><span class="line">        bool bDfs = Bfs(i, j);//扩散掉当前连通的所有'X'</span><br><span class="line">        <span class="keyword">if</span> (bDfs == false)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dfs(i, j, nNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int m = 0; m &lt; 4; ++m)</span><br><span class="line">    &#123;</span><br><span class="line">        int nNextI = i + nAdd[m][0];</span><br><span class="line">        int nNextJ = j + nAdd[m][1];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsPosOk(nNextI, nNextJ)  bVisit[nNextI][nNextJ] == false</span><br><span class="line">                 szData[nNextI][nNextJ] != <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(nNextI, nNextJ, nNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCases = 1;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nW, &amp;nH), nW + nH)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nH; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s", szData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(bVisit, false, sizeof(bVisit));</span><br><span class="line">        memset(nDice, 0, sizeof(nDice));</span><br><span class="line">        nNum = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nH; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; nW; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (szData[i][j] == <span class="string">'X'</span>  bVisit[i][j] == false)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(i, j, nNum);</span><br><span class="line">                    nNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nDice, nDice + nNum);</span><br><span class="line"></span><br><span class="line">        printf("Throw %d\n", nCases++);</span><br><span class="line">        for (int i = 0; i &lt; nNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d%s", nDice[i], i == nNum - 1 ? "\n" : " ");</span><br><span class="line">        &#125;</span><br><span class="line">        printf("\n");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 10562 - Undraw the Trees</title>
      <link href="/2012/06/12/uva-10562-undraw-the-trees/"/>
      <url>/2012/06/12/uva-10562-undraw-the-trees/</url>
      
        <content type="html"><![CDATA[<p>这是一个貌似很麻烦的题，题目要求是将一颗用ascii码绘画出来的树，转换为其一种字符串表示，这种字符串表示好像是叫做什么广义表什么的。<br>比如，<br><strong>    A</strong></p><div><p><strong>    |</strong></p><hr><p><strong>B  C   D</strong></p><p><strong>   |   |</strong></p><hr><p><strong> E   F G 对应的字符串表示 **</strong>(A(B()C(E()F())D(G())))**</p><p>&lt;/div&gt;<br>比较纠结的是如何读取数据，如何递归，如果建立树的话，也麻烦，因为还是颗不定叉的树。最主要的是如何方便地递归。最后知道了一个比较巧妙的方法，先一次性把一组数据读入字符串数组里面，再在这个字符串数组上进行递归处理。这样的话，就能很方便的找到树里面节点<br>的关系了。<br>而一次读一个字符就想进行递归是没办法确定节点的关系的，不递归估计更很难写，完全没头绪。。。</p><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char szLines[210][210];</span><br><span class="line">int nNumOfLine;</span><br><span class="line"></span><br><span class="line">void GetAns(int <span class="selector-tag">i</span>, int j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf("i:%d, j:%d, %c\n", i, j, szLines[i][j]);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (szLines[i][j] != <span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        putchar(szLines[i][j]);</span><br><span class="line">        <span class="comment">//printf("%c", szLines[i + 1][j]);</span></span><br><span class="line">        <span class="keyword">if</span> (szLines[<span class="selector-tag">i</span> + <span class="number">1</span>][j] == <span class="string">'|'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            int nBeg, nEnd;</span><br><span class="line">            nBeg = nEnd = j;</span><br><span class="line">            while (nBeg &gt;= <span class="number">0</span>  szLines[<span class="selector-tag">i</span> + <span class="number">2</span>][nBeg] == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                --nBeg;</span><br><span class="line">            &#125;</span><br><span class="line">            while (szLines[<span class="selector-tag">i</span> + <span class="number">2</span>][nEnd] == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++nEnd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf("nBeg:%d, nEnd:%d\n", nBeg, nEnd);</span></span><br><span class="line">            putchar('(');</span><br><span class="line">            for (int k = nBeg; k             &#123;</span><br><span class="line">                <span class="keyword">if</span> (szLines[<span class="selector-tag">i</span> + <span class="number">3</span>][k] != <span class="string">' '</span>  szLines[<span class="selector-tag">i</span> + <span class="number">3</span>][k] != <span class="string">'\0'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    GetAns(i + 3, k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            putchar(')');</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("()");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line">    char ch;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nN);</span><br><span class="line">    getchar();</span><br><span class="line">    while (nN--)</span><br><span class="line">    &#123;</span><br><span class="line">        nNumOfLine = 0;</span><br><span class="line">        memset(szLines, 0, sizeof(szLines));</span><br><span class="line">        while (gets(szLines[nNumOfLine]), szLines[nNumOfLine][<span class="number">0</span>] != <span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf("%s\n", szLines[nNumOfLine]);</span></span><br><span class="line">            nNumOfLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nNumOfLine == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("()\n");</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int i, j;</span><br><span class="line">        i = 0;</span><br><span class="line">        for (j = 0; szLines[0][j] == ' '; ++j);</span><br><span class="line">        <span class="comment">//printf("i:%d, j:%d\n", i, j);</span></span><br><span class="line">        putchar('(');</span><br><span class="line">        GetAns(i, j);</span><br><span class="line">        putchar(')');</span><br><span class="line">        putchar('\n');</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 327 - Evaluating Simple C Expressions</title>
      <link href="/2012/06/10/uva-327-evaluating-simple-c-expressions/"/>
      <url>/2012/06/10/uva-327-evaluating-simple-c-expressions/</url>
      
        <content type="html"><![CDATA[<p>这个题目的意思是要计算一些c语言表达式的值。这些表达式有+-还有++，—操作符与a-z这些变量组合而成。a-z的权值是1-26。比如，表达式 c+f—+—a，得出值是9，其它变量的值也需要计算出来。<br>这个题目感觉比较麻烦，刚开始一点思路也没有，还写了个错误的方法，浪费了时间。后面我的思路是 （+，-） （—，++）（变量）（—，++），这个匹配式子的意思是先处理二元操作符，然后处理前置，再处理变量，再处理后置，如果发现没有后置操作符，则把读取的数据重新写回数据流里面，下次再处理。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;sstream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct INFO</span><br><span class="line">&#123;</span><br><span class="line">    char ch;</span><br><span class="line">    int nValue;</span><br><span class="line">    char chAdd;</span><br><span class="line">    bool operator &lt; (const INFO info) const</span><br><span class="line">    &#123;</span><br><span class="line">        return ch &lt; info.ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">INFO infos[200];</span><br><span class="line">char szLine[200];</span><br><span class="line"></span><br><span class="line">bool GetNextChar(stringstream ss, char ch)</span><br><span class="line">&#123;</span><br><span class="line">    while (ss &gt;&gt; ch)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ch != ' ');</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (gets(szLine))</span><br><span class="line">    &#123;</span><br><span class="line">        printf("Expression: %s\n", szLine);</span><br><span class="line">        memset(infos, 0, sizeof(infos));</span><br><span class="line">        stringstream ss(szLine);</span><br><span class="line">        char ch;</span><br><span class="line">        int nNum = 0;</span><br><span class="line">        int nValue = 0;</span><br><span class="line">        char chOper;</span><br><span class="line">        bool bOk = true;</span><br><span class="line">        bool bFirst = true;</span><br><span class="line">        while (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (bFirst)</span><br><span class="line">            &#123;</span><br><span class="line">                chOper = '+';</span><br><span class="line">                bFirst = false;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                bOk = GetNextChar(ss, ch);</span><br><span class="line">                if (!bOk) break;</span><br><span class="line">                chOper = ch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bOk = GetNextChar(ss, ch);</span><br><span class="line">            if (!bOk) break;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>)<span class="comment">//前置--</span></span><br><span class="line">            &#123;</span><br><span class="line">                bOk = GetNextChar(ss, ch);</span><br><span class="line">                if (!bOk) break;//-</span><br><span class="line">                bOk = GetNextChar(ss, ch);</span><br><span class="line">                if (!bOk) break;//读取字母</span><br><span class="line"></span><br><span class="line">                infos[nNum].ch = ch;</span><br><span class="line">                infos[nNum].nValue = ch - 'a';</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (chOper == <span class="string">'+'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nValue += infos[nNum].nValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nValue -= infos[nNum].nValue;</span><br><span class="line">                &#125;</span><br><span class="line">                ++nNum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'+'</span>)<span class="comment">//前置++</span></span><br><span class="line">            &#123;</span><br><span class="line">                bOk = GetNextChar(ss, ch);</span><br><span class="line">                if (!bOk) break;//+</span><br><span class="line">                bOk = GetNextChar(ss, ch);</span><br><span class="line">                if (!bOk) break;//读取字母</span><br><span class="line"></span><br><span class="line">                infos[nNum].ch = ch;</span><br><span class="line">                infos[nNum].nValue = ch - 'a' + 2;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (chOper == <span class="string">'+'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nValue += infos[nNum].nValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nValue -= infos[nNum].nValue;</span><br><span class="line">                &#125;</span><br><span class="line">                ++nNum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                infos[nNum].ch = ch;</span><br><span class="line">                infos[nNum].nValue = ch - 'a' + 1;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (chOper == <span class="string">'+'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    nValue += infos[nNum].nValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nValue -= infos[nNum].nValue;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//读取后置操作符</span></span><br><span class="line">                char chOne;</span><br><span class="line">                char chTwo;</span><br><span class="line">                bOk = GetNextChar(ss, chOne);</span><br><span class="line">                <span class="keyword">if</span> (!bOk)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++nNum;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                bOk = GetNextChar(ss, chTwo);</span><br><span class="line">                <span class="keyword">if</span> (!bOk)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++nNum;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (chOne == chTwo)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chOne == <span class="string">'+'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        infos[nNum].chAdd = '+';</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        infos[nNum].chAdd = '-';</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ss.putback(chTwo);</span><br><span class="line">                    ss.putback(chOne);</span><br><span class="line">                &#125;</span><br><span class="line">                ++nNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf("    value = %d\n", nValue);</span><br><span class="line">        sort(infos, infos + nNum);</span><br><span class="line">        for (int i = 0; i &lt; nNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (infos[i]<span class="selector-class">.chAdd</span> == <span class="string">'+'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                infos[i].nValue++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (infos[i]<span class="selector-class">.chAdd</span> == <span class="string">'-'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                infos[i].nValue--;</span><br><span class="line">            &#125;</span><br><span class="line">            printf("    %c = %d\n", infos[i].ch, infos[i].nValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 297 - Quadtrees</title>
      <link href="/2012/06/08/uva-297-quadtrees/"/>
      <url>/2012/06/08/uva-297-quadtrees/</url>
      
        <content type="html"><![CDATA[<p>题意是用字符串描述的一棵四叉树，读取字符串获得最终叶子节点的颜色。输入是2个字符串，根据这2个字符串建立2个四叉树。然后对于，指定位置的叶子节点，如果2颗树的叶子颜色其中一个为黑色，那么ans++，输出的就是ans。<br>类似树形结构的东西，直接一个函数递归求解即可。函数参数，一般是字符串地址，当前位置，然后还有其它在递归时候需要用到的东西。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="number">#def</span>ine BLACK (<span class="number">1</span>)</span><br><span class="line"><span class="number">#def</span>ine WHITE (<span class="number">2</span>)</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">32</span>)</span><br><span class="line">int nStateA[MAX][MAX];</span><br><span class="line">int nStateB[MAX][MAX];</span><br><span class="line"></span><br><span class="line">char szOne[10000];</span><br><span class="line">char szTwo[10000];</span><br><span class="line"></span><br><span class="line">void GetState(int nState[MAX][MAX], char* pszLine, int nPos,</span><br><span class="line">              int nSize, int nX, int nY)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pszLine[nPos] == <span class="string">'p'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++nPos;</span><br><span class="line">        GetState(nState, pszLine, nPos, nSize / 2, nX + nSize / 2, nY);</span><br><span class="line">        GetState(nState, pszLine, nPos, nSize / 2, nX, nY);</span><br><span class="line">        GetState(nState, pszLine, nPos, nSize / 2, nX, nY + nSize / 2);</span><br><span class="line">        GetState(nState, pszLine, nPos, nSize / 2, nX + nSize / 2, nY + nSize / 2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = nX; i &lt; nX + nSize; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = nY; j &lt; nY + nSize; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pszLine[nPos] == <span class="string">'e'</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    nState[i][j] = WHITE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nState[i][j] = BLACK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;         ++nPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCases;</span><br><span class="line"></span><br><span class="line">    scanf("%d\n", &amp;nCases);</span><br><span class="line">    while (nCases--)</span><br><span class="line">    &#123;</span><br><span class="line">        gets(szOne);</span><br><span class="line">        gets(szTwo);</span><br><span class="line">        int nPos = 0;</span><br><span class="line">        GetState(nStateA, szOne, nPos, MAX, 0, 0);</span><br><span class="line">        nPos = 0;</span><br><span class="line">        GetState(nStateB, szTwo, nPos, MAX, 0, 0);</span><br><span class="line">        int nAns = 0;</span><br><span class="line">        for (int i = 0; i &lt; MAX; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; MAX; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if (nStateA[i][j] == BLACK || nStateB[i][j] == BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    nAns++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("There are %d black pixels.\n", nAns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 550 - Multiplying by Rotation</title>
      <link href="/2012/05/08/uva-550-multiplying-by-rotation/"/>
      <url>/2012/05/08/uva-550-multiplying-by-rotation/</url>
      
        <content type="html"><![CDATA[<p>这也是一个数学题，刚开始还真以为好难的样子，需要用到什么数论的理论啊。其实，只要去找规律就行了。<br>题意是给出一个进制，一个数字的最低位，和另外的一个数字，比如10进制，第一个数字的最低位是7，第二个数字是4，根据这些信息，和规则（XXXXX7 <em> 4 = 7XXXXX，例子: 179487 </em> 4 = 717948 ）求出第一个数字的最小长度。这个规则的意思是乘积是把第一个数字的最低位移动到最高位上去就行了。<br>貌似很难的样子，其实用笔在纸上求一下XXXXX7 <em> 4 = 7XXXXX就会发现。XXXXX7的每一位都是能够确定的，当然顺序是从最低位到最高位开始。因为知道最低位，所以次低位一定是最低位</em>第二个数%base。以此类推，递归下去即可。最终条件是，没有进位了，而且乘积+原来的进位==最低位。<br>我用的递归完全可以改成循环的形式，这样速度应该会快些。</p><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int nBase;</span><br><span class="line">int nTwo;</span><br><span class="line">int nOneLow;</span><br><span class="line"></span><br><span class="line">int GetMin(int nLow, int nCarry, int nNum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf("nLow:%d, nCarry:%d, nNum:%d\n", nLow, nCarry, nNum);</span></span><br><span class="line">    int nTemp = nCarry + nLow * nTwo;</span><br><span class="line">    <span class="keyword">if</span> (nTemp == nOneLow)</span><br><span class="line">    &#123;</span><br><span class="line">        return nNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return GetMin(nTemp % nBase, nTemp / nBase, nNum + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line">    while (scanf(<span class="string">"%d%d%d"</span>, &amp;nBase, &amp;nOneLow, &amp;nTwo) == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printf("%d\n", GetMin(nOneLow, 0, 0) + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 107 - The Cat in the Hat</title>
      <link href="/2012/05/07/uva-107-the-cat-in-the-hat/"/>
      <url>/2012/05/07/uva-107-the-cat-in-the-hat/</url>
      
        <content type="html"><![CDATA[<p>这是一个很神的数学题吧。基本上过这个题的很多都会wa10多次，而且这个题好像简单的枚举其中的一个指数值都能过，可能是数据量比较小。<br>但是，这个题还是有数学的解法的。但是，即使找到了这个正确的解法，过题的话，也是一件很困难的事情。题意大致如下：一只猫，高度为H，戴了一个帽子，帽子里面有N只猫（N是常数，且未知），同样帽子里面的猫也戴了帽子，但是这些猫的高度变成了H / (N + 1)，会向下取整。以此递归下去，直到最后的猫的高度都为1为止。现在，给出H和高度为1的猫的数量。要求的是高度大于1的猫的数量，以及所有猫的高度之和。<br>很别扭吧。通过上面的信息，得出2个式子。假设one代表为高度为1的猫的数量。one = N的n次。H &gt;= (N + 1)的n次。注意第二个式子不一定取等号，因为很多时候都是不能整除的。现在要求N和n。2个方程解2个未知数，应该能解出来。但是，注意的是其中一个还是不等式。。。<br>指数关系很多时候会转换为对数的关系。所以，继续求对数，有lgH &gt;= n <em> lg(N + 1)。其中，由第一个式子可以得到n = lg(one) / lg(N)。那么最终转换为：lgH &gt;= (lg(one) / lgN) </em> lg(N + 1)。换个形式就是lgH / lg(One) &gt;= lg(N + 1) / lgN。现在，已经很清晰了。因为，函数lg(N + 1) / lg(N) 是单调递减的。看到单调的函数，马上就会知道可以二分了。意思是，我们可以二分出一个N让lg(N + 1) / lgN 最接近lgH/lg(One)，而且是小于lgH / lg(One)的。剩下的工作就只是求和而已了。<br>写二分的时候，有一个地方可以注意一下。因为 lg(N + 1) / lgN 可能会出现除数为0的情况，所以可以进一步转换为lgH <em> lgN &gt;=lg(N + 1) </em> lg(one)。 也是求一个N让上面那个不等式2边的值最接近，而且右边小于左边。能很快写对这个题真不是件容易的事情。。。<br>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nInitH, nOnes;</span><br><span class="line">    int nN, n;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nInitH, &amp;nOnes), nInitH + nOnes)</span><br><span class="line">    &#123;</span><br><span class="line">        int nBeg = 1;</span><br><span class="line">        int nEnd = nOnes;</span><br><span class="line">        int nMid;</span><br><span class="line"></span><br><span class="line">        while (nBeg &lt;= nEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            nMid = (nBeg + nEnd) / 2;</span><br><span class="line"></span><br><span class="line">            double fRes = log10(nInitH) * log10(nMid);</span><br><span class="line">            double fTemp = log10(nMid + 1) * log10(nOnes);</span><br><span class="line">            <span class="keyword">if</span> (fabs(fRes - fTemp) &lt; <span class="number">1</span>e-<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printf("Find nN:%d\n", nMid);</span></span><br><span class="line">                nN = nMid;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (fTemp &gt; fRes)</span><br><span class="line">            &#123;</span><br><span class="line">                nBeg = nMid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nEnd = nMid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = floor(log10(nInitH) / log10(nN + 1) + 1e-9);</span><br><span class="line">        <span class="comment">//printf("nN:%d, n:%d\n", nN, n);</span></span><br><span class="line"></span><br><span class="line">        int nSum = 0;</span><br><span class="line">        int nLazy = 0;</span><br><span class="line">        int nNum = 1;</span><br><span class="line">        for (int i = 0; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nSum += nNum * nInitH;</span><br><span class="line">            nLazy += nNum;</span><br><span class="line">            nNum *= nN;</span><br><span class="line">            nInitH /= (nN + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf("%d %d\n", nLazy - nOnes, nSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 10112 - Myacm Triangles</title>
      <link href="/2012/05/07/uva-10112-myacm-triangles/"/>
      <url>/2012/05/07/uva-10112-myacm-triangles/</url>
      
        <content type="html"><![CDATA[<p>这是一个几何题。题意是给出一系列点，点最多才15个，求一个这里面的三个点组合出来的三角形，其面积是最大的，而且没有任何其它的点在这个三角形的内部和边界上。求三角形的面积，题目上面已经给了公式，也可以用0.5<em>|a|</em>|b|<em>sin(a,b)求，这里的a和b指的是2条边代表的向量。<br>现在就剩下一个问题了，怎么判断一个点在三角形的内部和边界上。在边界上，比较好判断，判断是否共线，然后再点是在线段的内部。<br>具体说明下，判断一个点在三角形内部的思路。我用的还是线性规划的思想。<em>*如果该点在三角形的内部，那么任取三角形的一条边，该内部点和剩余的三角形的一个顶点必定在三角形的那条的边的同一侧。</em></em>这个方法也可以推广到N边的凸多边形，证明的话很简单，因为线性规划一直在划分区域。所以，划分到最后围起来的区域就是凸多边形的内部了。<br>至于写代码的话，由于是第一次写这种几何题，写得很凌乱。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">20</span>)</span><br><span class="line">int nN;</span><br><span class="line">struct Point</span><br><span class="line">&#123;</span><br><span class="line">    char szLabel[5];</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">Point points[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//三点是否共线</span></span><br><span class="line">bool IsOneLine(int nOne, int nTwo, int nThree)</span><br><span class="line">&#123;</span><br><span class="line">    int nA = points[nTwo].x - points[nOne].x;</span><br><span class="line">    int nB = points[nTwo].y - points[nOne].y;</span><br><span class="line">    int nC = points[nThree].x - points[nOne].x;</span><br><span class="line">    int nD = points[nThree].y - points[nOne].y;</span><br><span class="line"></span><br><span class="line">    return (nA * nD == nB * nC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点nOne和点nTwo是否在直线(nBeg,nEnd)的同一侧(不能在直线上)</span></span><br><span class="line">bool IsSameSide(int nBeg, int nEnd, int nOne, int nTwo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求直线的向量</span></span><br><span class="line">    int nA = points[nBeg].x - points[nEnd].x;</span><br><span class="line">    int nB = points[nBeg].y - points[nEnd].y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直线方程为nB(x - points[nBeg].x) - nA(y - points[nBeg].y) = 0</span></span><br><span class="line">    <span class="comment">//分别用nOne和nTwo的坐标代入直线方程计算结果，然后将结果相乘</span></span><br><span class="line">    <span class="comment">//乘积必须大于0</span></span><br><span class="line">    int nRes = (nB * (points[nOne].x - points[nBeg].x) - nA * (points[nOne].y - points[nBeg].y))</span><br><span class="line">               * (nB * (points[nTwo].x - points[nBeg].x) - nA * (points[nTwo].y - points[nBeg].y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nRes &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("点:%d,点:%d,在直线nBeg:%d, nEnd:%d的同一侧\n", nOne, nTwo, nBeg, nEnd);</span></span><br><span class="line">    &#125;</span><br><span class="line">    return nRes &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点是否在三角形(nOne, nTwo, nThree)外部</span></span><br><span class="line">bool PointOutTriangle(int nOne, int nTwo, int nThree, int nPoint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前面3个ifelse是判断点是否在边上</span></span><br><span class="line">    <span class="keyword">if</span> (IsOneLine(nOne, nTwo, nPoint))</span><br><span class="line">    &#123;</span><br><span class="line">        if ((points[nOne].x - points[nPoint].x) * (points[nTwo].x - points[nPoint].x) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsOneLine(nOne, nThree, nPoint))</span><br><span class="line">    &#123;</span><br><span class="line">        if ((points[nOne].x - points[nPoint].x) * (points[nThree].x - points[nPoint].x) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (IsOneLine(nTwo, nThree, nPoint))</span><br><span class="line">    &#123;</span><br><span class="line">        if ((points[nTwo].x - points[nPoint].x) * (points[nThree].x - points[nPoint].x) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的IsSameSide如果nPoint在直线的(nOne,nTwo)的外侧也会判断为假</span></span><br><span class="line">    <span class="comment">//所以需要先在上面判断点是否在边的内侧</span></span><br><span class="line">    return !(IsSameSide(nOne, nTwo, nThree, nPoint)</span><br><span class="line">              IsSameSide(nOne, nThree, nTwo, nPoint)</span><br><span class="line">              IsSameSide(nTwo, nThree, nOne, nPoint));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsValid(int nOne, int nTwo, int nThree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsOneLine(nOne, nTwo, nThree))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("点:%d,%d,%d共线\n", nOne, nTwo, nThree);</span></span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i == nOne || i == nTwo || i == nThree)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!PointOutTriangle(nOne, nTwo, nThree, i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf("点:%d, 在三角形:%d,%d,%d内部\n", i, nOne, nTwo, nThree);</span></span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算三角形(nOne, nTwo, nThree)的面积</span></span><br><span class="line">double GetArea(int nOne, int nTwo, int nThree)</span><br><span class="line">&#123;</span><br><span class="line">    return 0.5 * fabs((points[nThree].y - points[nOne].y) * (points[nTwo].x - points[nOne].x)</span><br><span class="line">                      - (points[nTwo].y - points[nOne].y) * (points[nThree].x - points[nOne].x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s%d%d", points[i].szLabel, &amp;points[i].x, &amp;points[i].y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        double fMaxArea = 0.0;</span><br><span class="line">        int nI = -1, nJ = -1, nK = -1;</span><br><span class="line">        for (int i = 0; i &lt; nN - 2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; nN - 1; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int k = j + 1; k &lt; nN; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (IsValid(<span class="selector-tag">i</span>, j, k))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//printf("i:%d,j:%d,k:%d valid\n", i, j, k);</span></span><br><span class="line">                        double fArea = GetArea(i, j, k);</span><br><span class="line">                        <span class="comment">//printf("Area:%f\n", fArea);</span></span><br><span class="line">                        <span class="keyword">if</span> (fArea &gt; fMaxArea)</span><br><span class="line">                        &#123;</span><br><span class="line">                            nI = i;</span><br><span class="line">                            nJ = j;</span><br><span class="line">                            nK = k;</span><br><span class="line">                            fMaxArea = fArea;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%s%s%s\n", points[nI].szLabel, points[nJ].szLabel, points[nK].szLabel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uva 10025 - The ? 1 ? 2 ? ... ? n = k problem</title>
      <link href="/2012/05/04/uva-10025-the-1-2-n-k-problem/"/>
      <url>/2012/05/04/uva-10025-the-1-2-n-k-problem/</url>
      
        <content type="html"><![CDATA[<p>这也算一个数学类的杂题吧。题目本身比较有意思，解题的思路很需要猜想。题目的意思用+和-去替代式子(? 1 ? 2 ? … ? n = k)中的？号，对于指定的K，求最小的n。For example: to obtain k = 12 , - 1 + 2 + 3 + 4 + 5 + 6 - 7 = 12 with n = 7。<br>这个题，我的思路大致如下。首先，K可能是正的也是负的，而且显然负的情况，有相应的正对应情况。那么考虑所有k为正的情况。由于k一定小于等于n<em>(n+1)/2的，所以可以先求出这样的最小n。这个可以二分搜索，或者直接用解不等式方程(不过这种方法一直wa了)。<br>然后就剩下的是第二点了，假设a + b = n</em>(n+1)/2, a - b = k。可以得到 n<em>(n+1)/2 - k = 2 </em> b。意思是，必须满足 n<em>(n+1)/2和k的差为偶数。假如满足了，这样的n是不是一定OK了？？？<br>答案是肯定的，这一点就是需要猜想的地方了。因为，仔细观察下，1到n的数字可以组合出任意的1到 n</em>(n+1)/4之间的数字，这个数字即是b。至于证明，可以用数学归纳法从n==1开始证明了。。。至此已经很简单了。<br>由于求n存在2种不同的方法，而且我开始用解一元二次不等式的方法求的N，出现了浮点误差，一直WA了。后面改成二分才过了。。。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt; </span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int GetN(int nK)</span><br><span class="line">&#123;</span><br><span class="line">    int nBeg = 1;</span><br><span class="line">    int nEnd = sqrt(nK * 2) + 2;</span><br><span class="line"></span><br><span class="line">    while (nBeg &lt;= nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        int nMid = (nBeg + nEnd) / 2;</span><br><span class="line">        int nTemp = (nMid * nMid + nMid) / 2;</span><br><span class="line">        <span class="keyword">if</span> (nTemp &gt;= nK)</span><br><span class="line">        &#123;</span><br><span class="line">            nEnd = nMid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nBeg = nMid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nEnd + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nK;</span><br><span class="line">    int nTest;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nTest);</span><br><span class="line">    while (nTest--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d", &amp;nK);</span><br><span class="line">        <span class="keyword">if</span> (nK &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nK *= -1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int nN = ceil(sqrt(2 * fabs(1.0 * nK) + 0.25) - 0.5 + 1e-9);</span></span><br><span class="line">        <span class="comment">//上面那种方法存在浮点误差,wa了三次</span></span><br><span class="line">        int nN = GetN(nK);</span><br><span class="line"></span><br><span class="line">        while (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            if (((nN * nN + nN) / 2 - nK) % 2 == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                printf("%d\n", nN);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            ++nN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nTest)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 10014 - Simple calculations</title>
      <link href="/2012/05/03/uva-10014-simple-calculations/"/>
      <url>/2012/05/03/uva-10014-simple-calculations/</url>
      
        <content type="html"><![CDATA[<p>说实话，这个题不是我亲自推算出来。一直想到崩溃了，明知道只差一步，硬是无法想出来。实在想不出了，看了下别人解题报告上的解释。真的很惭愧很崩溃。。。这就是一个数列推理的题目吧。<br>给出一个数列ci（1&lt;=ci&lt;=n)，然后给出数列ai中的a0和a(n+1)。并给出一个公式ai = ( a(i-1) + a(i+1) )  /  2 - ci。题目的意思是让求a1。<br>大家在很久以前的高中时代一定做过很多的数列题，所以我一看到这个题还是感觉很亲切的。然后就开始推算。我把上面那个公式，从i==1到i==n，全部累加起来。消去2边一样的项，得到一个结果<strong>a1 + an = a0 + a(n+1) - 2Σci(1&lt;=i&lt;=n)</strong>。从这个公式，我只能得到a1和an 的和。想来想去都无法直接求出a1的值。但是，我也知道如果能求出a1，那么ai中的任何其它项都是能求出来的。我猜想a1和an相等，提交当然wa了。然后，我猜想ai是a0和a(n+1)的i分点，提交还是wa了。后面这个猜想倒是合理点，但是还是有不严谨的地方，因为那样，a1的值之和a0，a(n+1)，c1这三个值有关系了。<br>这个题其实以前我想了一下，没想出来。然后今天重新想的时候可能受以前的影响，限制了一个思路。那就是，再对式子a1 + an =a0 + a(n+1) - 2 Σci(1&lt;=i&lt;=n)进行累加。其实，也有a1 + a(n-1) = a0 + an - 2 Σci(1&lt;=i&lt;=n-1)。这样累加n次，刚好可以把a2-an全部消去。可以得到，一个式子 <strong>(n+1)a1 = n * a0 + a(n+1)- 2  ΣΣ cj(1&lt;=j&lt;=i) (1&lt;=i&lt;=n)</strong>。那么就可以直接求出a1了。<br>公式：<img alt data-src="http://www.cppblog.com/images/cppblog_com/csu-yx/mathtex.gif">&lt;/span&gt;</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCases;</span><br><span class="line">    int nN;</span><br><span class="line">    double a0, an1;</span><br><span class="line">    double a1;</span><br><span class="line">    double ci[3000 + 10];</span><br><span class="line">    double c;</span><br><span class="line">    double sum;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nCases);</span><br><span class="line"></span><br><span class="line">    while (nCases--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d", &amp;nN);</span><br><span class="line">        scanf("%lf%lf", &amp;a0, &amp;an1);</span><br><span class="line"></span><br><span class="line">        sum = 0.0;</span><br><span class="line">        memset(ci, 0, sizeof(ci));</span><br><span class="line">        for (int j = 1; j &lt;= nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%lf", c);</span><br><span class="line">            ci[j] = ci[j - 1] + c;//ci[j]代表数列ci中第1-j项的和</span><br><span class="line">            sum += ci[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a1 = (nN * a0 + an1 - 2 * sum) / (nN + 1);</span><br><span class="line">        printf("%.2f", a1);</span><br><span class="line">        putchar('\n');</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nCases)</span><br><span class="line">        &#123;</span><br><span class="line">            putchar('\n');</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 10061 - How many zero&#39;s and how many digits ?</title>
      <link href="/2012/05/02/uva-10061-how-many-zeros-and-how-many-digits/"/>
      <url>/2012/05/02/uva-10061-how-many-zeros-and-how-many-digits/</url>
      
        <content type="html"><![CDATA[<p>这又是一个数学题，不过我还是比较喜欢做这类数学杂题的。题目意思很简单，给2个十进制数，n和b。如果用b进制表示n!，需要多少位数，这个表示末尾会有多少个0。这个题并不需要什么高深的知识，这一点也是我喜欢做这类题的一个方法。<br>大家显然都知道求n！用10进制表示末尾会有多少个0的方法，就是求2 * 5最多有多少对。那么，b进制了。方法类似，发散一下想法而已。<br>我还是先说求多少位数的方法吧。 b的m-1次 看到这个不等式应该有想法了吧。两边同时取logb，就可以得到Σlogi(1&lt;=i 再说怎么求末尾0的，发散下想法，我们也可以对n！中的每个因子试着求b的因子对，一共有多少对。但是，后面发现这样不行，因为比如b是16，1和16是一对因子，2和8是一对因子，4和4是一对因子，也就是因为2也是4的因子，这样计算因子对就会重复了。但是对于b等于10的情况，可以例外而已。<br>呵呵，考虑其它的方法。求素数因子。任何数字都可以被分解为一些素数因子的乘积，这是毋容置疑的。那么，我们去分解n！中的小于等于b的素数因子，并将其个数存储在数组里面。然后死循环的去分解b的素数因子，能够完全分解一次(具体看下代码，不好描述），ans就加1。否则，已经没有末尾0了。<br>虽然提交了16次才过。不过最后还算不错吧，只用了0.508s。相比20s的时间界限，很小了。网上有些过的代码，跑一个数据都要几分钟。。。PS：uva上那些神人，怎么用0.0s算出来的，很难想象啊。<br>这个题目还有个很大的需要注意的地方，就是浮点数的精度问题。前面讲到求位数需要用到log函数，log函数的计算精度就出问题了。<br>最后需要对和加一个1e-9再floor才能过。特别需要注意这一点，因为开始我的程序过了所有<a href="http://online-judge.uva.es/board/viewtopic.php?f=9t=7137start=30" target="_blank" rel="noopener">http://online-judge.uva.es/board/viewtopic.php?f=9t=7137start=30</a>上说的数据还是wa了。而且我还发现log10计算精度高很多，如果log(这个是自然对数)去计算，这个网站上的数据都过不了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int nN, nB;</span><br><span class="line"></span><br><span class="line">int nDivisor[1000];</span><br><span class="line"></span><br><span class="line">int GetDigit(int nN, int nB)</span><br><span class="line">&#123;</span><br><span class="line">    double fSum = 0.0;</span><br><span class="line">    for (int i = 2; i &lt;= nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fSum += log10(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fSum /= log10(nB);</span><br><span class="line"></span><br><span class="line">    return floor(fSum + 1e-9) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int GetZero(int nN, int nB)</span><br><span class="line">&#123;</span><br><span class="line">    memset(nDivisor, 0, sizeof(nDivisor));</span><br><span class="line"></span><br><span class="line">    for (int i = 2; i &lt;= nN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int nTemp = i;</span><br><span class="line"></span><br><span class="line">        for (int j = 2; j &lt;= nTemp  j &lt;= nB; ++j)//这样循环就可以进行素数因子分解了</span><br><span class="line">        &#123;</span><br><span class="line">            while (nTemp % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                nDivisor[j]++;</span><br><span class="line">                nTemp /= j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nAns = 0;</span><br><span class="line"></span><br><span class="line">    while (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nTemp = nB;</span><br><span class="line"></span><br><span class="line">        for (int j = 2; j &lt;= nTemp; ++j)//分解nB</span><br><span class="line">        &#123;</span><br><span class="line">            while (nTemp % j == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nDivisor[j] &gt; <span class="number">0</span>)<span class="comment">//如果还可以继续分解</span></span><br><span class="line">                &#123;</span><br><span class="line">                    --nDivisor[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//直接可以goto跳出多重循环了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    goto out;</span><br><span class="line">                &#125;</span><br><span class="line">                nTemp /= j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++nAns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    return nAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nB) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nDigit = GetDigit(nN, nB);</span><br><span class="line">        int nZero = GetZero(nN, nB);</span><br><span class="line">        printf("%d %d\n", nZero, nDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 10177 - (2/3/4)-D Sqr/Rects/Cubes/Boxes?</title>
      <link href="/2012/04/14/uva-10177-234-d-sqrrectscubesboxes/"/>
      <url>/2012/04/14/uva-10177-234-d-sqrrectscubesboxes/</url>
      
        <content type="html"><![CDATA[<p>这是一道数学题吧。想清楚之后就发现就是求累加和。<br>问题是给定一个正方形(体,超体)，求其中的所有的正方形(体,超体),长方形(体,超体)。 比如，4 <em> 4的正方形中，有14个正方形，22个长方形，4 </em> 4 <em> 4的立方体中有36个正方体，180个长方体。依次类推，超正方体指的是四维空间。<br>观察一下一个4</em>4正方形中，仔细验证一下就会发现，正方形的个数是 Σ(4 - i + 1) <em> (4 - i + 1)(其中i从1到4)，长方形的个数是Σ(4 - i + 1) (其中j从1到4) </em> Σ(4 - j + 1)(其中j从1到4)。如果变成3维的就多一层k，k也从1变化到4。如果变成4维的就再多一层l，l也从1变化到4。<br>然后变换一下，就可以得到s2(n) = 1^1 + 2^2 + … + n^n，s3(n)则是对立方的累加和，s4(n)则是对四次方的累加和。<br>再计算r2(n)。可以先把正方形包括在内计算出所有的和。那么r2(n) = Σ(n - i + 1) <em> Σ(n - j + 1) - s2(n)。如果直接进行这个式子的求和话很复杂。再观察一下这个式子，因为n - i + 1的变化范围就是1到n，那么上面的式子可以变化为 r2(n) = ΣΣi </em> j - s2(n)。意思是求i<em>j的和，i和j都是从1变化到n。很简单就可以得到r2(n) = pow(n </em> (n + 1) / 2, 2) - s2(n)。同样的求和可以得到，r3(n) = pow(n <em> (n + 1) / 2, 3) - s3(n)。r4(n) = pow(n </em> (n + 1) / 2, 4) - s4(n)。<br>另外如果不知道平方和，立方和，四次方和的公式，也可以迭代计算，复杂度也是O(100)。这样的话，根本不需要使用这些难记忆的公式了。</p><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt; </span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line">unsigned long long s2[101];</span><br><span class="line">unsigned long long r2[101];</span><br><span class="line">unsigned long long s3[101];</span><br><span class="line">unsigned long long r3[101];</span><br><span class="line">unsigned long long s4[101];</span><br><span class="line">unsigned long long r4[101];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long long i = 0;</span><br><span class="line">    while (<span class="selector-tag">i</span> &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s2[i] = i * (i + 1) * (2 * i + 1) / 6;//平方和</span><br><span class="line">        s3[i] = i * i * (i + 1) * (i + 1) / 4;//立方和</span><br><span class="line">        s4[i] = i * (i + 1) * (6 * i * i * i + 9 * i * i + i - 1) / 30;//四次方和</span><br><span class="line">        r2[i] = pow(i * (i + 1) / 2, 2) - s2[i];</span><br><span class="line">        r3[i] = pow(i * (i + 1) / 2, 3) - s3[i];</span><br><span class="line">        r4[i] = pow(i * (i + 1) / 2, 4) - s4[i];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int nN;</span><br><span class="line">    while (scanf(";%d";, nN) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(";%I64u %I64u %I64u %I64u %I64u %I64u\n";, s2[nN], r2[nN], s3[nN], r3[nN], s4[nN], r4[nN]);</span></span><br><span class="line">        printf(";%llu %llu %llu %llu %llu %llu\n";, s2[nN], r2[nN], s3[nN], r3[nN], s4[nN], r4[nN]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 10790 - How Many Points of Intersection?</title>
      <link href="/2012/04/12/uva-10790-how-many-points-of-intersection/"/>
      <url>/2012/04/12/uva-10790-how-many-points-of-intersection/</url>
      
        <content type="html"><![CDATA[<p>这是一个数学题，比较有意思。题意大致是：有2条平行的直线，第一条上面有m个点，第二条上面有n个点。那么连接这写点能产生m<em>n条直线(不包括和原来的执行平行的直线)。问这m</em>n直线最多有多少个内交点(意思是不属于原来m,n个点的交点)…<br>想来想去，推理了1个多小时才出来正式结果。感觉比较有意思，写篇博文记录下。我先是从反面排除，想了试了好久到最后还是发现无法排除干净。。。最后只能从正面开始求证了。我这样定义一条执行(i，j)，其中i代表在第一条直线中的端点，j代表在第二条直线中的端点。显然1 现在的话只要求出和直线(i，j)相加的直线有多少条，然后对i，j进行累加求和。再对和除以2就能得到答案了。<br>那么有多少条直线能和直线(i，j）相交了。很显然，和(i,j)相交的直线的端点必须在其两侧。意思是在第一条直线中的端点范围为[1, i - 1],在第二条直线中的端点范围为[j + 1, n]，总结(i - 1) <em> (n - j) 条直线。但是还有第二种情况,在第一条直线中的端点范围为[i + 1, m], 在第二条直线中的端点范围为[1, j - 1]，总计(m - i) </em> (j - 1) 条直线。总计sum = i <em> n + i - m -n + j (m - 2 </em> i + 1) 条直线。<br>再求Σsum（j从1到n)得到和式(m<em>n</em>n - m<em>n - n</em>n + n) / 2，再对这个式子进行i从1到m的累加。因为没有i了，其效果就是乘以m。然后最终的和除以2，所以最后的表达式是(m<em>m</em>n<em>n - m</em>m<em>n - m</em>n<em>n + m</em>n) / 4。这个式子显然是关于m,n对称的。这一点也可以验证这个式子的正确性。</p><p>程序写起来就很简单了，代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long m, n;</span><br><span class="line">    int nCases = 0;</span><br><span class="line"></span><br><span class="line">    while (cin &gt;&gt; m &gt;&gt; n, m + n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        long long a = m * m;</span><br><span class="line">        long long b = n * n;</span><br><span class="line">        cout &lt;&lt; ";Case "; &lt;&lt; ++nCases &lt;&lt; ";: ";</span><br><span class="line">             &lt;&lt; (a * b - a * n - b * m + m * n) / 4 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 直线相交 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uva 465 - Overflow</title>
      <link href="/2012/04/03/uva-465-overflow/"/>
      <url>/2012/04/03/uva-465-overflow/</url>
      
        <content type="html"><![CDATA[<p>这是一道很简单的题吧，大数都不需要用到，可是很悲剧wa了很久。确实写题太不严谨了，出了好多bug，甚至题意都没注意清楚。<br>这种题我一直忘记忽略前导’0’。还有题目没有给出最长的数字的长度，所以最好用string类。<br>使用longlong之前最好已经测试了OJ，是用%lld还是%I64d，如果OJ后台是linux下的g++，只能是%lld，Windows下的MinGW32(Dev-C++也一样用的是这个库)要用%I64d才能正确。所以预赛之前需要对普通题进行测试下。还有注意复合逻辑表达式是否写正确了，最近经常写错了，太郁闷了。<br>给自己提个醒吧，校赛这种题再不能迅速A掉基本太丢人了。<br>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt; </span><br><span class="line"><span class="selector-id">#include</span> &lt;limits.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">10000</span>)</span><br><span class="line">char szIntMax[20];</span><br><span class="line">char szLine[MAX];</span><br><span class="line">char szOne[MAX];</span><br><span class="line">char szTwo[MAX];</span><br><span class="line">char szOper[10];</span><br><span class="line"></span><br><span class="line">char* MyItoa(int nNum, char* pszNum, int nBase)</span><br><span class="line">&#123;</span><br><span class="line">    int nLen = 0;</span><br><span class="line">    while (nNum)</span><br><span class="line">    &#123;</span><br><span class="line">        pszNum[nLen++] = nNum % nBase + '0';</span><br><span class="line">        nNum /= nBase;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(pszNum, pszNum + nLen);</span><br><span class="line">    pszNum[nLen] = '\0';</span><br><span class="line"></span><br><span class="line">    return pszNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool IsBigger(char* pszOne, int nLenOne, char* pszTwo, int nLenTwo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//printf(";pszOne:%s, pszTwo:%s\n";, pszOne, pszTwo);</span></span><br><span class="line">    <span class="keyword">if</span> (nLenOne != nLenTwo)</span><br><span class="line">    &#123;</span><br><span class="line">        return nLenOne &gt; nLenTwo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nLenOne; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pszOne[i] != pszTwo[i])</span><br><span class="line">            &#123;</span><br><span class="line">                return pszOne[i] &gt; pszTwo[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int StripHeadZero(char* pszNum)</span><br><span class="line">&#123;</span><br><span class="line">    int nLen = strlen(pszNum);</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; nLen &amp;&amp; pszNum[i] == '0'; ++i);</span><br><span class="line">    <span class="keyword">if</span> (<span class="selector-tag">i</span> == nLen)</span><br><span class="line">    &#123;</span><br><span class="line">        pszNum[0] = '0';</span><br><span class="line">        pszNum[1] = '\0';</span><br><span class="line">        nLen = 2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        char* pszWrite = pszNum;</span><br><span class="line">        char* pszRead = pszNum + i;</span><br><span class="line">        nLen = 0;</span><br><span class="line">        while (*pszRead)</span><br><span class="line">        &#123;</span><br><span class="line">            *pszWrite++ = *pszRead++;</span><br><span class="line">            ++nLen;</span><br><span class="line">        &#125;</span><br><span class="line">        *pszWrite = '\0';</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nIntMax = INT_MAX;</span><br><span class="line">    MyItoa(nIntMax, szIntMax, 10);</span><br><span class="line">    int nLenMax = strlen(szIntMax);</span><br><span class="line"></span><br><span class="line">    while (gets(szLine))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (szLine[<span class="number">0</span>] == <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sscanf(szLine, ";%s%s%s";, szOne, szOper, szTwo);</span><br><span class="line">        printf(";%s %s %s\n";, szOne, szOper, szTwo);</span><br><span class="line">        StripHeadZero(szOne);</span><br><span class="line">        StripHeadZero(szTwo);</span><br><span class="line"></span><br><span class="line">        int nLenOne = strlen(szOne);</span><br><span class="line">        int nLenTwo = strlen(szTwo);</span><br><span class="line">        bool bFirst = false;</span><br><span class="line">        bool bSecond = false;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsBigger(szOne, nLenOne, szIntMax, nLenMax))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(";first number too big\n";);</span><br><span class="line">            bFirst = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IsBigger(szTwo, nLenTwo, szIntMax, nLenMax))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(";second number too big\n";);</span><br><span class="line">            bSecond = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bFirst || bSecond)</span><br><span class="line">        &#123;</span><br><span class="line">            if (szOper[0] == '+' || (szOper[0] == '*' &amp;&amp; szOne[0] != '0' &amp;&amp; szTwo[0] != '0'))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(";result too big\n";);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            long long nOne, nTwo;</span><br><span class="line">            sscanf(szLine, "%lld%s%lld", &amp;nOne, szOper, &amp;nTwo);</span><br><span class="line">            long long nResult;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (szOper[<span class="number">0</span>] == <span class="string">'+'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nResult = nOne + nTwo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (szOper[<span class="number">0</span>] == <span class="string">'*'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nResult = nOne * nTwo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf(";%I64d\n";, nResult);</span></span><br><span class="line">            <span class="keyword">if</span> (nResult &gt; INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(";result too big\n";);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uva 10132 - File Fragmentation</title>
      <link href="/2012/03/30/Uva%2010132%20-%20File%20Fragmentation/"/>
      <url>/2012/03/30/Uva%2010132%20-%20File%20Fragmentation/</url>
      
        <content type="html"><![CDATA[<p>这个题，粗看之下还没怎么看懂，这个应该跟我英语水平有关系。然后再看输入输出，渐渐的才明白什么意思。原来是要把2 * N张破纸组合成N张一样的纸。我历来思维比较随便，不是很严谨的那种。然后，想了一下发现一定会有大于等于N张破纸片是符合前半部分模式的。<br>那么，可以建一个字典树，把所有的是前半张纸的找出来。然后根据这前半张纸，找出剩下的后半张纸（因为知道一整张纸的长度，所以知道剩下的半张纸的长度）。但是写出来就发现这样不严谨，是不对的。因为单纯根据已经找出来的前半张纸，无法确定后半张纸（事实上，只能确定其长度而已）。<br>那么只能找其它方法了，再检查了下数据范围，发现比较小，那么意味着可以暴力求解了。好吧，那就深搜吧。我把所有的破纸片按照它们的长度分成一些集合，对于长度为len的纸片集合，只要与长度为nAnsLen - len的纸片集合进行搜索匹配，找出一个可行的解即可了。我又想当然的认为只要匹配一对集合即可了，那么很显然又是错的了。好吧，我只能对所有集合进行匹配了。对每一对集合进行深搜回溯来匹配待选的Ans，而这个Ans是从第一对集合中搜索出来的答案。<br>代码写得很冗长，很复杂，差不多200多行了。真的是水平有限，这种题很明显应该有更方便的解法的，而且我的代码应该不至于写得这么乱的。后面还是错了很多次，发现了很多bug，比如我如果搜索长度为nAnsLen/2的集合时就必须进行特殊处理。还有最后一个样例后面不能输出’\n’，而且uvaoj不能对这个换行判PE，一直是WA，实在是让人崩溃。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">256</span> + <span class="number">10</span>)</span><br><span class="line"><span class="number">#def</span>ine MAX_NUM (<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">char szLines[MAX_NUM][MAX];</span><br><span class="line">char szAns[MAX];</span><br><span class="line"></span><br><span class="line">struct SET</span><br><span class="line">&#123;</span><br><span class="line">    int nNum;</span><br><span class="line">    char szLines[MAX_NUM][MAX];</span><br><span class="line">    bool bUsed[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SET sets[MAX];</span><br><span class="line">char szTmpOne[MAX];</span><br><span class="line">char szTmpTwo[MAX];</span><br><span class="line">int nAnsLen;</span><br><span class="line">bool bFind;</span><br><span class="line"></span><br><span class="line">void dfs(int nI, int nNum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nNum == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bFind = true;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; sets[nI].nNum &amp;&amp; !bFind; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; sets[nAnsLen - nI].nNum &amp;&amp; !bFind; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nI == nAnsLen - nI &amp;&amp; <span class="selector-tag">i</span> == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!sets[nI]<span class="selector-class">.bUsed</span>[i] &amp;&amp; !sets[nAnsLen - nI]<span class="selector-class">.bUsed</span>[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    strcpy(szTmpOne, sets[nI].szLines[i]);</span><br><span class="line">                    strcat(szTmpOne, sets[nAnsLen - nI].szLines[j]);</span><br><span class="line">                    strcpy(szTmpTwo, sets[nAnsLen - nI].szLines[j]);</span><br><span class="line">                    strcat(szTmpTwo, sets[nI].szLines[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//printf("%s\n", szAns);</span></span><br><span class="line">                    if (strcmp(szTmpOne, szAns) == 0 || strcmp(szTmpTwo, szAns) == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sets[nI].bUsed[i] = sets[nAnsLen - nI].bUsed[j] = true;</span><br><span class="line">                        <span class="keyword">if</span> (!bFind)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (nI == nAnsLen - nI)</span><br><span class="line">                            &#123;</span><br><span class="line">                                dfs(nI, nNum - 2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                dfs(nI, nNum - 1);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sets[nI].bUsed[i] = sets[nAnsLen - nI].bUsed[j] = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Find(int nI)</span><br><span class="line">&#123;</span><br><span class="line">    bFind = false;</span><br><span class="line">    for (int i = 0; i &lt; sets[nI].nNum &amp;&amp; !bFind; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 0; j &lt; sets[nAnsLen - nI].nNum &amp;&amp; !bFind; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nI == nAnsLen - nI &amp;&amp; <span class="selector-tag">i</span> == j)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sets[nI].bUsed[i] = true;</span><br><span class="line">            sets[nAnsLen - nI].bUsed[j] = true;</span><br><span class="line"></span><br><span class="line">            strcpy(szAns, sets[nI].szLines[i]);</span><br><span class="line">            strcat(szAns, sets[nAnsLen - nI].szLines[j]);</span><br><span class="line">            <span class="keyword">if</span> (nI == nAnsLen - nI)</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(nI, sets[nI].nNum - 2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dfs(nI, sets[nI].nNum - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bFind)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int k = nI + 1; k &lt;= nAnsLen / 2; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    bFind = false;</span><br><span class="line">                    dfs(k, sets[k].nNum);</span><br><span class="line">                    <span class="keyword">if</span> (!bFind)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bFind)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            strcpy(szAns, sets[nAnsLen - nI].szLines[j]);</span><br><span class="line">            strcat(szAns, sets[nI].szLines[i]);</span><br><span class="line">            <span class="keyword">if</span> (nI == nAnsLen - nI)</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(nI, sets[nI].nNum - 2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dfs(nI, sets[nI].nNum - 1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bFind)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int k = nI + 1; k &lt;= nAnsLen / 2; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    bFind = false;</span><br><span class="line">                    dfs(k, sets[k].nNum);</span><br><span class="line">                    <span class="keyword">if</span> (!bFind)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bFind)</span><br><span class="line">                &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sets[nI].bUsed[i] = false;</span><br><span class="line">            sets[nAnsLen - nI].bUsed[j] = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Search()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt;= nAnsLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sets[i].nNum)</span><br><span class="line">        &#123;</span><br><span class="line">            Find(i);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCases;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#ifdef</span> CSU_YX</span><br><span class="line">    freopen("in.txt", "r", stdin);</span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line">#endif</span><br><span class="line">    scanf("%d\n", &amp;nCases);</span><br><span class="line"></span><br><span class="line">    int nNum = 0;</span><br><span class="line">    int nTotalLen = 0;</span><br><span class="line">    while (gets(szLines[nNum]), nCases)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (szLines[nNum][<span class="number">0</span>] == <span class="string">'\0'</span> &amp;&amp; nNum != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nAnsLen = nTotalLen * 2 / nNum;</span><br><span class="line">            memset(szAns, 0, sizeof(szAns));</span><br><span class="line">            Search();</span><br><span class="line">            printf("%s\n\n", szAns);</span><br><span class="line"></span><br><span class="line">            memset(sets, 0, sizeof(sets));</span><br><span class="line">            memset(szLines, 0, sizeof(szLines));</span><br><span class="line">            nNum = 0;</span><br><span class="line">            nTotalLen = 0;</span><br><span class="line">            --nCases;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (szLines[nNum][<span class="number">0</span>] != <span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            int nLen = strlen(szLines[nNum]);</span><br><span class="line">            nTotalLen += nLen;</span><br><span class="line">            strcpy(sets[nLen].szLines[sets[nLen].nNum], szLines[nNum]);</span><br><span class="line">            ++sets[nLen].nNum;</span><br><span class="line">            ++nNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无穷大数组上如何直接寻址来实现字典？</title>
      <link href="/2012/03/20/%E6%97%A0%E7%A9%B7%E5%A4%A7%E6%95%B0%E7%BB%84%E4%B8%8A%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%EF%BC%9F/"/>
      <url>/2012/03/20/%E6%97%A0%E7%A9%B7%E5%A4%A7%E6%95%B0%E7%BB%84%E4%B8%8A%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AD%97%E5%85%B8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>这是算法导论习题11.1-4。<br>具体题目如下：<br><img alt data-src="https://c5.staticflickr.com/8/7454/27312219812_3440407ffa_o.jpg"></p><p>解决该题目的要点：<br>1.由于是无穷大的数组，所以无法事先初始化该数组。<br>2.所提供的方案必须是O（1）。<br>3.使用的额外空间只能是O（n），这样平均到每一个项上的空间都是O（1）。</p><p>一时之间好像没有一点头绪，在几个群里面发问了，网上搜了很久也没有找到答案，后面一群里有个高人给了个链接，里面有解法。链接地址：</p><blockquote><p><a href="http://www.cnblogs.com/flyfy1/archive/2011/03/05/1971502.html" target="_blank" rel="noopener">http://www.cnblogs.com/flyfy1/archive/2011/03/05/1971502.html</a></p></blockquote><p>这篇文章里面另外给了个pdf，这个pdf估计是解法的来源。伪代码写得不给力，不过前面的英文描述却很清晰。说实话，这个方法很巧妙。</p><p>解法大概的意思如下：<br>开一个额外的数组A，A[0]表示A数组元素的数目(当然不包括A[0]本身)，A[i]代表插入的第i个元素的key。假设原来的无穷大数组用Huge<br>表示，如果Huge<a href="直接寻址，假设i就是key">i</a>有效，则表示其在A数组中的索引。那么如果A[Huge[i]] == i 而且 Huge[i] &lt;= A[0] &amp;&amp;<br>Huge[i] &gt; 0，则表示i这个位置已经有元素插入了。</p><p>插入：A[0]++;A[A[0]] = key; Huge[key] = A[0];<br>搜索:  A[Huge[i]] == i &amp;&amp; Huge[i] &lt;= A[0] &amp;&amp; Huge[i] &gt; 0 则return true;<br>删除:  先搜索该位置是否有元素, 如果Search(key)成功，则先把Huge[ A[A[0]] ] = Huge[key]，<br>然后交换A[A[0]]和A[Huge[key]]，A[0]—即可。<br>所有操作都是O（1），平均到每一个项，使用的空间都是O（1）。</p><p>我用代码实现的模拟如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using std::swap;</span><br><span class="line">using std::vector;</span><br><span class="line"><span class="number">#def</span>ine INF (<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">int nHuge[INF];//假设这个巨大的数组是无法初始化的</span><br><span class="line">vector&lt;int&gt; vA;</span><br><span class="line"></span><br><span class="line">void Init()</span><br><span class="line">&#123;</span><br><span class="line">    vA.push_back(0);//添加A[0]表示元素的数目</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Insert(int nKey)</span><br><span class="line">&#123;</span><br><span class="line">    vA[0]++;</span><br><span class="line">    nHuge[nKey] = vA[0];</span><br><span class="line">    vA.push_back(nKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Search(int nKey)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nHuge[nKey] &gt; <span class="number">0</span> &amp;&amp; nHuge[nKey] &lt;= vA[<span class="number">0</span>] &amp;&amp; vA[nHuge[nKey]] == nKey)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Delete(int nKey)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Search(nKey))</span><br><span class="line">    &#123;</span><br><span class="line">        nHuge[ vA[vA[0]] ] = nHuge[nKey];//将huge的最后一个元素中存储的A数组的索引改为nHuge[nKey]</span><br><span class="line">        swap(vA[vA[0]], vA[nHuge[nKey]]);//交换key</span><br><span class="line">        --vA[0];</span><br><span class="line">        vA.erase(vA.end() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">10</span>)</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Init();</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf("Search:%d %s\n", i, Search(i) == true? "Success" : "Failure");</span><br><span class="line">    &#125;</span><br><span class="line">    printf("\n");</span><br><span class="line"></span><br><span class="line">    Delete(4);</span><br><span class="line">    Delete(9);</span><br><span class="line">    Delete(1);</span><br><span class="line">    for (i = 0; i &lt; MAX * 2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf("Search:%d %s\n", i, Search(i) == true? "Success" : "Failure");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSU OJ - 1183: 计算表达式的值</title>
      <link href="/2012/03/19/CSU%20OJ%20-%201183%20%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC/"/>
      <url>/2012/03/19/CSU%20OJ%20-%201183%20%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>题目意思很简单就是计算含括号的四则运算表达式的值。这个题目很坑爹，刚做的时候，题目描述里面只说里面会有空格，后面居然把题目描述改了。所以，这个题无论怎么改，都是不对。因为，不知道是哪个坑爹的出题人，把数据里面加了\t，难道出题人以为\t也是空格。估计，后面修改题目描述，也是发现这个问题后才改的。这可是还是哥了，改了无数多遍，不处理非法数据就超时，略过非常数据当然直接WA了。好坑爹。<br>计算表达式的值，以前严蔚敏书上就说用栈构造出来后缀表达式后再计算值。但是这个方法未免太那个了，首先太麻烦了，虽然算法思路不麻烦。我的做法是直接递归计算即可。碰到左括号递归计算新的表达式，<strong>右括号作为函数终止条件</strong>。否则，按照四则运算的优先级计算当前的表达式。递归算法中需要记录前一个运算符合的优先级，<strong>如果前一个运算符的优先级比现在碰到的运算符的优先级高，那么就应该直接返回答案了</strong>，当前碰到的运算符的计算交给下一次循环好了。</p><p>代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">100</span> + <span class="number">10</span>)</span><br><span class="line">char szData[MAX];</span><br><span class="line"></span><br><span class="line">void TrimSpace(char* pszData)</span><br><span class="line">&#123;</span><br><span class="line">    char* pszRead = pszData;</span><br><span class="line">    char* pszWrite = pszData;</span><br><span class="line">    while (*pszRead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//由于数据中有\t,与先前题目描述不符合,不处理掉就直接超时了</span></span><br><span class="line">        <span class="keyword">if</span> (*pszRead != <span class="string">' '</span> &amp;&amp; *pszRead != <span class="string">'\t'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *pszWrite++ = *pszRead;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pszRead;</span><br><span class="line">    &#125;</span><br><span class="line">    *pszWrite = '\0';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nKind代表前一个运算符合的优先级,开始时是0,+-是1,*/是2</span></span><br><span class="line">double Cal(char*&amp; pszData, int nKind)</span><br><span class="line">&#123;</span><br><span class="line">    double fAns = 0.0;</span><br><span class="line">    while (*pszData &amp;&amp; *pszData != <span class="string">')'</span>)<span class="comment">//表达式终止的条件是到达'\0'或者碰到右括号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pszData &gt;= <span class="string">'0'</span> &amp;&amp; *pszData &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fAns = 10 * fAns + *pszData - '0';</span><br><span class="line">            ++pszData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pszData == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nKind &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                return fAns;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pszData;</span><br><span class="line">            fAns += Cal(pszData, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pszData == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nKind &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                return fAns;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pszData;</span><br><span class="line">            fAns -= Cal(pszData, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pszData == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nKind &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                return fAns;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pszData;</span><br><span class="line">            fAns *= Cal(pszData, 2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pszData == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nKind &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                return fAns;</span><br><span class="line">            &#125;</span><br><span class="line">            ++pszData;</span><br><span class="line">            fAns /= Cal(pszData, 2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pszData == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++pszData;</span><br><span class="line">            fAns = Cal(pszData, 0);</span><br><span class="line">            ++pszData;//移到')'后面</span><br><span class="line">            return fAns;//一个括号内的是一个完整的表达式,因此直接返回</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fAns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (gets(szData))</span><br><span class="line">    &#123;</span><br><span class="line">        TrimSpace(szData);</span><br><span class="line">        char* pszData = szData;</span><br><span class="line">        printf("%.4f\n", Cal(pszData, 0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个递归函数能计算出表达式的值，而且能处理优先级和括号，如果是以前的话，我应该是写不出来的。再把算法的实现细节改改，应该也能计算出浮点数的表达式了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu - 1225:Football Score</title>
      <link href="/2012/03/14/hdu%20-%201225Football%20Score/"/>
      <url>/2012/03/14/hdu%20-%201225Football%20Score/</url>
      
        <content type="html"><![CDATA[<p>这是个简单的字符串处理题目。看题目，数据应该不是很大，直接暴力处理可以过。如果为了加快搜索速度，在中间输入过程中排序，再二分很麻烦，速度也快不了多少，因为只是输入的过程中需要查找。但是，这个题其实很好用map做，代码量可以少很多，也很简洁。<br>写这篇blog的目的是为了提醒自己，容易题再这样错下去，真的很伤人心，学什么都没必要了，当时打算继续搞ACM的目的之一就是为了提高代码正确率。这个题，不仅细节部分没看清楚，而且写代码时候把比较函数里面的one.nLost写成了one.nGet，查错了1个多小时，还让队友帮忙查错了好久，真的很无语。写程序确实可以debug，但是这也让我养成了很严重的依赖debug的习惯。<br>人生不可以debug，人生不可以重来。记得以前很多次很多事情就是开始无所谓，后面悲催到底，无限后悔。</p><p>代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;map&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;vector&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">100</span>)</span><br><span class="line">using std::map;</span><br><span class="line">using std::string;</span><br><span class="line">using std::vector;</span><br><span class="line">using std::sort;</span><br><span class="line"></span><br><span class="line">struct INFO</span><br><span class="line">&#123;</span><br><span class="line">    INFO()</span><br><span class="line">    &#123;</span><br><span class="line">        nScore = nGet = nLost = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string strName;</span><br><span class="line">    int nScore;</span><br><span class="line">    int nGet;</span><br><span class="line">    int nLost;</span><br><span class="line">    bool operator &lt; (const INFO&amp; one) const</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nScore != one.nScore)</span><br><span class="line">        &#123;</span><br><span class="line">            return nScore &gt; one.nScore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nGet - nLost != one<span class="selector-class">.nGet</span> - one.nLost)<span class="comment">//这里把one.nLost写成了one.nGet</span></span><br><span class="line">        &#123;</span><br><span class="line">            return nGet - nLost &gt; one.nGet - one.nLost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nGet != one.nGet)</span><br><span class="line">        &#123;</span><br><span class="line">            return nGet &gt; one.nGet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            return strName &lt; one.strName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//freopen("in.txt", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("out.txt", "w", stdout);</span></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nLast = nN * (nN - 1);</span><br><span class="line">        char szOne[MAX];</span><br><span class="line">        char szTwo[MAX];</span><br><span class="line">        int nOne, nTwo;</span><br><span class="line"></span><br><span class="line">        map&lt;string, INFO&gt; myMap;</span><br><span class="line">        for (int i = 0; i &lt; nLast; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%s %*s %s %d:%d", szOne, szTwo, &amp;nOne, &amp;nTwo);</span><br><span class="line">            <span class="comment">//printf("%s %s %d %d\n", szOne, szTwo, nOne, nTwo);</span></span><br><span class="line"></span><br><span class="line">            string strOne = szOne;</span><br><span class="line">            myMap[strOne].strName = strOne;</span><br><span class="line">            myMap[strOne].nGet += nOne;</span><br><span class="line">            myMap[strOne].nLost += nTwo;</span><br><span class="line"></span><br><span class="line">            string strTwo = szTwo;</span><br><span class="line">            myMap[strTwo].strName = strTwo;</span><br><span class="line">            myMap[strTwo].nGet += nTwo;</span><br><span class="line">            myMap[strTwo].nLost += nOne;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nOne &gt; nTwo)</span><br><span class="line">            &#123;</span><br><span class="line">                myMap[strOne].nScore += 3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nOne == nTwo)</span><br><span class="line">            &#123;</span><br><span class="line">                myMap[strOne].nScore += 1;</span><br><span class="line">                myMap[strTwo].nScore += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                myMap[strTwo].nScore += 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map&lt;string, INFO&gt;::iterator it;</span><br><span class="line">        vector&lt;INFO&gt; myVt;</span><br><span class="line">        for (it = myMap.begin(); it != myMap.end(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            myVt.push_back(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(myVt.begin(), myVt.end());</span><br><span class="line">        for (int i = 0; i &lt; myVt.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%s %d\n", myVt[i].strName.c_str(), myVt[i].nScore);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("\n");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个栈实现一个队列 和 两个队列实现一个栈</title>
      <link href="/2012/03/11/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%20%E5%92%8C%20%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88/"/>
      <url>/2012/03/11/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%20%E5%92%8C%20%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>两个栈实现一个队列<br>要求：只能使用栈的pop和push，以及测试栈是否为空三个操作。<br>实现思路：<br>队列里面使用stack one 和 stack two。<br>进队列时，直接进入栈one即可。<br>出队列时，从two弹出一个元素，如果two里面的元素为空，则将one里面的元素依次弹出并压入two中，再从two弹出一个元素返回。</p><p>用STL里面的stack模拟实现queue的代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stack&gt;</span><br><span class="line">using std::stack;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; class CQueue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CQueue()</span><br><span class="line">    &#123;</span><br><span class="line">        nSize = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void <span class="attribute">clear</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        while (!one.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            one.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while (!two.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            two.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(const T&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        one.push(t);</span><br><span class="line">        ++nSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (two.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            while (!one.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                two.push(one.<span class="attribute">top</span>());</span><br><span class="line">                one.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        two.pop();</span><br><span class="line">        --nSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; front()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (two.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            while (!one.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                two.push(one.<span class="attribute">top</span>());</span><br><span class="line">                one.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return two.<span class="attribute">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; back()</span><br><span class="line">    &#123;</span><br><span class="line">        return one.<span class="attribute">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return nSize == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;T&gt; one;</span><br><span class="line">    stack&lt;T&gt; two;</span><br><span class="line">    int nSize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX <span class="number">20</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CQueue&lt;int&gt; q;</span><br><span class="line"></span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    for (int i = 0; i &lt; MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q.push(i);</span><br><span class="line"></span><br><span class="line">        if (rand() % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("front: %d\n", q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!<span class="selector-tag">q</span>.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        printf("front: %d\n", q.front());</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个队列实现一个栈<br>要求：只能使用从队列的尾部入和头部出，以及测试队列是否为空三个操作。<br>实现思路：<br>队列里面使用queue one 和 stack two。<br>进栈时，根据当前元素是全部存储在哪个队列而选择从one或者two的尾部进入。<br>出栈时，假设当前元素都存储在one里面，则不断出队列，直到队列为空之前的所有元素一次进入队列two，而one里面的最后一个元素作为栈弹出的值返回。<br>对于当前元素是存储在哪个队列里面，可以设置变量标记，初始化时候存储在one里面，操作一次，由于元素要倒转，则存储位置会变一次。</p><p>用STL里面的queue模拟实现的stack代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;queue&gt;</span><br><span class="line">using std::queue;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; class CStack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    CStack()</span><br><span class="line">    &#123;</span><br><span class="line">        nSize = 0;</span><br><span class="line">        nTime = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void <span class="attribute">clear</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        while (!one.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            one.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        while (!two.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            two.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(const T&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        if (nTime % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            one.push(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            two.push(t);</span><br><span class="line">        &#125;</span><br><span class="line">        ++nSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop()</span><br><span class="line">    &#123;</span><br><span class="line">        if (nTime % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            while (!one.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                T t = one.front();</span><br><span class="line">                one.pop();</span><br><span class="line">                <span class="keyword">if</span> (!one.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    two.push(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            while (!two.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                T t = two.front();</span><br><span class="line">                two.pop();</span><br><span class="line">                <span class="keyword">if</span> (!two.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    one.push(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nTime = (nTime + 1) % 2;</span><br><span class="line">        --nSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="attribute">top</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        if (nTime % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            while (!one.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                T t = one.front();</span><br><span class="line">                one.pop();</span><br><span class="line">                <span class="keyword">if</span> (!one.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    two.push(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    two.push(t);</span><br><span class="line">                    nTime = (nTime + 1) % 2;</span><br><span class="line">                    return two.back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            while (!two.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                T t = two.front();</span><br><span class="line">                two.pop();</span><br><span class="line">                <span class="keyword">if</span> (!two.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    one.push(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    one.push(t);</span><br><span class="line">                    nTime = (nTime + 1) % 2;</span><br><span class="line">                    return one.back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty()</span><br><span class="line">    &#123;</span><br><span class="line">        return nSize == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    queue&lt;T&gt; one;</span><br><span class="line">    queue&lt;T&gt; two;</span><br><span class="line">    int nSize;</span><br><span class="line">    int nTime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX <span class="number">20</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    CStack&lt;int&gt; stack;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; MAX; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"top: %d\n"</span>, stack.<span class="attribute">top</span>());</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮局位置问题和带权中位数</title>
      <link href="/2012/03/11/%E9%82%AE%E5%B1%80%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%92%8C%E5%B8%A6%E6%9D%83%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2012/03/11/%E9%82%AE%E5%B1%80%E4%BD%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%92%8C%E5%B8%A6%E6%9D%83%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>带权中位数定义如下：<br><img alt data-src="https://c3.staticflickr.com/8/7433/27312306842_c847ce5c27_o.jpg"></p><p>邮局位置问题定义如下：<br><img alt data-src="https://c1.staticflickr.com/8/7123/27312315312_79d8c06f47_o.jpg"></p><p>上一篇文章输油管道问题里面证明了，当权值Wi都为1的时候，中位数就是最佳的解。但是，现在Wi已经不一定是1了。所以，现在<br>需要证明在任意Wi的取值情况下，带权中位数能够成为邮局位置的最佳解。假设，所有Wi都是1的倍数，如果是小数的话，可以所有的<br>Wi都乘以一定的倍数。那么wi<em>d(p,pi) = Σ(p,pi)(i从1到wi)，这个意思是把距离乘以了wi倍。<br>但是，现在可以换一种看法，换成了pi位置有wi个重合的点，且每一个点的权值都是1，那么其和也是wi</em>d(p,pi)。<strong>那么对所有的pi<br>都这样分解，就把问题重新转换成了输油管道问题了</strong>。输油管道问题的最优解就是中位数，那么邮局问题的最优解就是<strong>转换之后的<br>这些点的中位数点</strong>。而这个点一定存在于<strong>带权中位数</strong>那个点分解出的一堆点中。<br>二维邮局问题的解法是把x和y分开求2次一维邮局问题，然后把解组和起来，得到答案。</p><p>求带权中位数的算法比较简单，直接的做法是，先把n个点按照位置排序，然后按点的位置从小到大遍历，找到满足要求的点即可。<br>不算排序点位置的预处理，因为很多时候点应该就是按顺序给出的，所以其时间复杂度是O(n)。<br>要求：<img alt data-src="https://c6.staticflickr.com/8/7430/26803630933_bbf4ab1389_o.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中位数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输油管道问题(POJ - 1723)</title>
      <link href="/2012/03/09/%E8%BE%93%E6%B2%B9%E7%AE%A1%E9%81%93%E9%97%AE%E9%A2%98(POJ%20-%201723)/"/>
      <url>/2012/03/09/%E8%BE%93%E6%B2%B9%E7%AE%A1%E9%81%93%E9%97%AE%E9%A2%98(POJ%20-%201723)/</url>
      
        <content type="html"><![CDATA[<p>先看算导上输油管道问题的描述：<br><img alt data-src="https://c4.staticflickr.com/8/7589/27410289675_6cabb3a489_o.jpg"></p><p>这个题，虽然说给出了井的x,y坐标，但是要修建的主管道却只是一条横向的，而且其余管道也只是到这条管道的竖向距离。那么，就转换为确定一条直线 y = m，使得其它个点到这条直线的距离最多。也许不需要多的提示，大家的直觉就会想到应该所有y值的中点。但是，这个的证明却不是那么的明显。</p><p>证明如下：<br>设所有的y值系列为y1,y2,…,yn，并且假设这个是按递增排列的。我们要求的是Sum = Σ|yi-m|(1&lt;=i&lt;=n),</p><p><strong>1）显然假如选小于y1或者大于yn的y=m都不会比选y1或者yn更好。<br>2）如果选y1或者yn，那么|y1-m|+|yn-m| = |yn-y1|都是一样的结果，甚至选y1和yn之间的任意一个值。<br>3）如此继续下去，对于y2和yn，也有2）所描述的性质<br>4）继续到最后，只需要取最中间一对点之间的值即可，如果n是奇数，那么就是中间的点，如果n是偶数，取任意一个中间点都可以</strong>。</p><p>通过上面证明，我们可以选取第y(n/2 + 1)作为修建主管道的地方。当然这可能是唯一的最优选择，或者无数个最优选择中的一个。那么现在已经转换为求中位数了，求中位数的办法最简单的是对序列排序然后取中间的即可。算法导论上有一种平均代价<strong>O(n)</strong>的办法，思路类似于快速排序，快排的每一次操作都是划分数组，前小后大，如果我们也这一次次去划分数组，刚好轴元素处于我们要求的那个位置上那么就达到我们的目的了，下面的代码中<strong>Select</strong>函数就是求一个数组的中位数。</p><p>对于POJ 1723题，很显然y的选择是中位数即可，x的选择需要转换一下也变成求中位数了。题目中描述，最后要达到的效果是每个士兵都占成一横排，而且彼此相邻，也就是y相同，但是x系列k,k+1,k+2,…,k+n-1。那么如何从原来的x0,x1,x2,…,x(n-1)移动过去了。可以简单的考虑下，<strong>将最左边的士兵移动到k,次左的移动到k+1,…,最右边的移动到k+n-1</strong>，所需要的移动之和一定是最小的。那么我们可以将原来的x0-x(n-1)排序，得到x’0,x’1,…,x’(n-1),要求的<strong>Sum = **</strong>Σ|x’i - (k + i)| = Σ|(x’i - i) -  k|**,那么要使Sum最小，只需要求序列X’i - i的中位数即可了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line">using std::sort;</span><br><span class="line">using std::swap;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">10000</span> + <span class="number">10</span>)</span><br><span class="line">int Partion(int* pnA, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = j = 0; i &lt; nLen - 1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pnA[i] &lt; pnA[nLen - 1]) &#123; swap(pnA[i], pnA[j++]); &#125; &#125; swap(pnA[j], pnA[nLen - 1]); return j; &#125; int Select(int* pnA, int nLen, int nIndex) &#123; if (nLen &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        int nP = Partion(pnA, nLen);</span><br><span class="line">        <span class="keyword">if</span> (nP + <span class="number">1</span> == nIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            return pnA[nP];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nP + <span class="number">1</span> &gt; nIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            return  Select(pnA, nP, nIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            return Select(pnA + nP + 1, nLen - nP - 1, nIndex - nP - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return pnA[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nX[MAX];</span><br><span class="line">    int nY[MAX];</span><br><span class="line">    int nN;</span><br><span class="line">    int i;</span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d%d", &amp;nX[i], &amp;nY[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int nMY = Select(nY, nN, nN / 2 + 1);</span><br><span class="line">        sort(nX, nX + nN);</span><br><span class="line">        for (i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nX[i] = nX[i] - i;</span><br><span class="line">        &#125;</span><br><span class="line">        int nMX = Select(nX, nN, nN / 2 + 1);</span><br><span class="line">        int nSum = 0;</span><br><span class="line">        for (i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nSum += abs(nX[i] - nMX);</span><br><span class="line">            nSum += abs(nY[i] - nMY);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d\n", nSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中位数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快排的一种简易写法</title>
      <link href="/2012/03/03/%E5%BF%AB%E6%8E%92%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E6%98%93%E5%86%99%E6%B3%95/"/>
      <url>/2012/03/03/%E5%BF%AB%E6%8E%92%E7%9A%84%E4%B8%80%E7%A7%8D%E7%AE%80%E6%98%93%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>虽然简易二字，因人而异。不过，写一个快排确实并不需要过20行，超过几分钟时间的代码。面试的时候，面试官确实会经常问起快排什么的。但是，大家上的入门课基本是使用严蔚敏老奶奶的教材，上面对于快排的讲解我是不敢恭维的。至少上面关于快排的写法，我是写过好几次之后都是没掌握好的。后面，应该是看K&amp;R的c语言程序设计时候，发现一种更简便的partion方法，但是当时我也没怎么掌握。这一切直到，寒假认真阅读算法导论的时候。</p><p>不用算法牛人，算法学得好或者对快排理解深刻的，不用把这篇文章看完了，相信你们都能在10分钟之内写一个正确的快排了。<br>废话少说，还是来讲讲如何保证10分钟之内写一个正确的快排，而且以后都能10分钟之内写出来，而不是此刻看了我说的这些胡言之后。</p><p>快排的主函数大家都会，现在我给个简易点的样子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void QuickSort(int* pnA, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nLen &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nP = Partion(pnA, nLen);</span><br><span class="line">        QuickSort(pnA, nP);//排序第nP+1个元素前面的nP个元素</span><br><span class="line">        QuickSort(pnA + nP + 1, nLen - nP - 1);//排序第nP+1个元素后面的元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在就剩下Partion函数了。<br>我记得严蔚敏书上的写法中Partion 函数里面是有几个循环的。而且即使大概写出来了，也很难处理正确边界。<br>现在，我要说的就是算法导论上，作为教材内容出现的Partion函数。还是看代码吧。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int Partion(int* pnA, int nLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里选择最后一个元素作为轴元素</span></span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = j = 0; i &lt; nLen - 1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pnA[i] &lt; pnA[nLen - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(pnA[i], pnA[j];//交换2个数的函数，大家都能写吧，stl中也有</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(pnA[j], pnA[nLen - 1]);</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了公平起见，上面的代码我都是在blog上面直接敲的，写这10多行代码是绝对用不了10分钟的。主递归函数大家都会写，Partion函数里面只有一个for循环，所以只要明确了for循环的意思，快排的速写就迎刃而解了。其实，按照算导的说法，<strong>这个for一直在划分区间。区间[0,j-1]是小于最后一个元素的区间，[j,nLen - 2]是大于等于最后一个元素的区间，所以最后将第nLen-1个元素与第j个元素交换即可，Partion应该返回的值也应该是j</strong>。<br>我不知道大家理解上面那句黑体字的话没，如果理解了，随便写个快排是没问题了。至少，可能的下次面试时候，可以潇洒地写个快排给面试官看看了，虽然这也许并不是什么值得庆幸的事情。</p><p>算法导论里面的快速排序那章后面还有思考题，其中第一个思考题，提出的另外一种叫做Hoare划分的partion写法，意思就和严蔚敏书上的partion函数一致的。理解的关键是，<strong>轴元素一直处于被交换中</strong>。只要发现了这点，写一两次后，这种partion方法也能掌握好了，不过写起来是循环嵌循环了，没那么舒服。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何生成均匀随机排列(等概率生成排列)</title>
      <link href="/2012/02/26/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9D%87%E5%8C%80%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%88%97(%E7%AD%89%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97)/"/>
      <url>/2012/02/26/%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9D%87%E5%8C%80%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%88%97(%E7%AD%89%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97)/</url>
      
        <content type="html"><![CDATA[<p>这个算法的应用，比如洗牌，这个大家都非常熟悉。很久以前用的是最原始的方法，就是一直rand()未出现的牌，直至生成所有的牌。这当然是一个while(1)循环，很烂的算法吧。后面听说直接交换牌，打乱即可了。但是打乱后生成的排列是随机的么，是等可能随机的么。<br>其实，这个问题上算法导论上早已经有了答案了，看过算法导论之后觉得没看之前真的是算法修养太差了。<br>算法的伪代码如下图所示：<br><img alt data-src="https://c6.staticflickr.com/8/7645/27410389005_f5ea860442_o.jpg"></p><p>具体c++实现如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;assert.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;<span class="selector-tag">time</span>.h&gt;</span><br><span class="line"><span class="comment">// void Swap(int&amp; nOne, int&amp; nTwo)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  nOne = nOne + nTwo;</span></span><br><span class="line"><span class="comment">//  nTwo = nOne – nTwo;</span></span><br><span class="line"><span class="comment">//  nOne = nOne – nTwo;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">void Swap(int&amp;  nOne, int&amp;  nTwo)</span><br><span class="line">&#123;</span><br><span class="line">    int nTemp;</span><br><span class="line">    nTemp = nOne;</span><br><span class="line">    nOne = nTwo;</span><br><span class="line">    nTwo = nTemp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回一个在区间[nBeg, nEnd]内的随机数</span></span><br><span class="line">int Random(int nBeg, int nEnd)</span><br><span class="line">&#123;</span><br><span class="line">    assert(nEnd &gt;= nBeg);</span><br><span class="line">    <span class="keyword">if</span> (nBeg == nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        return nBeg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        return rand() % (nEnd – nBeg + 1) + nBeg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void RandomizeInPlace(int* pnA, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    static bool s_bFirst = false;</span><br><span class="line">    <span class="keyword">if</span> (!s_bFirst)</span><br><span class="line">    &#123;</span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        s_bFirst = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Swap(pnA[i], pnA[Random(i, nLen - 1)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nArray[20];</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = 1; i &lt;= 20; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int nCnt = i;</span><br><span class="line">        while (nCnt–)</span><br><span class="line">        &#123;</span><br><span class="line">            for (j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                nArray[j] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            RandomizeInPlace(nArray, i);</span><br><span class="line">            for (j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                printf("%d", nArray[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf("\n");</span><br><span class="line">        &#125;</span><br><span class="line">        printf("\n");</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果图片如下：<br><img alt data-src="https://c5.staticflickr.com/8/7321/27418169396_3d5491830a_o.jpg"><br>根据运行结果大致就可以感觉到，生成的排列都是随机的。<br>这里要多说一句那就是我注释的那个交换函数其实是有bug的，也许这才是不提倡使用这个交换方法的真正原因，而不仅仅是难以理解。用同一个变量去调用该函数，会将该变量置0，而不是保持原来的值！！！至于如何证明这个算法生成的均匀随机的排列，可以参考算法导论5.3节最后一部分。<br>证明的大致思路是利用循环不变式的证明方法：证明i次循环后得到某个排列的概论是(n -i)! / n!，那么n次循环后得到最终那个排列的<br>概论就是1/n!，这样就证明了该算法能够得到均匀随机排列。<br>这个算法其实就是随机化算法的一种，其实快排也有所谓的随机化版本，改动的地方只是随机选择了中轴元素而已，这个在算法导论上也有介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成均匀随机排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义可变参数函数BatchDelFile, 调用cmd批量删除指定格式文件, Windows界面下不回显Console窗口</title>
      <link href="/2012/01/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0BatchDelFile,%20%E8%B0%83%E7%94%A8cmd%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6,%20Windows%E7%95%8C%E9%9D%A2%E4%B8%8B%E4%B8%8D%E5%9B%9E%E6%98%BEConsole%E7%AA%97%E5%8F%A3/"/>
      <url>/2012/01/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0BatchDelFile,%20%E8%B0%83%E7%94%A8cmd%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6,%20Windows%E7%95%8C%E9%9D%A2%E4%B8%8B%E4%B8%8D%E5%9B%9E%E6%98%BEConsole%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>今天在做课设，由于想给程序加上删除以前的配置文件的功能，由于某种原因，同类型的文件比较多，加上暑假实习的时候，做了个用dir命令实现的批量文件修改器，所以决定用del命令，一下子写好后，发现以前由于没有要求做界面，而现在课设我用的是MFC里面的CFormView做的界面，所以会闪烁而过一个console窗口，实在不爽之，所以，找方法去掉它。<br>网上找来找去，只找到启动cmd，传参数的都很少，传参数时候组合参数的更加少，加上我对dos命令不熟悉，所以实在悲催，浪费了不少时间。<br>这种东西，一直窃以为有人做好之后，提供比较合格的接口，大家以后都方便，所以贴出来，大家雅俗共赏，批评下。还发现网上的代码有个问题，居然大多把直接cmd路径写上去，其实大家都知道，系统路径是不确定的，所以特定修正了这个bug，而且我也实验了下，无论参数是绝对路径还是相对路径这个函数都是有效的。<br>大家用这个函数的时候，记得cmd命令都是可以匹配通配符的哦。</p><p>函数代码如下:</p><p>//批量删除指定格式文件,不显示console窗口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void BatchDelFile(char* pszFile)</span><br><span class="line">&#123;</span><br><span class="line">    char szDelCmd[MAX_INFO_LEN];</span><br><span class="line">    char szCurDir[MAX_PATH];</span><br><span class="line">    char szCmdPath[MAX_PATH];</span><br><span class="line">    SHELLEXECUTEINFO shExecInfo = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    GetCurrentDirectory(MAX_PATH, szCurDir);//获取当前路径</span><br><span class="line">    GetSystemDirectory(szCmdPath, MAX_PATH);//获取cmd路径</span><br><span class="line">    strcat(szCmdPath, "\\cmd.exe");</span><br><span class="line">    sprintf(szDelCmd, <span class="string">"%s /c del /f /q /s %s"</span>,</span><br><span class="line">    szCmdPath, pszFile);//格式化出命令字符串, 注意加上/c, 还有那2个""</span><br><span class="line"></span><br><span class="line">    shExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);</span><br><span class="line">    shExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;</span><br><span class="line">    shExecInfo.hwnd = NULL;</span><br><span class="line">    shExecInfo.lpVerb = NULL;</span><br><span class="line">    shExecInfo.lpFile = szCmdPath;//cmd的路径</span><br><span class="line">    shExecInfo.lpParameters = szDelCmd;//程序参数,参数格式必须保证正确</span><br><span class="line">    shExecInfo.lpDirectory = szCurDir;//如果szFile是相对路径,那个这个参数就会起作用</span><br><span class="line">    shExecInfo.nShow = SW_HIDE;//隐藏cmd窗口</span><br><span class="line">    shExecInfo.hInstApp = NULL;</span><br><span class="line">    ShellExecuteEx(&amp;shExecInfo);</span><br><span class="line">    WaitForSingleObject(shExecInfo.hProcess, INFINITE);//无限等待cmd窗口执行完毕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是我在一个消息出来函数的调用：<br>char szDelFiles[MAX_PATH];<br>sprintf(szDelFiles, “\”<em>.tcp.txt\” + \”</em>.udp.txt\””);<br>BatchDelFile(szDelFiles);</p><p>为了调用方便，我还实现了一个可变参数列表的版本，以及一个传一个文件名数组的版本。</p><p>可变参数版本代码如下：<br>//批量删除指定格式文件,不显示console窗口</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void BatchDelFile(int nNum, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list argPtr;</span><br><span class="line">    int i;</span><br><span class="line">    char* pszDelCmd;</span><br><span class="line">    char szCurDir[MAX_PATH];</span><br><span class="line">    char szCmdPath[MAX_PATH];</span><br><span class="line">    SHELLEXECUTEINFO shExecInfo = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    pszDelCmd = (char*)malloc((nNum + 2)* MAX_PATH);</span><br><span class="line">    GetCurrentDirectory(MAX_PATH, szCurDir);//获取当前路径</span><br><span class="line">    GetSystemDirectory(szCmdPath, MAX_PATH);//获取cmd路径</span><br><span class="line">    strcat(szCmdPath, "\\cmd.exe");</span><br><span class="line">    sprintf(pszDelCmd, "%s /c del /f /q /s ", szCmdPath);//格式化出命令字符串, 注意加上/c</span><br><span class="line">    va_start(argPtr, nNum);</span><br><span class="line">    for(i = 0; i &lt; nNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        strcat(pszDelCmd, "\"");</span><br><span class="line">        strcat(pszDelCmd, *(char**)argPtr);</span><br><span class="line">        strcat(pszDelCmd, "\"");</span><br><span class="line">        <span class="keyword">if</span> (<span class="selector-tag">i</span> != nNum - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            strcat(pszDelCmd, " + ");</span><br><span class="line">        &#125;</span><br><span class="line">        va_arg(argPtr, char**);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(argPtr);</span><br><span class="line">    shExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);</span><br><span class="line">    shExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;</span><br><span class="line">    shExecInfo.hwnd = NULL;</span><br><span class="line">    shExecInfo.lpVerb = NULL;</span><br><span class="line">    shExecInfo.lpFile = szCmdPath;//cmd的路径</span><br><span class="line">    shExecInfo.lpParameters = pszDelCmd;//程序参数,参数格式必须保证正确</span><br><span class="line">    shExecInfo.lpDirectory = szCurDir;//如果szFile是相对路径,那个这个参数就会起作用</span><br><span class="line">    shExecInfo.nShow = SW_HIDE;//隐藏cmd窗口</span><br><span class="line">    shExecInfo.hInstApp = NULL;</span><br><span class="line">    ShellExecuteEx(&amp;shExecInfo);</span><br><span class="line">    WaitForSingleObject(shExecInfo.hProcess, INFINITE);//无限等待cmd窗口执行完毕</span><br><span class="line">    free(pszDelCmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：<br>BatchDelFile(2, “<em>.tcp.txt”, “</em>.udp.txt”);//第一个是文件个数，后面依次是文件路径，文件路径可以是相对路径也可以是绝对路径。</p><p>文件名数组的版本代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void BatchDelFile(int nNum, char** pszFiles)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    char* pszDelCmd;</span><br><span class="line">    char szCurDir[MAX_PATH];</span><br><span class="line">    char szCmdPath[MAX_PATH];</span><br><span class="line">    SHELLEXECUTEINFO shExecInfo = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    pszDelCmd = (char*)malloc((nNum + 2)* MAX_PATH);</span><br><span class="line">    GetCurrentDirectory(MAX_PATH, szCurDir);//获取当前路径</span><br><span class="line">    GetSystemDirectory(szCmdPath, MAX_PATH);//获取cmd路径</span><br><span class="line">    strcat(szCmdPath, "\\cmd.exe");</span><br><span class="line">    sprintf(pszDelCmd, "%s /c del /f /q /s ", szCmdPath);//格式化出命令字符串, 注意加上/c</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; nNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        strcat(pszDelCmd, "\"");</span><br><span class="line">        strcat(pszDelCmd, *(pszFiles + i));</span><br><span class="line">        strcat(pszDelCmd, "\"");</span><br><span class="line">        <span class="keyword">if</span> (<span class="selector-tag">i</span> != nNum - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            strcat(pszDelCmd, " + ");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);</span><br><span class="line">    shExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;</span><br><span class="line">    shExecInfo.hwnd = NULL;</span><br><span class="line">    shExecInfo.lpVerb = NULL;</span><br><span class="line">    shExecInfo.lpFile = szCmdPath;//cmd的路径</span><br><span class="line">    shExecInfo.lpParameters = pszDelCmd;//程序参数,参数格式必须保证正确</span><br><span class="line">    shExecInfo.lpDirectory = szCurDir;//如果szFile是相对路径,那个这个参数就会起作用</span><br><span class="line">    shExecInfo.nShow = SW_HIDE;//隐藏cmd窗口</span><br><span class="line">    shExecInfo.hInstApp = NULL;</span><br><span class="line">    ShellExecuteEx(&amp; shExecInfo);</span><br><span class="line">    WaitForSingleObject(shExecInfo.hProcess, INFINITE);//无限等待cmd窗口执行完毕</span><br><span class="line">    free(pszDelCmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char* szFiles[2];</span><br><span class="line">szFiles[0] = "*.tcp.txt";</span><br><span class="line">szFiles[1] = "*.udp.txt";</span><br><span class="line">BatchDelFile(2, szFiles);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成排列的算法(POJ - 1256 和 POJ百练 - 1833)</title>
      <link href="/2011/12/26/%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95(POJ%20-%201256%20%E5%92%8C%20POJ%E7%99%BE%E7%BB%83%20-%201833)/"/>
      <url>/2011/12/26/%E7%94%9F%E6%88%90%E6%8E%92%E5%88%97%E7%9A%84%E7%AE%97%E6%B3%95(POJ%20-%201256%20%E5%92%8C%20POJ%E7%99%BE%E7%BB%83%20-%201833)/</url>
      
        <content type="html"><![CDATA[<p>题目1描述:<br>输入:一个序列s,该序列里面可能会有同样的字符,不一定有序<br>输出:打乱输入中的序列,可能产生的所有新的序列<br>题目2描述:</p><p><div>输入:一个序列s,该序列里面可能会有同样的字符,不一定有序 和 一个整数k<br>输出:该序列往后计算第k个序列,所有序列是以字典序排序的如果会有序搜索的童鞋自然而然能立刻做出来第一个题目,可是第二个题目在s较长的情况下,却需要用模拟而不是搜索…<br>大家都知道STL里面有个泛函模版, prev_permutation和next_permutation,用法也很简单,实现的就是题目2的功能…<br>但是算法最好得靠自己想出来,自己想出来的才是自己的,碰到新的问题才能产生思想的火花…废话少说,题目1的解法就是深搜,不过需要加上一个bool数组标记和一个函数确定不同字符之间的大小(有可能这个大小还不是Ascii码就能决定的),<br>大致描述下搜索过程,比如输入序列是12345,那么我搜索的过程大致是第一层按顺序选取1-5,进入第二层的时候也是按顺序选取1-5,<br>以此类推,但是每一层里面都只能选前面的层次没有选过的数,而且因为有重复字符,算法还必须保证每一层里面按顺序选取的字符必须是升序的,<br>熟悉顺序搜索和回溯的同学,很自然就会产生这样的想法…<br>POJ - 1256的代码如下:</div></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;ctype.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">13</span> + <span class="number">10</span>)</span><br><span class="line">using namespace std;</span><br><span class="line">bool bUsed[MAX];</span><br><span class="line">char szAns[MAX];</span><br><span class="line">char szInput[MAX];</span><br><span class="line">bool CmpChar(char chOne, char chTwo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (abs(chOne - chTwo) != <span class="string">'a'</span> - <span class="string">'A'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return tolower(chOne) - tolower(chTwo) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return chOne - chTwo &lt; 0;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">bool Greater(char chOne, char chTwo) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (abs(chOne - chTwo) != <span class="string">'a'</span> - <span class="string">'A'</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        return tolower(chOne) - tolower(chTwo) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return chOne - chTwo &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Gen(int nDepth, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nDepth == nLen)</span><br><span class="line">    &#123;</span><br><span class="line">        szAns[nLen] = '\0';</span><br><span class="line">        printf("%s\n", szAns);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char chLast = '\0';</span><br><span class="line">    for (int i = 0; i &lt; nLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bUsed[i] &amp;&amp; Greater(szInput[i], chLast))</span><br><span class="line">        &#123;</span><br><span class="line">            bUsed[i] = true;</span><br><span class="line">            szAns[nDepth] = szInput[i];</span><br><span class="line">            Gen(nDepth + 1, nLen);</span><br><span class="line">            bUsed[i] = false;</span><br><span class="line">            chLast = szInput[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCases;</span><br><span class="line"></span><br><span class="line">    scanf("%d", &amp;nCases);</span><br><span class="line">    while (nCases--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%s", szInput);</span><br><span class="line">        int nLen = strlen(szInput);</span><br><span class="line">        sort(szInput, szInput + nLen, CmpChar);</span><br><span class="line">        Gen(0, nLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目2的解法是模拟,功能类似与STL的那2个泛型模版函数,算法的大致过程是想办法从当前序列进入下一个刚好比其大或者刚好比其小的序列…很自然我们想到要把序列后面大的字符交和前面小的字符交换就会使序列变大,为了使其刚好变大,可以把交换后的字符从交换位置起至最后都排序一下,现在的问题是我们如何选取2个字符交换…正确的想法是,我们从最后面开始往前面看,寻找一个最长的递增序列,找到之后,我们只需要选取递增序列前面的那个字符chBefore和递增序列里面的一个最小的比chBefore大的字符交换即可…交换之后,将新的递增序列排序一下即可…<br>为什么这样做了,因为从后往前看的递增序列,是不能交换2个字符让当前序列变大的,所以必须选取最长递增序列前面的那个字符交换…</p><p>POJ百练 - 1833 的代码如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">1024</span> + <span class="number">10</span>)</span><br><span class="line">using namespace std;</span><br><span class="line">int nInput[MAX];</span><br><span class="line">void GetNext(int* nInput, int nLen)</span><br><span class="line">&#123;</span><br><span class="line">    int i = nLen - 2;</span><br><span class="line">    while (<span class="selector-tag">i</span> &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nInput[i] &gt;= nInput[<span class="selector-tag">i</span> + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            int k = i + 1;</span><br><span class="line">            for (int j = nLen - 1; j &gt; i; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nInput[j] &gt; nInput[i] &amp;&amp; nInput[j] &lt; nInput[k])</span><br><span class="line">                &#123;</span><br><span class="line">                    k = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nInput[i], nInput[k]);</span><br><span class="line">            sort(nInput + i + 1, nInput + nLen);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(nInput, nInput + nLen);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCases;</span><br><span class="line">    scanf("%d", &amp;nCases);</span><br><span class="line">    while (nCases--)</span><br><span class="line">    &#123;</span><br><span class="line">        int nLen;</span><br><span class="line">        int nK;</span><br><span class="line">        scanf("%d%d", &amp;nLen, &amp;nK);</span><br><span class="line">        for (int i = 0; i &lt; nLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d", &amp;nInput[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nK; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            GetNext(nInput, nLen);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nLen; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d%s", nInput[i], i == nLen - 1 ? "\n" : " ");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全排列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2774:木材加工</title>
      <link href="/2011/12/08/POJ%E7%99%BE%E7%BB%83%20-%202774%E6%9C%A8%E6%9D%90%E5%8A%A0%E5%B7%A5/"/>
      <url>/2011/12/08/POJ%E7%99%BE%E7%BB%83%20-%202774%E6%9C%A8%E6%9D%90%E5%8A%A0%E5%B7%A5/</url>
      
        <content type="html"><![CDATA[<p>链接: <a href="http://poj.grids.cn/practice/2774" target="_blank" rel="noopener">http://poj.grids.cn/practice/2774</a></p><p>这个题可以用二分解,虽然也有dp的解法。可能用二分解这个题不是很明显,但是确实是可以的。最大的解就是所有的棍子长/要求的棍子数,最小的解是0,直接在其中进行二分即可。这个题属于二分出最大满足条件的解的情况。这个题为什么能够二分了。我是这样想的。首先,解空间确实是有序的吧,从数字0-数字nSum/nK。其次,对于任意一个处于这个范围内的数字,只有满足和满足题目要求2种情况,那么和我们二分数字有什么区别了,我们二分一个有序数组,看里面有没有某个数字,是不是也只要判断下nMid满足是否条件是吧。所以,这个题是可以二分的。二分的条件就是解空间有序的,或者可以方便在解空间里面跳跃。而且这个题的二分还需要点技巧,因为是查找满足条件的最大解。</p><p>代码:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> </span><br><span class="line"><span class="selector-id">#include</span> </span><br><span class="line"><span class="selector-id">#include</span> </span><br><span class="line"><span class="number">#def</span>ine MAX (<span class="number">10000</span> + <span class="number">10</span>)</span><br><span class="line">using namespace std;</span><br><span class="line">int nN, nK;</span><br><span class="line">int nWoods[MAX];</span><br><span class="line">bool IsAnsOk(int nAns)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nAns == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        int nTotal = 0;</span><br><span class="line">        for (int i = nN - 1; i &gt;= 0; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            nTotal += nWoods[i] / nAns;</span><br><span class="line">            <span class="keyword">if</span> (nTotal &gt;= nK)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int SearchAns(int nMax)</span><br><span class="line">&#123;</span><br><span class="line">    int nBeg = 0, nEnd = nMax;</span><br><span class="line">    while (nBeg &lt;= nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        int nMid = (nBeg + nEnd) / 2;</span><br><span class="line">        <span class="keyword">if</span> (IsAnsOk(nMid))</span><br><span class="line">        &#123;</span><br><span class="line">            nBeg = nMid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nEnd = nMid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nBeg - 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nK) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nSum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d", &amp;nWoods[i]);</span><br><span class="line">            nSum += nWoods[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nWoods, nWoods + nN);</span><br><span class="line">        int nMax = nSum / nK;</span><br><span class="line">        printf("%d\n", SearchAns(nMax));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以,只是把==换成了IsAnsOk函数调用而已…而且由于这是查找最大解,返回值做了下变化而已…<br>仔细分析二分的写法(我的另一篇文章(标题是关于密码的一个解题报告)有说明),<br>其实写出查找最大解和最小解的二分都不是件麻烦的事情…</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSU OJ - 1219: 建食堂 (所有结点间的最短路径)</title>
      <link href="/2011/12/04/CSU%20OJ%20-%201219%20%E5%BB%BA%E9%A3%9F%E5%A0%82%20(%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84)/"/>
      <url>/2011/12/04/CSU%20OJ%20-%201219%20%E5%BB%BA%E9%A3%9F%E5%A0%82%20(%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84)/</url>
      
        <content type="html"><![CDATA[<p>链接:<a href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1219" target="_blank" rel="noopener">http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1219</a></p><p>这个题就是求出所有结点的距离之后,再找出某个结点,该结点离其它结点的最大距离是所有结点中是最小的…<br>解法1:深搜出所有结点间的距离,但是会超时,即使深搜的过程使用中记忆化搜索(就是用2维数组保存已经搜出的答案,如果后面的搜索需要用到直接使用即可)…<br>解法2:Floyd算法,3重循环直接找出所有结点之间的最短距离<br>解法3:对每一个结点应用一次迪杰斯特拉算法,找出所有结点与其它结点间的最短距离…</p><p>解法2:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX  (<span class="number">100</span> + <span class="number">10</span>)</span><br><span class="line"><span class="number">#def</span>ine INF (<span class="number">1000000</span> + <span class="number">10</span>)</span><br><span class="line">int nN, nM;</span><br><span class="line">int nDis[MAX][MAX];</span><br><span class="line">void SearchAll()</span><br><span class="line">&#123;</span><br><span class="line">    for (int k = 0; k &lt; nN; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            for (int j = 0; j &lt; nN; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nDis[i][k] + nDis[k][j] &lt; nDis[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    nDis[i][j] = nDis[j][i] = nDis[i][k] + nDis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nM) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; nN; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="selector-tag">i</span> == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    nDis[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nDis[i][j] = INF;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (nM--)</span><br><span class="line">        &#123;</span><br><span class="line">            int nX, nY, nK;</span><br><span class="line">            scanf("%d%d%d", &amp;nX, &amp;nY, &amp;nK);</span><br><span class="line">            nDis[nX][nY] = nDis[nY][nX] = nK;</span><br><span class="line">        &#125;</span><br><span class="line">        SearchAll();</span><br><span class="line">        bool bOk = false;</span><br><span class="line">        int nMin = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int nTemp = 0;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for ( ; j &lt; nN; ++j) </span><br><span class="line">            &#123; </span><br><span class="line">                if (i == j) continue; </span><br><span class="line">                <span class="keyword">if</span> (nDis[i][j] == INF) </span><br><span class="line">                &#123; </span><br><span class="line">                    break; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="keyword">if</span> (nDis[i][j] &gt; nTemp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nTemp = nDis[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == nN)</span><br><span class="line">            &#123;</span><br><span class="line">                bOk = true;</span><br><span class="line">                <span class="keyword">if</span> (nTemp &lt; nMin)</span><br><span class="line">                &#123;</span><br><span class="line">                    nMin = nTemp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bOk)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d\n", nMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("Can not\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Floyd算法,可以这样理解…比如刚开始只取2个结点i,j,它们的距离一定是dis(i,j),但是还有其它结点,需要把其它结点也慢慢加进来,所以最外层关于k的循环意思就是从0至nN-1,把所有其它结点加进来,比如加入0号结点后,距离dis(i,0)+dis(0,j)可能会比dis(i,j)小,如果是这样就更新dis(i,j),然后后面加入1号结点的时候,实际上是在已经加入0号结点的基础上进行的处理了,效果变成dis(i,0,1,j),可能是最小的,而且中间的0,1也可能是不存在的,当然是在dis(i,j)原本就是最小的情况下…<br>这个算法可以用下面这个图片描述…<br><img alt data-src="https://c5.staticflickr.com/8/7303/26782450284_e07c633d3f_o.jpg"></p><p>解法3:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="number">#def</span>ine MAX  (<span class="number">100</span> + <span class="number">10</span>)</span><br><span class="line"><span class="number">#def</span>ine INF (<span class="number">1000000</span> + <span class="number">10</span>)</span><br><span class="line">int nN, nM;</span><br><span class="line">int nDis[MAX][MAX];</span><br><span class="line">void Search(int nSource)</span><br><span class="line">&#123;</span><br><span class="line">    bool bVisit[MAX];</span><br><span class="line">    memset(bVisit, false, sizeof(bVisit));</span><br><span class="line">    bVisit[nSource] = true;</span><br><span class="line">    for (int i = 0; i &lt; nN - 1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int nMin = INF;</span><br><span class="line">        int nMinPos = 0;</span><br><span class="line">        for (int j = 0; j &lt; nN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bVisit[j] &amp;&amp; nDis[nSource][j] &lt; nMin)</span><br><span class="line">            &#123;</span><br><span class="line">                nMin = nDis[nSource][j];</span><br><span class="line">                nMinPos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bVisit[nMinPos] == false)</span><br><span class="line">        &#123;</span><br><span class="line">            bVisit[nMinPos] = true;</span><br><span class="line">            for (int j = 0; j &lt; nN; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nDis[nSource][nMinPos] + nDis[nMinPos][j] &lt; nDis[nSource][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    nDis[nSource][j] = nDis[nSource][nMinPos] + nDis[nMinPos][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void SearchAll()</span><br><span class="line">&#123;</span><br><span class="line">    for (int k = 0; k &lt; nN; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        Search(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (scanf(<span class="string">"%d%d"</span>, &amp;nN, &amp;nM) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; nN; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="selector-tag">i</span> == j)</span><br><span class="line">                &#123;</span><br><span class="line">                    nDis[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nDis[i][j] = INF;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (nM--)</span><br><span class="line">        &#123;</span><br><span class="line">            int nX, nY, nK;</span><br><span class="line">            scanf("%d%d%d", &amp;nX, &amp;nY, &amp;nK);</span><br><span class="line">            nDis[nX][nY] = nDis[nY][nX] = nK;</span><br><span class="line">        &#125;</span><br><span class="line">        SearchAll();</span><br><span class="line">        bool bOk = false;</span><br><span class="line">        int nMin = 1 &lt;&lt; 30;</span><br><span class="line">        for (int i = 0; i &lt; nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int nTemp = 0;</span><br><span class="line">            int j = 0;</span><br><span class="line">            for ( ; j &lt; nN; ++j) </span><br><span class="line">            &#123; </span><br><span class="line">                if (i == j) continue; </span><br><span class="line">                <span class="keyword">if</span> (nDis[i][j] == INF) </span><br><span class="line">                &#123; </span><br><span class="line">                    break;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="keyword">if</span> (nDis[i][j] &gt; nTemp)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nTemp = nDis[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == nN)</span><br><span class="line">            &#123;</span><br><span class="line">                bOk = true;</span><br><span class="line">                <span class="keyword">if</span> (nTemp &lt; nMin)</span><br><span class="line">                &#123;</span><br><span class="line">                    nMin = nTemp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bOk)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%d\n", nMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("Can not\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迪杰斯特拉算法的核心思想是维护一个源点顶点集合,任何最短路径一定是从这个顶点集合发出的…<br>初始化时,这个集合就是源点…<br>我们从该其它结点中选出一个结点,该结点到源点的距离最小…<br>显然,这个距离就是源点到该结点的最短距离了,我们已经找到了答案的一部分了…然后,我们就把该结点加入前面所说的顶点集合…<br>现在顶点集合更新了,我们必须得更新距离了…由于新加入的结点可能发出边使得原来源点到某些结点的距离更小,也就是我们的源点变大了,边也变多了,所以我们的最短距离集合的值也必须变化了…<br>该算法一直循环nN-1次,直至所有的点都加入源点顶点集合…</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2814:拨钟问题</title>
      <link href="/2011/11/28/POJ%E7%99%BE%E7%BB%83%20-%202814%E6%8B%A8%E9%92%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2011/11/28/POJ%E7%99%BE%E7%BB%83%20-%202814%E6%8B%A8%E9%92%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>链接: <a href="http://poj.grids.cn/practice/2814" target="_blank" rel="noopener">http://poj.grids.cn/practice/2814</a></p><p>这个题目可以枚举或者直接暴力。但是,这之前必须弄明白答案的解空间。。。也就是解可能的情况。。。很简单,一共有9种移动方案。也很了然的知道对于某种方案使用N次的效果等同于N%4的效果,也就是说某种方案只可能使用0,1,2,3次。。。一共有9种方案,那么一共就只有4^9种可能的解。。。这么小的解空间,无论用什么方法都不会超时了。。。暴力可以才用9重循环,或者深搜,当时觉得写9重循环是件很糗的事情,就果断深搜了。。。<br>如果这题才用枚举的方法的话,思考方式还是那样先确定假设解的部分情况,通过已经知道的规则确定解的其它情况,然后求出这个解,判断这个解是否满足题目要求。。。比如,我们可以枚举1,2,3号方案的情况,根据规则确定其它方案的使用情况,求出所有方案的使用情况后,判断假设的解是否满足要求就可以了…</p><p>我才用的是dfs+剪枝,这个题目其实题意或者说答案有误,因为答案是搜索找到第一个解,而不是所谓的最短序列的解,当然如果数据使得2者都是一样的话,那么题意就无误了…我的代码是假设找到的第一个就是最短序列的,这种情况下才能使用剪枝,因为找到一个解后就不需要继续找了…</p><p>代码如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line">int nMinTimes;</span><br><span class="line">int nPath[40];</span><br><span class="line">bool bFind = false;</span><br><span class="line">char* szMoves[10] =</span><br><span class="line">&#123;</span><br><span class="line">    NULL,</span><br><span class="line">    <span class="string">"ABDE"</span>,</span><br><span class="line">    <span class="string">"ABC"</span>,</span><br><span class="line">    <span class="string">"BCEF"</span>,</span><br><span class="line">    <span class="string">"ADG"</span>,</span><br><span class="line">    <span class="string">"BDEFH"</span>,</span><br><span class="line">    <span class="string">"CFI"</span>,</span><br><span class="line">    <span class="string">"DEGH"</span>,</span><br><span class="line">    <span class="string">"GHI"</span>,</span><br><span class="line">    <span class="string">"EFHI"</span></span><br><span class="line">&#125;;</span><br><span class="line">bool IsPosOK(int* nPos)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; 9; ++i) &#123; if (nPos[i]) &#123; return false; &#125; &#125; return true; &#125; void Move(int nChoose, int nTimes, int* nPos) &#123; if (nTimes &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        char* pszStr = szMoves[nChoose];</span><br><span class="line">        while (*pszStr)</span><br><span class="line">        &#123;</span><br><span class="line">            nPos[*pszStr - 'A'] = (nPos[*pszStr - 'A'] + nTimes) % 4;</span><br><span class="line">            ++pszStr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void MoveBack(int nChoose, int nTimes, int* nPos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nTimes &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        char* pszStr = szMoves[nChoose];</span><br><span class="line">        while (*pszStr)</span><br><span class="line">        &#123;</span><br><span class="line">            nPos[*pszStr - 'A'] = (nPos[*pszStr - 'A'] - nTimes + 4) % 4;</span><br><span class="line">            ++pszStr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Cal(int nChoose, int* nPos, int* nUsed, int nUsedTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nChoose == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsPosOK(nPos) &amp;&amp; !bFind)</span><br><span class="line">        &#123;</span><br><span class="line">            nMinTimes = nUsedTimes;</span><br><span class="line">            for (int i = 0; i &lt; nMinTimes; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                nPath[i] = nUsed[i];</span><br><span class="line">            &#125;</span><br><span class="line">            bFind = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;= 3; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Move(nChoose, i, nPos);</span><br><span class="line">        for (int j = 0; j &lt; i; ++j)//放入i次的nChoose</span><br><span class="line">        &#123;</span><br><span class="line">            nUsed[nUsedTimes + j] = nChoose;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bFind)</span><br><span class="line">        &#123;</span><br><span class="line">            Cal(nChoose + 1, nPos, nUsed, nUsedTimes + i);</span><br><span class="line">        &#125;</span><br><span class="line">        MoveBack(nChoose, i, nPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nPos[9];</span><br><span class="line">    int nUsed[40];</span><br><span class="line">    for (int i = 0; i &lt; 9; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d", &amp;nPos[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Cal(1, nPos, nUsed, 0);</span><br><span class="line">    for (int i = 0; i &lt; nMinTimes; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf("%d", nPath[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="selector-tag">i</span> != nMinTimes - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            putchar(' ');</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            putchar('\n');</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题其实我wa了近10次,原因就是Move和MoveBack写错了,没有移动nTimes次,而前面一直写成了1,昨晚wa得实在无语了…今天晚上检查才突然发现的…<br>这半个多月做了60道题了,都没有改动这低级的bug习惯…实在无语…递归,回溯,剪枝都写上了…唉…实在无语…还不如直接9重循环,多省心…真不该歧视某种方法的…</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 1183:反正切函数的应用</title>
      <link href="/2011/11/24/POJ%E7%99%BE%E7%BB%83%20-%201183%E5%8F%8D%E6%AD%A3%E5%88%87%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2011/11/24/POJ%E7%99%BE%E7%BB%83%20-%201183%E5%8F%8D%E6%AD%A3%E5%88%87%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="http://poj.grids.cn/practice/1183/" target="_blank" rel="noopener">http://poj.grids.cn/practice/1183/</a></p><p>方法1:<br>本题很容易推断出 ,a = (b * c - 1) / (b + c), 由于需要求(b+c)的最小值,根据高中的函数思想,如果(b+c)能够转换为关于b或者c的函数就好办了,刚好这里已经有个b和c的关系式子了,可以推导出(b+c) = (c^2+1)/(c-a),这个时候只需要求f(c)的最小值,但是c必须取整数,对这个函数可以求导,也可以进行变形,变形后可以得到f(c) = (c-a) + 2 <em> a + (a^2+1)/(c-a)。<br>令x=c-a,那么可以得到(b+c)=f(x)=x + 2 </em> a+(a^2+1)/x, 其中x必须是整数,到现在为止就是一个用程序模拟高中时候学过的双曲线函数的求最值问题了,我们知道该函数的极值点是sqrt(a^2+1),但是由于x必须是整数,<br>我们必须从极值开始往下和往上找到一个最小值,然后取2者中的最小值…这样这个题就解出来了…</p><p>代码:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"><span class="comment">//b + c = (c^2 + 1) / (c - a) = (c-a) + (2 * a) + (a^2 + 1) / (c -a)</span></span><br><span class="line"><span class="comment">//令c-a = t, f(t) = t + 2*a + (a^2+1)/ t</span></span><br><span class="line"><span class="comment">//因为f(t)在sqrt(a^2+1)时取最小值,但是由于t只能取整数,</span></span><br><span class="line"><span class="comment">//所以,必须从极值点往下和往上寻找最小的值,然后取2者中最小的</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long a;</span><br><span class="line">    while (std::cin &gt;&gt; a)</span><br><span class="line">    &#123;</span><br><span class="line">        long long nTemp = a * a + 1;</span><br><span class="line">        long long nDown =  sqrt(nTemp);</span><br><span class="line">        long long nUp = nDown;</span><br><span class="line">        long long one, two;</span><br><span class="line"></span><br><span class="line">        while (nTemp % nDown )</span><br><span class="line">        &#123;</span><br><span class="line">            nDown--;</span><br><span class="line">        &#125;</span><br><span class="line">        one = 2 * a + nTemp / nDown + nDown;</span><br><span class="line"></span><br><span class="line">        while (nTemp % nUp )</span><br><span class="line">        &#123;</span><br><span class="line">            nUp++;</span><br><span class="line">        &#125;</span><br><span class="line">        two = 2 * a + nTemp / nUp + nUp;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; (one &lt; two ? one : two) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法2:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = (b*c-1)/(b+c)</span></span><br><span class="line"><span class="comment">//令b = a + m, c = a + n, c &gt;= b</span></span><br><span class="line"><span class="comment">//-&gt; a*(2*a+m+n) = (a+m)*(a+n)-1</span></span><br><span class="line"><span class="comment">//m*n = a^2 + 1  (n&gt;=m)</span></span><br><span class="line"><span class="comment">//所以,求出a^2+1所有因子对,取其中m+n最小的即可</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long a;</span><br><span class="line">    while (std::cin &gt;&gt; a)</span><br><span class="line">    &#123;</span><br><span class="line">        long long m, n;</span><br><span class="line">        long long nTemp = a * a + 1;</span><br><span class="line">        long long nMax = sqrt(nTemp);</span><br><span class="line">        long long nRes = 1 + nTemp;</span><br><span class="line">        for (m = 2; m &lt;= nMax; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nTemp % m == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                n = nTemp / m;</span><br><span class="line">                <span class="keyword">if</span> (m + n &lt; nRes)</span><br><span class="line">                &#123;</span><br><span class="line">                    nRes = m + n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; 2 * a + nRes &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2797:最短前缀(可以使用字典树做)</title>
      <link href="/2011/11/22/POJ%E7%99%BE%E7%BB%83%20-%202797%E6%9C%80%E7%9F%AD%E5%89%8D%E7%BC%80(%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%91%E5%81%9A)/"/>
      <url>/2011/11/22/POJ%E7%99%BE%E7%BB%83%20-%202797%E6%9C%80%E7%9F%AD%E5%89%8D%E7%BC%80(%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%A0%91%E5%81%9A)/</url>
      
        <content type="html"><![CDATA[<p>链接: <a href="http://poj.grids.cn/practice/2797/" target="_blank" rel="noopener">http://poj.grids.cn/practice/2797/</a></p><p>这题乍看之下确实没什么思路,后面终于明白题意了,然后突然想到可以用字典树做,速度当然会是非常快的…<br>但是其实还有一种更简单的方法,那就是对所有字符串排序之后,每个字符串的前缀长度其实就是由其前一个和后一个字符串共同决定,<br>nLen = max(nOne, nTwo), nOne 和 nTwo就分别代表当前字符串和前后字符串公告部分的长度+1后的值…<br>代码写出来写非常简单…同学这样实现了下,也轻松过了…</p><p>然后我就辛苦的写了一棵字典树…可能我的写法不是很标准,因为我没参考什么模板,自己硬想出来怎么写的…<br>我的想法是开一个静态大数组,第一个结点作为根,不存储数据,从第二个结点开始作为自由空间分配…<br>其实,就是对26颗字典树虚拟了个无数据的根结点…<br>使用了虚拟的根结点后,代码比用26个根结点简洁很多…<br>刚开始我就假设1-26号结点分别为a-z,作为26颗树的根,<br>而且下26个结点的位置我用的是索引,没用指针,后面换成了指针,代码看起来更舒服了…</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="number">#def</span>ine LETTER_NUM <span class="number">26</span></span><br><span class="line"><span class="number">#def</span>ine WORD_LEN_MAX <span class="number">25</span></span><br><span class="line"><span class="number">#def</span>ine WORD_NUM_MAX <span class="number">1030</span></span><br><span class="line">#define NODE_MAX (WORD_LEN_MAX * WORD_NUM_MAX + 10)</span><br><span class="line">struct WORD_TREE</span><br><span class="line">&#123;</span><br><span class="line">    char ch;</span><br><span class="line">    WORD_TREE* next[LETTER_NUM];</span><br><span class="line">    int nTime;</span><br><span class="line">&#125;;</span><br><span class="line">WORD_TREE tree[NODE_MAX];</span><br><span class="line">WORD_TREE* pFreeNode = tree + 1;//第一个结点作为头结点,不存储数据</span><br><span class="line">char szWords[WORD_NUM_MAX][WORD_LEN_MAX];</span><br><span class="line">void AddToTree(char* pszStr)</span><br><span class="line">&#123;</span><br><span class="line">    WORD_TREE* pTree = tree;</span><br><span class="line">    while (*pszStr &amp;&amp; pTree-&gt;next[*pszStr - <span class="string">'a'</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        pTree = pTree-&gt;next[*pszStr - 'a'];</span><br><span class="line">        pTree-&gt;nTime++;</span><br><span class="line">        ++pszStr;</span><br><span class="line">    &#125;</span><br><span class="line">    while (*pszStr)</span><br><span class="line">    &#123;</span><br><span class="line">        pFreeNode-&gt;ch = *pszStr;</span><br><span class="line">        pFreeNode-&gt;nTime++;</span><br><span class="line">        pTree-&gt;next[*pszStr - 'a'] = pFreeNode;</span><br><span class="line">        pTree = pFreeNode;</span><br><span class="line">        ++pszStr;</span><br><span class="line">        ++pFreeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int FindPrefix(char* pszStr)</span><br><span class="line">&#123;</span><br><span class="line">    WORD_TREE* pTree = tree;</span><br><span class="line">    int nLen = 0;</span><br><span class="line">    while (*pszStr)</span><br><span class="line">    &#123;</span><br><span class="line">        ++nLen;</span><br><span class="line">        pTree = pTree-&gt;next[*pszStr - 'a'];</span><br><span class="line">        <span class="keyword">if</span> (pTree-&gt;nTime &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ++pszStr;</span><br><span class="line">    &#125;</span><br><span class="line">    return nLen;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nCount = 0;</span><br><span class="line">    while (scanf(<span class="string">"%s"</span>, szWords[nCount]) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        AddToTree(szWords[nCount]);</span><br><span class="line">        nCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int nLen = FindPrefix(szWords[i]);</span><br><span class="line">        printf("%s ", szWords[i]);</span><br><span class="line">        for (int j = 0; j &lt; nLen; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            putchar(szWords[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        putchar('\n');</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSU OJ - 1207: 镇管的难题(判断一正整数是否可能是直角边)</title>
      <link href="/2011/11/20/CSU%20OJ%20-%201207%20%E9%95%87%E7%AE%A1%E7%9A%84%E9%9A%BE%E9%A2%98(%E5%88%A4%E6%96%AD%E4%B8%80%E6%AD%A3%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E8%83%BD%E6%98%AF%E7%9B%B4%E8%A7%92%E8%BE%B9)/"/>
      <url>/2011/11/20/CSU%20OJ%20-%201207%20%E9%95%87%E7%AE%A1%E7%9A%84%E9%9A%BE%E9%A2%98(%E5%88%A4%E6%96%AD%E4%B8%80%E6%AD%A3%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E8%83%BD%E6%98%AF%E7%9B%B4%E8%A7%92%E8%BE%B9)/</url>
      
        <content type="html"><![CDATA[<p>链接：[<a href="http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1207" target="_blank" rel="noopener">http://acm.csu.edu.cn/OnlineJudge/problem.php?id=1207</a>]</p><p>问题描述是：给定一个大于0的整数N(1&lt;=N&lt;=10^8),判断其是否可能是一个直角三角形的直角边(这个三角形的三条边必须都是整数)…<br>这个题还是做得我挺郁闷的。。。刚开始完全没思路。。。后面没办法，硬着头皮往下想。<br>对于勾股定理a^2 + b^2 = c^2，假设N是a,可以得到a^2 = (c + b) * (c -b), 那么(c + b)和(c - b)是a^2的2个因子,而且(c+b)&gt;=a,(c-b)&lt;=a。。。<br>到这一步已经可以用程序轻松解决出来了,但是对于任意一个整数N来说,其复杂度都是O(N),那么计算量还是很大的…<br>这个时候只需要枚举1-N,求出a^2的2个因子,然后求c和b,如果能得出c和b都是正整数那么,就满足条件了…<br>但是这样还是过不了题,因为数据量不会这么小…数据量好像有10000组。。。<br>那么还需要推导出进一步的结论…<br>因为1和a^2一定是a^2的一对因子,那么(c+b) = a^2和(c-b) = 1一定可以成功,<br>则可以推导出，2 <em> c = a^2 + 1。<br>要c可解,a必须为奇数,那么可以推导出如果a是奇数,一定是直角边了。。。<br>如果a是偶数了,可以化简为 4 </em> (a / 2) ^ 2  =  4 <em>（c + b) \</em>  (c - b) = (2c + 2b) * (2c - 2b) = a ^ 2，那么继续推导也可以得到一样的结果了…</p><p>结论就是:对于大于等于3的正整数都可以是一条直角边(&gt;=3也可以根据上面的c和b是正整数推导出来)…</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2820:古代密码 AND POJ百练 - 2801:填词</title>
      <link href="/2011/11/18/POJ%E7%99%BE%E7%BB%83%20-%202820%E5%8F%A4%E4%BB%A3%E5%AF%86%E7%A0%81%20AND%20POJ%E7%99%BE%E7%BB%83%20-%202801%E5%A1%AB%E8%AF%8D/"/>
      <url>/2011/11/18/POJ%E7%99%BE%E7%BB%83%20-%202820%E5%8F%A4%E4%BB%A3%E5%AF%86%E7%A0%81%20AND%20POJ%E7%99%BE%E7%BB%83%20-%202801%E5%A1%AB%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>链接: <a href="http://poj.grids.cn/practice/2820" target="_blank" rel="noopener">http://poj.grids.cn/practice/2820 </a><br>链接: <a href="http://poj.grids.cn/practice/2801" target="_blank" rel="noopener">http://poj.grids.cn/practice/2801</a></p><p>为啥把这2个不相干的题目放在一起了…说实话这其实也是二个容易的题目,尤其第二个更容易想到…第一个也许暂时<br>没那么容易想出来。。。<br>而且感觉第一个古代密码还挺有意思的…判断一个字符串是否能够通过移位和替换方法加密成另外一个字符串。。。<br>至于第二个,各位去看看题目吧。。。<br>也是个解法跟题目不大相关的题目。。。<br>这2个题最大的特点和共同点就是解法和题目意思想去甚远。。。<br>所以我觉得做这种二丈和尚摸不早头脑的题,思维应该往跟题意背离的方向思考。。。</p><p>尤其第一个题，如果只看代码,即使代码可读性再好，也不知道代码有何意义，有何目的，跟题意有啥关系。。。<br>不过第一个居然轻松AC了,虽然我2b得搞了个ce和re出来了…<br>第一个的转换方法是,计算出现的字符’A’-‘Z’的出现次数,然后从大小排序,如果针对加密后的字符串得到的结果一直大于等于<br>加密前的字符串得到的结果,表明答案是YES…具体还是看代码吧…<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using std::sort;</span><br><span class="line">bool Greater(int one, int two)</span><br><span class="line">&#123;</span><br><span class="line">    return one &gt; two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char szOne[110];</span><br><span class="line">    char szTwo[110];</span><br><span class="line">    int nNumOne[26];</span><br><span class="line">    int nNumTwo[26];</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%s%s"</span>, szOne, szTwo) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(nNumOne, 0, sizeof(int) * 26);</span><br><span class="line">        memset(nNumTwo, 0, sizeof(int) * 26);</span><br><span class="line"></span><br><span class="line">        char* psz = szOne;</span><br><span class="line">        while (*psz)</span><br><span class="line">        &#123;</span><br><span class="line">            ++nNumOne[*psz - 'A'];</span><br><span class="line">            ++psz;</span><br><span class="line">        &#125;</span><br><span class="line">        psz = szTwo;</span><br><span class="line">        while (*psz)</span><br><span class="line">        &#123;</span><br><span class="line">            ++nNumTwo[*psz - 'A'];</span><br><span class="line">            ++psz;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nNumOne, nNumOne + 26, Greater);</span><br><span class="line">        sort(nNumTwo, nNumTwo + 26, Greater);</span><br><span class="line">        bool bIsYes = true;</span><br><span class="line">        for (int i = 0; i &lt; 26; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nNumOne[i] &lt; nNumTwo[i])</span><br><span class="line">            &#123;</span><br><span class="line">                bIsYes = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bIsYes)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("YES\n");</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("NO\n");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2804:词典</title>
      <link href="/2011/11/16/POJ%E7%99%BE%E7%BB%83%20-%202804%E8%AF%8D%E5%85%B8/"/>
      <url>/2011/11/16/POJ%E7%99%BE%E7%BB%83%20-%202804%E8%AF%8D%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<p>链接: <a href="http://poj.grids.cn/practice/2804/" target="_blank" rel="noopener">http://poj.grids.cn/practice/2804/</a></p><p>这也是一个很简单的题目,大家一看都知道用什么方法了,当然如果是查找的话,顺序查找是不行的,<br>方法一,是用map,建立个map<string, string>的字典,注意不要想当然用map<char*, char*>,<br>那样得动态分配内存,或者还是先开个大数组存好字典,其结果还是多浪费了内存…<br>排序+二分也不错的,因为数据量确实很大,而且题目也建议用c的io输入,所以这样再建立map<string, string><br>中间还得转换一下…<br>总之做这个题还是很顺利的,就wa了一次,原因是2分写错了,我也很久没在oj上写2分了…</string,></char*,></string,></p><p>代码如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">#def</span>ine MAX_WORD_LEN <span class="number">11</span></span><br><span class="line"><span class="number">#def</span>ine MAX_DICTION_ITEM (<span class="number">100000</span> + <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">using std::sort;</span><br><span class="line"></span><br><span class="line">struct Dictionary</span><br><span class="line">&#123;</span><br><span class="line">    char szWord[MAX_WORD_LEN];</span><br><span class="line">    char szEnglish[MAX_WORD_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dictionary diction[MAX_DICTION_ITEM];</span><br><span class="line"></span><br><span class="line">bool CmpDictionItem(Dictionary one, Dictionary two)</span><br><span class="line">&#123;</span><br><span class="line">    return strcmp(one.szWord, two.szWord) &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int FindEnglish(char* pszWord, int nItemNum)</span><br><span class="line">&#123;</span><br><span class="line">    int nBeg = 0, nEnd = nItemNum - 1;</span><br><span class="line">    int nCmp = 0;</span><br><span class="line"></span><br><span class="line">    while (nBeg &lt;= nEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        int nMid = (nBeg + nEnd) / 2;</span><br><span class="line">        nCmp = strcmp(pszWord, diction[nMid].szWord);</span><br><span class="line">        <span class="keyword">if</span> (nCmp == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            return nMid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nCmp &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nEnd = nMid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nBeg = nMid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char szStr[30];</span><br><span class="line">    char szWord[MAX_WORD_LEN];</span><br><span class="line">    int nCount = 0;</span><br><span class="line">    int nAnsItem = 0;</span><br><span class="line"></span><br><span class="line">    while (fgets(szStr, <span class="number">29</span>, stdin), szStr[<span class="number">0</span>] != <span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sscanf(szStr, "%s%s", diction[nCount].szEnglish, diction[nCount].szWord);</span><br><span class="line">        ++nCount;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(diction, diction + nCount, CmpDictionItem);</span><br><span class="line">    while (scanf(<span class="string">"%s"</span>, szWord) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((nAnsItem = FindEnglish(szWord, nCount)) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            printf("%s\n", diction[nAnsItem].szEnglish);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf("eh\n"); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我的主要目的是为了指出二分的写法,大家看我的FindEnglish函数,传递的是数组的地址和数组的长度,<br>然后我写函数体的时候用的是[]的形式,就是下确界,上确界,这样最重要的是需要考虑循环的条件是&lt;还是<br>&lt;=,其实这也很好判断,因为上界和下界都能够取到,所以=是成立的…而且修改right的时候,必须将right = mid - 1,<br>原因也是因为这是上确界,<br>但是如果是上不确界了,那么等号就必须去掉,而且right也只能修改为mid,因为mid-1就是确界了,而mid才是上不确界…<br>想到这个程度的话,以后写只有唯一解二分就应该不会出错了…但是写查找满足条件的最大或者最小解的二分还需要其它技巧…</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2964:日历问题</title>
      <link href="/2011/11/16/POJ%E7%99%BE%E7%BB%83%20-%202964%E6%97%A5%E5%8E%86%E9%97%AE%E9%A2%98/"/>
      <url>/2011/11/16/POJ%E7%99%BE%E7%BB%83%20-%202964%E6%97%A5%E5%8E%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>链接: [<a href="http://poj.grids.cn/practice/2964/" target="_blank" rel="noopener">http://poj.grids.cn/practice/2964/</a>]</p><p>这本来就是一个简单的题目,但是还是值得我用一篇文章的位置。大家都做过闰年的题目,这只是闰年的一个升级版。。。本来我不至于这么纠结这个题目的,一看到题目,<br>我就考虑到了一次次减去天数来加年数和月份,而且我还想在读入数据之前初始化一个存储2000-9999年每年有多少天得数组…这样就可以避免循环时候计算每年的天数了…但是我还是怕时间不够,所以我想到了个O(1)的算法…<br>那就是按照题目的说明,其实每400是一个周期的,但是我前面写代码的时候把4年当中一个小周期,100年当中一个中周期,400年当中一个大周期,同样的处理了…<br>事实上,只能对400作为周期处理,其它的必须分类讨论,虽然代码写出来很复杂,而且我也因为出现这个bug错了无数次,但是我还是感觉非常值得的…因为这是我独立思考的成果,耗费了多少时间和精力倒是无所谓…写算法题,目的不仅仅应该是学习了多少个算法,而是在于能力的提高,个人的严谨性,思考问题的完整性等等…一直觉得自己思考问题时候有创意,但是完整性和严谨性很低…</p><p>下面贴我的代码吧,只用了10ms,如果采用第一种方法则需要60ms-70ms…<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define SMALL (365 * 3 + 366)</span><br><span class="line">#define MID   (SMALL * 25 - 1)</span><br><span class="line">#define BIG (MID * 4 + 1)</span><br><span class="line"></span><br><span class="line">char* pszWeekdays[7] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Saturday"</span>, <span class="string">"Sunday"</span>, <span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int nDaysOfMon[<span class="number">2</span>][<span class="number">13</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void GetMonthAndDay(int nDays, bool bIsLeap, int* nMon, int* nDay)</span><br><span class="line">&#123;</span><br><span class="line">    int nChoose = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bIsLeap)</span><br><span class="line">    &#123;</span><br><span class="line">        nChoose = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    *nMon = *nDay = 0;</span><br><span class="line">    i = 1;</span><br><span class="line">    while (nDays &gt; nDaysOfMon[nChoose][i])</span><br><span class="line">    &#123;</span><br><span class="line">        nDays -= nDaysOfMon[nChoose][i];</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    *nMon = i;</span><br><span class="line">    *nDay = nDays;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CountSmall(int* pnDays, int* pnPastYears, int* pnMon, int* pnDay)</span><br><span class="line">&#123;</span><br><span class="line">    if (*pnDays &gt;= 3 * 365)//4</span><br><span class="line">    &#123;</span><br><span class="line">        *pnPastYears += 3;</span><br><span class="line">        *pnDays -= 365 * 3;</span><br><span class="line">        GetMonthAndDay(*pnDays + 1, true, pnMon, pnDay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//1-3</span></span><br><span class="line">    &#123;</span><br><span class="line">        *pnPastYears += *pnDays / 365;</span><br><span class="line">        *pnDays %= 365;</span><br><span class="line">        GetMonthAndDay(*pnDays + 1, false, pnMon, pnDay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nPastDays = 0;</span><br><span class="line">    int nPastYears = 0;</span><br><span class="line">    int nYear = 0, nMon = 0, nDay = 0;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nPastDays), nPastDays != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        int nTemp = nPastDays;</span><br><span class="line">        nPastYears = 0;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nTemp &lt; <span class="number">366</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GetMonthAndDay(nTemp + 1, true, &amp;nMon, &amp;nDay);</span><br><span class="line">            nPastYears = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nPastYears++;</span><br><span class="line">            nTemp -= 366;</span><br><span class="line"></span><br><span class="line">            nPastYears += (nTemp / BIG) * 400;</span><br><span class="line">            nTemp %= BIG;</span><br><span class="line"></span><br><span class="line">            if (nTemp &gt;= MID * 3)//301-400年(以4为周期)</span><br><span class="line">            &#123;</span><br><span class="line">                nTemp -= MID * 3;</span><br><span class="line">                nPastYears += 300;</span><br><span class="line"></span><br><span class="line">                nPastYears += nTemp / SMALL * 4;</span><br><span class="line">                nTemp %= SMALL;</span><br><span class="line"></span><br><span class="line">                CountSmall(&amp;nTemp, &amp;nPastYears, &amp;nMon, &amp;nDay);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//1-300年</span></span><br><span class="line">            &#123;</span><br><span class="line">                nPastYears += nTemp / MID * 100;</span><br><span class="line">                nTemp %= MID;</span><br><span class="line"></span><br><span class="line">                if (nTemp &gt;= SMALL * 24)//97-100年(4个平年)</span><br><span class="line">                &#123;</span><br><span class="line">                    nTemp -= SMALL * 24;</span><br><span class="line">                    nPastYears += 4 * 24;</span><br><span class="line"></span><br><span class="line">                    nPastYears += nTemp / 365;</span><br><span class="line">                    nTemp %= 365;</span><br><span class="line">                    GetMonthAndDay(nTemp + 1, false, &amp;nMon, &amp;nDay);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//1-96年</span></span><br><span class="line">                &#123;</span><br><span class="line">                    nPastYears += nTemp / SMALL * 4;</span><br><span class="line">                    nTemp %= SMALL;</span><br><span class="line"></span><br><span class="line">                    CountSmall(&amp;nTemp, &amp;nPastYears, &amp;nMon, &amp;nDay);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf("%d-%02d-%02d %s\n", nPastYears + 2000, nMon, nDay, pszWeekdays[nPastDays % 7]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2818:密码</title>
      <link href="/2011/11/10/POJ%E7%99%BE%E7%BB%83%20-%202818%E5%AF%86%E7%A0%81/"/>
      <url>/2011/11/10/POJ%E7%99%BE%E7%BB%83%20-%202818%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>链接:<a href="http://poj.grids.cn/practice/2818" target="_blank" rel="noopener">http://poj.grids.cn/practice/2818</a><br>这其实就是一个简单的移位密码算法题,只是多了个循环而已,密码学里面也指出过循环运算是没有效果的,所以题目估计也就考察了这一点,如果没有找出循环周期,此题会一直超时的…<br>刚开始,我就直接模拟K次加密,显然超时了,当时还不信了,以为简单至此。。。<br>后面我就开始改进了,刚开始是把周期计算和加密放在一起写了,样例也过了,但是还是一直错…<br>没办法再改,我改成把周期求出来,再对加密次数K取模后,再进行运算…<br>好吧,还是一样wa,后面就变成PE了。。。<br>最后,这个题经过我近2个小时的奋战,终于过了,一共错了近10次吧…第一次提交是距现在1个多小时前了…<br>最后发现错误的原因还是换行输出的地方错了,题目要求是每一组中间有个空行,我则输出的是每次计算后有个空行…<br>实在无语…<br>思维不严谨啊…</p><p>代码:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;string.h&gt;</span><br><span class="line"><span class="number">#def</span>ine N_MAX <span class="number">200</span> + <span class="number">10</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int nN = 0;</span><br><span class="line">    int nNArr[N_MAX];//密钥</span><br><span class="line">    int nK = 0;</span><br><span class="line">    char szMsg[N_MAX];</span><br><span class="line">    char szMsgBckup[N_MAX];//字符串备份</span><br><span class="line">    int nCir[N_MAX];//周期</span><br><span class="line">    int nMsgLen = 0;</span><br><span class="line">    int nPos = 0;</span><br><span class="line">    int i, j;</span><br><span class="line"></span><br><span class="line">    while (scanf(<span class="string">"%d"</span>, &amp;nN), nN != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = 1; i &lt;= nN; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf("%d", &amp;nNArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i = 1; i &lt;= nN; ++i)//计算周期</span><br><span class="line">        &#123;</span><br><span class="line">            nPos = i;</span><br><span class="line">            for (j = 1; ; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                nPos = nNArr[nPos];</span><br><span class="line">                <span class="keyword">if</span> (nPos == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    nCir[i] = j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (scanf(<span class="string">"%d"</span>, &amp;nK), nK != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();//销掉空格</span><br><span class="line">            gets(szMsg + 1);</span><br><span class="line">            nMsgLen = strlen(szMsg + 1);</span><br><span class="line">            for (i = nMsgLen; i &lt; nN; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                szMsg[1 + i] = ' ';</span><br><span class="line">            &#125;</span><br><span class="line">            szMsg[1 + nN] = '\0';</span><br><span class="line">            strcpy(szMsgBckup + 1, szMsg + 1);</span><br><span class="line"></span><br><span class="line">            for (i = 1; i &lt;= nN; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                nPos = i;</span><br><span class="line">                int nTimes = nK % nCir[i];</span><br><span class="line">                for (j = 1; j &lt;= nTimes; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    nPos = nNArr[nPos];</span><br><span class="line">                &#125;</span><br><span class="line">                szMsg[nPos] = szMsgBckup[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            printf("%s\n", szMsg + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf("\n");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 1017:装箱问题</title>
      <link href="/2011/11/08/POJ%E7%99%BE%E7%BB%83%20-%201017%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/"/>
      <url>/2011/11/08/POJ%E7%99%BE%E7%BB%83%20-%201017%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>链接：<a href="http://poj.grids.cn/practice/1017" target="_blank" rel="noopener">http://poj.grids.cn/practice/1017</a><a href="http://poj.grids.cn/practice/1017" target="_blank" rel="noopener"><br>说实话</a>这就是个简单的装箱子问题,很容易想清楚装箱子的过程,而且这个过程是满足贪心算法的,<br>所以只需要用代码模拟整个装箱子的过程即可,但是这样真的就足够了吗？？？<br>我刚开始就是用代码模拟这个手动过程了,虽然AC了,但是代码有150行左右,逻辑也显得过于复杂了,<br>得不偿失。。。整个过程是6<em>6的一个占一个箱子,5</em>5的也必须一个占一个箱子,但是需要补11个1<em>1的,<br>4</em>4的也是一个占一个箱子,但是需要补5个2<em>2的,如果2</em>2的不足够,则用1<em>1的代替,<br>3</em>3的4个占一个箱子,但是会有余数,可能余下1,2,3个3<em>3的箱子,这个时候必须非情况考虑,<br>1个3</em>3的需要和5个2<em>2的,7个1</em>1的组合,2个3<em>3的需要和3个2</em>2的,6个1<em>1的组合,<br>3个3</em>3的需要和1个2<em>2的,5个1</em>1的组合,最后考虑9个2<em>2的装一个箱子,多余的2</em>2用1<em>1的去填充尽量挤满一个箱子,<br>最后36个1</em>1的装一个箱子,余下的1*1的也必须占一个箱子。。。<br>这个过程说出来已经非常复杂了,更何况用代码写,我费了九牛二虎之力才写出来,WA了一次才AC了…</p><p>代码:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int one, two, three, four, five, six;</span><br><span class="line">    int num = 0;</span><br><span class="line">    while (scanf(“%d%d%d%d%d%d”, &amp;one, &amp;two, &amp;three, &amp;four, &amp;five, &amp;six) == 6)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (one == <span class="number">0</span> &amp;&amp; two == <span class="number">0</span> &amp;&amp; three == <span class="number">0</span> &amp;&amp; four == <span class="number">0</span> &amp;&amp; five == <span class="number">0</span> &amp;&amp; six == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        num = six;</span><br><span class="line">        num += five;</span><br><span class="line">        if (one &gt; five * 11)</span><br><span class="line">        &#123;</span><br><span class="line">            one -= five * 11;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            one = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        num += four;</span><br><span class="line">        if (two &gt; four * 5)</span><br><span class="line">        &#123;</span><br><span class="line">            two -= four * 5;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            if (one &gt; four * 5 * 4 – two * 4)</span><br><span class="line">            &#123;</span><br><span class="line">                one -= four * 5 * 4 – two * 4;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                one = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            two = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        num += three / 4;</span><br><span class="line">        three = three % 4;</span><br><span class="line">        <span class="keyword">if</span> (three == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (two &gt; <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                two -= 5;</span><br><span class="line">                <span class="keyword">if</span> (one &gt; <span class="number">7</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    one -= 7;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    one = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                if (one &gt; 27 – two * 4)</span><br><span class="line">                &#123;</span><br><span class="line">                    one -= 27 – two * 4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    one = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                two = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (three == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (two &gt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                two -= 3;</span><br><span class="line">                <span class="keyword">if</span> (one &gt; <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    one -= 6;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    one = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                if (one &gt; 18 – two * 4)</span><br><span class="line">                &#123;</span><br><span class="line">                    one -= 18 – two * 4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    one = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                two = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (three == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (two &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                two -= 1;</span><br><span class="line">                <span class="keyword">if</span> (one &gt; <span class="number">5</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    one -= 5;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    one = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                if (one &gt; 9 – two * 4)</span><br><span class="line">                &#123;</span><br><span class="line">                    one -= 9 – two * 4;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    one = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                two = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        num += two / 9;</span><br><span class="line">        two = two % 9;</span><br><span class="line">        <span class="keyword">if</span> (two)</span><br><span class="line">        &#123;</span><br><span class="line">            if (one &gt; 36 – two * 4)</span><br><span class="line">            &#123;</span><br><span class="line">                one -= 36 – two * 4;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                one = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        num += one / 36;</span><br><span class="line">        if (one % 36)</span><br><span class="line">        &#123;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(“%d\n”, num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的写法显然不好吧。。。首先,余下1,2,3个3<em>3时候需要填几个2</em>2的可以存储在数组里面,这样就可以不用写重复代码了,<br>如果再从整体考虑余下多少个格子,就不用用贪心算法模拟装箱子的过程了。。。<br>代码如下:<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int one, two, three, four, five, six;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int twoPlace[4] = &#123;0, 5, 3, 1&#125;;</span><br><span class="line">    int remTwo, remOne;</span><br><span class="line">    while (scanf(<span class="string">"%d%d%d%d%d%d"</span>, &amp;one, &amp;two, &amp;three, &amp;four, &amp;five, &amp;six) == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (one == <span class="number">0</span> &amp;&amp; two == <span class="number">0</span> &amp;&amp; three == <span class="number">0</span> &amp;&amp; four == <span class="number">0</span> &amp;&amp; five == <span class="number">0</span> &amp;&amp; six == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        num = six + five + four + (three + 3) / 4;</span><br><span class="line">        remTwo = four * 5 + twoPlace[three % 4];</span><br><span class="line">        <span class="keyword">if</span> (two &gt; remTwo)</span><br><span class="line">        &#123;</span><br><span class="line">            num += (two – remTwo + 8) / 9;</span><br><span class="line">        &#125;</span><br><span class="line">        remOne = 36 * num – 36 * six – 25 * five – 16 * four – 9 * three – 4 * two;</span><br><span class="line">        <span class="keyword">if</span> (one &gt; remOne)</span><br><span class="line">        &#123;</span><br><span class="line">            num += (one – remOne + 35) / 36;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(“%d\n”, num);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ百练 - 2808:校门外的树</title>
      <link href="/2011/11/07/POJ%E7%99%BE%E7%BB%83%20-%202808%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/"/>
      <url>/2011/11/07/POJ%E7%99%BE%E7%BB%83%20-%202808%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>链接：</p><p><a href="http://poj.grids.cn/practice/2808" target="_blank" rel="noopener">http://poj.grids.cn/practice/2808</a></p><p>方法1(空间换时间)：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int L, M;</span><br><span class="line">    int nTrees[10005] = &#123;0&#125;;</span><br><span class="line">    int start, end;</span><br><span class="line">    int nCount = 0;</span><br><span class="line"></span><br><span class="line">    scanf("%d%d", &amp;L, &amp;M);</span><br><span class="line">    while (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d%d", &amp;start, &amp;end);</span><br><span class="line">        for (int i = start; i &lt;= end; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nTrees[i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= L; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nTrees[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf("%d\n", nCount);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2(合并区间)：<br>思想是将所有区间存储在数组里面,对所有区间以下限为标准排序,然后从头至尾扫描区间数组,合并区间的方法是：当前区间初始化为第一个区间,然后判断下一个区间的下限是否已经超过当前区间的上限,如果是这样的话,就无法继续合并了,那么就继续已经合并区间的长度,重新开始一次新的合并,否则的话,将下一个区间合并到当前区间起来。。。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;stdio.h&gt;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdlib.h&gt;</span><br><span class="line"><span class="number">#def</span>ine M_MAX <span class="number">100</span> + <span class="number">2</span></span><br><span class="line">struct Area</span><br><span class="line">&#123;</span><br><span class="line">    int start;</span><br><span class="line">    int end;</span><br><span class="line">&#125;;</span><br><span class="line">int CompareArea(const void *elem1, const void *elem2)</span><br><span class="line">&#123;</span><br><span class="line">    return ((Area*)elem1)-&gt;start - ((Area*)elem2)-&gt;start;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Area area[M_MAX], temp;</span><br><span class="line">    int L = 0;</span><br><span class="line">    int M = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    scanf("%d%d", &amp;L, &amp;M);</span><br><span class="line">    for (int i = 0; i &lt; M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf("%d%d", &amp;area[i].start, &amp;area[i].end);</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(area, M, sizeof(Area), CompareArea);</span><br><span class="line"></span><br><span class="line">    temp = area[0];</span><br><span class="line">    for (int i = 1; i &lt; M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (area[i].start &lt;= temp.end)</span><br><span class="line">        &#123;</span><br><span class="line">            if (area[i].end &gt; temp.end)</span><br><span class="line">            &#123;</span><br><span class="line">                temp.end = area[i].end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            count += temp.end - temp.start + 1;</span><br><span class="line">            temp = area[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count += temp.end - temp.start + 1;</span><br><span class="line"></span><br><span class="line">    printf("%d\n", L + 1 - count);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>整个算法的时间复杂度是 O(M * logM) + O(M)…</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
