<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://xiaopengcheng.top').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left"},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '420f506edca2c5290761c146d6bde3b2',
      indexName: 'xiaopengcheng.top',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="filament是Google开源的一个跨平台实时pbr渲染引擎。注意，这是一个渲染引擎，不是一个完整的游戏引擎。filament的材质系统文档：Filament Materials Guide，pbr算法文档：Physically Based Rendering in Filament。这些文档只是从使用层面简单介绍材质系统和使用的PBR算法等，并没有深入介绍材质的整体流程和一些关键技术细节。因">
<meta property="og:type" content="article">
<meta property="og:title" content="filament的材质系统">
<meta property="og:url" content="http://xiaopengcheng.top/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="远行&#39;s Blog">
<meta property="og:description" content="filament是Google开源的一个跨平台实时pbr渲染引擎。注意，这是一个渲染引擎，不是一个完整的游戏引擎。filament的材质系统文档：Filament Materials Guide，pbr算法文档：Physically Based Rendering in Filament。这些文档只是从使用层面简单介绍材质系统和使用的PBR算法等，并没有深入介绍材质的整体流程和一些关键技术细节。因">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/filament%E6%9D%90%E8%B4%A8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/filament%E6%9D%90%E8%B4%A8%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%9D%90%E8%B4%A8%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA.png">
<meta property="article:published_time" content="2024-12-28T04:28:30.000Z">
<meta property="article:modified_time" content="2024-12-28T06:06:26.440Z">
<meta property="article:author" content="远行">
<meta property="article:tag" content="filament">
<meta property="article:tag" content="材质系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/filament%E6%9D%90%E8%B4%A8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png">

<link rel="canonical" href="http://xiaopengcheng.top/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>filament的材质系统 | 远行's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="远行's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">远行's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">STEP BY STEP</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-github">

    <a href="https://github.com/xpc-yx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>

  </li>
        <li class="menu-item menu-item-e-mail">

    <a href="mailto:xiaopengcheng4912@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>邮箱</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xiaopengcheng.top/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="远行">
      <meta itemprop="description" content="远行的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远行's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          filament的材质系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-28 12:28:30" itemprop="dateCreated datePublished" datetime="2024-12-28T12:28:30+08:00">2024-12-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rendering/" itemprop="url" rel="index">
                    <span itemprop="name">Rendering</span>
                  </a>
                </span>
            </span>

          
            <span id="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" class="post-meta-item leancloud_visitors" data-flag-title="filament的材质系统" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body><p><a href="https://github.com/google/filament">filament</a>是Google开源的一个跨平台实时pbr渲染引擎。注意，这是一个渲染引擎，不是一个完整的游戏引擎。<br>filament的材质系统文档：<a href="https://google.github.io/filament/Materials.html">Filament Materials Guide</a>，pbr算法文档：<a href="https://google.github.io/filament/Filament.html">Physically Based Rendering in Filament</a>。这些文档只是从使用层面简单介绍材质系统和使用的PBR算法等，并没有深入介绍材质的整体流程和一些关键技术细节。因此，本文打算深入介绍材质系统相关的整体流程以及材质渲染相关的关键技术细节。</p>
<h1 id="一-材质编写"><a href="#一-材质编写" class="headerlink" title="一. 材质编写"></a>一. 材质编写</h1><p>这部分大概介绍下材质相关的语法。以下面的材质示例代码来说明：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">material {    </span><br><span class="line">    name : "Textured material",</span><br><span class="line">    requires : [ uv0, color ],    </span><br><span class="line">    shadingModel : lit,</span><br><span class="line">    blending : opaque,</span><br><span class="line">    parameters : [       </span><br><span class="line">        {    type : sampler2d,       name : baseColor        },    </span><br><span class="line">        {    type : float,           name : metallic       },     </span><br><span class="line">        {    type : float,           name : roughness      }</span><br><span class="line">    ],</span><br><span class="line">    constants : [</span><br><span class="line">        {</span><br><span class="line">           name : overrideAlpha,</span><br><span class="line">           type : bool</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">           name : customAlpha,</span><br><span class="line">           type : float,</span><br><span class="line">           default : 0.5</span><br><span class="line">        }</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">vertex {    </span><br><span class="line">    void materialVertex(inout MaterialVertexInputs material) { </span><br><span class="line">        material.color *= sin(getUserTime().x); </span><br><span class="line">        material.uv0 *= sin(getUserTime().x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fragment {  </span><br><span class="line">    void material(inout MaterialInputs material) { </span><br><span class="line">        prepareMaterial(material);</span><br><span class="line">        material.baseColor = texture(materialParams_baseColor, getUV0()); </span><br><span class="line">        material.metallic = materialParams.metallic;</span><br><span class="line">        material.roughness = materialParams.roughness;</span><br><span class="line">                </span><br><span class="line">                if (materialConstants_overrideAlpha) {</span><br><span class="line">            material.baseColor.a = materialConstants_customAlpha;</span><br><span class="line">            material.baseColor.rgb *= material.baseColor.a;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上述示例代码来看，一个材质分开三块：material、vertex、fragment。其中，material是材质熟悉块，vertex是顶点代码块，fragment是片元代码块。如果是一个compute材质，那么只有一个compute代码块。</p>
<h2 id="1-1-材质属性块"><a href="#1-1-材质属性块" class="headerlink" title="1.1 材质属性块"></a>1.1 材质属性块</h2><p>这部分包括所有的材质设置，比如渲染状态设置、材质的uniform参数以及各种其它设置。举例说明，blending是混合模式，是渲染状态设置；shadingModel是光照模型，类似一个材质变体设置；parameters则是uniform参数，比如float最终是存放在材质的uniform buffer内，而sampler2d是生成uniform sampler。</p>
<h2 id="1-2-代码块"><a href="#1-2-代码块" class="headerlink" title="1.2 代码块"></a>1.2 代码块</h2><p>filament的材质是一种surface材质。surface材质是一种受限制的材质，意思是一种只开放表面属性修改的材质，这种材质书写方式入门比较简单，但是功能比较受限制。unity的默认管线也支持surface材质，具体可以参考<a href="https://docs.unity3d.com/Manual/SL-SurfaceShaders.html">Introduction to surface shaders in the Built-In Render Pipeline</a>。</p>
<h3 id="1-2-1-顶点代码"><a href="#1-2-1-顶点代码" class="headerlink" title="1.2.1 顶点代码"></a>1.2.1 顶点代码</h3><p>vertex下的入口函数是materialVertex，只能在该函数内修改inout的MaterialVertexInputs参数material来定制顶点着色器。MaterialVertexInputs是顶点的输入定义结构体，定义如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct MaterialVertexInputs {</span><br><span class="line">#ifdef HAS_ATTRIBUTE_COLOR</span><br><span class="line">    vec4 color;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_UV0</span><br><span class="line">    vec2 uv0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_UV1</span><br><span class="line">    vec2 uv1;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM0</span><br><span class="line">    vec4 VARIABLE_CUSTOM0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM1</span><br><span class="line">    vec4 VARIABLE_CUSTOM1;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM2</span><br><span class="line">    vec4 VARIABLE_CUSTOM2;</span><br><span class="line">#endif</span><br><span class="line">#ifdef VARIABLE_CUSTOM3</span><br><span class="line">    vec4 VARIABLE_CUSTOM3;</span><br><span class="line">#endif</span><br><span class="line">#ifdef HAS_ATTRIBUTE_TANGENTS</span><br><span class="line">    vec3 worldNormal;</span><br><span class="line">#endif</span><br><span class="line">    vec4 worldPosition;</span><br><span class="line">#ifdef VERTEX_DOMAIN_DEVICE</span><br><span class="line">#ifdef MATERIAL_HAS_CLIP_SPACE_TRANSFORM</span><br><span class="line">    mat4 clipSpaceTransform;</span><br><span class="line">#endif // MATERIAL_HAS_CLIP_SPACE_TRANSFORM</span><br><span class="line">#endif // VERTEX_DOMAIN_DEVICE</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>比如，color、uv0、uv1都是顶点属性。</p>
<h3 id="1-2-2-片元代码"><a href="#1-2-2-片元代码" class="headerlink" title="1.2.2 片元代码"></a>1.2.2 片元代码</h3><p>fragment也是类似的逻辑，入口函数是material，只能通过修改inout的MaterialInputs参数material来定制片元着色器。MaterialInputs结构体是pbr或者更复杂的渲染模型的属性，定义如下。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">struct MaterialInputs {</span><br><span class="line">    vec4  baseColor;</span><br><span class="line">#if !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">#if !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    float roughness;</span><br><span class="line">#endif</span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    float metallic;</span><br><span class="line">    float reflectance;</span><br><span class="line">#endif</span><br><span class="line">    float ambientOcclusion;</span><br><span class="line">#endif</span><br><span class="line">    vec4  emissive;</span><br><span class="line"></span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SUBSURFACE) &amp;&amp; !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">    vec3 sheenColor;</span><br><span class="line">    float sheenRoughness;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    float clearCoat;</span><br><span class="line">    float clearCoatRoughness;</span><br><span class="line"></span><br><span class="line">    float anisotropy;</span><br><span class="line">    vec3  anisotropyDirection;</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_SUBSURFACE) || defined(MATERIAL_HAS_REFRACTION)</span><br><span class="line">    float thickness;</span><br><span class="line">#endif</span><br><span class="line">#if defined(SHADING_MODEL_SUBSURFACE)</span><br><span class="line">    float subsurfacePower;</span><br><span class="line">    vec3  subsurfaceColor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_CLOTH)</span><br><span class="line">    vec3  sheenColor;</span><br><span class="line">#if defined(MATERIAL_HAS_SUBSURFACE_COLOR)</span><br><span class="line">    vec3  subsurfaceColor;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">    vec3  specularColor;</span><br><span class="line">    float glossiness;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_NORMAL)</span><br><span class="line">    vec3  normal;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_BENT_NORMAL)</span><br><span class="line">    vec3  bentNormal;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_CLEAR_COAT) &amp;&amp; defined(MATERIAL_HAS_CLEAR_COAT_NORMAL)</span><br><span class="line">    vec3  clearCoatNormal;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_POST_LIGHTING_COLOR)</span><br><span class="line">    vec4  postLightingColor;</span><br><span class="line">    float postLightingMixFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if !defined(SHADING_MODEL_CLOTH) &amp;&amp; !defined(SHADING_MODEL_SUBSURFACE) &amp;&amp; !defined(SHADING_MODEL_UNLIT)</span><br><span class="line">#if defined(MATERIAL_HAS_REFRACTION)</span><br><span class="line">#if defined(MATERIAL_HAS_ABSORPTION)</span><br><span class="line">    vec3 absorption;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_TRANSMISSION)</span><br><span class="line">    float transmission;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_IOR)</span><br><span class="line">    float ior;</span><br><span class="line">#endif</span><br><span class="line">#if defined(MATERIAL_HAS_MICRO_THICKNESS) &amp;&amp; (REFRACTION_TYPE == REFRACTION_TYPE_THIN)</span><br><span class="line">    float microThickness;</span><br><span class="line">#endif</span><br><span class="line">#elif !defined(SHADING_MODEL_SPECULAR_GLOSSINESS)</span><br><span class="line">#if defined(MATERIAL_HAS_IOR)</span><br><span class="line">    float ior;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_SPECULAR_FACTOR)</span><br><span class="line">    float specularFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if defined(MATERIAL_HAS_SPECULAR_COLOR_FACTOR)</span><br><span class="line">    vec3 specularColorFactor;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>因此，只需要简单的在入口函数内修改属性，就可以便捷的实现材质效果。</p>
<h3 id="1-2-3-compute代码块"><a href="#1-2-3-compute代码块" class="headerlink" title="1.2.3 compute代码块"></a>1.2.3 compute代码块</h3><p>如果使用的是compute材质，那么代码块是compute代码块。示例如下：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">material {</span><br><span class="line">    name: testCompute,</span><br><span class="line">    domain: compute,</span><br><span class="line">    groupSize: [32, 32, 1],</span><br><span class="line">    parameters: [</span><br><span class="line">        {type : sampler2d, name : color}</span><br><span class="line">    ]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">compute {</span><br><span class="line">    void compute() {</span><br><span class="line">        int3 id = int3(getGlobalInvocationID());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="二-材质编译"><a href="#二-材质编译" class="headerlink" title="二. 材质编译"></a>二. 材质编译</h1><p>filament有一个专门的材质编译工具matc。该工具主要做了两件事情：一个是解析material材质属性块，根据材质属性块生成代码，需要序列化的材质属性写入材质属性数据块中；一个是编译材质代码，将编译后的所有的变体代码写入到代码数据块中。<br>整体流程图：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/filament材质编译流程.png"></p>
<h2 id="2-1-材质属性编译"><a href="#2-1-材质属性编译" class="headerlink" title="2.1 材质属性编译"></a>2.1 材质属性编译</h2><p>材质属性，指定是material块内的定义。材质属性主要包括两类，生成代码的属性和其它属性。生成代码的属性包括parameters和constants属性，parameters和constants属性会生成代码定义，同时也会进行序列化；而其它类型的材质属性会在解析后进行序列化。</p>
<h3 id="2-1-1-parameters属性"><a href="#2-1-1-parameters属性" class="headerlink" title="2.1.1 parameters属性"></a>2.1.1 parameters属性</h3><p>parameters块内定义的属性，type指定类型，主要是两类：数值类型和采样器类型。最终，所有的数值类型会存放到一个着材质实例的uniform buffer内。而每个采样器类型的参数，都会生成一个着材质实例的uniform sampler。</p>
<h3 id="2-1-2-其它属性"><a href="#2-1-2-其它属性" class="headerlink" title="2.1.2 其它属性"></a>2.1.2 其它属性</h3><p>这部分属性包括，材质渲染状态设置、光照模型相关等。对于编译器来说，这部分设置解析出来后再序列化就行。</p>
<h2 id="2-2-材质代码编译"><a href="#2-2-材质代码编译" class="headerlink" title="2.2 材质代码编译"></a>2.2 材质代码编译</h2><h3 id="2-2-1-生成材质属性定义"><a href="#2-2-1-生成材质属性定义" class="headerlink" title="2.2.1 生成材质属性定义"></a>2.2.1 生成材质属性定义</h3><p>示例代码的parameters生成的ubo定义可能如下：</p>
<ol>
<li><strong>Uniform Buffer生成</strong></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout(binding = 10, std140, set = 1) uniform MaterialParams {</span><br><span class="line">    float metallic;</span><br><span class="line">    float roughness;</span><br><span class="line">} materialParams;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>Uniform Sampler生成</strong><br>示例代码的parameters生成的uniform sampler定义可能如下：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout(binding = 10, set = 2) uniform lowp sampler2D materialParams_baseColor;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>Specialization Constants生成</strong><br>示例代码的constants生成的specialization constants定义可能如下</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout (constant_id = 8) const bool materialConstants_overrideAlpha = false;</span><br><span class="line">layout (constant_id = 9) const float materialConstants_customAlpha = 0.500000;</span><br></pre></td></tr></tbody></table></figure>
<p>至于什么是<strong>specialization constants</strong>，请参考文档：<a href="https://docs.vulkan.org/samples/latest/samples/performance/specialization_constants/README.htm">Utilizing Specialization Constants</a>。简而言之，这是一种将编译器的预处理阶段的宏延迟到gpu编译阶段的手段。</p>
<h1 id="三-材质加载和材质实例创建"><a href="#三-材质加载和材质实例创建" class="headerlink" title="三. 材质加载和材质实例创建"></a>三. 材质加载和材质实例创建</h1><h2 id="3-1-整体介绍"><a href="#3-1-整体介绍" class="headerlink" title="3.1 整体介绍"></a>3.1 整体介绍</h2><p>这部分主要涉及三个类，材质类Material、材质示例类MaterialInstance、材质解析类MaterialParser。Material类对应的是Unity的Shader类，MaterialInstance类对应的是Unity的Material类。整体流程如下：<br><img alt="" data-src="https://raw.githubusercontent.com/xpc-yx/markdown_img/master/小书匠/filament材质加载和材质实例创建.png"></p>
<h2 id="3-2-材质创建"><a href="#3-2-材质创建" class="headerlink" title="3.2 材质创建"></a>3.2 材质创建</h2><h3 id="3-2-1-数据解析"><a href="#3-2-1-数据解析" class="headerlink" title="3.2.1 数据解析"></a>3.2.1 数据解析</h3><ol>
<li><strong>MaterialParser</strong><br>材质创建的第一步是解析二进制的材质数据，即材质编译阶段序列化各种数据块，包括材质属性数据块以及材质代码数据块。该类的parse函数会遍历解析出所有的数据Chunk，保存起来作为后续真正的数据解析使用。</li>
<li><strong>兼容检测</strong><br>将所有的数据块全部加载到内存中后，再做一些基本的检测，比如材质版本号匹配、shaderModel（平台）匹配等，如果通过才真正去创建材质。<h3 id="3-2-2-创建材质对象"><a href="#3-2-2-创建材质对象" class="headerlink" title="3.2.2 创建材质对象"></a>3.2.2 创建材质对象</h3>材质数据加载后，并且通过兼容性检测后，会调用engine的createMaterial函数去创建材质对象。filament的所有gpu相关对象最终都是通过engine类来创建管理的。<h3 id="3-2-3-初始化材质属性"><a href="#3-2-3-初始化材质属性" class="headerlink" title="3.2.3 初始化材质属性"></a>3.2.3 初始化材质属性</h3>在FMaterial类的构造函数内，会通过调用MaterialParser的具体解析函数，将所有材质数据属性解析出来，然后做好相应的运行时状态初始化。</li>
<li><strong>描述集Layout</strong><br>材质内有两个DescriptorSetLayout，一个是材质本身的DescriptorSetLayout，一个是PerView的DescriptorSetLayout。这两个layout是用于提交材质级别和PerView级别的数据。材质本身的DescriptorSetLayout用于后续初始化材质实例的DescriptorSet；材质实例的DescriptorSet用于提交材质数据。</li>
<li><strong>SpecializationConstants</strong><br>specializationConstants是一种新的动态变体技术，具体在生成材质属性定义里面有介绍。在材质解析阶段，需要解析出材质的specializationConstants设置，然后在切换材质变体时候通过传递给对应的gpu program进行切换。<br>filament的specializationConstants变体问题<br>filament将specializationConstants数据保存在材质内，会导致设置时候引起该材质所有的材质实例变化。这并不喝了，因为变体从使用上是材质实例级别的，不同的材质实例需要保存不同的变体设置，所以应该通过材质实例来保存和设置变体数据。</li>
<li><strong>pushConstants</strong><br>关于什么是pushConstants ，参考文档：Push Constants。简单理解，即这是一块区分于UBO的小数据块，相比UBO有一定的性能优势，但是大小受限制。<br>实际上，当前版本的filament只是用pushConstants处理了引擎morphing数据，并没有开放材质级别的写法。如下代码，<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">utils::FixedCapacityVector&lt;filament::MaterialPushConstant&gt; const PUSH_CONSTANTS = {</span><br><span class="line">    {</span><br><span class="line">        "morphingBufferOffset",</span><br><span class="line">        filament::backend::ConstantType::INT,</span><br><span class="line">        filament::backend::ShaderStage::VERTEX,</span><br><span class="line">    },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
材质文件固定序列化上述代码的pushConstants。</li>
<li><strong>其它属性</strong><br>其它属性涉及范围比较广，比如渲染状态的设置，包括深度测试/写入、混合、模板测试等，也包括材质相关的设置，比如材质效果相关的设置等。这些属性都会序列化为数据块，然后在材质创建时候，通过MaterialParser解析出来保存在材质内。<h2 id="3-3-材质实例创建"><a href="#3-3-材质实例创建" class="headerlink" title="3.3 材质实例创建"></a>3.3 材质实例创建</h2>创建材质实例有两种路径，但是初始化流程是一致的，都是初始化描述集和其它材质属性。</li>
<li><strong>初始化描述集</strong><br>材质实例的DescriptorSet通过材质的DescriptorSetLayout进行初始化。材质实例使用该DescriptorSet进行数据的提交和绑定，包括Sampler和Uniform Buffer。因此，需要在初始化阶段将材质Uniform Buffer的通过调用setBuffer设置给DescriptorSet。</li>
<li><strong>初始化其它材质属性</strong><br>其它材质属性，基本是通过从材质或者其它材质实例内拷贝的方式设置的。这些存储在材质实例内的材质属性，通常与渲染状态或者渲染效果相关，比如混合、深度测试/写入等。</li>
</ol>
<h1 id="四-材质变体"><a href="#四-材质变体" class="headerlink" title="四. 材质变体"></a>四. 材质变体</h1><p>filament支持基于宏的传统变体，即每一个变体是一个gpu program。在编译材质时候，根据不同的宏定义组合编译出不同的gpu program；在运行阶段，根据stage和变体匹配到对应的gpu program。</p>
<h2 id="4-1-变体定义"><a href="#4-1-变体定义" class="headerlink" title="4.1 变体定义"></a>4.1 变体定义</h2><h3 id="4-1-1-Surface材质变体"><a href="#4-1-1-Surface材质变体" class="headerlink" title="4.1.1 Surface材质变体"></a>4.1.1 Surface材质变体</h3><p>filament有一个Variant类，里面定义了Surface材质可以使用的变体。如下摘自其变体注释代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// DIR: Directional Lighting</span><br><span class="line">// DYN: Dynamic Lighting</span><br><span class="line">// SRE: Shadow Receiver</span><br><span class="line">// SKN: Skinning</span><br><span class="line">// DEP: Depth only</span><br><span class="line">// FOG: Fog</span><br><span class="line">// PCK: Picking (depth variant only)</span><br><span class="line">// VSM: Variance shadow maps</span><br><span class="line">// STE: Instanced stereo rendering</span><br><span class="line">//</span><br><span class="line">//   X: either 1 or 0</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">// Variant              | STE | VSM | FOG | DEP | SKN | SRE | DYN | DIR |   256</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                                    PCK</span><br><span class="line">//</span><br><span class="line">// Standard variants:</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                      | STE | VSM | FOG |  0  | SKN | SRE | DYN | DIR |    128 - 44 = 84</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//      Vertex shader      X     0     0     0     X     X     X     X</span><br><span class="line">//    Fragment shader      0     X     X     0     0     X     X     X</span><br><span class="line">//       Fragment SSR      0     1     0     0     0     1     0     0</span><br><span class="line">//           Reserved      X     1     1     0     X     1     0     0      [ -4]</span><br><span class="line">//           Reserved      X     0     X     0     X     1     0     0      [ -8]</span><br><span class="line">//           Reserved      X     1     X     0     X     0     X     X      [-32]</span><br><span class="line">//</span><br><span class="line">// Depth variants:</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//                      | STE | VSM | PCK |  1  | SKN |  0  |  0  |  0  |   16 - 4 = 12</span><br><span class="line">//                      +-----+-----+-----+-----+-----+-----+-----+-----+</span><br><span class="line">//       Vertex depth      X     X     0     1     X     0     0     0</span><br><span class="line">//     Fragment depth      0     X     X     1     0     0     0     0</span><br><span class="line">//           Reserved      X     1     1     1     X     0     0     0     [  -4]</span><br><span class="line">//</span><br><span class="line">// 96 variants used, 160 reserved (256 - 96)</span><br><span class="line">//</span><br><span class="line">// note: a valid variant can be neither a valid vertex nor a valid fragment variant</span><br><span class="line">//       (e.g.: FOG|SKN variants), the proper bits are filtered appropriately,</span><br><span class="line">//       see filterVariantVertex(), filterVariantFragment().</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>8位变体</li>
<li>顶点和片元的变体是分开的</li>
<li>X表示该变体位可以切换，1或者0表示只能设置为固定值。</li>
<li>Reserved是无效的变体组合。<h3 id="4-1-2-PostProcess材质变体"><a href="#4-1-2-PostProcess材质变体" class="headerlink" title="4.1.2 PostProcess材质变体"></a>4.1.2 PostProcess材质变体</h3></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static constexpr size_t POST_PROCESS_VARIANT_BITS = 1;</span><br><span class="line">static constexpr size_t POST_PROCESS_VARIANT_COUNT = (1u &lt;&lt; POST_PROCESS_VARIANT_BITS);</span><br><span class="line">static constexpr size_t POST_PROCESS_VARIANT_MASK = POST_PROCESS_VARIANT_COUNT - 1;</span><br><span class="line"></span><br><span class="line">enum class PostProcessVariant : uint8_t {</span><br><span class="line">    OPAQUE,</span><br><span class="line">    TRANSLUCENT</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>根据上述定义，后处理材质支持2个变体。</p>
<h3 id="4-1-3-Compute材质变体"><a href="#4-1-3-Compute材质变体" class="headerlink" title="4.1.3 Compute材质变体"></a>4.1.3 Compute材质变体</h3><p>compute材质不支持变体切换。</p>
<h2 id="4-2-变体编译"><a href="#4-2-变体编译" class="headerlink" title="4.2 变体编译"></a>4.2 变体编译</h2><ol>
<li><strong>计算所有有效变体组合</strong></li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// Generate all shaders and write the shader chunks.</span><br><span class="line"></span><br><span class="line">std::vector&lt;Variant&gt; variants;</span><br><span class="line">switch (mMaterialDomain) {</span><br><span class="line">    case MaterialDomain::SURFACE:</span><br><span class="line">        variants = determineSurfaceVariants(mVariantFilter, isLit(), mShadowMultiplier);</span><br><span class="line">        break;</span><br><span class="line">    case MaterialDomain::POST_PROCESS:</span><br><span class="line">        variants = determinePostProcessVariants();</span><br><span class="line">        break;</span><br><span class="line">    case MaterialDomain::COMPUTE:</span><br><span class="line">        variants = determineComputeVariants();</span><br><span class="line">        break;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>determineSurfaceVariants函数是跟Variant类的定义，遍历出所有有效的顶点变体和片元变体。determinePostProcessVariants则是返回2个固定的顶点和片元变体。determineComputeVariants返回默认的一个0变体。</p>
<ol>
<li><strong>根据变体组合生成宏定义</strong><br>材质编译工具的代码生成类ShaderGenerator里面有一个generateSurfaceMaterialVariantDefines函数，该函数会根据变体组合variant来生成对应的宏定义。其部分代码如下：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void ShaderGenerator::generateSurfaceMaterialVariantDefines(utils::io::sstream&amp; out,</span><br><span class="line">        ShaderStage stage, MaterialBuilder::FeatureLevel featureLevel,</span><br><span class="line">        MaterialInfo const&amp; material, filament::Variant variant) noexcept {</span><br><span class="line"></span><br><span class="line">    bool const litVariants = material.isLit || material.hasShadowMultiplier;</span><br><span class="line"></span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_DIRECTIONAL_LIGHTING",</span><br><span class="line">            litVariants &amp;&amp; variant.hasDirectionalLighting());</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_DYNAMIC_LIGHTING",</span><br><span class="line">            litVariants &amp;&amp; variant.hasDynamicLighting());</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_SHADOWING",</span><br><span class="line">            litVariants &amp;&amp; filament::Variant::isShadowReceiverVariant(variant));</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_VSM",</span><br><span class="line">            filament::Variant::isVSMVariant(variant));</span><br><span class="line">    CodeGenerator::generateDefine(out, "VARIANT_HAS_STEREO",</span><br><span class="line">            hasStereo(variant, featureLevel));</span><br><span class="line"></span><br><span class="line">    switch (stage) {</span><br><span class="line">        case ShaderStage::VERTEX:</span><br><span class="line">        CodeGenerator::generateDefine(out, "VARIANT_HAS_SKINNING_OR_MORPHING",</span><br><span class="line">                hasSkinningOrMorphing(variant, featureLevel));</span><br><span class="line">            break;</span><br><span class="line">        case ShaderStage::FRAGMENT:</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_FOG",</span><br><span class="line">                    filament::Variant::isFogVariant(variant));</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_PICKING",</span><br><span class="line">                    filament::Variant::isPickingVariant(variant));</span><br><span class="line">            CodeGenerator::generateDefine(out, "VARIANT_HAS_SSR",</span><br><span class="line">                    filament::Variant::isSSRVariant(variant));</span><br><span class="line">            break;</span><br><span class="line">        case ShaderStage::COMPUTE:</span><br><span class="line">            break;</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
<p>所有的宏定义组合就对应一个变体组合的program。</p>
<h2 id="4-3-变体切换"><a href="#4-3-变体切换" class="headerlink" title="4.3 变体切换"></a>4.3 变体切换</h2><p>变体编译阶段是根据材质类型、Stage（顶点/片元）、变体组合来生成对应的program的。因此，变体切换阶段，也是根据这些信息查找出对应的program代码。然后，使用这个代码（比如SPIR-V中间代码）来创建gpu program。<br>部分关键代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void FMaterial::prepareProgramSlow(Variant variant,</span><br><span class="line">        backend::CompilerPriorityQueue priorityQueue) const noexcept {</span><br><span class="line">    assert_invariant(mEngine.hasFeatureLevel(mFeatureLevel));</span><br><span class="line">    switch (getMaterialDomain()) {</span><br><span class="line">        case MaterialDomain::SURFACE:</span><br><span class="line">            getSurfaceProgramSlow(variant, priorityQueue);</span><br><span class="line">            break;</span><br><span class="line">        case MaterialDomain::POST_PROCESS:</span><br><span class="line">            getPostProcessProgramSlow(variant, priorityQueue);</span><br><span class="line">            break;</span><br><span class="line">        case MaterialDomain::COMPUTE:</span><br><span class="line">            // TODO: implement MaterialDomain::COMPUTE</span><br><span class="line">            break;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool MaterialChunk::getBinaryShader(BlobDictionary const&amp; dictionary,</span><br><span class="line">        ShaderContent&amp; shaderContent, ShaderModel shaderModel, filament::Variant variant, ShaderStage shaderStage) {</span><br><span class="line"></span><br><span class="line">    if (mBase == nullptr) {</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    uint32_t key = makeKey(shaderModel, variant, shaderStage);</span><br><span class="line">    auto pos = mOffsets.find(key);</span><br><span class="line">    if (pos == mOffsets.end()) {</span><br><span class="line">        return false;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    shaderContent = dictionary[pos-&gt;second];</span><br><span class="line">    return true;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>getSurfaceProgramSlow最终会调用到MaterialChunk::getBinaryShader从二进制材质数据中查找出指定变体的二进制代码。makeKey函数的参数是shaderModel（平台）、variant、shaderStage，这个key就是变体查找的键值。</p>
<h2 id="4-4-变体使用"><a href="#4-4-变体使用" class="headerlink" title="4.4 变体使用"></a>4.4 变体使用</h2><p>filament的变体使用方式分为三步：</p>
<ol>
<li><strong>计算变体组合</strong><br>这一步通常是渲染管线或者渲染Pass在计算。比如，ColorPass或者DepthPass、PickingPass等。</li>
<li><strong>prepareProgram</strong><br>使用第一步计算出的变体调用材质函数的prepareProgram以准备变体。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void prepareProgram(Variant variant,</span><br><span class="line">        backend::CompilerPriorityQueue priorityQueue = CompilerPriorityQueue::HIGH) const noexcept {</span><br><span class="line">    if (UTILS_UNLIKELY(!isCached(variant))) {</span><br><span class="line">        prepareProgramSlow(variant, priorityQueue);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><strong>getProgram</strong><br>使用第一步计算出的变体调用材质函数的getProgram获得对应变体的program的handle。</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backend::Handle&lt;backend::HwProgram&gt; getProgram(Variant variant) const noexcept {</span><br><span class="line">    assert_invariant(mCachedPrograms[variant.key]);</span><br><span class="line">    return mCachedPrograms[variant.key];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pipeline.program = ma-&gt;getProgram(info.materialVariant);</span><br></pre></td></tr></tbody></table></figure>
<p>然后将获得的program赋值给pipeline的program。</p>
<h2 id="4-5-再谈SpecializationConstants变体"><a href="#4-5-再谈SpecializationConstants变体" class="headerlink" title="4.5 再谈SpecializationConstants变体"></a>4.5 再谈SpecializationConstants变体</h2><h3 id="4-5-1-filament变体的问题"><a href="#4-5-1-filament变体的问题" class="headerlink" title="4.5.1 filament变体的问题"></a>4.5.1 filament变体的问题</h3><p>根据前述变体使用的步骤，在使用filament的变体时候并不方便。</p>
<pre><code>1. 首先，变体设置是需要在外部计算的。
2. 其次，变体设置并没有保存在材质实例内，反而需要外部代码保存。
3.从使用角度上来说，应该在材质实例内保存其对应的variant，然后一个材质实例对应一个program才更方便理解。
</code></pre><h3 id="4-5-2-filament的SpecializationConstants变体问题"><a href="#4-5-2-filament的SpecializationConstants变体问题" class="headerlink" title="4.5.2 filament的SpecializationConstants变体问题"></a>4.5.2 filament的SpecializationConstants变体问题</h3><p>filament的specializationConstants变体也存在类似的问题。specializationConstants变体是通过传入设置数据给gpu program对象来生效的，而且specializationConstants变体的设置还存在在材质内。</p>
<h3 id="4-5-3-优化思路"><a href="#4-5-3-优化思路" class="headerlink" title="4.5.3 优化思路"></a>4.5.3 优化思路</h3><p>因此，比较好的优化方向是将variant和specializationConstants的状态都保存在材质实例内；然后，通过材质实例来从材质中获得不同的program和设置不同的specializationConstants数据。</p>
<h1 id="五-渲染数据的提交和绑定"><a href="#五-渲染数据的提交和绑定" class="headerlink" title="五. 渲染数据的提交和绑定"></a>五. 渲染数据的提交和绑定</h1><p>最后再来讲一讲渲染使用的数据提交和绑定。渲染数据一般指定是Buffer和Sampler，也包括其它一些特殊数据，比如SpecializationConstants和pushConstants。从作用范围上来区分，渲染数据一般能分为三个级别，渲染当前pass要使用的全局数据、当前使用材质的数据、当前drawcall对应的物体的数据。<br>DescriptorSet<br>首先，需要明确filament提交和绑定Buffer和Sampler数据的封装类DescriptorSet。filament通过该类提交和绑定Buffer和Sampler。因此，后续三个级别的数据提交都是通过对该类的封装进行。</p>
<h2 id="5-1-渲染Pass数据提交和绑定"><a href="#5-1-渲染Pass数据提交和绑定" class="headerlink" title="5.1 渲染Pass数据提交和绑定"></a>5.1 渲染Pass数据提交和绑定</h2><p>通常是封装一个Pass级别的数据提交类，比如ColorPassDescriptorSet、PostProcessDescriptorSet、SsrPassDescriptorSet。这些类里面有一个DescriptorSet对象用于真正的数据提交和绑定。<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class PostProcessDescriptorSet {</span><br><span class="line">public:</span><br><span class="line">    explicit PostProcessDescriptorSet() noexcept;</span><br><span class="line"></span><br><span class="line">    void init(FEngine&amp; engine) noexcept;</span><br><span class="line"></span><br><span class="line">    void terminate(HwDescriptorSetLayoutFactory&amp; factory, backend::DriverApi&amp; driver);</span><br><span class="line"></span><br><span class="line">    void setFrameUniforms(backend::DriverApi&amp; driver,</span><br><span class="line">            TypedUniformBuffer&lt;PerViewUib&gt;&amp; uniforms) noexcept;</span><br><span class="line"></span><br><span class="line">    void bind(backend::DriverApi&amp; driver) noexcept;</span><br><span class="line"></span><br><span class="line">    DescriptorSetLayout const&amp; getLayout() const noexcept {</span><br><span class="line">        return mDescriptorSetLayout;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DescriptorSetLayout mDescriptorSetLayout;</span><br><span class="line">    DescriptorSet mDescriptorSet;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">void PostProcessManager::setFrameUniforms(backend::DriverApi&amp; driver,</span><br><span class="line">        TypedUniformBuffer&lt;PerViewUib&gt;&amp; uniforms) noexcept {</span><br><span class="line">    mPostProcessDescriptorSet.setFrameUniforms(driver, uniforms);</span><br><span class="line">    mSsrPassDescriptorSet.setFrameUniforms(uniforms);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void PostProcessManager::bindPostProcessDescriptorSet(backend::DriverApi&amp; driver) const noexcept {</span><br><span class="line">    mPostProcessDescriptorSet.bind(driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>后处理Pass会在适当的时候调用相关函数进行数据提交和绑定，一般是在Pass的最开始进行设置。<br>实际上，一些数据是全局的，可以一次设置后不用改变。所以，Pass级别的数据不一定完全遵守Pass级别的作用域。比如，PostProcessDescriptorSet的setFrameUniforms实际上是在renderJob一开始就调用了，如下代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void FRenderer::renderJob(RootArenaScope&amp; rootArenaScope, FView&amp; view) {</span><br><span class="line">    FEngine&amp; engine = mEngine;</span><br><span class="line">    JobSystem&amp; js = engine.getJobSystem();</span><br><span class="line">    FEngine::DriverApi&amp; driver = engine.getDriverApi();</span><br><span class="line">    PostProcessManager&amp; ppm = engine.getPostProcessManager();</span><br><span class="line">    ppm.setFrameUniforms(driver, view.getFrameUniforms());</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-2-材质数据提交和绑定"><a href="#5-2-材质数据提交和绑定" class="headerlink" title="5.2 材质数据提交和绑定"></a>5.2 材质数据提交和绑定</h2><p>所有的渲染Pass都必须使用材质，渲染物体的Pass需要切换材质，后处理Pass则是使用一个材质。材质数据的使用也是需要有时机的。材质数据实际上会覆盖Pass级别的数据的设置，如果有重复的话；不过，按照filament的定义，这两部分数据是不会互相影响的，因为使用的是不同的DescriptorSetLayout。实际上，filament定义pipeline里面已经对PerView和PerMaterial的DescriptorSetLayout做了区分。PerView的layout就是前面所说的渲染Pass级别的数据。代码如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">struct PipelineLayout {</span><br><span class="line">    using SetLayout = std::array&lt;Handle&lt;HwDescriptorSetLayout&gt;, MAX_DESCRIPTOR_SET_COUNT&gt;;</span><br><span class="line">    SetLayout setLayout;      // 16</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct PipelineState {</span><br><span class="line">    Handle&lt;HwProgram&gt; program;                                              //  4</span><br><span class="line">    Handle&lt;HwVertexBufferInfo&gt; vertexBufferInfo;                            //  4</span><br><span class="line">    PipelineLayout pipelineLayout;                                          // 16</span><br><span class="line">    RasterState rasterState;                                                //  4</span><br><span class="line">    StencilState stencilState;                                              // 12</span><br><span class="line">    PolygonOffset polygonOffset;                                            //  8</span><br><span class="line">    PrimitiveType primitiveType = PrimitiveType::TRIANGLES;                 //  1</span><br><span class="line">    uint8_t padding[3] = {};                                                //  3</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">static constexpr size_t MAX_DESCRIPTOR_SET_COUNT    = 4;    // This is guaranteed by Vulkan.</span><br><span class="line"></span><br><span class="line">enum class DescriptorSetBindingPoints : uint8_t {</span><br><span class="line">    PER_VIEW        = 0,</span><br><span class="line">    PER_RENDERABLE  = 1,</span><br><span class="line">    PER_MATERIAL    = 2,</span><br><span class="line">};</span><br><span class="line">在RenderPass执行时候渲染Command时候，给pipepline同时绑定PER_VIEW和PER_MATERIAL的layout。</span><br><span class="line">// Each material has its own version of the per-view descriptor-set layout,</span><br><span class="line">// because it depends on the material features (e.g. lit/unlit)</span><br><span class="line">pipeline.pipelineLayout.setLayout[+DescriptorSetBindingPoints::PER_VIEW] =</span><br><span class="line">        ma-&gt;getPerViewDescriptorSetLayout(info.materialVariant).getHandle();</span><br><span class="line"></span><br><span class="line">// Each material has a per-material descriptor-set layout which encodes the</span><br><span class="line">// material's parameters (ubo and samplers)</span><br><span class="line">pipeline.pipelineLayout.setLayout[+DescriptorSetBindingPoints::PER_MATERIAL] =</span><br><span class="line">        ma-&gt;getDescriptorSetLayout().getHandle();</span><br><span class="line">5.2.1 材质commit数据</span><br><span class="line">void FEngine::prepare() {</span><br><span class="line">    FEngine::DriverApi&amp; driver = getDriverApi();</span><br><span class="line"></span><br><span class="line">    for (auto&amp; materialInstanceList: mMaterialInstances) {</span><br><span class="line">        materialInstanceList.second.forEach([&amp;driver](FMaterialInstance* item) {</span><br><span class="line">            item-&gt;commit(driver);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void PostProcessManager::commitAndRenderFullScreenQuad(backend::DriverApi&amp; driver,</span><br><span class="line">        FrameGraphResources::RenderPassInfo const&amp; out, FMaterialInstance const* mi,</span><br><span class="line">        PostProcessVariant variant) const noexcept {</span><br><span class="line">    mi-&gt;commit(driver);</span><br><span class="line">    mi-&gt;use(driver);</span><br><span class="line">    FMaterial const* const ma = mi-&gt;getMaterial();</span><br><span class="line">    PipelineState const pipeline = getPipelineState(ma, variant);</span><br><span class="line"></span><br><span class="line">    assert_invariant(</span><br><span class="line">            ((out.params.readOnlyDepthStencil &amp; RenderPassParams::READONLY_DEPTH)</span><br><span class="line">             &amp;&amp; !pipeline.rasterState.depthWrite)</span><br><span class="line">            || !(out.params.readOnlyDepthStencil &amp; RenderPassParams::READONLY_DEPTH));</span><br><span class="line"></span><br><span class="line">    driver.beginRenderPass(out.target, out.params);</span><br><span class="line">    driver.draw(pipeline, mFullScreenQuadRph, 0, 3, 1);</span><br><span class="line">    driver.endRenderPass();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void FMaterialInstance::commit(DriverApi&amp; driver) const {</span><br><span class="line">    // update uniforms if needed</span><br><span class="line">    if (mUniforms.isDirty()) {</span><br><span class="line">        driver.updateBufferObject(mUbHandle, mUniforms.toBufferDescriptor(driver), 0);</span><br><span class="line">    }</span><br><span class="line">    // Commit descriptors if needed (e.g. when textures are updated,or the first time)</span><br><span class="line">    mDescriptorSet.commit(mMaterial-&gt;getDescriptorSetLayout(), driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>prepare是在FRenderer::beginFrame里面调用的，即每帧开始时候会提交所有的材质实例数据，实际上这里主要是非处理材质，后处理材质是在commitAndRenderFullScreenQuad内提交的。commit内做了两件事情，一个是更新UBO数据，一个是通过DescriptorSet进行commit。</p>
<h3 id="5-2-2-材质绑定数据"><a href="#5-2-2-材质绑定数据" class="headerlink" title="5.2.2 材质绑定数据"></a>5.2.2 材质绑定数据</h3><p>绑定材质数据是通过调用材质实例的use函数。材质绑定数据要在调用drawcall函数之前，比如renderpass里面就必须在执行每个command的drawcall前绑定，后处理这种Pass则需要在最终执行渲染drawcall之前绑定数据，可以参考commitAndRenderFullScreenQuad函数代码。下面代码段是RenderPass内绑定材质数据的代码：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (UTILS_UNLIKELY(mi != info.mi)) {</span><br><span class="line">    // this is always taken the first time</span><br><span class="line">    assert_invariant(info.mi);</span><br><span class="line"></span><br><span class="line">    mi = info.mi;</span><br><span class="line">    ...</span><br><span class="line">    // Each MaterialInstance has its own descriptor set. This binds it.</span><br><span class="line">    mi-&gt;use(driver);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>上述代码在RenderPass::Executor::execute内执行command的一段，可以看到在材质实例变化时候，会调用材质实例的use函数绑定不同的材质级别数据。</p>
<h2 id="5-3-Renderable数据提交和绑定"><a href="#5-3-Renderable数据提交和绑定" class="headerlink" title="5.3 Renderable数据提交和绑定"></a>5.3 Renderable数据提交和绑定</h2><p>同一个渲染Pass的Command，可以包括多个材质实例；同一个材质实例，可以渲染多个物体。因此，物体级别的数据优先级别是最高的。</p>
<h3 id="5-3-1-初始化Renderble数据"><a href="#5-3-1-初始化Renderble数据" class="headerlink" title="5.3.1 初始化Renderble数据"></a>5.3.1 初始化Renderble数据</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct PrimitiveInfo { // 56 bytes</span><br><span class="line">    union {</span><br><span class="line">        FMaterialInstance const* mi;</span><br><span class="line">        uint64_t padding; // make this field 64 bits on all platforms</span><br><span class="line">    };</span><br><span class="line">    backend::RenderPrimitiveHandle rph;                 // 4 bytes</span><br><span class="line">    backend::VertexBufferInfoHandle vbih;               // 4 bytes</span><br><span class="line">    backend::DescriptorSetHandle dsh;                   // 4 bytes</span><br><span class="line">    uint32_t indexOffset;                               // 4 bytes</span><br><span class="line">    uint32_t indexCount;                                // 4 bytes</span><br><span class="line">    uint32_t index = 0;                                 // 4 bytes</span><br><span class="line">    uint32_t skinningOffset = 0;                        // 4 bytes</span><br><span class="line">    uint32_t morphingOffset = 0;                        // 4 bytes</span><br><span class="line"></span><br><span class="line">    backend::RasterState rasterState;                   // 4 bytes</span><br><span class="line"></span><br><span class="line">    uint16_t instanceCount;                             // 2 bytes [MSb: user]</span><br><span class="line">    Variant materialVariant;                            // 1 byte</span><br><span class="line">    backend::PrimitiveType type : 3;                    // 1 byte       3 bits</span><br><span class="line">    bool hasSkinning : 1;                               //              1 bit</span><br><span class="line">    bool hasMorphing : 1;                               //              1 bit</span><br><span class="line">    bool hasHybridInstancing : 1;                       //              1 bit</span><br><span class="line"></span><br><span class="line">    uint32_t rfu[2];                                    // 16 bytes</span><br><span class="line">};</span><br><span class="line">static_assert(sizeof(PrimitiveInfo) == 56);</span><br><span class="line"></span><br><span class="line">struct alignas(8) Command {     // 64 bytes</span><br><span class="line">    CommandKey key = 0;         //  8 bytes</span><br><span class="line">    PrimitiveInfo info;    // 56 bytes</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如上代码，RenderPass内的Command定义内有一个图元信息结构PrimitiveInfo。该结构内有一个backend::DescriptorSetHandle成员dsh。dsh表示的就是Renderable级别的渲染数据。dsh是在RenderPass::generateCommandsImpl内通过场景数据FScene::RenderableSoa内的FScene::DESCRIPTOR_SET_HANDLE数据初始化的。</p>
<h3 id="5-3-2-绑定Renderble数据"><a href="#5-3-2-绑定Renderble数据" class="headerlink" title="5.3.2 绑定Renderble数据"></a>5.3.2 绑定Renderble数据</h3><p>在执行每个command的drawcall之前，会调用driver.bindDescriptorSet绑定Renderable级别的数据。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.bindDescriptorSet(info.dsh,</span><br><span class="line">        +DescriptorSetBindingPoints::PER_RENDERABLE,</span><br><span class="line">        {{ offset, info.skinningOffset }, driver});</span><br></pre></td></tr></tbody></table></figure>
<h2 id="5-4-其它数据"><a href="#5-4-其它数据" class="headerlink" title="5.4 其它数据"></a>5.4 其它数据</h2><h3 id="5-4-1-SpecializationConstants"><a href="#5-4-1-SpecializationConstants" class="headerlink" title="5.4.1 SpecializationConstants"></a>5.4.1 SpecializationConstants</h3><p>这部分之前提过，filament是通过切换变体时候，将材质内保存的constants设置数据传递给gpu program，也提到过这部分在实现上有一定的不合理。</p>
<h3 id="5-4-2-PushConstant"><a href="#5-4-2-PushConstant" class="headerlink" title="5.4.2 PushConstant"></a>5.4.2 PushConstant</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (UTILS_UNLIKELY(info.hasMorphing)) {</span><br><span class="line">    driver.setPushConstant(ShaderStage::VERTEX,</span><br><span class="line">            +PushConstantIds::MORPHING_BUFFER_OFFSET, int32_t(info.morphingOffset));</span><br><span class="line">}</span><br><span class="line">driver.draw2(info.indexOffset, info.indexCount, info.instanceCount);</span><br></pre></td></tr></tbody></table></figure>
<p>pushConstant数据则是在调用drawcall之前通过driver.setPushConstant传入driver。目前，filament只支持固定的pushConstants数据。</p>
</body></html>
    </div>

    
    
    
      

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>远行
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://xiaopengcheng.top/2024/12/28/filament%E7%9A%84%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" title="filament的材质系统">http://xiaopengcheng.top/2024/12/28/filament的材质系统/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/filament/" rel="tag"><i class="fa fa-tag"></i> filament</a>
              <a href="/tags/%E6%9D%90%E8%B4%A8%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="fa fa-tag"></i> 材质系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/18/%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E5%92%8C%E7%AA%97%E6%88%B7%E5%AE%A4%E5%86%85%E6%95%88%E6%9E%9C%E6%A8%A1%E6%8B%9F/" rel="prev" title="玻璃效果和窗户室内效果模拟">
      <i class="fa fa-chevron-left"></i> 玻璃效果和窗户室内效果模拟
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/04/24/%E5%9F%BA%E4%BA%8EVulkan%20Specialization%20Constants%E7%9A%84%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93%E7%B3%BB%E7%BB%9F/" rel="next" title="基于Vulkan Specialization Constants的材质变体系统">
      基于Vulkan Specialization Constants的材质变体系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E6%9D%90%E8%B4%A8%E7%BC%96%E5%86%99"><span class="nav-number">1.</span> <span class="nav-text">一. 材质编写</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7%E5%9D%97"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 材质属性块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E9%A1%B6%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 顶点代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E7%89%87%E5%85%83%E4%BB%A3%E7%A0%81"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 片元代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-compute%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 compute代码块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E6%9D%90%E8%B4%A8%E7%BC%96%E8%AF%91"><span class="nav-number">2.</span> <span class="nav-text">二. 材质编译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7%E7%BC%96%E8%AF%91"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 材质属性编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-parameters%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 parameters属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E5%85%B6%E5%AE%83%E5%B1%9E%E6%80%A7"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 其它属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%9D%90%E8%B4%A8%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 材质代码编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E7%94%9F%E6%88%90%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 生成材质属性定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E6%9D%90%E8%B4%A8%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%9D%90%E8%B4%A8%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.</span> <span class="nav-text">三. 材质加载和材质实例创建</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 整体介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%9D%90%E8%B4%A8%E5%88%9B%E5%BB%BA"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 材质创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 数据解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E5%88%9B%E5%BB%BA%E6%9D%90%E8%B4%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 创建材质对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 初始化材质属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%9D%90%E8%B4%A8%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 材质实例创建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93"><span class="nav-number">4.</span> <span class="nav-text">四. 材质变体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%8F%98%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 变体定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-Surface%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 Surface材质变体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-PostProcess%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 PostProcess材质变体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-Compute%E6%9D%90%E8%B4%A8%E5%8F%98%E4%BD%93"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 Compute材质变体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%8F%98%E4%BD%93%E7%BC%96%E8%AF%91"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 变体编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%8F%98%E4%BD%93%E5%88%87%E6%8D%A2"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 变体切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E5%8F%98%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 变体使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E5%86%8D%E8%B0%88SpecializationConstants%E5%8F%98%E4%BD%93"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 再谈SpecializationConstants变体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-filament%E5%8F%98%E4%BD%93%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.1.</span> <span class="nav-text">4.5.1 filament变体的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-filament%E7%9A%84SpecializationConstants%E5%8F%98%E4%BD%93%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.2.</span> <span class="nav-text">4.5.2 filament的SpecializationConstants变体问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="nav-number">4.5.3.</span> <span class="nav-text">4.5.3 优化思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%90%E4%BA%A4%E5%92%8C%E7%BB%91%E5%AE%9A"><span class="nav-number">5.</span> <span class="nav-text">五. 渲染数据的提交和绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%B8%B2%E6%9F%93Pass%E6%95%B0%E6%8D%AE%E6%8F%90%E4%BA%A4%E5%92%8C%E7%BB%91%E5%AE%9A"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 渲染Pass数据提交和绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E6%9D%90%E8%B4%A8%E6%95%B0%E6%8D%AE%E6%8F%90%E4%BA%A4%E5%92%8C%E7%BB%91%E5%AE%9A"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 材质数据提交和绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E6%9D%90%E8%B4%A8%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.2 材质绑定数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Renderable%E6%95%B0%E6%8D%AE%E6%8F%90%E4%BA%A4%E5%92%8C%E7%BB%91%E5%AE%9A"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 Renderable数据提交和绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E5%88%9D%E5%A7%8B%E5%8C%96Renderble%E6%95%B0%E6%8D%AE"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 初始化Renderble数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E7%BB%91%E5%AE%9ARenderble%E6%95%B0%E6%8D%AE"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 绑定Renderble数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 其它数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-SpecializationConstants"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 SpecializationConstants</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-PushConstant"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 PushConstant</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="远行"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">远行</p>
  <div class="site-description" itemprop="description">远行的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">223</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xpc-yx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xpc-yx" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiaopengcheng4912@qq.com" title="E-Mail → mailto:xiaopengcheng4912@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/sitemap.xml" title="sitemap → &#x2F;sitemap.xml"><i class="fa fa-fw fa-sitemap"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i></a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">远行</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">676k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">10:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
if (document.querySelectorAll('div.pdf').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js', () => {
    document.querySelectorAll('div.pdf').forEach(element => {
      PDFObject.embed(element.getAttribute('target'), element, {
        pdfOpenParams: {
          navpanes: 0,
          toolbar: 0,
          statusbar: 0,
          pagemode: 'thumbs',
          view: 'FitH'
        },
        PDFJS_URL: '/lib/pdf/web/viewer.html',
        height: element.getAttribute('height') || '500px'
      });
    });
  }, window.PDFObject);
}
</script>





  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'xqSndxWj2seRmSIR1WvYWOxI-gzGzoHsz',
    appKey: 'dWX3wyEMQ9djk8yiujbPp4pz',
    placeholder: "留下你的足迹 O(∩_∩)O~~",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

</body>
</html>
