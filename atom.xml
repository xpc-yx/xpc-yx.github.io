<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>远行&#39;s Blog</title>
  
  <subtitle>STEP BY STEP</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiaopengcheng.top/"/>
  <updated>2022-01-07T11:05:24.511Z</updated>
  <id>http://xiaopengcheng.top/</id>
  
  <author>
    <name>远行</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>游戏引擎渲染管线的总结</title>
    <link href="http://xiaopengcheng.top/2021/12/22/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://xiaopengcheng.top/2021/12/22/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-22T12:15:00.000Z</published>
    <updated>2022-01-07T11:05:24.511Z</updated>
    
    <content type="html"><![CDATA[<p>需要注意的是，本文涉及的内容过多过杂，基本涉及到游戏渲染和图形管线的方方面面。内容是根据多方面的资料整理而成，比如本人的Unity和Unreal引擎相关的理解和认知，以及引擎相关官方文档等，以及DirectX和OpenGL相关官方文档等，以及网络上各种相关文章和资料等。可能有一些纰漏或者不足之处，或者有些阶段的资料来源较为单一，本人主要目的是从概念理解上对应整个游戏引擎的渲染管线，不一定和真实的游戏完全一一对应，比如应用程序阶段的知识对应到游戏引擎应该会有一些区别和取舍，几何阶段和光栅化阶段主要参考的是OpenGL和DirectX，Vulkan和Metal相关资料参考较少，可能不同的图形API会有一些出入。由于涉及内容过多，难免理解不到位，有发现比较明显错误的，请指出以尽早修正，避免造成误解。</p><h1 id="一、渲染管线的思维导图"><a href="#一、渲染管线的思维导图" class="headerlink" title="一、渲染管线的思维导图"></a>一、渲染管线的思维导图</h1><p>这是本文内容的思维导图，通过该图可以从整体上把握全文的内容，对渲染管线有整理的理解。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/渲染管线.png"></p><h1 id="二、应用程序阶段"><a href="#二、应用程序阶段" class="headerlink" title="二、应用程序阶段"></a>二、应用程序阶段</h1><h2 id="2-1-渲染数据加载"><a href="#2-1-渲染数据加载" class="headerlink" title="2.1 渲染数据加载"></a>2.1 渲染数据加载</h2><p>这个阶段指的是将渲染所需要的相关数据，比如模型、贴图、材质、Shader等加载到内存中，通常只发生一次，不需要每帧重复加载。比如，Unity游戏需要在运行时，将需要的场景或者人物从AssetBundle中加载出来，然后引擎才能显示加载的场景或者人物。</p><h2 id="2-2-物体级别的裁剪"><a href="#2-2-物体级别的裁剪" class="headerlink" title="2.2 物体级别的裁剪"></a>2.2 物体级别的裁剪</h2><p>以下描述的裁剪算法是按照粒度从粗到细的裁剪，相应复杂度和代价也是在递增。最简单的是基于距离的裁剪；然后是利用空间数据结构实现的视锥体裁剪；动态的入口裁剪是一种特殊情况，可以算在视口裁剪内也可以用于预计算；然后预计算数据的裁剪；接下来才是动态的遮挡剔除。</p><h3 id="2-2-1-基于距离的裁剪"><a href="#2-2-1-基于距离的裁剪" class="headerlink" title="2.2.1 基于距离的裁剪"></a>2.2.1 基于距离的裁剪</h3><p>思路是超过一定的视距即不渲染该物体，Unreal引擎支持这个特性，参考<a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/VisibilityCulling/CullDistanceVolume/" target="_blank" rel="noopener">Cull Distance Volumes</a>。对于Unity，可以使用<a href="https://docs.unity3d.com/Manual/CullingGroupAPI.html" target="_blank" rel="noopener">CullingGroup</a>实现类似的功能。即使引擎没有提供类似的支持，在游戏逻辑层面，先可以每帧或者隔帧判断物体跟摄像机的距离，来动态显示隐藏物体。</p><h3 id="2-2-2-视锥体裁剪"><a href="#2-2-2-视锥体裁剪" class="headerlink" title="2.2.2 视锥体裁剪"></a>2.2.2 视锥体裁剪</h3><p>用物体跟摄像机视锥体做相交测试，将完全没有相交的物体过滤掉。为了加快速度，使用的是物体的包围盒或者包围球跟视锥体做相交测试。游戏引擎内一般都会有空间数据结构来组织物体，比如BVH，那么可以直接使用BVH来搜索加速这个计算。具体过程是用视锥体和空间数据结构去做相交测试，如果当前节点没有相交，那么不需要继续，如果有相交则继续遍历子节点直到叶子节点或者没有相交，叶子节点中存储的物体即是需要渲染的物体。</p><h4 id="基于空间数据结构的裁剪"><a href="#基于空间数据结构的裁剪" class="headerlink" title="基于空间数据结构的裁剪"></a>基于空间数据结构的裁剪</h4><h5 id="四叉树和八叉树"><a href="#四叉树和八叉树" class="headerlink" title="四叉树和八叉树"></a>四叉树和八叉树</h5><p>四叉树对应的是二维空间，下面以八叉树为例来说明。八叉树是将三维空间平均划分为八个部分作为八个子节点，重复划分到一定的粒度为止，比如叶子节点内最多存储多少个物体，物体存储在叶子节点内。<br>优点：概念和实现简单。<br>缺点：无限空间不好划分；物体可能跨越分割面；物体分布不均匀会造成层次过深，搜索效率不高。<br>适用场景：四叉树适用于基于高度场的地形管理；八叉树室适用于室外分布均匀的三维场景（有高度）。</p><h5 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h5><p>针对八叉树这种不均匀划分，如果将物体均匀划分成两部分，那么就是Binary Space Partition Tree，可以避免树的层次过深。注意，BSP的每个节点存储的是划分平面，而不是物体，划分平面将场景分为前后2个部分，分别对应左右子树；由于需要BSP树针对的多边形，因此可以针对物体的AABB包围盒做划分。</p><p>优点：物体分布均匀，不会出现树层次过深；支持任意空间。<br>缺点：实现复杂，构造时间长，不适合动态场景。<br>适用场景：紧凑并且分布均匀的室内场景；静态场景；自带物体排序，方便实现画家算法。</p><h5 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h5><p>BSP全称是K-Dimensional Tree。这是一种特殊的BSP，在BSP上进一步将划分面限制跟坐标轴垂直，但是保持从物体分布的中间划分，以尽可能得到一个物体分布均匀的树。KD-Tree不仅仅可以用来做空间划分，在其它领域经常用来组织K维度的数据来做搜索，比如K维数据查询、近邻查询。<br>优点：物体分布均匀，不会出现树层次过深；数据可以组织为数组形式的完全二叉树，缓存友好等。<br>缺点：如何确定最优或者较优的划分面？<br>适用场景：紧凑并且分布均匀的室内场景；辅助其它数据结构进行邻域查询。</p><h5 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h5><p>全名是Bounding Volume Hierarchy，中文翻译层次包围盒。BSP和KD-Tree的节点代表的都是分割面，但是面有可能穿过物体。层次包围盒的思想是每个节点代表一个空间，空间计算其包含物体的最小包围盒，划分空间后重新计算子空间的包围盒。与BSP最大区别是节点代表的不再是分割平面而是包含最小包围盒的子空间。因此，这些子空间可能出现一定的重叠，但是不会出现物体出现在不同的划分里面。<br>优点：节点存储的是物体，方便碰撞检测等查询；构建快，动态更新方便。<br>缺点：如何确定最优的包围盒？<br>适用场景：视锥剔除；物体碰撞检测；射线检测；光线跟踪。</p><h5 id="空间数据结构的其它应用"><a href="#空间数据结构的其它应用" class="headerlink" title="空间数据结构的其它应用"></a>空间数据结构的其它应用</h5><p>除了视锥体裁剪外，空间数据结构还有很多其它应用，比如<br>1、Ray Casting （射线检测）<br>2、碰撞检测<br>3、邻近查询 （比如查询玩家周围敌人）<br>4、光线追踪</p><h4 id="Portal-Culling（入口裁剪）"><a href="#Portal-Culling（入口裁剪）" class="headerlink" title="Portal Culling（入口裁剪）"></a>Portal Culling（入口裁剪）</h4><p>适用于将场景划分为格子，格子之间可能存在入口的情形，如下图所示，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/portal-diagram.png"></p><p>从入口只能看到部分被墙壁遮挡住的物体，因此可以借助这个特性加速视锥体和格子的相交裁剪。Unity中的<a href="https://docs.unity3d.com/Manual/class-OcclusionPortal.html" target="_blank" rel="noopener">Occlusion Portal</a>即是这个特性。如果预计算出Protal Culling的结果，那么可以在运行时加快物体裁剪。</p><h3 id="2-2-3-预计算遮挡剔除"><a href="#2-2-3-预计算遮挡剔除" class="headerlink" title="2.2.3 预计算遮挡剔除"></a>2.2.3 预计算遮挡剔除</h3><p>这是一种空间换时间的算法，会增大内存占用，降低Cpu的裁剪消耗。所以是否需要预计算遮挡数据，还需要具体讨论。一般如果内存消耗不大，但是Cpu占用较高的话，可以尝试开启预计算遮挡数据。</p><h4 id="Precomputed-Visibility-UE4"><a href="#Precomputed-Visibility-UE4" class="headerlink" title="Precomputed Visibility (UE4)"></a>Precomputed Visibility (UE4)</h4><p>参考虚幻引擎的<a href="https://docs.unrealengine.com/4.27/en-US/RenderingAndGraphics/VisibilityCulling/PrecomputedVisibilityVolume/" target="_blank" rel="noopener">Precomputed Visibility</a>。思想是将场景划分为格子，计算每个格子内可以看到的可见物体集合相关的数据，用于运行时动态查询。</p><h4 id="预计算Occlusion-Culling-Unity"><a href="#预计算Occlusion-Culling-Unity" class="headerlink" title="预计算Occlusion Culling (Unity)"></a>预计算Occlusion Culling (Unity)</h4><p>参考Unity的<a href="https://docs.unity3d.com/Manual/OcclusionCulling.html" target="_blank" rel="noopener">Occlusion culling</a>。类似于UE4的Precomputed Visibility，不过Unity的Occlusion Culling也支持动态物体，但是动态物体只能occludee（被遮挡物体）。Unity的预计算Occlusion Culling应该是入口剔除的一种预计算实现。</p><h3 id="2-2-4-动态遮挡查询"><a href="#2-2-4-动态遮挡查询" class="headerlink" title="2.2.4 动态遮挡查询"></a>2.2.4 动态遮挡查询</h3><p>这里讲的是在CPU上或者GPU上实现的遮挡查询。图形API已经提供了遮挡查询相关的接口，比如OpenGL的<a href="https://www.khronos.org/opengl/wiki/Query_Object" target="_blank" rel="noopener">Query Object</a>或者DirectX的<a href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/predication-queries" target="_blank" rel="noopener">Predication Queries</a>。但是不是所有的硬件都能够支持，因此可以在软件层面即在CPU上做软渲染实现遮挡查询。Hierarchical Z-Buffer Occlusion则是在普通的硬件遮挡查询上的进一步优化，使用了层次Z-Buffer来进一步加快速度。</p><h4 id="软件遮挡查询"><a href="#软件遮挡查询" class="headerlink" title="软件遮挡查询"></a>软件遮挡查询</h4><p>软光栅化模仿硬件遮挡查询，因此不受设备类型限制，只是需要额外消耗CPU。</p><h4 id="硬件遮挡查询"><a href="#硬件遮挡查询" class="headerlink" title="硬件遮挡查询"></a>硬件遮挡查询</h4><p>使用图形接口本身提供的遮挡查询接口。基本思想是用物体的包围盒去渲染Z-Buffer，统计通过深度测试的像素数目，如果有通过说明当前物体没有被完全挡住，保存结果用于下一帧查询。因此，硬件遮挡查询会存在两个问题：额外的渲染消耗和延迟一帧。</p><h4 id="Hierarchical-Z-Buffer-Occlusion"><a href="#Hierarchical-Z-Buffer-Occlusion" class="headerlink" title="Hierarchical Z-Buffer Occlusion"></a>Hierarchical Z-Buffer Occlusion</h4><p>类似硬件遮挡查询，不过使用Hierarchical Z-Buffer来加快查询速度。具体实现比较复杂，请参考相关文章。</p><h3 id="2-2-5-LOD切换"><a href="#2-2-5-LOD切换" class="headerlink" title="2.2.5 LOD切换"></a>2.2.5 LOD切换</h3><p>LOD指的是Level Of Details。如果物体通过了以上的裁剪，那么说明会提交给渲染线程进行处理。LOD切换指的是这些物体的细节层次切换，比如一些不重要的或者看不清楚的物体选择更简单的模型。</p><h4 id="基于距离的LOD切换"><a href="#基于距离的LOD切换" class="headerlink" title="基于距离的LOD切换"></a>基于距离的LOD切换</h4><p>最常见的方式是根据摄像机距离来进行LOD切换，越远的物体选择更简略的LOD，Unity和UE4默认是这种方式。</p><h4 id="基于渲染分级切换LOD"><a href="#基于渲染分级切换LOD" class="headerlink" title="基于渲染分级切换LOD"></a>基于渲染分级切换LOD</h4><p>但是我们也可以主动切换LOD，比如检测到当前硬件较差，需要切换到更低的画质，那么可以根据游戏设置的渲染品质分级来切换低的LOD。</p><h4 id="LOD过渡"><a href="#LOD过渡" class="headerlink" title="LOD过渡"></a>LOD过渡</h4><p>LOD的一个常见问题是LOD的过渡问题，可能在切换LOD时候会察觉到明显的过渡。常见的方式是在切换时候混合2个LOD，比如透明度逐渐从1变化到0或者从0变化到1，避免出现明显的过渡。</p><h2 id="2-3-物体级别的渲染排序"><a href="#2-3-物体级别的渲染排序" class="headerlink" title="2.3 物体级别的渲染排序"></a>2.3 物体级别的渲染排序</h2><p>为了减少OverDraw或者实现半透明效果，所有通过裁剪的物体会按照一定的次序进行渲染。下面列举几个常见的渲染次序。游戏引擎实际的渲染过程还会跟引擎渲染管线的Pass定义顺序相关，比如不透明和透明物体在不同的Pass内渲染的，而且是先在一个Pass内渲染透明物体，再在另外一个Pass渲染透明物体。</p><h3 id="从前到后渲染（不透明物体）"><a href="#从前到后渲染（不透明物体）" class="headerlink" title="从前到后渲染（不透明物体）"></a>从前到后渲染（不透明物体）</h3><p>从前到后渲染可以利用Early Z-Test过滤掉不必要的片元处理。因此，如果先渲染近处的物体，那么后面渲染的远处物体就不会通过Early Z-Test，就不会进入片段处理阶段。不过，不是所有的硬件都需要按照从前到后的物体顺序进行渲染，这毕竟需要额外的CPU消耗来排序物体，部分支持HSV（hidden surface removal）特性的GPU，比如PowerVR是不需要做这个排序的。Unity提高了静态变量SystemInfo.hasHiddenSurfaceRemovalOnGPU来查询GPU是否支持HSV，<br>Urp渲染管线会根据这个来判断是否需要跳过从前到后排序物体。</p><h3 id="从后到前渲染（半透明物体）"><a href="#从后到前渲染（半透明物体）" class="headerlink" title="从后到前渲染（半透明物体）"></a>从后到前渲染（半透明物体）</h3><p>由于半透明物体的渲染算法要求必须从后到前渲染物体，同时关闭深度测试 ，前面的物体与后面的物体进行颜色混合。那么这个排序过程是无法省掉的，类似从前到后渲染的排序，可以采样BSP来排序物体。</p><h3 id="渲染层级或渲染队列"><a href="#渲染层级或渲染队列" class="headerlink" title="渲染层级或渲染队列"></a>渲染层级或渲染队列</h3><p>Unity同时定义了这2种排序，不过SortingLayer的优先级更高，这个是定义在物体的Renderer组件上。RenderQueue是定义在Shader和材质上，优先级在渲染层级之后。理论上，就是对所有物体进行优先级排序。</p><h3 id="最少渲染状态切换"><a href="#最少渲染状态切换" class="headerlink" title="最少渲染状态切换"></a>最少渲染状态切换</h3><p>还有一种方式是尽可能在渲染物体的时候避免渲染状态切换，这样能够尽可能减少CPU消耗。那么可以在CPU计算出来一个最优的渲染顺序来尽可能减少渲染状态切换。</p><h2 id="2-4-渲染数据绑定和状态设置"><a href="#2-4-渲染数据绑定和状态设置" class="headerlink" title="2.4 渲染数据绑定和状态设置"></a>2.4 渲染数据绑定和状态设置</h2><p>这一个阶段讲的是在CPU上设置渲染相关数据和状态，以及为了减少渲染状态切换的渲染合批的思想。</p><h3 id="视口设置"><a href="#视口设置" class="headerlink" title="视口设置"></a>视口设置</h3><p>设置窗口的渲染区域，比如OpenGL的<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml" target="_blank" rel="noopener">glViewport</a>。通过这个设置，我们可以在一个窗口上渲染多个不同的视口，比如游戏的分屏。</p><h3 id="FrameBuffer设置"><a href="#FrameBuffer设置" class="headerlink" title="FrameBuffer设置"></a>FrameBuffer设置</h3><p>一般游戏引擎不会直接将物体渲染到默认的渲染缓冲上，单独的RenderTarget方便进行后处理，在后处理之后再Blit到默认缓冲上。一个FrameBuffer可以包含颜色、深度、模板三个附件，也可以将深度和模板组织成一个32位的RT。</p><h3 id="渲染合批"><a href="#渲染合批" class="headerlink" title="渲染合批"></a>渲染合批</h3><p>渲染合批指的是为了减少渲染状态切换的一种优化手段，Unity URP渲染管线的SRP技术可以大幅度优化渲染批次。这是一个在Shader变体层次的合批，与之前的材质层次的合批相比有很大的优化。</p><h3 id="顶点输入绑定"><a href="#顶点输入绑定" class="headerlink" title="顶点输入绑定"></a>顶点输入绑定</h3><p>对于OpenGL来说就是创建和绑定VAO（Vertex Array Object）。一个VAO中可以包含VBO（Vertex Buffer Object）、IBO（Index Buffer Object）。然后用glVertexAttribPointer和glEnableVertexAttribArray指定数据到Shader的输入变量。<br>顶点属性通常包括，位置、法线、切线、UV、顶点颜色等。</p><h3 id="Shader绑定"><a href="#Shader绑定" class="headerlink" title="Shader绑定"></a>Shader绑定</h3><p>渲染数据绑定好之后，需要指定当前使用的Shader，这包括Shader的编译链接和使用等（假设Shader代码已经加载进来）。</p><h4 id="Shader编译链接使用"><a href="#Shader编译链接使用" class="headerlink" title="Shader编译链接使用"></a>Shader编译链接使用</h4><p>类似于CPU上运行的程序，Shader也需要编译链接以及开始使用的过程，不过这个过程基本上是固定。<br>可以参考learnopengl的<a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/" target="_blank" rel="noopener">着色器</a>一节。</p><h4 id="Uniform变量绑定"><a href="#Uniform变量绑定" class="headerlink" title="Uniform变量绑定"></a>Uniform变量绑定</h4><p>Shader中通常会有很多全局变量，比如MVP、摄像机位置、光的信息等。这些都需要在CPU上传入Shader中。</p><h3 id="Output-Merger-Stage相关设置"><a href="#Output-Merger-Stage相关设置" class="headerlink" title="Output-Merger Stage相关设置"></a>Output-Merger Stage相关设置</h3><p>在渲染管线的最后（片元着色器之后），有一个Output-Merger阶段，也叫做Raster Operations。这是一个不可编程阶段，但是有很多选择可以设置。比如剪切测试、模板测试、深度测试、颜色混合因子和函数、sRGB转换等。这些都需要在应用程序阶段进行设置。</p><h2 id="2-5-DrawCall调用"><a href="#2-5-DrawCall调用" class="headerlink" title="2.5 DrawCall调用"></a>2.5 DrawCall调用</h2><p>终于到了应用程序的最后一步，即DrawCall的调用了。OpenGL对应的接口是<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" target="_blank" rel="noopener">glDrawArrays</a>或者<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawElements.xhtml" target="_blank" rel="noopener">glDrawElements</a>。</p><h1 id="三、几何处理阶段"><a href="#三、几何处理阶段" class="headerlink" title="三、几何处理阶段"></a>三、几何处理阶段</h1><p>这是第二个大的阶段，当前阶段已经进行GPU中了。该阶段的起点和主要过程是顶点着色器。除了着色器之外，其余阶段都是硬件自动进行的，除了可选阶段之外，其余的都是固定的，应用程序无法根据配置来进行更改。</p><h2 id="3-1-顶点着色器"><a href="#3-1-顶点着色器" class="headerlink" title="3.1 顶点着色器"></a>3.1 顶点着色器</h2><p>顶点着色器的处理对象是应用程序阶段绑定的每个顶点，顶点着色器会获得顶点属性以及相应的Uniform变量。顶点着色器的输出是一个NDC Clip Space的顶点位置。NDC（Normalized device coordinates）是规范化设备坐标系的位置，OpenGL的范围[-1,1]，DirectX的范围是[0,1]。之所以说是Clip Space，因为该阶段得到的顶点数据是一个齐次坐标，还需要进行透视除法，即x、y、z除以w分量才能得到NDC坐标系下的位置。</p><h2 id="3-2-曲面细分着色器"><a href="#3-2-曲面细分着色器" class="headerlink" title="3.2 曲面细分着色器"></a>3.2 曲面细分着色器</h2><p>曲面细分着色器是一个可选阶段，用于将一个简单模型细分成复杂的模型。其实该阶段是2个着色器和一个固定阶段的组合。在DirectX中叫做Hull Shader stage、Tessellator stage、Domain Shader stage；在OpenGL的<a href="https://www.khronos.org/opengl/wiki/Tessellation" target="_blank" rel="noopener">Tessellation</a>中叫做Tessellation Control Shader、Tessellation Primitive eneration、Tessellation Evaluation Shader。具体的介绍和使用方式请参考相关资料。</p><h2 id="3-3-几何着色器"><a href="#3-3-几何着色器" class="headerlink" title="3.3 几何着色器"></a>3.3 几何着色器</h2><p>几何着色器也是一个可选阶段。几何着色器的输入是图元的顶点集合（比如三角形图元有三个顶点，点图元只有一个顶点），输出是一个新的图元，新的图元也要包含一个顶点集合。简单来说，几何着色器的输入和输出都是图元，输入的图元是在应用程序阶段指定的，输出的图元可以在顶点着色器中实现。</p><h2 id="3-4-Stream-Output-（Transform-Feedback）"><a href="#3-4-Stream-Output-（Transform-Feedback）" class="headerlink" title="3.4 Stream Output （Transform Feedback）"></a>3.4 Stream Output （Transform Feedback）</h2><p>这是一个可选的阶段。这个阶段在DirectX中叫做Stream Output ，在OpenGL找叫做Transform Feedback。如果该阶段开启，那么顶点数据流会输出到一个Buffer中，这个Buffer可以给顶点着色器使用也可以返回给CPU，当前渲染管线则不会进行接下来的处理。</p><h2 id="3-5-图元组装"><a href="#3-5-图元组装" class="headerlink" title="3.5 图元组装"></a>3.5 图元组装</h2><p>这一步是将之前得到的顶点数据组合成图元，比如顶点图元、线段图元、三角形图元。该阶段输出图元进行接下来的处理。</p><h2 id="3-6-透视除法和NDC裁剪"><a href="#3-6-透视除法和NDC裁剪" class="headerlink" title="3.6 透视除法和NDC裁剪"></a>3.6 透视除法和NDC裁剪</h2><p>该阶段的输入是组装好的图元，输出的是NDC裁剪之后的图元。首先对图元的顶点进行透视除法，这样得到的顶点数据都会位于NDC内，方便进行NDC裁剪。图元裁剪后可以会产生新的图元。</p><h2 id="3-7-屏幕空间映射"><a href="#3-7-屏幕空间映射" class="headerlink" title="3.7 屏幕空间映射"></a>3.7 屏幕空间映射</h2><p>该阶段是将NDC下的图元顶点坐标映射到屏幕空间。值得注意的是顶点坐标是一个齐次坐标，透视除法后得到的是NDC下的坐标；然后，通过一个缩放和平移变换将x和y映射到屏幕空间。</p><h2 id="3-8-面剔除-（Face-Culling）"><a href="#3-8-面剔除-（Face-Culling）" class="headerlink" title="3.8 面剔除 （Face Culling）"></a>3.8 面剔除 （Face Culling）</h2><p>这一个阶段指的是三角形的前后面剔除。前或者后的定义是根据正视三角形的时候定义三角形顶点的旋向，可以定义逆时针旋转或者顺时针旋转为前面。实际上，面剔除跟实际的摄像机位置没有关系，不管摄像机转到哪个地方，前后面不会改变，比如渲染立方体的时候，后面都是立方体内部看不到的面，无论摄像机如何旋转。因为，前后面的定义是固定视角正对三角形时候定义的。</p><h1 id="四、光栅化阶段"><a href="#四、光栅化阶段" class="headerlink" title="四、光栅化阶段"></a>四、光栅化阶段</h1><p>该大的阶段的输入是几何处理阶段输出的图元。该阶段主要分为四个部分，首先是光栅化图元得到片元（潜在的像素信息），然后进行Early Fragment Test，通过测试后再进行片元着色器，最终进行输出合并阶段的各种测试以及颜色混合等，再输出到颜色缓冲区。</p><h2 id="4-1-图元光栅化"><a href="#4-1-图元光栅化" class="headerlink" title="4.1 图元光栅化"></a>4.1 图元光栅化</h2><p>该阶段是将图元的顶点信息进行线性插值，然后生成片元数据。每个片元上有顶点信息线性插值而来的片元数据。需要注意的是，这个插值是线性的，如果有一些数据是非线性的，则不能在顶点着色器中计算然后输出到片元着色器，因为线性插值的结果和在片元着色器中计算的结果是不一致的。<br>这里需要特别说明的是，关于深度z’的生成。屏幕空间映射后的z’是关于摄像机空间z倒数的一个线性函数。之所以使用1/z而不是z，是为了在近处获得更好的深度缓冲精度，因为1/z在近处的变化更快，可以优化Z-Fighting这种现象。由于z’不是一个关于z的线性函数，因此z’应该是在光栅化后硬件自动根据1/z计算出来的，而不是先计算z’再光栅化。 </p><h2 id="4-2-Early-Fragment-Test"><a href="#4-2-Early-Fragment-Test" class="headerlink" title="4.2 Early Fragment Test"></a>4.2 Early Fragment Test</h2><p>参考OpenGL的<a href="https://www.khronos.org/opengl/wiki/Early_Fragment_Test" target="_blank" rel="noopener">Early Fragment Test</a>，可以看到不仅仅通常所说的Early Z-Test还有其它好几个阶段都可以进行EarlyTest，一共是四个测试（Pixel ownership test、Scissor test、<br> Stencil test、Depth test）和遮挡查询更新。根据文档，Pixel ownership test和Scissor test从OpenGL4.2起会总是在EarlyTest阶段进行。那么，如果这些测试没有在EarlyTest阶段进行，则会在最终的输出合并阶段进行；如果进行了，那么输出合并阶段也不会重复处理。</p><h3 id="4-3-Early-Z-Test的限制"><a href="#4-3-Early-Z-Test的限制" class="headerlink" title="4.3 Early Z-Test的限制"></a>4.3 Early Z-Test的限制</h3><p>不要在片元着色器中改变深度，比如glsl的gl_FragDepth；也不要discard片元，通常实现AlphaTest会根据Alphadiscard片元。因为这些操作会导致硬件无法预测最终的深度，从而无法进行提前深度测试。</p><h2 id="4-4-片段着色器"><a href="#4-4-片段着色器" class="headerlink" title="4.4 片段着色器"></a>4.4 片段着色器</h2><p>片段着色器的输入是光栅化来的各种顶点属性，输出是一个颜色值。该阶段是计算光照结果的主要阶段。通常片元着色器会有比较复杂的计算，通常的优化手段是将计算转移到顶点着色器甚至CPU（应用程序阶段，用Uniform传入）上。</p><h2 id="4-5-Output-Merger-Stage-Raster-Operations"><a href="#4-5-Output-Merger-Stage-Raster-Operations" class="headerlink" title="4.5 Output-Merger Stage(Raster Operations)"></a>4.5 Output-Merger Stage(Raster Operations)</h2><p>终于进入最后的输出合并阶段，该阶段的输入是一个个的片元。片元需要进行一些列的测试和转换，最终才会将颜色输出到缓冲区上。</p><h3 id="Pixel-ownership-test"><a href="#Pixel-ownership-test" class="headerlink" title="Pixel ownership test"></a>Pixel ownership test</h3><p>根据OpenGL的文档，该阶段只对默认缓冲区生效，用于测试像素是否被其它窗口遮挡的情形。对于自定义的FrameBuffer，不存在这个测试。</p><h3 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h3><p>需要特别说明的是，Alpha测试当前是已经被废弃了，从DirectX10和OpenGL3.1开始废弃，参考<a href="https://www.khronos.org/opengl/wiki/Transparency_Sorting" target="_blank" rel="noopener">Transparency Sorting</a>文档；当前需要在片元着色器用discard实现。列在这里主要是为了完整性。</p><h3 id="Scissor-test"><a href="#Scissor-test" class="headerlink" title="Scissor test"></a>Scissor test</h3><p>参考OpenGL的剪切测试文档，<a href="https://www.khronos.org/opengl/wiki/Scissor_Test" target="_blank" rel="noopener">Scissor Test</a>。通过在应用程序阶段设置，可以让片元只通过视口的一个小矩形区域。根据EarlyTest的文档，推测该阶段目前都在EarlyTest阶段进行了。</p><h3 id="Multisample-operations"><a href="#Multisample-operations" class="headerlink" title="Multisample operations"></a>Multisample operations</h3><p>如果启用了MSAA，那么需要进行resolve才能够输出到默认颜色缓冲中，进行屏幕显示。假如在默认缓冲中开了MSAA，那么从MSAA的后备缓冲交换到前向缓冲就需要进行resolve操作，因为前向缓冲是single-sample的。如果是自定义的FrameBuffer开启了MSAA，那么在Blit到默认缓冲区的时候也需要进行resolve操作。</p><h3 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h3><p>模板测试基本思想是用一个八位的模板缓冲，一个参考值，一个比较函数，一个掩码，用该参考值和片元对应的模板缓冲值使用比较进行比较（比较之前进行掩码），通过的则片元可以继续进行深度测试，否则丢弃。另外还可以定义模板成功和失败，以及深度测试成功和失败后模板缓冲如何变化。可以参考OpenGL的<a href="https://www.khronos.org/opengl/wiki/Stencil_Test" target="_blank" rel="noopener">Stencil Test</a>文档。<br>模板测试的一个常见的应用是描边或者在像素级别分类。</p><h3 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3><p>深度测试是根据当前片元的深度值与深度缓冲进行比较，比较函数可以设置，通过比较的片元才会进行接下来的处理，否则丢弃当前片元。</p><h3 id="遮挡查询更新"><a href="#遮挡查询更新" class="headerlink" title="遮挡查询更新"></a>遮挡查询更新</h3><p>参考OpenGL的遮挡查询文档<a href="https://www.khronos.org/opengl/wiki/Query_Object#Occlusion_queries" target="_blank" rel="noopener">Query Object</a>。<br>该阶段会更新遮挡查询的结果，因此遮挡查询的结果只能用于下一帧渲染。</p><h3 id="颜色混合"><a href="#颜色混合" class="headerlink" title="颜色混合"></a>颜色混合</h3><p>需要注意的是，容易误解半透明渲染才会有颜色混合，实际上颜色混合是管线的一个固定的阶段，不透明渲染也会有默认的混合方式。<br>理解颜色混合，首先要明白2个概念，source和dest，source指的是当前的片元，dest指的是要目标缓冲中对应的颜色。<br>颜色混合主要是需要设置2个函数，一个函数用于设置混合因子，一个函数用来设置混合函数。混合因子有四种，source rgb和dest rgb，source a和dest a，可以一起指定也可以分开指定。具体可以参考OpenGL的<a href="https://www.khronos.org/opengl/wiki/Blending" target="_blank" rel="noopener">Blending</a>文档。</p><h3 id="sRGB转换"><a href="#sRGB转换" class="headerlink" title="sRGB转换"></a>sRGB转换</h3><p>1、我们知道显示器或者颜色纹理的颜色空间是sRgb，sRGB空间就是Gamma校正的颜色空间，也就是已经Gamma校正过的颜色数据，这样子在显示器上才能正常显示。如果我们使用的线性工作流，也就是在线性空间中制作资源，编写Shader计算光照结果，那么片元着色器的输出需要转换到sRgb空间。这个转换部分硬件上是自动支持，对于不支持的硬件则需要在Shader里面转换。<br>2、如果要硬件自动转换，首先要创建的必须是srgb颜色空间的FrameBuffer，在OpenGL中可以使用glEnable(GL_FRAMEBUFFER_SRGB)开启；要保证片元输出的线性空间的颜色，也就是要采用线性工作流。<br>3、需要注意的是，避免将sRGB转换和ToneMaping混合起来，ToneMaping做的是将HDR映射到LDR。这只是一个带偏向性颜色范围映射，也就是算法倾向性的增强部分颜色。而sRGB转换才是将颜色从线性空间转换到sRGB空间。</p><h3 id="Dithering"><a href="#Dithering" class="headerlink" title="Dithering"></a>Dithering</h3><p>首先说明一下，颜色格式分为Float、Normalized Integer、Integer三种，默认缓冲区就是Normalized Integer格式的颜色。根据OpenGL的文档，当将一个Float颜色写入Normalized Integer缓冲区的时候，可以开启Dithering。Normalized Integer缓冲区是一个定点数缓冲来存储浮点值，比如通常我们的颜色是定义在[0,\1]的浮点值，但是颜色缓冲是[0,254]\的Int值，OpenGL会自动进行转换。</p><h3 id="Logic-operations"><a href="#Logic-operations" class="headerlink" title="Logic operations"></a>Logic operations</h3><p>根据OpenGL的文档，当将颜色写入Integer（Normalized Or Not）缓冲区的时候，可以开启Logic operations。这是一些Bool操作。具体可以参考文档<a href="https://www.khronos.org/opengl/wiki/Logical_Operation" target="_blank" rel="noopener">Logical Operation</a>。Logical Operations在sRGB颜色空间是禁止的。</p><h3 id="Write-mask"><a href="#Write-mask" class="headerlink" title="Write mask"></a>Write mask</h3><p>该阶段可以分别指定Color、Depth、Stencil的写入掩码。具体参考文档<a href="https://www.khronos.org/opengl/wiki/Write_Mask" target="_blank" rel="noopener">Write Mask</a>。</p><h1 id="五、RenderPass"><a href="#五、RenderPass" class="headerlink" title="五、RenderPass"></a>五、RenderPass</h1><h2 id="5-1-Renderer"><a href="#5-1-Renderer" class="headerlink" title="5.1 Renderer"></a>5.1 Renderer</h2><p>以上所有内容在游戏引擎只是一个RenderPass，实际情况下，每帧游戏引擎会按照一定的顺序渲染多个Pass。比如，深度Pass（或者深度法线Pass）、阴影Pass、不透明物体Pass、透明物体Pass、后处理Pass等；而且后面的Pass会利用前面的Pass渲染结果来处理，比如深度Pass渲染的深度纹理可以用在后续的Pass实现一些效果。<br>总而言之，真实的游戏引擎是每帧渲染多个Pass，每个Pass对应上述的内容。</p><h2 id="5-2-CameraStack"><a href="#5-2-CameraStack" class="headerlink" title="5.2 CameraStack"></a>5.2 CameraStack</h2><p>实际上，在Unity的Urp渲染管线中，更完整的过程是渲染相机堆栈-&gt;每个相机堆栈对应一个渲染器-&gt;每个渲染器包含多个Pass。不过，Urp里面每个相机堆栈只对应一个FrameBuffer，也就是所有的相机渲染输出都是这一个FrameBuffer，避免内存和带宽浪费。如果在场景内创建多个相机堆栈，那么其它的相机堆栈的输出应该是离屏RT。</p><h1 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h1><blockquote><p>1、<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/graphics-pipeline" target="_blank" rel="noopener">Graphics pipeline</a><br>2、<a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target="_blank" rel="noopener">Rendering Pipeline Overview</a><br>3、<a href="https://www.khronos.org/opengl/wiki/Per-Sample_Processing" target="_blank" rel="noopener">Per-Sample Processing</a><br>4、<a href="https://docs.microsoft.com/en-us/windows/uwp/graphics-concepts/output-merger-stage--om-" target="_blank" rel="noopener">Output Merger (OM) stage</a><br>5、<a href="https://blog.codingnow.com/2020/07/culling_space.html" target="_blank" rel="noopener">裁剪和空间管理</a><br>6、<a href="https://zhuanlan.zhihu.com/p/138295496" target="_blank" rel="noopener">[总结] 漫谈HDR和色彩管理（三）SDR和HDR</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要注意的是，本文涉及的内容过多过杂，基本涉及到游戏渲染和图形管线的方方面面。内容是根据多方面的资料整理而成，比如本人的Unity和Unreal引擎相关的理解和认知，以及引擎相关官方文档等，以及DirectX和OpenGL相关官方文档等，以及网络上各种相关文章和资料等。可能有一些纰漏或者不足之处，或者有些阶段的资料来源较为单一，本人主要目的是从概念理解上对应整个游戏引擎的渲染管线，不一定和真实的游戏完全一一对应，比如应用程序阶段的知识对应到游戏引擎应该会有一些区别和取舍，几何阶段和光栅化阶段主要参考的是OpenGL和DirectX，Vulkan和Metal相关资料参考较少，可能不同的图形API会有一些出入。由于涉及内容过多，难免理解不到位，有发现比较明显错误的，请指出以尽早修正，避免造成误解。&lt;/p&gt;
&lt;h1 id=&quot;一、渲染管线的思维导图&quot;&gt;&lt;a href=&quot;#一、渲染管线的思维导图&quot; class=&quot;headerlink&quot; title=&quot;一、渲染管线的思维导图&quot;&gt;&lt;/a&gt;一、渲染管线的思维导图&lt;/h1&gt;&lt;p&gt;这是本文内容的思维导图，通过该图可以从整体上把握全文的内容，对渲染管线有整理的理解。&lt;br&gt;&lt;img alt data-src=&quot;https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/渲染管线.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Rendering" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/"/>
    
    
      <category term="渲染管线" scheme="http://xiaopengcheng.top/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>反射效果的实现总结</title>
    <link href="http://xiaopengcheng.top/2021/10/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://xiaopengcheng.top/2021/10/22/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-22T04:15:00.000Z</published>
    <updated>2022-01-14T11:54:12.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、反射的实现原理分类"><a href="#一、反射的实现原理分类" class="headerlink" title="一、反射的实现原理分类"></a>一、反射的实现原理分类</h1><p>首先要说明下<strong>反射向量</strong>，指的是视线的镜面反射向量，如下图所示，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/视线反射方向.png"><br>实际上，人眼看向一个物体表面的时候，在该位置（上图O点）的反射信息，来自于视线的反射方向，因为光线会从该反射方向打到物体表面，最终进入人眼。一般情况下，我们假定反射角和入射角相等。以下所有涉及到的反射向量， 都是指的视线反射向量，不是光线反射向量。</p><h2 id="1-1-CubeMap"><a href="#1-1-CubeMap" class="headerlink" title="1.1 CubeMap"></a>1.1 CubeMap</h2><p>天空盒就是一个CubeMap，我们可以假定天空盒是一个环境反射来源，也可以指定另外的CubeMap，用反射向量采样这个CubeMap就能得到反射颜色。CubeMap虽然比较简单，但是也能出很好的效果，而且不需要实时计算反射信息，性能很好。<br>优点：实现简单，效率高，只需要额外的CubeMap存储反射信息；适用于多种情况，不仅仅限于平面反射。<br>缺点：反射信息固定，没有变化。</p><h2 id="1-2-反射探针"><a href="#1-2-反射探针" class="headerlink" title="1.2 反射探针"></a>1.2 反射探针</h2><p>这种方式需要在场景内布置反射探针，用来采集反射信息。渲染时候，在Shader内根据反射探针来获得反射信息。反射探针如果是实时的，性能就会很差，这个时候可以考虑降低反射探针的更新频率或者使用烘焙模式的反射探针。因为反射探针的输出就是CubeMap，因此烘焙模式的反射探针，本质上和CubeMap没有区别。<br>优点：直接利用引擎计算反射信息，不需要额外工作；适用于多种情况，不仅仅限于平面反射。<br>缺点：实时反射探针性能差，计算一次反射探针需要朝着6个方向渲染场景，Drawcall增加6倍，性能太差；烘焙反射探针无法变化。</p><h2 id="1-3-平面反射"><a href="#1-3-平面反射" class="headerlink" title="1.3 平面反射"></a>1.3 平面反射</h2><p>这种方式限制于只能在平面上做反射。如果要求在凹凸不平的表面上实现反射效果，则不太适合。基本思路是将场景根据平面对称镜像一次，具体实现上是将生成的反射矩阵乘以到原场景摄像机的世界到相机空间的矩阵，然后用新的相机再渲染一次场景生成RT。然后在屏幕空间内采样这个RT，得到的像素值作为反射信息。<br>其实，使用反射探针也能实现平面反射的效果，原理是将探针的位置放在摄像机在平面的对称位置。可以参考大佬的这篇文章，<a href="https://baddogzz.github.io/2020/04/22/Probe-Reflection/" target="_blank" rel="noopener">关于反射探头的实时反射</a>。实现难度相对平面反射低很多，不过实时探针比平面反射性能差6倍，优化起来难度太大。<br>优点：反射效果最好，最真实接近平面反射。<br>缺点：需要额外渲染一次场景，DrawCall翻倍。</p><h2 id="1-4-屏幕空间反射（SSR）"><a href="#1-4-屏幕空间反射（SSR）" class="headerlink" title="1.4 屏幕空间反射（SSR）"></a>1.4 屏幕空间反射（SSR）</h2><p>屏幕空间反射的基本原理比较简单，也就是在屏幕空间内通过深度法线纹理恢复世界空间坐标。然后，沿着反射向量方向做步进，也就是所谓的RayMarching，检查当前深度是否已经超过深度纹理对应的值，如果超过，表面已经碰到物体了，那么取当前步进到的颜色值作为反射结果即可。<br>优点：适用于多种情况，不仅仅限于平面反射；DrawCall不变。<br>缺点：需要额外的深度和法线纹理，在前向渲染中这不是免费的，需要多渲染一次场景得到深度和法线纹理；效果一般；无法反射屏幕之外的信息；实现比较复杂，移动平台下性能差（步进相交的计算量大），很可能跑不起来；带宽增加。</p><p>SSR应该是更适合于延迟渲染的一个反射效果实现方案，毕竟可以免费得到深度和法线纹理。</p><h2 id="1-5-屏幕空间平面反射"><a href="#1-5-屏幕空间平面反射" class="headerlink" title="1.5 屏幕空间平面反射"></a>1.5 屏幕空间平面反射</h2><p>这个是平面反射在屏幕空间下的一个实现。<br>SSPR大体的实现思路如下，<br>1、用当前屏幕UV从深度图重建当前世界坐标，将世界坐标以反射平面进行对称翻转<br>2、使用翻转后的世界坐标的计算屏幕UV<br>3、对当前屏幕纹理进行采样得到ReflectColor保存到一张新的ColorRT中，保存位置是翻转后的世界坐标的屏幕UV<br>4、在反射平面的Shader中用屏幕UV对ColorRT进行采样得到反射颜。<br>5、在反射平面的Shader中将反射颜色和着色结果进行组合得到最终颜色。</p><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/SSPR.jpg"><br>如上大佬的图能够基本说明SSPR的实现思路。UAV write即是3的输出。关键点和难点是要得到步骤三的ColorRT，并且要正确高效。网上有不少博客说的是如何正确高效实现前三步，基本上要使用Computer Shader，图形接口要求是vulkan/metal。具体实现比较复杂，不在此详细说明。</p><p>优点：效果较高；性能比SSR好；DrawCall不变。<br>缺点：对硬件要求高；需要额外的ColorRT，带宽和内存增加；只适用于平面反射。</p><h1 id="二、Unity对反射效果支持"><a href="#二、Unity对反射效果支持" class="headerlink" title="二、Unity对反射效果支持"></a>二、Unity对反射效果支持</h1><h2 id="2-1-CubeMap"><a href="#2-1-CubeMap" class="headerlink" title="2.1 CubeMap"></a>2.1 CubeMap</h2><p>Unity自带的Shader或许有支持，实现起来也很简单，关键代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 reflectVector = reflect(-viewDirectionWS, normalWS);</span><br><span class="line">half3 reflectColor = SAMPLE_TEXTURECUBE(_Cubemap, sampler_Cubemap, reflectVector).rgb;</span><br></pre></td></tr></table></figure><h2 id="2-2-反射探针"><a href="#2-2-反射探针" class="headerlink" title="2.2 反射探针"></a>2.2 反射探针</h2><p>目前，Unity内置管线和Urp支持<a href="https://docs.unity3d.com/cn/2019.4/Manual/class-ReflectionProbe.html" target="_blank" rel="noopener">反射探针</a>，HDRP管线还支持一种特殊的<a href="https://docs.unity3d.com/cn/Packages/com.unity.render-pipelines.high-definition@10.4/manual/Planar-Reflection-Probe.html" target="_blank" rel="noopener">平面反射探针</a>，平面反射探针猜测是针对平面反射这种特殊情况的一种优化手段。<br>场景内布置了反射探针后，Urp管线中反射信息是存储在叫做unity_SpecCube0的内置CubeMap中。Shader中需要采样该CubeMap获得反射信息，Urp代码中搜索函数GlossyEnvironmentReflection，可以得到如下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">half3 <span class="title">GlossyEnvironmentReflection</span>(<span class="params">half3 reflectVector, half perceptualRoughness, half occlusion</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_ENVIRONMENTREFLECTIONS_OFF)</span></span><br><span class="line">    half mip = PerceptualRoughnessToMipmapLevel(perceptualRoughness);</span><br><span class="line">    half4 encodedIrradiance = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectVector, mip);</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span>DOTS - we need to port probes to live in c# so we can manage this manually.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(UNITY_USE_NATIVE_HDR) || defined(UNITY_DOTS_INSTANCING_ENABLED)</span></span><br><span class="line">    half3 irradiance = encodedIrradiance.rgb;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    half3 irradiance = DecodeHDREnvironment(encodedIrradiance, unity_SpecCube0_HDR);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> irradiance * occlusion;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> // GLOSSY_REFLECTIONS</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _GlossyEnvironmentColor.rgb * occlusion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数三个关键点，根据粗糙度计算mipmap，采样光照探针，解析HDR贴图。我们重点关注的是mipmap计算，mipmap大家都知道，越远的地方，贴图采样率越低效果才好，看起来越模糊，没有锐利的毛刺感觉；同时粗糙度刚好可以表示这个概率，粗糙度越低越接近镜面，那么反射效果更接近光滑镜子的效果，粗糙度越高，反射效果越模糊。<br><strong>计算Mipmap的概念可以应用到所有的反射效果实现中，不仅仅反射探针</strong>。</p><h2 id="2-3-平面反射"><a href="#2-3-平面反射" class="headerlink" title="2.3 平面反射"></a>2.3 平面反射</h2><p>Unity没有发现支持，需要自己实现或者找第三方实现。后续会写文章介绍如何实现。</p><h2 id="2-4-屏幕空间反射"><a href="#2-4-屏幕空间反射" class="headerlink" title="2.4 屏幕空间反射"></a>2.4 屏幕空间反射</h2><p>Unity没有发现支持，需要自己实现或者找第三方实现。后续会写文章介绍如何实现。</p><h2 id="2-5-屏幕空间平面反射"><a href="#2-5-屏幕空间平面反射" class="headerlink" title="2.5 屏幕空间平面反射"></a>2.5 屏幕空间平面反射</h2><p>Unity没有发现支持，需要自己实现或者找第三方实现。后续会写文章介绍如何实现。</p><h1 id="三、UE4对反射效果支持"><a href="#三、UE4对反射效果支持" class="headerlink" title="三、UE4对反射效果支持"></a>三、UE4对反射效果支持</h1><h2 id="3-1-CubeMap"><a href="#3-1-CubeMap" class="headerlink" title="3.1 CubeMap"></a>3.1 CubeMap</h2><p>UE4的材质编辑器可以实现。</p><h2 id="3-2-反射探针"><a href="#3-2-反射探针" class="headerlink" title="3.2 反射探针"></a>3.2 反射探针</h2><p><a href="https://docs.unrealengine.com/4.27/zh-CN/BuildingWorlds/LightingAndShadows/ReflectionEnvironment/" target="_blank" rel="noopener">UE4有盒子和球形的反射探针</a>。</p><h2 id="3-3-平面反射"><a href="#3-3-平面反射" class="headerlink" title="3.3 平面反射"></a>3.3 平面反射</h2><p>UE4有<a href="https://docs.unrealengine.com/4.27/zh-CN/BuildingWorlds/LightingAndShadows/PlanarReflections/" target="_blank" rel="noopener">Planar Reflection Actor</a>，放入场景中即可。不过先要在工程设置中开启平面反射。</p><h2 id="3-4-屏幕空间反射"><a href="#3-4-屏幕空间反射" class="headerlink" title="3.4 屏幕空间反射"></a>3.4 屏幕空间反射</h2><p>UE4默认是启用<a href="https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/PostProcessEffects/ScreenSpaceReflection/" target="_blank" rel="noopener">屏幕空间反射</a>的。不过是可以在工程设置或者配置文件中关闭的。</p><h2 id="3-5-屏幕空间平面反射"><a href="#3-5-屏幕空间平面反射" class="headerlink" title="3.5 屏幕空间平面反射"></a>3.5 屏幕空间平面反射</h2><p>目前没有发现UE4支持这个特性。</p><h1 id="四、反射颜色与物体颜色的组合"><a href="#四、反射颜色与物体颜色的组合" class="headerlink" title="四、反射颜色与物体颜色的组合"></a>四、反射颜色与物体颜色的组合</h1><h2 id="4-1-Mipmap"><a href="#4-1-Mipmap" class="headerlink" title="4.1 Mipmap"></a>4.1 Mipmap</h2><p>计算Mipmap，模拟粗糙度的效果，这个在反射探针中已经有说明。</p><h2 id="4-2-菲涅尔效果"><a href="#4-2-菲涅尔效果" class="headerlink" title="4.2 菲涅尔效果"></a>4.2 菲涅尔效果</h2><p>获得反射颜色后，可以根据菲涅尔定律与物体本身的着色结果进行一定的组合即可。不过，不一定完全照搬菲涅尔效果的近似公式，比如Schlick菲涅耳近似等式。关键在于NdotV或者HdotV，也就是反射强弱基本是跟视线相关的。当NdotV为1的时候，说明视线垂直平面，为0的时候说明视线跟平面平行。因此，可以根据NdotV在反射颜色和物体颜色之间进行某种插值，来得到想要的效果。</p><p>以下是一个同时应用了粗糙度计算Mipmap和菲涅尔效果的反射平面，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/平面反射.jpg"></p><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote><p>1、<a href="https://blog.csdn.net/puppet_master/article/details/80808486" target="_blank" rel="noopener">Unity Shader-反射效果（CubeMap，Reflection Probe，Planar Reflection，Screen Space Reflection）</a><br>2、<a href="https://baddogzz.github.io/2020/04/22/Probe-Reflection/" target="_blank" rel="noopener">关于反射探头的实时反射</a><br>3、<a href="https://zhuanlan.zhihu.com/p/150890059" target="_blank" rel="noopener">Unity URP 移动平台的屏幕空间平面反射（SSPR）趟坑记</a><br>4、<a href="https://www.lfzxb.top/screen-space-plana-reflection-in-urp-study/" target="_blank" rel="noopener">URP下屏幕空间平面反射（ScreenSpacePlanarReflection）学习笔记</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、反射的实现原理分类&quot;&gt;&lt;a href=&quot;#一、反射的实现原理分类&quot; class=&quot;headerlink&quot; title=&quot;一、反射的实现原理分类&quot;&gt;&lt;/a&gt;一、反射的实现原理分类&lt;/h1&gt;&lt;p&gt;首先要说明下&lt;strong&gt;反射向量&lt;/strong&gt;，指的是视线的镜面反射向量，如下图所示，&lt;br&gt;&lt;img alt data-src=&quot;https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/视线反射方向.png&quot;&gt;&lt;br&gt;实际上，人眼看向一个物体表面的时候，在该位置（上图O点）的反射信息，来自于视线的反射方向，因为光线会从该反射方向打到物体表面，最终进入人眼。一般情况下，我们假定反射角和入射角相等。以下所有涉及到的反射向量， 都是指的视线反射向量，不是光线反射向量。&lt;/p&gt;
&lt;h2 id=&quot;1-1-CubeMap&quot;&gt;&lt;a href=&quot;#1-1-CubeMap&quot; class=&quot;headerlink&quot; title=&quot;1.1 CubeMap&quot;&gt;&lt;/a&gt;1.1 CubeMap&lt;/h2&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Rendering" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/"/>
    
    
      <category term="反射效果" scheme="http://xiaopengcheng.top/tags/%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>Urp下自定义特效管线和后处理特效实现</title>
    <link href="http://xiaopengcheng.top/2021/08/10/Urp%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%95%88%E7%AE%A1%E7%BA%BF%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xiaopengcheng.top/2021/08/10/Urp%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%95%88%E7%AE%A1%E7%BA%BF%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-08-10T09:15:51.000Z</published>
    <updated>2022-01-14T11:39:59.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、如何获得颜色缓冲"><a href="#一、如何获得颜色缓冲" class="headerlink" title="一、如何获得颜色缓冲"></a>一、如何获得颜色缓冲</h1><p>网上搜索Unity的后处理或者获得屏幕缓冲，大部分会提到用grabpass到一张指定纹理上或者写一个后处理脚本挂在摄像机上。但是这种方式在Urp管线下已经不生效了。urp取消了默认管线抓取颜色缓冲的grabpass，同时也取消了<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnRenderImage.html" target="_blank" rel="noopener">MonoBehaviour.OnRenderImage</a>，需要使用<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/api/UnityEngine.Rendering.Universal.ScriptableRenderPass.html" target="_blank" rel="noopener">ScriptableRenderPass</a> 来完成类似的功能。ScriptableRenderPass是urp中的pass基类，urp预定义的pass都继承自该类，我们自定义的pass也需要继承自该类。</p><h2 id="1-1-Urp的渲染顺序"><a href="#1-1-Urp的渲染顺序" class="headerlink" title="1.1 Urp的渲染顺序"></a>1.1 Urp的渲染顺序</h2><p>urp中通过类型RenderPassEvent定义了一些列pass的渲染顺序或者说时机，大致的顺序是ShadowPass-&gt;PrePass(Depth Or DepthNormal)-&gt;Opaques-&gt;SkyBox-&gt;Transparents-&gt;PostProcessing，这个顺序也是Urp渲染管线的大致执行顺序。每个Pass或者说每个渲染事件都分Before和After，比如BeforePostProcessing和AfterPostProcessing分别表示后处理之前和后处理之后。<br>说了这么多，现在说结论，我们的特效Pass或者说特效管线就是要插入在BeforePostProcessing这个事件范围内。对了，同一个事件，比如BeforePostProcessing事件内的pass，最终的执行顺序是已加入管线的先后为准的。</p><h2 id="1-2-Urp内置的CameraOpaqueTexture"><a href="#1-2-Urp内置的CameraOpaqueTexture" class="headerlink" title="1.2 Urp内置的CameraOpaqueTexture"></a>1.2 Urp内置的CameraOpaqueTexture</h2><p>那么，我们是一定要自定义一个Pass才能获得颜色缓冲吗？不需要，其实Urp的ForwardRenderer内会在某种情况下给我生成一个颜色缓冲存储到贴图_CameraOpaqueTexture中，通过调用函数SampleSceneColor就得获得屏幕颜色。不过，这个贴图的生成时机是固定的，只会在渲染不透明物体之后，更准确的说是在渲染天空盒之后，通过CopyColorPass把摄像机的颜色缓冲Blit到_CameraOpaqueTexture。同时，需要摄像机或者Urp设置中有开启需要OpaqueTexture或者某个Pass的Input有要求ColorTexture。<br>假如，不需要颜色缓冲中有半透明物体的信息，那么这个_CameraOpaqueTexture就已经足够了。问题是，特效基本是半透明物体，部分场景物体也可能是半透明物体。所以，默认的_CameraOpaqueTexture大概率满足不了需求。<br>因此，需要在半透明物体渲染之后再获取一次颜色缓冲。这个可以通过在AfterTransparents或者BeforePostProcessing事件中插入一个CopyColorPass来实现。</p><h1 id="二、特效渲染管线"><a href="#二、特效渲染管线" class="headerlink" title="二、特效渲染管线"></a>二、特效渲染管线</h1><p>说实话，特效同学的要求有点多，要求部分特效受到全屏效果影响部分不受到影响。那么，特效要分成两部分渲染，一部分在全屏特效前，另外一部分在全屏特效后。那么，需要至少4个Pass，全屏特效前的特效Pass-&gt;CopyColorPass-&gt;全屏特效Pass-&gt;全屏特效后的特效Pass。<br>特效渲染管线如下：</p><ol><li>EffectPass</li><li>CopyColorPass</li><li>UberEffectPostRenderPass</li><li>EffectPass</li></ol><p>其中，中间2个Pass最好是能够根据是否有全屏特效来动态激活。</p><h2 id="2-1-EffectRenderFeature"><a href="#2-1-EffectRenderFeature" class="headerlink" title="2.1 EffectRenderFeature"></a>2.1 EffectRenderFeature</h2><p>Urp中需要定义RenderFeature来配置相应的Pass。因此，我们定义一个专门用于特效管线的Feature。在这个Feature中，我们按照上述的顺序加入这4个Pass，其中2和3根据全屏特效是否存在来判断是否加入渲染管线。</p><h2 id="2-2-兼容UI特效穿插UI的解决方案"><a href="#2-2-兼容UI特效穿插UI的解决方案" class="headerlink" title="2.2 兼容UI特效穿插UI的解决方案"></a>2.2 兼容UI特效穿插UI的解决方案</h2><p>由于发现自定义一个BeforeRenderingPostProcessing的特效Pass来专门渲染特效，会导致所有的特效都在半透明物体之后渲染，UI都是在半透明Pass渲染的，ShaderTag是UniversalForward，这样子会导致根据UI的Canvas来动态计算UI特效的sortingOrder以解决UI特效穿插UI的问题失效。因此，需要去除后处理特效前的特效pass，将这个Pass对应的特效改成默认的UniversalForward的ShaderTag。</p><p>关键代码如下，在这个Feature中还定义ColorRT的名字和采样方式、全屏后处理超级Shader的名字等。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">AddRenderPasses</span>(<span class="params">ScriptableRenderer renderer, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    renderer.EnqueuePass(mEffectBeforePostProcessRenderPass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UberEffectPostRenderPass.IsPostProcessEnable())</span><br><span class="line">    &#123;</span><br><span class="line">        mCopyColorRenderTarget.Init(RenderTargetName);</span><br><span class="line">        mCopyColorPass.Setup(renderer.cameraColorTarget, mCopyColorRenderTarget, RenderTargetSampling);</span><br><span class="line">        renderer.EnqueuePass(mCopyColorPass);</span><br><span class="line">        renderer.EnqueuePass(mUberEffectPostRenderPass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer.EnqueuePass(mEffectAfterPostProcessRenderPass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后处理特效前的特效pass（UniversalForward就会在后处理之前，因此不需要定义专门的Pass，专门的Pass会造成SortingOrder排序失效，UI无法遮挡特效）</span></span><br><span class="line">    <span class="comment">//mEffectBeforePostProcessRenderPass = new EffectRenderPass(new ShaderTagId("EffectBeforePostProcess"));</span></span><br><span class="line"><span class="comment">//mEffectBeforePostProcessRenderPass.renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝颜色缓冲pass</span></span><br><span class="line">    mSamplingMaterial = CoreUtils.CreateEngineMaterial(Shader.Find(<span class="string">"Hidden/Universal Render Pipeline/Sampling"</span>));</span><br><span class="line">    mCopyColorMaterial = CoreUtils.CreateEngineMaterial(Shader.Find(<span class="string">"Hidden/Universal Render Pipeline/Blit"</span>));</span><br><span class="line">    mCopyColorPass = <span class="keyword">new</span> CopyColorPass(RenderPassEvent.BeforeRenderingPostProcessing, mSamplingMaterial, mCopyColorMaterial);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特效后处理超级Pass</span></span><br><span class="line">    mUberEffectPostRenderPass = <span class="keyword">new</span> UberEffectPostRenderPass();</span><br><span class="line">    mUberEffectPostRenderPass.renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后处理特效后的特效pass</span></span><br><span class="line">    mEffectAfterPostProcessRenderPass = <span class="keyword">new</span> EffectRenderPass(<span class="keyword">new</span> ShaderTagId(<span class="string">"EffectAfterPostProcess"</span>));</span><br><span class="line">    mEffectAfterPostProcessRenderPass.renderPassEvent = RenderPassEvent.BeforeRenderingPostProcessing;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Urp的ForwardRender配置如图：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/EffectRenderFeature.jpg"></p><h2 id="2-3-EffectRenderPass"><a href="#2-3-EffectRenderPass" class="headerlink" title="2.3 EffectRenderPass"></a>2.3 EffectRenderPass</h2><p>特效渲染Pass用于渲染普通的特效，Pass跟Shader的对应方式是ShaderTag。关键代码如下，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DrawingSettings drawingSettings = CreateDrawingSettings(mShaderTag, <span class="keyword">ref</span> renderingData, SortingCriteria.CommonTransparent);</span><br><span class="line">    FilteringSettings filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line">    context.DrawRenderers(renderingData.cullResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个需要注意的地方是物体渲染的排序方式要用SortingCriteria.CommonTransparent，毕竟特效都是半透明物体。这个标志是Urp默认的渲染半透明物体的排序方式，理论上是从后到前的顺序渲染。</p><h2 id="2-4-UberEffectPostRenderPass"><a href="#2-4-UberEffectPostRenderPass" class="headerlink" title="2.4 UberEffectPostRenderPass"></a>2.4 UberEffectPostRenderPass</h2><p>后处理特效Pass为了兼容面片类型的扭曲特效和全屏类型的色散、黑白屏、径向模糊特效，调用了2次绘制函数。第一次是用context.DrawRenderers绘制普通的物体；第二次是用cmd.DrawMesh绘制一个全屏三角形。同时为了支持，场景中出现多个全屏特效，该Pass中保存了一个材质数组，同时根据优先级来排序，优先级高的先渲染，这样就可以实现多个全屏特效的叠加效果。<br>代码如下，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddMaterial</span>(<span class="params">Material mat, <span class="keyword">int</span> order = <span class="number">0</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> matOrder = mMaterialOrders.Find((temp) =&gt; temp.Mat == mat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matOrder == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        matOrder = <span class="keyword">new</span> MaterialOrder();</span><br><span class="line">        matOrder.Mat = mat;</span><br><span class="line">        mMaterialOrders.Add(matOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    matOrder.Order = order;</span><br><span class="line"></span><br><span class="line">    mMaterialOrders.Sort((a, b) =&gt; a.Order - b.Order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveMaterial</span>(<span class="params">Material mat</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mMaterialOrders.RemoveAll((temp) =&gt; temp.Mat == mat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ScriptableRenderContext context, <span class="keyword">ref</span> RenderingData renderingData</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DrawingSettings drawingSettings = CreateDrawingSettings(<span class="keyword">new</span> ShaderTagId(<span class="string">"UberEffectPost"</span>), <span class="keyword">ref</span> renderingData, SortingCriteria.RenderQueue | SortingCriteria.SortingLayer);</span><br><span class="line">    FilteringSettings filteringSettings = <span class="keyword">new</span> FilteringSettings(RenderQueueRange.all);</span><br><span class="line">    context.DrawRenderers(renderingData.cullResults, <span class="keyword">ref</span> drawingSettings, <span class="keyword">ref</span> filteringSettings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMaterialOrders == <span class="literal">null</span> || mMaterialOrders.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CommandBuffer cmd = CommandBufferPool.Get();</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">new</span> ProfilingScope(cmd, mProfilingSampler))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//set V,P to identity matrix so we can draw full screen quad (mesh's vertex position used as final NDC position)</span></span><br><span class="line">        cmd.SetViewProjectionMatrices(Matrix4x4.identity, Matrix4x4.identity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mMaterialOrders.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Material mat = mMaterialOrders[i] != <span class="literal">null</span> ? mMaterialOrders[i].Mat : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (mat != <span class="literal">null</span> &amp;&amp; mat.shader.name == mUberEffectPostShaderName)</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.DrawMesh(RenderingUtils.fullscreenMesh, Matrix4x4.identity, mat, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmd.SetViewProjectionMatrices(renderingData.cameraData.camera.worldToCameraMatrix, renderingData.cameraData.camera.projectionMatrix); <span class="comment">// restore</span></span><br><span class="line">    &#125;</span><br><span class="line">    context.ExecuteCommandBuffer(cmd);</span><br><span class="line">    CommandBufferPool.Release(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、后处理特效"><a href="#三、后处理特效" class="headerlink" title="三、后处理特效"></a>三、后处理特效</h1><h2 id="3-1-屏幕扭曲"><a href="#3-1-屏幕扭曲" class="headerlink" title="3.1 屏幕扭曲"></a>3.1 屏幕扭曲</h2><p>屏幕扭曲的效果最简单，只是偏移uv坐标即可。实现方式很多，基本上是采样噪声或者法线贴图来偏移uv坐标，核心代码大概如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">half2 screenUV = input.screenPos.xy / input.screenPos.w;</span><br><span class="line">float2 uvDiffuse = input.uv + float2(_ScreenDistortionU, _ScreenDistortionV) * _Time.y;</span><br><span class="line">float4 diffuseTex = tex2D(_ScreenDistortionDiffuse, TRANSFORM_TEX(uvDiffuse, _ScreenDistortionDiffuse));</span><br><span class="line">half2 offset = float2(diffuseTex.r, diffuseTex.g) * _ScreenDistortStrength;</span><br><span class="line">screenUV = screenUV + offset; <span class="keyword">return</span> half4(SampleScreenColor(screenUV).rgb, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>以上代码计算了2次偏移，第一次偏移是计算噪声图的uv，第二次是计算颜色缓冲的uv，也就是屏幕uv。<br>效果如下，中间的部分放了一个扭曲面片特效。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/屏幕扭曲.jpg"></p><h2 id="3-2-色散"><a href="#3-2-色散" class="headerlink" title="3.2 色散"></a>3.2 色散</h2><p>色散的原理也很简单，计算一个偏移的uv，分别在两个方向上计算r和b，不偏移的位置计算g，合并起来作为完整的颜色输出。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   half2 deltaUv = half2(_ColorDispersionStrength * _ColorDispersionU, _ColorDispersionStrength * _ColorDispersionV);</span><br><span class="line">result.r = SampleScreenColor(screenUV + deltaUv).r;</span><br><span class="line">result.g = SampleScreenColor(screenUV).g;</span><br><span class="line">result.b = SampleScreenColor(screenUV - deltaUv).b;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/色散.jpg"></p><h2 id="3-3-黑白屏"><a href="#3-3-黑白屏" class="headerlink" title="3.3 黑白屏"></a>3.3 黑白屏</h2><p>黑白屏的关键实现代码也很短。但是想出来不太容易。网上大部分实现，就是简单的灰度化加上和屏幕颜色的插件。后面发现特效同学要的东西其实就是网上找了位特效大佬用ASE生成的shader效果，拿到代码后，过滤掉生成的冗余代码发现核心就是下面2个插值计算。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">half luminosity = dot(screenColor.rgb, half3(<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>));</span><br><span class="line"><span class="keyword">float</span> smoothstepResult = smoothstep(_BlackWhiteThreshold, _BlackWhiteThreshold + _BlackWhiteWidth, luminosity.x);</span><br><span class="line">result = lerp(_BlackWhiteWhiteColor,_BlackWhiteBlackColor, smoothstepResult);</span><br></pre></td></tr></table></figure><p>关键代码是smoothstep，在阈值和阈值+阈值范围之间曲线插值，返回的值再用来插值白屏颜色色和黑屏颜色。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/黑白屏.png"></p><h2 id="3-4-径向模糊"><a href="#3-4-径向模糊" class="headerlink" title="3.4 径向模糊"></a>3.4 径向模糊</h2><p>径向模糊的思想是沿着到中点的方向采样几个点，然后平均。代码如下，这里假定是6次采样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   half2 dir = screenUV - half2(_RadialBlurHorizontalCenter, _RadialBlurVerticalCenter);</span><br><span class="line">half4 blur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">half2 uv = screenUV + _RadialBlurWidth * dir * i;</span><br><span class="line">blur += SampleScreenColor(uv);</span><br><span class="line">&#125;</span><br><span class="line">blur /= <span class="number">6</span>;</span><br><span class="line">   result = lerp(result, blur, saturate(_RadialBlurStrength));</span><br></pre></td></tr></table></figure><p>不过，以上代码不一定能满足美术的需求。比如dir是否需要归一化，lerp时候是否需要考虑距离中点的远近等都会影响最终的效果。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/径向模糊.jpg"></p><h2 id="3-5-色散和径向模糊"><a href="#3-5-色散和径向模糊" class="headerlink" title="3.5 色散和径向模糊"></a>3.5 色散和径向模糊</h2><p>  如果先计算色散的DeltaUv，再将取屏幕颜色替换为屏幕扭曲的话，就能得到一个色散和径向模糊结合的效果，关键代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">half2 deltaUv = half2(_ColorDispersionStrength * _ColorDispersionU, _ColorDispersionStrength * _ColorDispersionV);</span><br><span class="line">result.r = RadialBlur(screenUV + deltaUv, screenColor).r;</span><br><span class="line">result.g = RadialBlur(screenUV, screenColor).g;</span><br><span class="line">result.b = RadialBlur(screenUV - deltaUv, screenColor).b;</span><br></pre></td></tr></table></figure><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/色散和径向模糊的结合.jpg"></p><h2 id="3-6-UberEffectPost超级Shader"><a href="#3-6-UberEffectPost超级Shader" class="headerlink" title="3.6 UberEffectPost超级Shader"></a>3.6 UberEffectPost超级Shader</h2><p>具体实现上，我是用一个超级shader将这些功能整合到一起（除了屏幕扭曲，特效的需求是面片）形成一个UberShader。不同的效果通过shader_feature_local的开关来控制，这样既不用增加额外的大小和内存，也更方便美术同学的使用，整合到一起也是美术提出来的。<br>材质界面如下，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/UberEffectPost.jpg"></p><h2 id="3-7-UberEffectPost脚本"><a href="#3-7-UberEffectPost脚本" class="headerlink" title="3.7 UberEffectPost脚本"></a>3.7 UberEffectPost脚本</h2><p>该脚本继承自MonoBehavior，用于判断是否存在全屏特效以及全屏特效材质、全屏特效优先级设置，并且在材质改变时候将后处理材质传入Pass等。<br>另外，美术同学要求加的后处理参数控制曲线也是在该脚本中，截图如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/UberEffectPostScript.jpg"></p><p>这些参数曲线相对于TimeLine来说，可以更快的生成动态变化的后处理效果，减少美术去编辑TimeLine的工作量，不过自由度会有所降低。</p><h1 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h1><blockquote><p>1、<a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnRenderImage.html" target="_blank" rel="noopener">OnRenderImage</a><br>2、<a href="https://zhuanlan.zhihu.com/p/419814256" target="_blank" rel="noopener">仿.碧蓝幻想versus黑白闪后处理shader分享(build_in 与urp双版本)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、如何获得颜色缓冲&quot;&gt;&lt;a href=&quot;#一、如何获得颜色缓冲&quot; class=&quot;headerlink&quot; title=&quot;一、如何获得颜色缓冲&quot;&gt;&lt;/a&gt;一、如何获得颜色缓冲&lt;/h1&gt;&lt;p&gt;网上搜索Unity的后处理或者获得屏幕缓冲，大部分会提到用grabpass到一张指定纹理上或者写一个后处理脚本挂在摄像机上。但是这种方式在Urp管线下已经不生效了。urp取消了默认管线抓取颜色缓冲的grabpass，同时也取消了&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnRenderImage.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MonoBehaviour.OnRenderImage&lt;/a&gt;，需要使用&lt;a href=&quot;https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/api/UnityEngine.Rendering.Universal.ScriptableRenderPass.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ScriptableRenderPass&lt;/a&gt; 来完成类似的功能。ScriptableRenderPass是urp中的pass基类，urp预定义的pass都继承自该类，我们自定义的pass也需要继承自该类。&lt;/p&gt;
&lt;h2 id=&quot;1-1-Urp的渲染顺序&quot;&gt;&lt;a href=&quot;#1-1-Urp的渲染顺序&quot; class=&quot;headerlink&quot; title=&quot;1.1 Urp的渲染顺序&quot;&gt;&lt;/a&gt;1.1 Urp的渲染顺序&lt;/h2&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Rendering" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/"/>
    
    
      <category term="urp" scheme="http://xiaopengcheng.top/tags/urp/"/>
    
      <category term="特效" scheme="http://xiaopengcheng.top/tags/%E7%89%B9%E6%95%88/"/>
    
      <category term="后处理" scheme="http://xiaopengcheng.top/tags/%E5%90%8E%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>伽马校正和颜色空间</title>
    <link href="http://xiaopengcheng.top/2021/06/26/%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3%E5%92%8C%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    <id>http://xiaopengcheng.top/2021/06/26/%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3%E5%92%8C%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/</id>
    <published>2021-06-26T04:28:30.000Z</published>
    <updated>2022-01-21T05:04:15.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、伽马校正"><a href="#一、伽马校正" class="headerlink" title="一、伽马校正"></a>一、伽马校正</h1><p>所谓gamma校正，实际上是一个颜色的非线性变换。下面来解释这个变换曲线存在的原因。</p><h2 id="1-1-人眼的非线性视觉效应"><a href="#1-1-人眼的非线性视觉效应" class="headerlink" title="1.1 人眼的非线性视觉效应"></a>1.1 人眼的非线性视觉效应</h2><p>为什么要有gamma校正了。一言以蔽之，人眼的生理效应。如下图所示，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/gamma_correction_brightness.png"><br>第一行是人眼感受到的线性亮度变化，第二行是真实的非线性亮度变化。可以得出结论，首尾两端是一致的，但是中间值变化不一致；真实的中间亮度值必须更大，才能得到人眼感知的线性亮度变化。我们的目的是让人眼感受到线性的亮度变化曲线，因此输入亮度必须是第二行这种非线性的亮度变化曲线。<br>第二行的亮度变化曲线，就是<strong>伽马校正曲线</strong>。</p><h2 id="1-2-非线性显示器"><a href="#1-2-非线性显示器" class="headerlink" title="1.2 非线性显示器"></a>1.2 非线性显示器</h2><p>显示器为了应对人眼的这种非线性视觉效应，采用的也是类似的机制（也可能是历史原因，总之认为当今的显示器都是如此设计就行）。假设我们输入的颜色值，即输入给显示器的电压，那么这个电压对应的是1.1的第二行（Gamma校正曲线）；人眼感受到的显示器的真实输出对应的是1.1的第一行（线性颜色输出）。<br>如下图所示，<br><img alt="gamma_correction_gamma_curves" data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/gamma_correction_gamma_curves.png"></p><ul><li>假如显示器输入信号是gamma correction曲线，那么人眼看到的是线性曲线</li><li>如果显示输入信号是线性曲线，那么人眼看到的gamma曲线</li></ul><p>这里反复强调了，人眼感受到的显示器输出，而不是显示器的输出亮度。也就是，输入颜色值是0.5的话，人眼感受到的亮度是0.218，刚好和人眼的视觉效应匹配。实际上，这个时候显示器的输出亮度应该还是接近线性的，只是刚好和人眼的视觉效应吻合了。<br>值得强调的是，gamma指数2.2是可以变化的，在不同的场景下，可以选择不同的gamma指数。</p><h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h2><p>我们要明白两个事情，人眼的视觉感受是非线性的，显示器的输入信号和对应的输出也是非线性的；要让人眼感受到线性的颜色变化，那么输入的颜色信号必须进行伽马校正。</p><h1 id="二、颜色空间和工作流"><a href="#二、颜色空间和工作流" class="headerlink" title="二、颜色空间和工作流"></a>二、颜色空间和工作流</h1><p>颜色空间可以理解为，颜色是在哪个空间下制作的。不需要特别多的数学曲线来描绘，但是这个说明又需要一点美术经验来理解。下面来具体分类解释。</p><h2 id="2-1-伽马颜色空间和工作流"><a href="#2-1-伽马颜色空间和工作流" class="headerlink" title="2.1 伽马颜色空间和工作流"></a>2.1 伽马颜色空间和工作流</h2><p>比如，我们拍摄的<strong>照片</strong>，人眼看起来是正确的，那么说明人眼感受到的是线性变化的，因此照片的数据是经过伽马校正的，也就是照片的数据变化是在gamma校正曲线上的。同样的，在电脑上<strong>使用软件制作的图片</strong>也是处于gamma校正曲线上的。<br>我们把这种颜色数据在gamma校正曲线上的，叫做gamma color space，也叫做sRGB。<br>那么，伽马工作流指的是所有的流程都在伽马颜色空间完成，比如输入数据，比如光照计算等。</p><h2 id="2-2-线性颜色空间和工作流"><a href="#2-2-线性颜色空间和工作流" class="headerlink" title="2.2 线性颜色空间和工作流"></a>2.2 线性颜色空间和工作流</h2><p>类似的，线性颜色空间指的是输入数据是在线性曲线上的。那么，我们如果用一张真实的图片作为输入，首先要对其进行gamma校正，也就是需要将这张贴图设置为sRGB，引擎或者图形接口自动会将其转换。<br>线性工作流指的是所有的流程都在线性颜色空间完成，比如输入数据，比如光照计算等。<br>值得强调的是，我们现在的显示器都是gamma显示器，因此我们不能在渲染管线中不能直接输出线性数据，需要转换到sRGB空间再进行输出，某些硬件支持这个自动转换，如果检测到硬件不支持，渲染引擎会在后处理流程中用shader来转换。</p><h2 id="2-3-工作流总结"><a href="#2-3-工作流总结" class="headerlink" title="2.3 工作流总结"></a>2.3 工作流总结</h2><p>知乎上有一张图片总结了引擎的gamma和工作流，如下所示，<img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/颜色空间工作流.jpg"><br>不过这张图的gamma工作流是有一点问题的，颜色贴图是在gamma空间下，即sRGB贴图，显示器对其进行gamma变换后，得到的刚好是线性空间，因此人眼看起来是对的，并不是不真实的。</p><h1 id="三、关于贴图设置为sRGB后变暗的说明"><a href="#三、关于贴图设置为sRGB后变暗的说明" class="headerlink" title="三、关于贴图设置为sRGB后变暗的说明"></a>三、关于贴图设置为sRGB后变暗的说明</h1><p>业界或者网上一直流传，贴图设置为sRGB后变暗，这是因为贴图设置为sRGB后，<strong>如果使用的是线性工作流</strong>，引擎会对贴图进行去gamma校正，变换为线性空间，颜色值会压低，自然变暗了，在编辑下或者游戏中这个贴图都会看起来变暗了。如果是gamma工作流，则不会变暗，因为没有去gamma校正这个过程。<br>可以参考2.3的图，其中sRGB的remove gamma correction变换到线性空间描述了这个过程。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>我们讲述了人眼和显示器的视觉效应，以及两种颜色空间和对应的工作流。我们需要着重弄清楚的是，人眼的视觉效应、显示器的gamma校正、gamma颜色空间（sRGB）。</p><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote><p><a href="https://docs.unity.cn/2019.4/Documentation/Manual/LinearLighting.html" target="_blank" rel="noopener">Unity Color space</a><br><a href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction" target="_blank" rel="noopener">Gamma Correction</a><br><a href="https://zhuanlan.zhihu.com/p/66558476" target="_blank" rel="noopener">Gamma、Linear、sRGB 和Unity Color Space，你真懂了吗？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、伽马校正&quot;&gt;&lt;a href=&quot;#一、伽马校正&quot; class=&quot;headerlink&quot; title=&quot;一、伽马校正&quot;&gt;&lt;/a&gt;一、伽马校正&lt;/h1&gt;&lt;p&gt;所谓gamma校正，实际上是一个颜色的非线性变换。下面来解释这个变换曲线存在的原因。&lt;/p&gt;
&lt;h2 id=&quot;1-1-人眼的非线性视觉效应&quot;&gt;&lt;a href=&quot;#1-1-人眼的非线性视觉效应&quot; class=&quot;headerlink&quot; title=&quot;1.1 人眼的非线性视觉效应&quot;&gt;&lt;/a&gt;1.1 人眼的非线性视觉效应&lt;/h2&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Rendering" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/"/>
    
    
      <category term="伽马校正" scheme="http://xiaopengcheng.top/tags/%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3/"/>
    
      <category term="颜色空间" scheme="http://xiaopengcheng.top/tags/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    
      <category term="srgb" scheme="http://xiaopengcheng.top/tags/srgb/"/>
    
  </entry>
  
  <entry>
    <title>渲染管线中的坐标空间和相关变换</title>
    <link href="http://xiaopengcheng.top/2020/06/19/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8C%E7%9B%B8%E5%85%B3%E5%8F%98%E6%8D%A2/"/>
    <id>http://xiaopengcheng.top/2020/06/19/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%92%8C%E7%9B%B8%E5%85%B3%E5%8F%98%E6%8D%A2/</id>
    <published>2020-06-19T13:20:00.000Z</published>
    <updated>2022-01-14T11:48:35.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h1><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/坐标空间.png"></p><h1 id="二、模型空间"><a href="#二、模型空间" class="headerlink" title="二、模型空间"></a>二、模型空间</h1><p>这里的模型空间指的是建模出来的空间，也就是用建模软件输出的数据所在的坐标空间。比如，3D Max用的是右手系，输出的模型数据所在的空间就叫模型空间；由于Unity的模型空间是左手系，所以通常需要旋转90度才能对应上。</p><h1 id="三、切线空间"><a href="#三、切线空间" class="headerlink" title="三、切线空间"></a>三、切线空间</h1><p>切线空间又可以叫做纹理空间。假如纹理坐标uv构成一个二维空间，加上垂直于这个二维空间的法线，那么就是一个三维的切线空间。</p><h2 id="3-1-法线贴图的切线空间"><a href="#3-1-法线贴图的切线空间" class="headerlink" title="3.1 法线贴图的切线空间"></a>3.1 法线贴图的切线空间</h2><p>切线空间有什么应用了？我们在计算光照模型的时候，通常会有更精细表示法线的数据，比如法线贴图，法线贴图通常是建模软件用高模计算出来的。不过，法线贴图是原始切线空间下的数据。因此，法线贴图中的法线数据通常是(0,0,1)，所以法线贴图表现出大部分是蓝色。我们在读取这个法线数据后，需要将其变换到计算光照模型所在的空间，比如世界空间。</p><h2 id="3-2-模型空间下的切线空间"><a href="#3-2-模型空间下的切线空间" class="headerlink" title="3.2 模型空间下的切线空间"></a>3.2 模型空间下的切线空间</h2><p>顶点上除了位置数据外，还可以有法线、切线数据。注意，这些数据都是在模型空间的。因此，法线、切线、副切线（法线和切线叉积计算出来）自然可以构成一个模型空间下的切线空间。</p><h2 id="3-3-切线变换"><a href="#3-3-切线变换" class="headerlink" title="3.3 切线变换"></a>3.3 切线变换</h2><p>假如我们想将切线空间下的法线变换到世界空间，该如何做了？我们需要得到一个世界空间下的切线空间。首先将<strong>模型空间下的切线空间变换到世界空间</strong>，这样我们就得到了一个世界空间下的切线子空间，然后用这个切线子空间构成一个切线变换，再对切线空间下的法线数据应用这个切线变换就能变换到世界空间。<br>用公式来表示这个变换是，$NormalWS=TangentMatrix*NormalTS$。当然也可以将切线变换到其它的空间，比如摄像机空间，区别是构造不同的TangentMatrix。</p><h1 id="四、关节空间"><a href="#四、关节空间" class="headerlink" title="四、关节空间"></a>四、关节空间</h1><h2 id="4-1-关节空间"><a href="#4-1-关节空间" class="headerlink" title="4.1 关节空间"></a>4.1 关节空间</h2><p><strong>这里的关节空间，指的是带骨骼的模型中，骨骼或者关节所定义的局部空间。</strong><br>以人体手指为假设，手指会受到腕关节、肘关节、肩关节影响，对应三个骨骼。那么，手指会依次受到这三个关节的牵扯影响。我们知道，虚拟的根骨骼Root所在的是模型空间，同时每个关节也定义了自己的局部空间，比如腕关节是最终的局部空间，我们把这个关节定义的局部空间叫做关节空间。</p><h2 id="4-2-关节姿势"><a href="#4-2-关节姿势" class="headerlink" title="4.2 关节姿势"></a>4.2 关节姿势</h2><p>所谓关节姿势，存储的是子关节到父关节的变换，包括旋转、缩放、平移，这个也可以叫做局部关节姿势。全局关节姿势是，将所有的局部关节姿势结合起来。<br>比如公式，$P_{2\to M} = P_{2\to 1} P_{1\to 0} P_{0\to M}$表示的是将顶点从子关节2的局部空间变换到模型空间。全局关节姿势可以表示为$P_{j\to M} = \prod _{i=j}^{0} P_{i\to p(i)}$，其中p(i)是关节i的父关节。</p><h2 id="4-3-绑定关节姿势"><a href="#4-3-绑定关节姿势" class="headerlink" title="4.3 绑定关节姿势"></a>4.3 绑定关节姿势</h2><p>我们知道，默认情况下，蒙皮骨骼都有一个T-Pose，即绑定姿势，也可以理解为初始姿势。模型空间的顶点乘以绑定姿势的逆变换就能得到关节空间的顶点。</p><h2 id="4-4-蒙皮矩阵"><a href="#4-4-蒙皮矩阵" class="headerlink" title="4.4 蒙皮矩阵"></a>4.4 蒙皮矩阵</h2><p>模型空间的顶点乘以绑定姿势的逆变换就能得到关节空间的顶点。关键点来了，这个时候再乘以骨骼的当前全局姿势矩阵，就又变换回了模型空间。所谓的蒙皮矩阵，就是这两个变换的结合。可以用公式表示骨骼i的蒙皮矩阵，$K_{j} = (B_{j\to M})^{-1}  C_{j \to M}$，B代表绑定姿势，C代表当前姿势。多个蒙皮矩阵的加权，就能得到蒙皮动画。</p><h2 id="4-5-蒙皮动画"><a href="#4-5-蒙皮动画" class="headerlink" title="4.5 蒙皮动画"></a>4.5 蒙皮动画</h2><p>顶点会受到多个骨骼影响，这些骨骼的影响加权和为1，这个就是蒙皮动画。可以用公式来表示，$p’ = \sum_{i=1}^{n}W_i(p)K_ip$。其中，p是模型空间的顶点，Wi是骨骼i影响的权重，Ki是骨骼i的蒙皮矩阵。蒙皮矩阵的计算如上所示。</p><h2 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h2><p>根据以上五步的推导，蒙皮动画需要存储的数据是，</p><ul><li>绑定姿势下的的模型空间顶点</li><li>绑定关节姿势的逆矩阵</li><li>当前姿势数据（实时计算当前姿势矩阵）</li><li>蒙皮矩阵的权重</li></ul><h1 id="五、世界空间"><a href="#五、世界空间" class="headerlink" title="五、世界空间"></a>五、世界空间</h1><p>所谓世界空间，不需要解释了吧。放在游戏场景里面，指的是规定了场景坐标系的空间。模型空间，则指的是场景内的单个模型自身数据所在的空间。</p><h2 id="5-1-模型变换"><a href="#5-1-模型变换" class="headerlink" title="5.1 模型变换"></a>5.1 模型变换</h2><p>模型变换就是将模型空间的顶点数据变换到世界空间，通常包括对模型的平移、旋转和缩放。但是，一般要求的变换顺序是先缩放、再旋转、最后平移，如果反过来会造成平移受到前面的变换影响，与直观印象不符合。<br>所以，$ModelMatrix=TranslateMatrix*RotateMatrix*ScaleMatrix$。特别说明平移矩阵指的是，将模型从原点移动到其在世界空间的位置。</p><h1 id="六、摄像机空间"><a href="#六、摄像机空间" class="headerlink" title="六、摄像机空间"></a>六、摄像机空间</h1><p>摄像机空间也叫做观察空间。摄像机可以理解为世界空间的一个位置和朝向，比如在坐标(1,1,1)看向原点，那么射线的位置就是坐标(1,1,1)，前向就是看向的方向（-1，-1，-1）。这个时候再定义一个垂直于forward的Up方向，就可以根据叉积找到垂直forward和up方向的right方向。这三个方向就可以构成一个摄像机空间。</p><h2 id="6-1-观察变换"><a href="#6-1-观察变换" class="headerlink" title="6.1 观察变换"></a>6.1 观察变换</h2><p>观察变换是将顶点从世界空间变换到新的摄像机空间。首先，需要将顶点平移，比如上述情况下的原点在观察空间下是(-1，-1，-1)；然后，需要旋转顶点以匹配观察空间的坐标轴。由于观察空间的坐标轴是世界空间下的单位正交基，因此将三个轴放入矩阵即可得到旋转矩阵的逆矩阵（等于旋转矩阵的转置矩阵）。</p><h1 id="七、裁剪空间"><a href="#七、裁剪空间" class="headerlink" title="七、裁剪空间"></a>七、裁剪空间</h1><p>裁剪空间指的是观察空间下的顶点经过投影变换后所处的空间。我们知道，可视区域是摄像机前面的一个平截头体（透视投影）或者一个长方体（正交投影）。裁剪空间的用途是将可视区域外的物体裁剪，同时计算物体的二维坐标。</p><h2 id="7-1-投影变换"><a href="#7-1-投影变换" class="headerlink" title="7.1 投影变换"></a>7.1 投影变换</h2><p>投影分为透视投影和正交投影两种，透视投影会造成近大远小的效果，符合视觉效应，三维游戏一般使用透视投影，正交投影则远近一样大，通常只用于建模软件。</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/透视投影.jpg"><br>从图可以看出，透视投影后w是有值的，并不是1，结果还是一个平截头体。具体的矩阵推动，请参考相关资料。</p><h3 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/正交投影.jpg"><br>从图可以看出，正交投影实际上就是缩放和平移的结合，得到的结果是一个-1到1范围的立方体。</p><h2 id="7-2-透视除法和图元裁剪"><a href="#7-2-透视除法和图元裁剪" class="headerlink" title="7.2 透视除法和图元裁剪"></a>7.2 透视除法和图元裁剪</h2><p>由于透视投影后齐次坐标的w非1，需要进行透视除法，这个是图形硬件自动进行的。如图所示：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/透视除法.jpg"><br>透视除法后，可以得到和正交投影结果一样的规范化立方体，也叫做NDC（规范化设备坐标系）。<br>到了NDC后，就可以方便的进行图元裁剪，毕竟坐标都是-1到1了（DirectX下Z坐标是0到1）。</p><h2 id="7-3-顶点着色器的输出"><a href="#7-3-顶点着色器的输出" class="headerlink" title="7.3 顶点着色器的输出"></a>7.3 顶点着色器的输出</h2><p>顶点着色器必须输出裁剪空间下的坐标。由于DirectX的NDC的Z范围是0到1，与OpenGL的-1到1有一定区别。因此，这2者的投影矩阵在Z坐标上有一定的平移和缩放区别。</p><h1 id="八、屏幕空间"><a href="#八、屏幕空间" class="headerlink" title="八、屏幕空间"></a>八、屏幕空间</h1><p>投影变换后得到的顶点范围是-1到1。现在还需要将NDC下的顶点映射到屏幕空间。屏幕空间也可以叫做窗口空间，即窗口定义的坐标空间。</p><h2 id="8-1-视口变换"><a href="#8-1-视口变换" class="headerlink" title="8.1 视口变换"></a>8.1 视口变换</h2><p>假设，窗口坐标原点在左下角（OpenGL的原点在左下角，但是DirectX的在左上角），窗口大小为Width和Height。视口变换就是把-1到1的x和y坐标范围映射到（0，width）和（0，height），对应DirectX的话，y还需要取反。这就是一个平移和缩放的过程。</p><p>实际上，透视除法和视口变换（屏幕空间映射）都是硬件自动进行的。</p><h1 id="九、参考资料"><a href="#九、参考资料" class="headerlink" title="九、参考资料"></a>九、参考资料</h1><blockquote><p><a href="https://book.douban.com/subject/26821639/" target="_blank" rel="noopener">Unity Shader入门精要</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、思维导图&quot;&gt;&lt;a href=&quot;#一、思维导图&quot; class=&quot;headerlink&quot; title=&quot;一、思维导图&quot;&gt;&lt;/a&gt;一、思维导图&lt;/h1&gt;&lt;p&gt;&lt;img alt data-src=&quot;https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/坐标空间.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;二、模型空间&quot;&gt;&lt;a href=&quot;#二、模型空间&quot; class=&quot;headerlink&quot; title=&quot;二、模型空间&quot;&gt;&lt;/a&gt;二、模型空间&lt;/h1&gt;
    
    </summary>
    
    
      <category term="渲染" scheme="http://xiaopengcheng.top/categories/%E6%B8%B2%E6%9F%93/"/>
    
    
      <category term="渲染管线" scheme="http://xiaopengcheng.top/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
      <category term="坐标空间" scheme="http://xiaopengcheng.top/tags/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4/"/>
    
      <category term="坐标变换" scheme="http://xiaopengcheng.top/tags/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>左右手坐标系和相关定则的总结</title>
    <link href="http://xiaopengcheng.top/2020/03/06/%E5%B7%A6%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E5%AE%9A%E5%88%99%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://xiaopengcheng.top/2020/03/06/%E5%B7%A6%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C%E7%9B%B8%E5%85%B3%E5%AE%9A%E5%88%99%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2020-03-06T12:15:30.000Z</published>
    <updated>2022-01-17T12:58:34.191Z</updated>
    
    <content type="html"><![CDATA[<p>左手坐标系和右手坐标系是三维空间下两种不同的坐标系，而且无法通过旋转将左手坐标系转换到右手坐标系。与其相对应的，有左手定则和右手定则，主要是用来确定叉积的朝向或者说旋向。<br>首先，规定二维坐标，X轴朝右、Y轴朝上，推广到三维空间，需要确定的是Z轴是朝前还是朝后。</p><h1 id="一、左手坐标系"><a href="#一、左手坐标系" class="headerlink" title="一、左手坐标系"></a>一、左手坐标系</h1><p>所谓左手坐标系，指的是通过左手来确定的一个三维空间坐标系。</p><h2 id="1-1-确定左手坐标系的方式"><a href="#1-1-确定左手坐标系的方式" class="headerlink" title="1.1 确定左手坐标系的方式"></a>1.1 确定左手坐标系的方式</h2><p>下面总结了三种可以确定左手坐标系的方法。</p><h3 id="1-1-1-拇指、食指、中指相互垂直确定法"><a href="#1-1-1-拇指、食指、中指相互垂直确定法" class="headerlink" title="1.1.1 拇指、食指、中指相互垂直确定法"></a>1.1.1 拇指、食指、中指相互垂直确定法</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/左右手坐标系.png"><br>如图，伸出左手，拇指朝上代表Y轴、食指朝前代表Z轴、中指朝右代表X轴。注意，中指这个时候是只能往右边弯曲的。</p><h3 id="1-1-2-左手定则确定法"><a href="#1-1-2-左手定则确定法" class="headerlink" title="1.1.2 左手定则确定法"></a>1.1.2 左手定则确定法</h3><p>伸出左手，手指朝着右边X轴，握向Y轴，这个时候拇指指向的方向就是Z轴（朝前）。</p><h3 id="1-1-3-人站立的正面朝向确定法"><a href="#1-1-3-人站立的正面朝向确定法" class="headerlink" title="1.1.3 人站立的正面朝向确定法"></a>1.1.3 人站立的正面朝向确定法</h3><p>人朝前站立着，右手伸出的朝向是X轴，头顶的方向是Y轴，面向Z轴。</p><h2 id="1-2-左手定则"><a href="#1-2-左手定则" class="headerlink" title="1.2 左手定则"></a>1.2 左手定则</h2><p>假设，叉乘计算，C=A叉乘B。如何确定在C的朝向了？如果A和B都在左手坐标系下，那么使用左手定则来确定C的朝向。<br>类似1.1.2，伸出左手，手指朝着A，握向B，这个时候拇指指向的方向就是C。</p><h1 id="二、右手坐标系"><a href="#二、右手坐标系" class="headerlink" title="二、右手坐标系"></a>二、右手坐标系</h1><h2 id="2-1-确定右手坐标系的方式"><a href="#2-1-确定右手坐标系的方式" class="headerlink" title="2.1 确定右手坐标系的方式"></a>2.1 确定右手坐标系的方式</h2><h3 id="2-1-1-拇指、食指、中指相互垂直确定法"><a href="#2-1-1-拇指、食指、中指相互垂直确定法" class="headerlink" title="2.1.1 拇指、食指、中指相互垂直确定法"></a>2.1.1 拇指、食指、中指相互垂直确定法</h3><p>参考1.1.1，伸出右手，拇指朝上代表Y轴、食指朝前代表Z轴、中指朝左代表X轴。注意，中指这个时候是只能往左边弯曲的。<br>但是，我们一般假定X轴朝右，因此需要握着Z轴旋转180度。这个时候，拇指朝上代表Y轴、食指朝后代表Z轴、中指朝右代表X轴。注意，左右手坐标系旋转后不会改变。</p><h3 id="2-1-2-左手定则确定法"><a href="#2-1-2-左手定则确定法" class="headerlink" title="2.1.2 左手定则确定法"></a>2.1.2 左手定则确定法</h3><p>伸出右手，手指朝着右边X轴，握向Y轴，这个时候拇指指向的方向就是Z轴（朝后）。</p><h3 id="2-1-3-人站立的正面朝向确定法"><a href="#2-1-3-人站立的正面朝向确定法" class="headerlink" title="2.1.3 人站立的正面朝向确定法"></a>2.1.3 人站立的正面朝向确定法</h3><p>人朝前站立着，右手伸出的朝向是X轴，头顶的方向是Y轴，背后的是Z轴。</p><h2 id="2-2-右手定则"><a href="#2-2-右手定则" class="headerlink" title="2.2 右手定则"></a>2.2 右手定则</h2><p>类似1.1，如果A和B都在,右手坐标系下，那么使用右手定则来确定C的朝向。<br>类似1.1.2，伸出右手，手指朝着A，握向B，这个时候拇指指向的方向就是C。<br>因此，左手定则和右手定则的区别是使用左手还是右手。</p><h1 id="三、图形API的左右手坐标系"><a href="#三、图形API的左右手坐标系" class="headerlink" title="三、图形API的左右手坐标系"></a>三、图形API的左右手坐标系</h1><p>图形管线中，存在多个坐标系，每个坐标系都可以使用左手或者右手坐标系。下面按照，物体坐标系-&gt;世界坐标系-&gt;摄像机坐标系-&gt;裁剪坐标系-&gt;窗口坐标系来说明。</p><h2 id="3-1-OpenGL"><a href="#3-1-OpenGL" class="headerlink" title="3.1 OpenGL"></a>3.1 OpenGL</h2><p>OpenGL默认是右手坐标系。不过到了窗口坐标系，OpenGL使用的是左手坐标系。为什么了？<strong>因为OpenGL的深度范围是[0,1]，而且是摄像机越远，深度越大，这就是左手坐标系啦</strong>。<br>由于物体坐标系、世界坐标系、摄像机坐标系都是右手坐标系，但是窗口坐标系是左手坐标系，那么投影矩阵就需要乘以右手坐标系变换到左手坐标系这个变换，也就是Z变换成-Z。不过这个变换也可以放在摄像机坐标系，也就是MVP的V中。现在假定，都乘到P中了。<br>最终结论是：物体坐标系、世界坐标系、摄像机坐标系是右手坐标系；裁剪坐标系和窗口坐标系是左手坐标系，窗口坐标系实际上只是裁剪坐标系进行齐次除法后再平移缩放而已。</p><h2 id="3-2-DirectX"><a href="#3-2-DirectX" class="headerlink" title="3.2 DirectX"></a>3.2 DirectX</h2><p>DirectX默认是左手坐标系。<br>类似3.1，物体坐标系、世界坐标系、摄像机坐标系是左手坐标系。<strong>注意，DirectX的窗口坐标系是以左上角为原点的，深度是朝前的，那么跟OpenGL的反过来，是右手坐标系。</strong><br>因此，裁剪坐标系和窗口坐标系是右手手坐标系。投影变化同样要乘以，右手坐标系变换到左手坐标系这个变换，也就是Z变换成-Z。</p><h2 id="3-3-Vulkan"><a href="#3-3-Vulkan" class="headerlink" title="3.3 Vulkan"></a>3.3 Vulkan</h2><p>Vulkan的窗口坐标系和DirectX的一致，因此推测其余坐标系和DirectX的一致。</p><h2 id="3-4-Metal"><a href="#3-4-Metal" class="headerlink" title="3.4 Metal"></a>3.4 Metal</h2><p>Vulkan的窗口坐标系和DirectX的一致，因此推测其余坐标系和DirectX的一致。</p><p>看来只有，历史遗留的奇葩OpenGL的窗口坐标系，原点在左下角啊。原点在哪，这个跟纹理的v坐标是否需要取反也有关系。</p><h1 id="四、游戏引擎的左右手坐标系"><a href="#四、游戏引擎的左右手坐标系" class="headerlink" title="四、游戏引擎的左右手坐标系"></a>四、游戏引擎的左右手坐标系</h1><p>游戏引擎中，物体和世界坐标系是固定的，对于所有的图形API都会一样。</p><h2 id="4-1-Unity"><a href="#4-1-Unity" class="headerlink" title="4.1 Unity"></a>4.1 Unity</h2><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/Unity物体坐标系.jpg"><br>根据上图，Unity的物体和世界坐标系可以推测都是左手系。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/Unity坐标系旋向.jpg"><br>根据上图，出自UnityShader入门精要，Unity的窗口坐标系和OpenGL的一致，是左手系。但是摄像机空间变换到了右手系。那么，在V中需要乘以Z到-Z的变换。同时，P中再乘以-Z到Z的变换变回左手系。<br>为啥多次一举了，怀疑这个结论的正确性。下面做实验，用IMGizmos绘制坐标轴。代码如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace GYGame</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 出生点</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public class PlayerStart : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        public float GizmosHeight &#123; get; set; &#125; &#x3D; 2.0f;</span><br><span class="line"></span><br><span class="line">        void OnDrawGizmos()</span><br><span class="line">        &#123;</span><br><span class="line">            IMGizmos.Line3D(transform.position, transform.position + transform.up * GizmosHeight, Color.green);</span><br><span class="line">            IMGizmos.Line3D(transform.position, transform.position + transform.right * GizmosHeight, Color.red);</span><br><span class="line">            IMGizmos.Line3D(transform.position, transform.position + transform.forward * GizmosHeight, Color.blue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选中场景相机，可以得到下面结果，<br><img alt="Unity摄像机坐标系" data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/Unity摄像机坐标系.jpg"><br>可以看到右下角的场景相机画面里面有显示PlayerStart的Gizmos，Gizmos显示的坐标系是左手系，跟右上角显示的坐标系是一致的。同时，引擎自带的Gizmos显示的摄像机前向也是Z轴正向。<br>因此，推测我实验的Unity版本是2020，与UnityShader入门精要使用的Unity5.X版本，摄像机空间的旋向性已经发生了变化。</p><h2 id="4-2-UnrealEngine"><a href="#4-2-UnrealEngine" class="headerlink" title="4.2 UnrealEngine"></a>4.2 UnrealEngine</h2><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/虚幻坐标系.jpg"><br>虚幻和Unity一样也是采用左手坐标系，不过其是Z轴朝上，Y轴朝外。沿着X轴旋转90度，可以得到Z轴朝内，Y轴朝上，那么和Unity的是一致的。<br>推测，其余的空间的坐标系旋向和Unity的是一致。摄像机空间的旋向也可以用类似4.1的方式绘制Gizmos，然后选中摄像机，查看摄像机的绘制结果。</p><h1 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h1><blockquote><p><a href="https://book.douban.com/subject/26821639/" target="_blank" rel="noopener">Shader入门精要</a><br><a href="https://zhuanlan.zhihu.com/p/269621383" target="_blank" rel="noopener">图形坐标系的跨平台适配</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;左手坐标系和右手坐标系是三维空间下两种不同的坐标系，而且无法通过旋转将左手坐标系转换到右手坐标系。与其相对应的，有左手定则和右手定则，主要是用来确定叉积的朝向或者说旋向。&lt;br&gt;首先，规定二维坐标，X轴朝右、Y轴朝上，推广到三维空间，需要确定的是Z轴是朝前还是朝后。&lt;/p&gt;
&lt;h1 id=&quot;一、左手坐标系&quot;&gt;&lt;a href=&quot;#一、左手坐标系&quot; class=&quot;headerlink&quot; title=&quot;一、左手坐标系&quot;&gt;&lt;/a&gt;一、左手坐标系&lt;/h1&gt;&lt;p&gt;所谓左手坐标系，指的是通过左手来确定的一个三维空间坐标系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="Rendering" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/Rendering/"/>
    
    
      <category term="左右手坐标系" scheme="http://xiaopengcheng.top/tags/%E5%B7%A6%E5%8F%B3%E6%89%8B%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
    
      <category term="左右手定理" scheme="http://xiaopengcheng.top/tags/%E5%B7%A6%E5%8F%B3%E6%89%8B%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D代码规范</title>
    <link href="http://xiaopengcheng.top/2018/12/19/Unity3D%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://xiaopengcheng.top/2018/12/19/Unity3D%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2018-12-19T09:15:51.000Z</published>
    <updated>2022-01-07T11:05:54.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、命名法"><a href="#一、命名法" class="headerlink" title="一、命名法"></a>一、命名法</h1><p>Pascal命名法：每个单词首字母大写。<br>Camel命名法：第一个单词首字母小写，其余单词首字母大写。<br>C++标准库命名法：全小写，单词用下划线分割。</p><h2 id="1-1-C"><a href="#1-1-C" class="headerlink" title="1.1 C"></a>1.1 C</h2><p>函数和类采用Pascal命名法，变量采用Camel命名法。<br>代码目录和文件采用Pascal命名法。</p><h2 id="1-2-Lua"><a href="#1-2-Lua" class="headerlink" title="1.2 Lua"></a>1.2 Lua</h2><p>类采用Pascal命名法，其余采用C++标准库命名法。<br>代码目录和文件采用C++标准库命名法。</p><h2 id="1-3-其它"><a href="#1-3-其它" class="headerlink" title="1.3 其它"></a>1.3 其它</h2><p>其它目录和文件采用Pascal命名法。</p><h1 id="二、C-代码规范"><a href="#二、C-代码规范" class="headerlink" title="二、C#代码规范"></a>二、C#代码规范</h1><h2 id="2-1-命名的基本约定"><a href="#2-1-命名的基本约定" class="headerlink" title="2.1 命名的基本约定"></a>2.1 命名的基本约定</h2><p>函数用动词命名，其它的用名词或者形容词命名。</p><h3 id="避免使用拼音"><a href="#避免使用拼音" class="headerlink" title="避免使用拼音"></a>避免使用拼音</h3><p>原则上避免使用拼音命名代码。</p><h3 id="尽量避免缩写"><a href="#尽量避免缩写" class="headerlink" title="尽量避免缩写"></a>尽量避免缩写</h3><p>尽量不要缩写名字，名字长没关系，尽可能描述清楚。</p><h3 id="类型前缀"><a href="#类型前缀" class="headerlink" title="类型前缀"></a>类型前缀</h3><p>类和变量前一般不要加前缀。模板类型加前缀T，接口加前缀I，枚举加前缀E。</p><h3 id="类型后缀"><a href="#类型后缀" class="headerlink" title="类型后缀"></a>类型后缀</h3><p>特殊类型可选加后缀。<br>List：可选加List后缀。<br>Dictionary：可选加Dict后缀。<br>delegate：加上后缀Event。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>使用Pascal命名法。<br>命名空间采用GY开头，比如GYEngine、GYGame。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用Pascal命名法。<br>类名要用名词。模板类开头用T。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>使用Pascal命名法。<br>接口开头用I。接口名要用名词或者形容词。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举类型采用Pascal命名法，需要加上前缀E，比如EMessageType。<br>枚举常量不需要加前缀，采用Pascal命名法，特殊情况下可以拆成两部分用下划线区分，比如Message_Start。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Enum EWeaponType</span><br><span class="line">&#123;</span><br><span class="line">Knife,</span><br><span class="line">Pistol,</span><br><span class="line">MachineGun,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Enum EMessageType</span><br><span class="line">&#123;</span><br><span class="line">Message_Start,</span><br><span class="line">Message_End,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>使用Pascal命名法。<br>函数名最好用动词开头。</p><h3 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h3><p>使用Pascal命名法。<br>使用动词短语命名，delegate类型的命名需要加上后缀Event。<br>event类型的实例需要加上On前缀，Event后缀。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">KillMonsterEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> KillMonsterEvent OnKillMonsterEvent = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>使用Pascal命名法。<br>属性是对Get和Set的语法封装，一般是public或者protected采有意义。</p><h3 id="特性-Attribute"><a href="#特性-Attribute" class="headerlink" title="特性(Attribute)"></a>特性(Attribute)</h3><p>使用Pascal命名法。<br>用名词或名词短语+Attribute方式命名特性。<br>比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObsoleteAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>采用Camel命名法。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>采用Camel命名法。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>类非公有非静态成员变量用m开头。比如mActorId。<br>类的公有成员变量大写开头，不需要加m前缀，尽量用属性代替公有变量。</p><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>类的静态成员变量用s开头。<br>函数内的静态变量用s开头。<br>比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Actor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mActorId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sActorNumInClass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> mActorClassId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> ActorName = <span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ActorId</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> mActorId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123; </span><br><span class="line">mActorId = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">KillMonsterEvent</span>(<span class="params"></span>)</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">event</span> KillMonsterEvent OnKillMonsterEvent = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Actor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mActorId = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetActorNum</span>(<span class="params"><span class="keyword">bool</span> isFirstTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sActorNumInFun;</span><br><span class="line"><span class="keyword">int</span> addNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> sActorNumInFun = (isFirstTime ? <span class="number">0</span> : sActorNumInFun + addNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所有单词大写，多个单词之间用下划线隔开，比如public const int MAX_NUM = 10。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>原则上，尽量写可读性良好、自解释的代码，避免写冗余的注释。</p><h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><p>文件开头必须要有注释，如果是单个类的文件，可以将用类注释替代。</p><h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><p>单个类的文件，必须有类注释。<br>类注释说明该类是做什么的，可选包含怎么实现以及为什么这么实现的原因。</p><h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><p>简单函数不需要注释，难以使用的函数需要加注释，想想为什么难以使用，这个时候往往需要重构或者拆分函数代码了。</p><h3 id="语句注释"><a href="#语句注释" class="headerlink" title="语句注释"></a>语句注释</h3><p>关键难以理解的代码语句，需要加上注释说明。</p><h3 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h3><p>关键变量加上注释，普通的不需要加注释。</p><h2 id="2-2-代码风格"><a href="#2-2-代码风格" class="headerlink" title="2.2 代码风格"></a>2.2 代码风格</h2><h3 id="类成员排列顺序"><a href="#类成员排列顺序" class="headerlink" title="类成员排列顺序"></a>类成员排列顺序</h3><ol><li>属性：公有属性 、受保护属性 </li><li>字段：受保护字段、私有字段（公有字段当作属性对待）</li><li>事件：公有事件、受保护事件、私有事件</li><li>构造函数：参数数量最少的构造函数，参数数量中等的构造函数，参数数量最多的构造函数</li><li>方法：重载方法的排列顺序与构造函数相同，从参数数量最少往下至参数最多。方法按照功能分块，尽可能按照公有、保护、私有的访问级别来分布。</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li>一行只能声明一个变量，尽量避免用var定义变量类型，除非类型写起来很冗余。</li><li>尽量在声明的同时初始化。</li><li>变量定义在开头，比如类开头或者函数开头。除非是根据条件定义的块变量。</li></ol><p>比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> mName = <span class="string">"PeopleName"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mAge = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeAge</span>(<span class="params"><span class="keyword">int</span> newAge, <span class="keyword">bool</span> needAddAge</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mAge = newAge;</span><br><span class="line"><span class="keyword">if</span> (needAddAge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tempAddAge = <span class="number">1</span>;</span><br><span class="line">mAge += tempAddAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><ol><li>一行只能有一条语句。</li><li><p>单行复合语句必须加大括号。原则上，即使只有一行语句，也需要加大括号包起来，防止后续修改代码破坏忘记语句范围。比如，</p></li><li><p>else if等必须新起一行。比如，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isWorkday)</span><br><span class="line">&#123;</span><br><span class="line">Work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isHoliday)</span><br><span class="line">&#123;</span><br><span class="line">Rest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>代码缩进使用Tab键实现，最好不要使用空格，为保证在不同机器上使代码缩进保持一致，设置Tab键宽度为4个字符。</p><h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><ol><li>大括号需要占一行对齐，而不是将左大括号放在行尾。</li><li>Lambda函数可以将左大括号放在同一行，不需要另起一行。</li></ol><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ol><li>if、while、for、return等关键词后应有一个空格［eg. “if (a == b)”］。</li><li>运算符前后应各有一个空格［eg. “a = b + c;”］。</li><li>函数调用后不需要加空格。</li><li>左括号后面和右括号前面不需要加额外的空格。</li></ol><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ol><li>函数之间必须加空行。</li><li>较长函数的代码块直接用空行分割。</li><li>变量定义可以分块加空行分割。</li></ol><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>每一行代码的行长度，建议不要超过110个字符或者说不超过屏幕宽度。如果超过这个长度，可以按照以下规则换行：</p><ol><li>在逗号后换行。</li><li>在操作符前换行。</li><li>第一条优先于第二条。</li></ol><h3 id="函数长度"><a href="#函数长度" class="headerlink" title="函数长度"></a>函数长度</h3><p>建议单个函数长度不要超过80行。越简短越好。<br>超过80行，可以考虑拆分函数重用代码。</p><h3 id="类长度"><a href="#类长度" class="headerlink" title="类长度"></a>类长度</h3><p>单个类文件原则上不超过1000行。接近或者超过，考虑拆分类或者多个文件实现类。</p><h2 id="2-3-示例代码"><a href="#2-3-示例代码" class="headerlink" title="2.3 示例代码"></a>2.3 示例代码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">YMGame</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> Enum EWeaponType</span><br><span class="line">&#123;</span><br><span class="line">Knife,</span><br><span class="line">Pistol,</span><br><span class="line">MachineGun,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Actor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mActorId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sActorNumInClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> mActorClassId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> ActorName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> ActorId</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">return</span> mActorId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123; </span><br><span class="line">mActorId = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetActorNum</span>(<span class="params"><span class="keyword">bool</span> isFirstTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sActorNumInFun;</span><br><span class="line"><span class="keyword">int</span> addNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> sActorNumInFun = (isFirstTime ? <span class="number">0</span> : sActorNumInFun + addNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetActorId</span>(<span class="params"><span class="keyword">int</span> classId, <span class="keyword">int</span> actorId</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sNonClassIdActorNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mActorClassId = classId;</span><br><span class="line">mActorId = actorId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mActorClassId &lt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">sNonClassIdActorNum++;</span><br><span class="line"><span class="keyword">bool</span> isNonClassIdActor = <span class="literal">true</span>;</span><br><span class="line">actorId = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、Lua代码规范"><a href="#三、Lua代码规范" class="headerlink" title="三、Lua代码规范"></a>三、Lua代码规范</h1><p>除了以下特殊提及到的，Lua的代码规范参照C#的代码规范。</p><h2 id="3-1-命名规则"><a href="#3-1-命名规则" class="headerlink" title="3.1 命名规则"></a>3.1 命名规则</h2><h3 id="文件（类）名"><a href="#文件（类）名" class="headerlink" title="文件（类）名"></a>文件（类）名</h3><p>采用Pascal命名法。</p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>采用Pascal命名法。</p><h3 id="文件的local变量"><a href="#文件的local变量" class="headerlink" title="文件的local变量"></a>文件的local变量</h3><p>下划线开头，采用Camel命名法。比如_classType。</p><h3 id="函数的local变量"><a href="#函数的local变量" class="headerlink" title="函数的local变量"></a>函数的local变量</h3><p>采用Camel命名法。</p><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><p>采用Camel命名法。</p><h3 id="C-代码导出到Lua"><a href="#C-代码导出到Lua" class="headerlink" title="C#代码导出到Lua"></a>C#代码导出到Lua</h3><p>必须增加Cs前缀以做区分，比如CsFileManager = CS.GYEngine.FileManager.Instance。</p><h3 id="双下划线"><a href="#双下划线" class="headerlink" title="双下划线"></a>双下划线</h3><p>双下划线用于一些特殊函数的前缀，比如类的初始化和销毁函数。</p><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>使用项目规定的log函数。比如使用log.l，可以通过个人logid来过滤其他人日志；警告使用log.w；错误使用log.e，避免使用默认的error。</p><h1 id="四、编程技巧"><a href="#四、编程技巧" class="headerlink" title="四、编程技巧"></a>四、编程技巧</h1><h2 id="避免使用魔数"><a href="#避免使用魔数" class="headerlink" title="避免使用魔数"></a>避免使用魔数</h2><p>代码里面不要出现魔法数字，用常量来替代。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span>(<span class="params"><span class="keyword">double</span> radius</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量替代魔法数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> final Double PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span>(<span class="params"><span class="keyword">double</span> radius</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释型变量"><a href="#解释型变量" class="headerlink" title="解释型变量"></a>解释型变量</h2><p>如下所示，用bool变量代替复杂的条件判断，bool变量的命名可以解释条件判断的意思。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入解释性变量后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">bool</span> isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line"><span class="keyword">if</span> (isSummer)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免函数参数过多"><a href="#避免函数参数过多" class="headerlink" title="避免函数参数过多"></a>避免函数参数过多</h2><p>参数过多时候，可以将参数组合成一个结构体传入，方便后续对参数的修改。</p><h3 id="避免函数参数控制函数内部逻辑"><a href="#避免函数参数控制函数内部逻辑" class="headerlink" title="避免函数参数控制函数内部逻辑"></a>避免函数参数控制函数内部逻辑</h3><p>可以考虑拆分成多个函数，保证函数职责单一。</p><h2 id="避免嵌套过深"><a href="#避免嵌套过深" class="headerlink" title="避免嵌套过深"></a>避免嵌套过深</h2><p><code>可以考虑使用</code>continue、break、return关键字，提前退出嵌套。</p><h2 id="分割代码和单一职责"><a href="#分割代码和单一职责" class="headerlink" title="分割代码和单一职责"></a>分割代码和单一职责</h2><p>如果函数或者类的代码过长，考虑拆分成多个函数或者类，保证职责单一。</p><h2 id="预计算和缓存"><a href="#预计算和缓存" class="headerlink" title="预计算和缓存"></a>预计算和缓存</h2><p>比如Component或者UI控件的获得等，可以在初始化的时候获取然后缓存引用，避免重复查询。</p><h2 id="避免频繁创建字符串"><a href="#避免频繁创建字符串" class="headerlink" title="避免频繁创建字符串"></a>避免频繁创建字符串</h2><p>由于C#中的string是独一无二的，无法修改，所以字符串操作会创建新的字符串，不像C++可以就地初始化或者重复利用对象，因此避免大量使用string的操作符构建字符串，改成使用StringBuilder。</p><h1 id="五、安全性编程"><a href="#五、安全性编程" class="headerlink" title="五、安全性编程"></a>五、安全性编程</h1><h2 id="5-1-安全性编程原则"><a href="#5-1-安全性编程原则" class="headerlink" title="5.1 安全性编程原则"></a>5.1 安全性编程原则</h2><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>C#中的对象都是引用，使用前需要判空，空引用会造成异常。这个是良好的编程习惯。可以用空值传播操作符等，简略代码。</p><h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>对传入的参数要进行安全性检查，比如空引用，索引范围等，非法情况提前返回，然后再进行正常的逻辑处理。</p><h3 id="尽可能使用错误处理而不是异常处理"><a href="#尽可能使用错误处理而不是异常处理" class="headerlink" title="尽可能使用错误处理而不是异常处理"></a>尽可能使用错误处理而不是异常处理</h3><p>异常有额外的性能消耗，加上异常会破坏调用链，应该尽可能用错误判断得方式处理各种可以预测的问题，而不是抛出异常。游戏引擎内一般不使用异常，比如UE4的源码内就禁用异常。</p><h2 id="5-2-示例代码"><a href="#5-2-示例代码" class="headerlink" title="5.2 示例代码"></a>5.2 示例代码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator <span class="title">SpawnObjectAsync</span>(<span class="params"><span class="keyword">string</span> assetPath, Vector3 position, Quaternion rotation, Vector3 scale, Transform parent = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">string</span> name = <span class="string">""</span>, Action&lt;GameObject&gt; onSpawnObjectDone = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(assetPath))</span><br><span class="line">    &#123;</span><br><span class="line">        GYLog.LogError(<span class="string">"GameObjectPool SpawnObjectAsync assetPath is IsNullOrEmpty"</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObjectPooledItemList pool = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAssetPathLookup.TryGetValue(assetPath, <span class="keyword">out</span> pool) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return <span class="title">WarmPoolAsync</span>(<span class="params">assetPath, <span class="number">1</span>, (tempPool</span>)</span> =&gt; pool = tempPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GYLog.LogError(<span class="string">"GameObjectPool SpawnObjectAsync Get GameObjectCollection return null"</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObject clone = pool.GetItem();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GYLog.LogError(<span class="string">"GameObjectPool SpawnObject Get GameObject from GameObjectCollection return null"</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clone.SetActiveEx(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clone.transform.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    clone.transform.position = position;</span><br><span class="line">    clone.transform.rotation = rotation;</span><br><span class="line">    clone.transform.localScale = scale;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="string">""</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clone.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInstanceLookup.Add(clone.GetInstanceID(), pool);</span><br><span class="line">    mIsDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    onSpawnObjectDone?.Invoke(clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如示例代码，首先做了输入参数检查，然后在执行过程中做了条件检查，检查失败直接主动报错，马上返回。</p><h1 id="六、改动权限"><a href="#六、改动权限" class="headerlink" title="六、改动权限"></a>六、改动权限</h1><p>项目中可以通过SVN或者Git的权限限制，避免过多人改动底层或者关键代码。下面举例说明，</p><h2 id="C-的Engine代码"><a href="#C-的Engine代码" class="headerlink" title="C#的Engine代码"></a>C#的Engine代码</h2><p>原则上，Engine代码不做改动，主程或者指定的人有权限改动，其它人需要改动需要事先跟主程沟通后才能改动。</p><h2 id="C-的Game代码"><a href="#C-的Game代码" class="headerlink" title="C#的Game代码"></a>C#的Game代码</h2><p>在游戏发布之前，Game代码允许改动；在游戏发布之后，改动Game层的C#代码需要热更新二进制包或者打补丁更新，有改动需求需要事先跟主程沟通。</p><h2 id="Lua的框架代码"><a href="#Lua的框架代码" class="headerlink" title="Lua的框架代码"></a>Lua的框架代码</h2><p>框架代码改动之前需要考虑清楚，客户端程序都有改动权限，改动大的部分最好同步主程或者执行主程等，并且负责跟踪和修复改动后引入的问题</p><h2 id="Lua的业务代码"><a href="#Lua的业务代码" class="headerlink" title="Lua的业务代码"></a>Lua的业务代码</h2><p>客户端程序一直有改动权限，需要遵守代码规范。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、命名法&quot;&gt;&lt;a href=&quot;#一、命名法&quot; class=&quot;headerlink&quot; title=&quot;一、命名法&quot;&gt;&lt;/a&gt;一、命名法&lt;/h1&gt;&lt;p&gt;Pascal命名法：每个单词首字母大写。&lt;br&gt;Camel命名法：第一个单词首字母小写，其余单词首字母大写。&lt;br&gt;C++标准库命名法：全小写，单词用下划线分割。&lt;/p&gt;
&lt;h2 id=&quot;1-1-C&quot;&gt;&lt;a href=&quot;#1-1-C&quot; class=&quot;headerlink&quot; title=&quot;1.1 C&quot;&gt;&lt;/a&gt;1.1 C&lt;/h2&gt;
    
    </summary>
    
    
      <category term="游戏开发" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="Unity" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    
      <category term="Unity" scheme="http://xiaopengcheng.top/tags/Unity/"/>
    
      <category term="代码规范" scheme="http://xiaopengcheng.top/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>C++类对象的内存布局</title>
    <link href="http://xiaopengcheng.top/2018/08/12/C++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://xiaopengcheng.top/2018/08/12/C++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2018-08-12T11:15:51.000Z</published>
    <updated>2022-01-07T11:05:13.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、内存对齐"><a href="#一、内存对齐" class="headerlink" title="一、内存对齐"></a>一、内存对齐</h1><p>C++的对象都会进行内存对齐，所谓内存对齐，指的是对象的地址和大小都会对齐到n的倍数上。比如按照4对齐，那么对象的地址会是4的倍数，对象的大小也是4的倍数。究其原因是，机器在内存对齐的地址上访问数据更快，可以一起取出数据；如果数据存在在不对齐的地址上，需要换成2次对齐地址上的取数据，再组合出原始数据；而且，部分机器根本没有取非对齐的数据。</p><h2 id="1-1-默认对齐"><a href="#1-1-默认对齐" class="headerlink" title="1.1 默认对齐"></a>1.1 默认对齐</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassWithMemoryPack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line"></span><br><span class="line">    short shortB;</span><br><span class="line"></span><br><span class="line">    float floatC;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(int):&quot; &lt;&lt; sizeof(int) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(short):&quot; &lt;&lt; sizeof(short) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(float):&quot; &lt;&lt; sizeof(float) &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; &quot;sizeof(OrdinaryClassWithMemoryPack):&quot; &lt;&lt; sizeof(OrdinaryClassWithMemoryPack) &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; &quot;address of omp:&quot; &lt;&lt; &amp;omp &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="vs2019-x86的结果"><a href="#vs2019-x86的结果" class="headerlink" title="vs2019 x86的结果"></a>vs2019 x86的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x86.png"></p><h3 id="vs2019-x64的结果"><a href="#vs2019-x64的结果" class="headerlink" title="vs2019 x64的结果"></a>vs2019 x64的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x64.png"></p><p>可以看到，默认都是按照4字节对齐，int和float都是4个字节，short是2个字节，不过强制按照4字节对齐了。对象的地址都是4的倍数，不过64位程序的地址是64位了。</p><h2 id="1-2-Pack-n"><a href="#1-2-Pack-n" class="headerlink" title="1.2 Pack(n)"></a>1.2 Pack(n)</h2><p>假如我们用pack指令强制按照2字节对齐，那么输出结果如何了？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(push)</span><br><span class="line">#pragma pack(2)</span><br><span class="line">class OrdinaryClassWithMemoryPack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line"></span><br><span class="line">    float floatB;</span><br><span class="line"></span><br><span class="line">    short shortC;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack(pop)</span><br></pre></td></tr></table></figure></p><h3 id="vs2019-x86的结果-1"><a href="#vs2019-x86的结果-1" class="headerlink" title="vs2019 x86的结果"></a>vs2019 x86的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x86Pack2.png"></p><h3 id="vs2019-x64的结果-1"><a href="#vs2019-x64的结果-1" class="headerlink" title="vs2019 x64的结果"></a>vs2019 x64的结果</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++对象默认内存对齐x64Pack2.png"></p><p>从输出结果可以看出，对象还是位于4对齐的地址上，只是对象本身的大小变成10了。short只占2个字节，那么接下来的float并没有强制在4字节的地址对齐，而是根据pack指令对齐在2字节的地址上了。</p><h2 id="1-3-实验环境"><a href="#1-3-实验环境" class="headerlink" title="1.3 实验环境"></a>1.3 实验环境</h2><p>未避免文章过于啰嗦，接下来的例子只说明vs2019 x86的输出结果。</p><h1 id="二、普通类的对象"><a href="#二、普通类的对象" class="headerlink" title="二、普通类的对象"></a>二、普通类的对象</h1><h2 id="2-1-基类的对象"><a href="#2-1-基类的对象" class="headerlink" title="2.1 基类的对象"></a>2.1 基类的对象</h2><p>接下来的讨论为避免内存对齐的干扰，忽略内存对齐。因此，类的成员变量只有一个int。定义基类如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-单继承子类的对象"><a href="#2-2-单继承子类的对象" class="headerlink" title="2.2 单继承子类的对象"></a>2.2 单继承子类的对象</h2><p>定义子类如下，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassAFirstSon : public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intAFirstSon;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="2-3-多继承子类的对象"><a href="#2-3-多继承子类的对象" class="headerlink" title="2.3 多继承子类的对象"></a>2.3 多继承子类的对象</h2><p>定义多继承的子类如下,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassASecondSon : public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intASecondSon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OrdinaryMultipleInheritClassE : public OrdinaryClassAFirstSon, public OrdinaryClassASecondSon</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intE;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassA):&quot; &lt;&lt; sizeof(OrdinaryClassA) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassAFirstSon):&quot; &lt;&lt; sizeof(OrdinaryClassAFirstSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryMultipleInheritClassE):&quot; &lt;&lt; sizeof(OrdinaryMultipleInheritClassE) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++普通对象多继承x86.png"><br>根据输出结果，可以看出：基类是4个字节；子类拥有基类的对象，加上自己的成员，一起是8个字节；多重继承的子类，拥有2个基类对象，加上自己的成员，总共是8+8+4=20个字节。<br>OrdinaryMultipleInheritClassE的两个基类都继承同一个类OrdinaryClassA，因此E的对象中会有2份A的实例。一般的编程范式中，都要求避免多继承，改用多接口继承。C++在针对这种情况，也有一种虚拟继承的方式来避免数据冗余。</p><h1 id="三、带虚函数的类对象"><a href="#三、带虚函数的类对象" class="headerlink" title="三、带虚函数的类对象"></a>三、带虚函数的类对象</h1><h2 id="3-1-带虚函数的基类的对象"><a href="#3-1-带虚函数的基类的对象" class="headerlink" title="3.1 带虚函数的基类的对象"></a>3.1 带虚函数的基类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intA;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-1-带虚函数的单继承子类的对象"><a href="#3-1-带虚函数的单继承子类的对象" class="headerlink" title="3.1 带虚函数的单继承子类的对象"></a>3.1 带虚函数的单继承子类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassAFirstSon : public VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intAFirstSon;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunAFirstSon()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VirtualFunClassA va;</span><br><span class="line">VirtualFunClassAFirstSon vason;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassA):&quot; &lt;&lt; sizeof(VirtualFunClassA) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassAFirstSon):&quot; &lt;&lt; sizeof(VirtualFunClassAFirstSon) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>用vs2019调试，自动窗口中显示的va和vason的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数类对象内存布局x86.png"><br>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数类对象大小x86.png"><br>可以看到，类对象内多了一个vfptr（虚函数指针），其中子类的虚函数指针是放在父对象内的。</p><h2 id="3-2-带虚函数的多继承子类的对象"><a href="#3-2-带虚函数的多继承子类的对象" class="headerlink" title="3.2 带虚函数的多继承子类的对象"></a>3.2 带虚函数的多继承子类的对象</h2><p>现在来考虑多继承的情况，假如多个基类都有虚函数，那么内存布局如何了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intB;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunB()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VirtualFunMultipleInheritClassC : public VirtualFunClassA, public VirtualFunClassB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intC;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunB() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunC()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VirtualFunMultipleInheritClassC vmc;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassA):&quot; &lt;&lt; sizeof(VirtualFunClassA) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassB):&quot; &lt;&lt; sizeof(VirtualFunClassB) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunMultipleInheritClassC):&quot; &lt;&lt; sizeof(VirtualFunMultipleInheritClassC) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>用vs2019调试，自动窗口中显示的vmc的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数多继承类对象内存布局x86.png"><br>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚函数多继承类对象内存大小x86.png"><br>可以得出结论：vmc中有2个基类的对象，大小分别是8，自身有一个大小为4的int，因此总共是20的大小；多继承的对象内会有多个虚函数指针，一个指针对应一个带虚函数的基类；子类如果也带非继承而来的虚函数，那么这个虚函数也会放在某个基类的虚函数表内。<br>因此，多重继承的子类对象，会有多个虚函数指针，对应多个虚函数表，自身虚函数会被合并到某个基类的虚函数表中，不会再多一个虚函数指针和虚函数表。对于多重继承子类的多个虚函数表，可能是分开存储，也可能是连续存储为一个表，只是虚函数指针有一定的偏移。</p><h1 id="四、虚拟继承的类对象"><a href="#四、虚拟继承的类对象" class="headerlink" title="四、虚拟继承的类对象"></a>四、虚拟继承的类对象</h1><p>下面来讨厌最变态的部分，虚拟继承的对象。</p><h2 id="4-1-虚多继承子类的对象"><a href="#4-1-虚多继承子类的对象" class="headerlink" title="4.1 虚多继承子类的对象"></a>4.1 虚多继承子类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class OrdinaryClassAVirtualFirstSon : virtual public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intAFirstSon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OrdinaryClassAVirtualSecondSon : virtual public OrdinaryClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intASecondSon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class OrdinayVirtualMultipleInheritClassF : public OrdinaryClassAVirtualFirstSon, public OrdinaryClassAVirtualSecondSon</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intF;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OrdinaryClassAVirtualFirstSon oavson;</span><br><span class="line">OrdinayVirtualMultipleInheritClassF ovmf;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassAVirtualFirstSon):&quot; &lt;&lt; sizeof(OrdinaryClassAVirtualFirstSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinaryClassAVirtualSecondSon):&quot; &lt;&lt; sizeof(OrdinaryClassAVirtualSecondSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(OrdinayVirtualMultipleInheritClassF):&quot; &lt;&lt; sizeof(OrdinayVirtualMultipleInheritClassF) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>用vs2019调试，自动窗口中显示的ovmf的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚多继承类对象内存布局x86.png"></p><p>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/C++虚多继承类对象内存大小x86.png"></p><p>可以看到2个基类的大小都是12，子类的大小是24。如果是普通继承的话，基类的大小是8，子类的大小是20，这个可以参考2.3。那么，虚继承的对象内肯定多了什么？具体是什么了。</p><h3 id="启用类内存布局分析"><a href="#启用类内存布局分析" class="headerlink" title="启用类内存布局分析"></a>启用类内存布局分析</h3><p>由于自动窗口无法显示虚拟继承的内存布局了，那么我们只能用其它方式来查看。<br>如下图，我们通过Project的属性窗口，找到C/C++ -&gt;命令行，添加新的选项 /d1 reportAllClassLayout。<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/reportAllClassLayout.png"></p><h3 id="虚继承的基类内存布局"><a href="#虚继承的基类内存布局" class="headerlink" title="虚继承的基类内存布局"></a>虚继承的基类内存布局</h3><p>然后清理工程重新生成，在输出窗口会输出所有类的局部情况，然后搜索OrdinaryClassAVirtualFirstSon，如下图所示，<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/虚继承的基类内存布局.png"><br>可以看到，对象内有三个成员，按照顺序分别是vbptr（虚表指针）、数据成员intAFirstSon、基类的数据成员intA。相比普通的继承，多了虚表指针。大小总和是4+4+4=12。</p><h3 id="虚继承的多重继承子类内存布局"><a href="#虚继承的多重继承子类内存布局" class="headerlink" title="虚继承的多重继承子类内存布局"></a>虚继承的多重继承子类内存布局</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/虚多重继承内存布局.png"><br>可以看到，对象的成员按照顺序分别是基类1对象、基类2对象、数据成员intF、虚继承的基类数据成员intA。<br>大小总和是8+8+4+4=24。基类1和基类2里面都是带1个虚表指针和1个数据成员。<br>相比普通的继承，多了2个虚表指针，但是减少了重复基类数据，总的大小变化是20+8-4=24。如果，重复的基类OrdinaryClassA有更多的数据成员，那么虚拟继承这种机制就更划算了。</p><h2 id="4-2-带虚函数的虚多继承子类的对象"><a href="#4-2-带虚函数的虚多继承子类的对象" class="headerlink" title="4.2 带虚函数的虚多继承子类的对象"></a>4.2 带虚函数的虚多继承子类的对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class VirtualFunClassASecondSon : virtual public VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intASecondSon;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunASecondSon()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VirtualFunClassAThirdSon : virtual public VirtualFunClassA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int AThirdSon;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunAThirdSon()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class VirtualFunVirtualInheritClassG : public VirtualFunClassASecondSon, public VirtualFunClassAThirdSon</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int intG;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    virtual int VirtualFunA() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunASecondSon() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunAThirdSon() override</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual int VirtualFunE()</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassASecondSon):&quot; &lt;&lt; sizeof(VirtualFunClassASecondSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunClassAThirdSon):&quot; &lt;&lt; sizeof(VirtualFunClassAThirdSon) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &quot;sizeof(VirtualFunVirtualInheritClassG):&quot; &lt;&lt; sizeof(VirtualFunVirtualInheritClassG) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚多继承对象大小.png"><br>发现基类的大小变成了20，多了8个字节。子类的从24变成了36，多了12个字节。猜测是多了虚函数指针。</p><h3 id="带虚函数的虚继承的基类内存布局"><a href="#带虚函数的虚继承的基类内存布局" class="headerlink" title="带虚函数的虚继承的基类内存布局"></a>带虚函数的虚继承的基类内存布局</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚继承的基类内存布局.png"><br>可以看到，内存布局是虚函数指针、虚表指针、数据成员、基类对象（基类的虚函数指针、基类数据成员）。相比不带虚函数的虚拟继承，是多了2个虚函数指针。相比，普通的继承，是多了1个虚表指针和1个虚函数指针。所以，最奇怪的地方是没有像普通继承那样将2个虚函数指针合并成一个。</p><p>如果注释掉当前类的虚函数VirtualFunASecondSon，得到的内存布局如下：<br><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚继承的基类内存布局1.png"><br>区别是少了当前类的虚函数指针，基类对象内的虚函数指针保留。</p><h3 id="带虚函数的虚继承的多重继承子类内存布局"><a href="#带虚函数的虚继承的多重继承子类内存布局" class="headerlink" title="带虚函数的虚继承的多重继承子类内存布局"></a>带虚函数的虚继承的多重继承子类内存布局</h3><p><img alt data-src="https://gitee.com/xiao_peng_cheng/markdown_img/raw/master/小书匠/带虚函数的虚继承的多重继承子类内存布局.png"></p><p>这应该是已知的最复杂的类对象布局情况了。按照顺序是基类1、基类2、数据成员、虚拟基类。基类1和基类2内部都是虚函数指针、虚表指针、数据成员，大小都是12，那么总共是24。数据成员大小是4。虚拟基类的内部是虚函数指针、数据成员，大小是8。因此，总共的大小是12+12+4+8=36。<br>相比不带虚函数的虚拟继承，多了3个虚函数指针，总计12个字节。相比普通的继承，多了2个虚表指针和1个虚函数指针，但是减少了虚拟基类数据的重复，那么总大小是28+12-4=36。</p><h3 id="虚拟继承的最终结论"><a href="#虚拟继承的最终结论" class="headerlink" title="虚拟继承的最终结论"></a>虚拟继承的最终结论</h3><p>1、虚拟继承的对象内会多一个虚表指针。<br>2、带虚函数的虚继承，子类和基类的虚函数表不会合并，因此会多一个虚函数指针。<br>3、多重继承的基类，如果虚继承了共同的基类，那么其共同基类对象只会存在一份，包括数据成员和虚函数指针。</p><h3 id="疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？"><a href="#疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？" class="headerlink" title="疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？"></a>疑问：带虚函数的虚继承为何不合并子类和基类的虚函数指针？</h3><p>猜测可能跟vs2019对应的vc++编译器实现有关。</p><h2 id="4-3-虚表指针的用途"><a href="#4-3-虚表指针的用途" class="headerlink" title="4.3 虚表指针的用途"></a>4.3 虚表指针的用途</h2><p>我们知道，虚函数指针指向的是虚函数表，虚函数表内存储的是虚函数的地址。对于采用指针或者引用来动态调用虚函数的情况，会在运行时才能确定真正的虚函数地址，这个就叫做延迟绑定。为了灵活性，失去了部分性能。<br>那么，虚表指针是用来做什么的？可以肯定的是用于找到共同的基类对象的。猜测虚表指针指向一张table，该table内部存储共同的基类数据在类对象内的偏移。</p><h2 id="4-4-虚拟继承实现的编译器差异"><a href="#4-4-虚拟继承实现的编译器差异" class="headerlink" title="4.4 虚拟继承实现的编译器差异"></a>4.4 虚拟继承实现的编译器差异</h2><p>根据深入探索C++对象模型的说明，虚拟继承在不同的编译器下有不同的实现，而且C++标准并未规定如何实现。因此，g++的内存布局跟vc++的内存布局可能会有显著差别。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、内存对齐&quot;&gt;&lt;a href=&quot;#一、内存对齐&quot; class=&quot;headerlink&quot; title=&quot;一、内存对齐&quot;&gt;&lt;/a&gt;一、内存对齐&lt;/h1&gt;&lt;p&gt;C++的对象都会进行内存对齐，所谓内存对齐，指的是对象的地址和大小都会对齐到n的倍数上。比如按照4对齐，那么对象的地址会是4的倍数，对象的大小也是4的倍数。究其原因是，机器在内存对齐的地址上访问数据更快，可以一起取出数据；如果数据存在在不对齐的地址上，需要换成2次对齐地址上的取数据，再组合出原始数据；而且，部分机器根本没有取非对齐的数据。&lt;/p&gt;
&lt;h2 id=&quot;1-1-默认对齐&quot;&gt;&lt;a href=&quot;#1-1-默认对齐&quot; class=&quot;headerlink&quot; title=&quot;1.1 默认对齐&quot;&gt;&lt;/a&gt;1.1 默认对齐&lt;/h2&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://xiaopengcheng.top/categories/C/"/>
    
    
      <category term="C++" scheme="http://xiaopengcheng.top/tags/C/"/>
    
      <category term="内存布局" scheme="http://xiaopengcheng.top/tags/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>NGUI概述</title>
    <link href="http://xiaopengcheng.top/2017/01/12/NGUI%E6%A6%82%E8%BF%B0/"/>
    <id>http://xiaopengcheng.top/2017/01/12/NGUI%E6%A6%82%E8%BF%B0/</id>
    <published>2017-01-12T09:15:51.000Z</published>
    <updated>2021-12-26T08:52:46.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NGUI介绍"><a href="#NGUI介绍" class="headerlink" title="NGUI介绍"></a>NGUI介绍</h2><p>NGUI是Unity中最流行的UI插件，在UGUI出现前几乎是Unity唯一的UI解决方案。<br>NGUI是一个提供高效事件通知框架的强大UI系统。NGUI遵循<a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">Kiss准则</a>，其中类代码简洁，多数在200行以内。程序员可以方便的扩展其组件类代码以获得定制的功能。<br><a href="http://www.tasharen.com/?page_id=140" target="_blank" rel="noopener">NGUI官方网址</a><br><a href="http://www.tasharen.com/forum/index.php?board=12.0" target="_blank" rel="noopener">NGUI官方文档地址</a></p><h2 id="NGUI下载"><a href="#NGUI下载" class="headerlink" title="NGUI下载"></a>NGUI下载</h2><p>我们可以从unity商店购买NGUI，或者下载其免费版本。<br><a href="https://www.assetstore.Unity.com/cn/#!/content/2413" target="_blank" rel="noopener">NGUI的Unity商店</a><br>当然也可以下载网上其它人提供的版本学习研究。<br><a href="http://www.ceeger.com/forum/read.php?tid=20718fid=16" target="_blank" rel="noopener">NGUI 3.10.2</a></p><h2 id="NGUI导入"><a href="#NGUI导入" class="headerlink" title="NGUI导入"></a>NGUI导入</h2><p>下载NGUI后，我们得到的是一个.unitypackage文件，比如NGUI Next-Gen UI v3.6.8.unitypackage。<br>Unity编辑器中，打开菜单Assets-&gt;ImportPackage-&gt;CustomPackage，然后选择下载的.unitypackage文件导入编辑器。导入NGUI后，在工程的Assets目录下会出现一个NGUI文件夹，并且Unity编辑器中会多了一个NGUI主菜单。</p><h2 id="NGUI例子"><a href="#NGUI例子" class="headerlink" title="NGUI例子"></a>NGUI例子</h2><p>打开NGUI-&gt;Options-&gt;Reset Prefab ToolBar，会出现如下工具条：</p><p><img alt="NGUI例子" data-src="https://c1.staticflickr.com/1/782/31420422424_657c6cee61_o.png"><br>这里面有基本的NGUI控件例子，是我们学习参照的好材料。</p><h2 id="NGUI类图"><a href="#NGUI类图" class="headerlink" title="NGUI类图"></a>NGUI类图</h2><p>下面是我整理的NGUI类图：<br><img alt="NGUI类图" data-src="https://c1.staticflickr.com/1/363/32223724406_7e07b90f4b_o.png"></p><p>该类图中列出了NGUI中绝大部分的类。<br>类图中有两个最重要的分支，UIWidgetContainer分支和UIWidget分支。<br>NGUI中的大部分控件都继承自UIWidgetContainer，这说明在NGUI中，其实是把控件当作Sprite的容器而已。UIWidget的子类就是Sprite和Texture，表示NGUI中的控件都是图片化的，控件的表现都依赖图片。</p><h2 id="NGUI常用组件"><a href="#NGUI常用组件" class="headerlink" title="NGUI常用组件"></a>NGUI常用组件</h2><h3 id="UILabel-文本"><a href="#UILabel-文本" class="headerlink" title="UILabel 文本"></a>UILabel 文本</h3><h3 id="UIInput-输入框"><a href="#UIInput-输入框" class="headerlink" title="UIInput 输入框"></a>UIInput 输入框</h3><h3 id="UITextList-多文本显示框，类似聊天窗"><a href="#UITextList-多文本显示框，类似聊天窗" class="headerlink" title="UITextList 多文本显示框，类似聊天窗"></a>UITextList 多文本显示框，类似聊天窗</h3><h3 id="UISprite-图片精灵"><a href="#UISprite-图片精灵" class="headerlink" title="UISprite 图片精灵"></a>UISprite 图片精灵</h3><h3 id="UIBotton-按钮"><a href="#UIBotton-按钮" class="headerlink" title="UIBotton 按钮"></a>UIBotton 按钮</h3><h3 id="UIToggle-单选框-复选框"><a href="#UIToggle-单选框-复选框" class="headerlink" title="UIToggle 单选框/复选框"></a>UIToggle 单选框/复选框</h3><h3 id="UIScrollBar-滚动条"><a href="#UIScrollBar-滚动条" class="headerlink" title="UIScrollBar 滚动条"></a>UIScrollBar 滚动条</h3><h3 id="UISlider-滑动条-进度条"><a href="#UISlider-滑动条-进度条" class="headerlink" title="UISlider 滑动条/进度条"></a>UISlider 滑动条/进度条</h3><h3 id="UIProgressBar-进度条"><a href="#UIProgressBar-进度条" class="headerlink" title="UIProgressBar 进度条"></a>UIProgressBar 进度条</h3><h3 id="UIPopupList-下拉框"><a href="#UIPopupList-下拉框" class="headerlink" title="UIPopupList 下拉框"></a>UIPopupList 下拉框</h3><h3 id="UIGrid-将子控件按照单元格布局"><a href="#UIGrid-将子控件按照单元格布局" class="headerlink" title="UIGrid 将子控件按照单元格布局"></a>UIGrid 将子控件按照单元格布局</h3><h3 id="UITable-UIGrid加强版，类似Html的table"><a href="#UITable-UIGrid加强版，类似Html的table" class="headerlink" title="UITable UIGrid加强版，类似Html的table"></a>UITable UIGrid加强版，类似Html的table</h3><h3 id="UIPanel-控件渲染器，管理和绘制其下所有的组件"><a href="#UIPanel-控件渲染器，管理和绘制其下所有的组件" class="headerlink" title="UIPanel 控件渲染器，管理和绘制其下所有的组件"></a>UIPanel 控件渲染器，管理和绘制其下所有的组件</h3><h3 id="UIScrollView-滚动视窗"><a href="#UIScrollView-滚动视窗" class="headerlink" title="UIScrollView 滚动视窗"></a>UIScrollView 滚动视窗</h3><h3 id="UIKeyBinding-给控件的点击或者选中事情绑定按键"><a href="#UIKeyBinding-给控件的点击或者选中事情绑定按键" class="headerlink" title="UIKeyBinding 给控件的点击或者选中事情绑定按键"></a>UIKeyBinding 给控件的点击或者选中事情绑定按键</h3><h3 id="UIRoot-NGUI的UI根物体"><a href="#UIRoot-NGUI的UI根物体" class="headerlink" title="UIRoot NGUI的UI根物体"></a>UIRoot NGUI的UI根物体</h3><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="http://www.tasharen.com/forum/index.php?topic=6754" target="_blank" rel="noopener">NGUI官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NGUI介绍&quot;&gt;&lt;a href=&quot;#NGUI介绍&quot; class=&quot;headerlink&quot; title=&quot;NGUI介绍&quot;&gt;&lt;/a&gt;NGUI介绍&lt;/h2&gt;&lt;p&gt;NGUI是Unity中最流行的UI插件，在UGUI出现前几乎是Unity唯一的UI解决方案。&lt;br&gt;NGUI是一个提供高效事件通知框架的强大UI系统。NGUI遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/KISS_principle&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kiss准则&lt;/a&gt;，其中类代码简洁，多数在200行以内。程序员可以方便的扩展其组件类代码以获得定制的功能。&lt;br&gt;&lt;a href=&quot;http://www.tasharen.com/?page_id=140&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NGUI官方网址&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.tasharen.com/forum/index.php?board=12.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NGUI官方文档地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;NGUI下载&quot;&gt;&lt;a href=&quot;#NGUI下载&quot; class=&quot;headerlink&quot; title=&quot;NGUI下载&quot;&gt;&lt;/a&gt;NGUI下载&lt;/h2&gt;
    
    </summary>
    
    
      <category term="游戏开发" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="Unity" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/Unity/"/>
    
    
      <category term="NGUI" scheme="http://xiaopengcheng.top/tags/NGUI/"/>
    
      <category term="Unity" scheme="http://xiaopengcheng.top/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>WebGL编程模型</title>
    <link href="http://xiaopengcheng.top/2016/12/25/WebGL%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://xiaopengcheng.top/2016/12/25/WebGL%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2016-12-25T10:16:11.000Z</published>
    <updated>2019-12-19T18:08:58.709Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍编写一个原生的WebGL程序需要哪些步骤。</p><h2 id="WebGL程序的软件结构"><a href="#WebGL程序的软件结构" class="headerlink" title="WebGL程序的软件结构"></a>WebGL程序的软件结构</h2><p>默认情况下，一个动态网页程序只包括HTML和JavaScript两种语言。<br>而在WebGL程序中，还包括了第三种语言：GLSL ES。</p><p><img alt="enter description here" data-src="https://c1.staticflickr.com/1/417/31743655591_e5815e1579_o.png"></p><h2 id="WebGL编程模型"><a href="#WebGL编程模型" class="headerlink" title="WebGL编程模型"></a>WebGL编程模型</h2><p><img alt="enter description here" data-src="https://c1.staticflickr.com/1/502/31050538443_ca9377f3a2_o.png"><br>上图表示一个WebGL程序运行的主要流程。主要分为3个阶段，应用程序阶段、着色器阶段、片元后处理阶段。<br>本文接下来按照一定的规律介绍编写一个原生WebGL程序主要的步骤。</p><h3 id="获得WebGL渲染环境"><a href="#获得WebGL渲染环境" class="headerlink" title="获得WebGL渲染环境"></a>获得WebGL渲染环境</h3><h4 id="在Html中定义canvas标签"><a href="#在Html中定义canvas标签" class="headerlink" title="在Html中定义canvas标签"></a>在Html中定义canvas标签</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">canvas</span> id=<span class="string">"webgl"</span> <span class="attribute">width</span>=<span class="string">"400"</span> height=<span class="string">"400"</span>&gt; &lt;/canvas&gt;</span><br></pre></td></tr></table></figure><h4 id="在JS代码中获得canvas对象"><a href="#在JS代码中获得canvas对象" class="headerlink" title="在JS代码中获得canvas对象"></a>在JS代码中获得canvas对象</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById('webgl');</span><br></pre></td></tr></table></figure><h4 id="通过canvas对象获得WebGL渲染环境"><a href="#通过canvas对象获得WebGL渲染环境" class="headerlink" title="通过canvas对象获得WebGL渲染环境"></a>通过canvas对象获得WebGL渲染环境</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var gl = getWebGLContext(canvas);</span><br></pre></td></tr></table></figure><h3 id="编写着色器"><a href="#编写着色器" class="headerlink" title="编写着色器"></a>编写着色器</h3><h4 id="编写顶点着色器"><a href="#编写顶点着色器" class="headerlink" title="编写顶点着色器"></a>编写顶点着色器</h4><p>顶点着色器是用来描述顶点属性（比如位置、颜色、纹理坐标等的程序）<br><img alt="enter description here" data-src="https://c1.staticflickr.com/1/441/31822594876_583f762171_o.png"></p><h4 id="编写片元着色器"><a href="#编写片元着色器" class="headerlink" title="编写片元着色器"></a>编写片元着色器</h4><p>片元着色器处理光栅后的数据，可以片元将其理解为像素。<br>片元着色器的输出构成了最终的像素值（开启多重采样的话只构成了某个像素的一部分值）<br><img alt="enter description here" data-src="https://c1.staticflickr.com/1/771/31822601086_e8b7848d25_o.png"></p><h3 id="初始化着色器"><a href="#初始化着色器" class="headerlink" title="初始化着色器"></a>初始化着色器</h3><p>初始化着色器基本上是一个固定的流程，主要分为以下几个步骤。</p><h4 id="创建shader"><a href="#创建shader" class="headerlink" title="创建shader"></a>创建shader</h4><h4 id="加载shader源码"><a href="#加载shader源码" class="headerlink" title="加载shader源码"></a>加载shader源码</h4><h4 id="编译shader"><a href="#编译shader" class="headerlink" title="编译shader"></a>编译shader</h4><h4 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h4><h4 id="附加编译好的shader"><a href="#附加编译好的shader" class="headerlink" title="附加编译好的shader"></a>附加编译好的shader</h4><h4 id="链接程序"><a href="#链接程序" class="headerlink" title="链接程序"></a>链接程序</h4><h4 id="使用程序"><a href="#使用程序" class="headerlink" title="使用程序"></a>使用程序</h4><h3 id="获得顶点属性"><a href="#获得顶点属性" class="headerlink" title="获得顶点属性"></a>获得顶点属性</h3><p>顶点上有各种属性，比如空间坐标、纹理坐标、材质等，一个顶点就是一个属性集合。<br>如下图所示的立方体，顶点上有2个属性，坐标和颜色。<br><img alt="enter description here" data-src="https://c1.staticflickr.com/1/280/31487505630_7c7a69ed2f_o.png"><br>顶点属性可以通过读取模型文件，比如obj文件等获得，或者简单写在代码定义中，比如上图的立方体。</p><h3 id="创建顶点缓冲区"><a href="#创建顶点缓冲区" class="headerlink" title="创建顶点缓冲区"></a>创建顶点缓冲区</h3><p>缓冲区存在于显存中，能够被显卡直接用来进行渲染，不需要进行数据传输。<br>在WebGL中，通过以下调用获得一个缓冲区对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var vertexColorBuffer = gl.createBuffer();</span><br></pre></td></tr></table></figure><h3 id="写入顶点数据到顶点缓冲区对象"><a href="#写入顶点数据到顶点缓冲区对象" class="headerlink" title="写入顶点数据到顶点缓冲区对象"></a>写入顶点数据到顶点缓冲区对象</h3><p>这个步骤分为两个操作。</p><h4 id="首先，绑定创建的缓冲区"><a href="#首先，绑定创建的缓冲区" class="headerlink" title="首先，绑定创建的缓冲区"></a>首先，绑定创建的缓冲区</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);</span><br></pre></td></tr></table></figure><h4 id="然后，传输系统内存中上的顶点数据到缓冲区（显存中）"><a href="#然后，传输系统内存中上的顶点数据到缓冲区（显存中）" class="headerlink" title="然后，传输系统内存中上的顶点数据到缓冲区（显存中）"></a>然后，传输系统内存中上的顶点数据到缓冲区（显存中）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure><h4 id="传输数据的标志"><a href="#传输数据的标志" class="headerlink" title="传输数据的标志"></a>传输数据的标志</h4><p>gl.bufferData的第三个参数表示数据的使用标志，表示三种不同的应用场景。<br>1. gl.STATIC_DRAW ：表示数据不会经常改变，通常用于静态物体，比如地形、墙体等。<br>2. gl.STREAM_DRAW：表示数据使用一次后就会被丢弃。<br>3. gl.DYNAMIC_DRAW：表示数据会被多次修改，也会被使用多次。</p><p>系统会根据usage标示符为缓冲区对象分配最佳的存储位置。<br>STATIC_DRAW和STREAM_DRAW分配在显存上，DYNAMIC_DRAW可能分配在AGP中。</p><h3 id="将顶点数据传输到顶点着色器"><a href="#将顶点数据传输到顶点着色器" class="headerlink" title="将顶点数据传输到顶点着色器"></a>将顶点数据传输到顶点着色器</h3><p>目前，我们已经准会了WebGL渲染环境，并且数据已经从系统内存传输到显存中的缓冲区对象中。现在，我们要将缓存区对象中的数据指定给顶点着色器中对应的变量。<br>顶点着色器中的attribute变量对象顶点的属性。我们的顶点着色器中定义了2个变量，a_Position，a_Color。下面我们分为三步为这其指定数据。</p><ol><li>获得着色器中attribute变量位置<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a_Position = gl.getAttribLocation(gl.program, 'a_Position');</span><br></pre></td></tr></table></figure></li><li><p>根据变量位置传入缓冲区中的顶点属性数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.vertexAttribPointer(a_Position, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>启用该attribute变量的属性数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.enableVertexAttribArray(a_Position);</span><br></pre></td></tr></table></figure></li></ol><p>对于a_Color，我们在系统内存中定义在坐标的后面，因此在第2步中需要进行<strong>偏移</strong>，gl.vertexAttribPointer的最后一个参数可以指定数据的偏移位置，因此第2步修改为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.vertexAttribPointer(a_Position, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, FSIZE * <span class="number">3</span>);</span><br></pre></td></tr></table></figure><br>FSIZE表示float的大小。</p><h3 id="传入uniform变量到着色器"><a href="#传入uniform变量到着色器" class="headerlink" title="传入uniform变量到着色器"></a>传入uniform变量到着色器</h3><p>着色器中还存在一种uniform变量，这种变量对于所有顶点来说都是一样的。<br>比如，mvp矩阵就应该定义为uniform变量。一般情况，我们在js代码中计算好mvp矩阵，然后传输到着色器中的uniform变量中。主要步骤如下：<br>1. 获取uniform变量的在着色中的位置<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');</span><br></pre></td></tr></table></figure></p><ol><li>计算uniform变量（比如mvp矩阵）的值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var mvpMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">mvpMatrix.setPerspective(<span class="number">30</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">mvpMatrix.lookAt(<span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol><li>传入uniform变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.uniformMatrix4fv(u_MvpMatrix, <span class="literal">false</span>, mvpMatrix.elements);</span><br></pre></td></tr></table></figure><p>目前，顶点着色器已经有了每个顶点的属性，以及用uniform变量表示的mvp矩阵，因此可以变换顶点属性后传入片元着色器中进一步处理。</p><h3 id="定义面片索引"><a href="#定义面片索引" class="headerlink" title="定义面片索引"></a>定义面片索引</h3><p>上面我们处理的数据都是顶点属性，但是我们实际要绘制的图元是面片，比如三角面片。<br>通常情况下，我们会用三个顶点索引表示一个三角面片。<br>如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Indices of the vertices</span></span><br><span class="line">var indices = <span class="keyword">new</span> Uint8Array([</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="comment">// front</span></span><br><span class="line"><span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="comment">// right</span></span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="comment">// up</span></span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="comment">// left</span></span><br><span class="line"><span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="comment">// down</span></span><br><span class="line"><span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span> <span class="comment">// back</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>indices表示一个立方体的面片索引。</p><h3 id="创建索引缓冲区，写入索引"><a href="#创建索引缓冲区，写入索引" class="headerlink" title="创建索引缓冲区，写入索引"></a>创建索引缓冲区，写入索引</h3><p>接下来，我们要创建索引缓冲区，并将内存中的索引数据传入缓存区。<br>1. 创建索引缓冲区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var indexBuffer = gl.createBuffer();</span><br></pre></td></tr></table></figure><ol><li>绑定索引缓冲区</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);</span><br></pre></td></tr></table></figure><ol><li>将面片索引写入缓冲区对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="根据索引绘制图元"><a href="#根据索引绘制图元" class="headerlink" title="根据索引绘制图元"></a>根据索引绘制图元</h3><p>最后一步只需要根据面片索引绘制图元即可。<br>根据面片的顶点索引绘制图元节省内存，不需要存储重复的顶点数据。<br>我们只需要调用gl.drawElements即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其中，第二个参数n表示要绘制的图元（三角形面片）个数。最后一个参数0表示使用已经绑定好的索引缓冲区对象。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>下面给出绘制一个彩色立方体的完整代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex shader program</span></span><br><span class="line">var VSHADER_SOURCE =</span><br><span class="line">'attribute vec4 a_Position;\n' +</span><br><span class="line">'attribute vec4 a_Color;\n' +</span><br><span class="line">'uniform mat4 u_MvpMatrix;\n' +</span><br><span class="line">'varying vec4 v_Color;\n' +</span><br><span class="line">'void main() &#123;\n' +</span><br><span class="line">' gl_Position = u_MvpMatrix * a_Position;\n' +</span><br><span class="line">' v_Color = a_Color;\n' +</span><br><span class="line">'&#125;\n';</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fragment shader program</span></span><br><span class="line">var FSHADER_SOURCE =</span><br><span class="line">'#ifdef GL_ES\n' +</span><br><span class="line">'precision mediump float;\n' +</span><br><span class="line">'#endif\n' +</span><br><span class="line">'varying vec4 v_Color;\n' +</span><br><span class="line">'void main() &#123;\n' +</span><br><span class="line">' gl_FragColor = v_Color;\n' +</span><br><span class="line">'&#125;\n';</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Retrieve &lt;canvas&gt; element</span></span><br><span class="line">var canvas = document.getElementById('webgl');</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the rendering context for WebGL</span></span><br><span class="line">var gl = getWebGLContext(canvas);</span><br><span class="line"><span class="keyword">if</span> (!gl) &#123;</span><br><span class="line">console.log('Failed to get the rendering context for WebGL');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize shaders</span></span><br><span class="line"><span class="keyword">if</span> (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) &#123;</span><br><span class="line">console.log('Failed to intialize shaders.');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the vertex coordinates and color</span></span><br><span class="line">var n = initVertexBuffers(gl);</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">console.log('Failed to set the vertex information');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set clear color and enable hidden surface removal</span></span><br><span class="line">gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">gl.enable(gl.DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the storage location of u_MvpMatrix</span></span><br><span class="line">var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');</span><br><span class="line"><span class="keyword">if</span> (!u_MvpMatrix) &#123;</span><br><span class="line">console.log('Failed to get the storage location of u_MvpMatrix');</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the eye point and the viewing volume</span></span><br><span class="line">var mvpMatrix = <span class="keyword">new</span> Matrix4();</span><br><span class="line">mvpMatrix.setPerspective(<span class="number">30</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">mvpMatrix.lookAt(<span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass the model view projection matrix to u_MvpMatrix</span></span><br><span class="line">gl.uniformMatrix4fv(u_MvpMatrix, <span class="literal">false</span>, mvpMatrix.elements);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear color and depth buffer</span></span><br><span class="line">gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Draw the cube</span></span><br><span class="line">gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">initVertexBuffers</span><span class="params">(gl)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create a cube</span></span><br><span class="line"><span class="comment">// v6----- v5</span></span><br><span class="line"><span class="comment">// /| /|</span></span><br><span class="line"><span class="comment">// v1------v0|</span></span><br><span class="line"><span class="comment">// | | | |</span></span><br><span class="line"><span class="comment">// | |v7---|-|v4</span></span><br><span class="line"><span class="comment">// |/ |/</span></span><br><span class="line"><span class="comment">// v2------v3</span></span><br><span class="line">var verticesColors = <span class="keyword">new</span> Float32Array([</span><br><span class="line"><span class="comment">// Vertex coordinates and color</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="comment">// v0 White</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="comment">// v1 Magenta</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="comment">// v2 Red</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="comment">// v3 Yellow</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="comment">// v4 Green</span></span><br><span class="line"><span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="comment">// v5 Cyan</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="comment">// v6 Blue</span></span><br><span class="line"><span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span> <span class="comment">// v7 Black</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Indices of the vertices</span></span><br><span class="line">var indices = <span class="keyword">new</span> Uint8Array([</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="comment">// front</span></span><br><span class="line"><span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="comment">// right</span></span><br><span class="line"><span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="comment">// up</span></span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="comment">// left</span></span><br><span class="line"><span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="comment">// down</span></span><br><span class="line"><span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span> <span class="comment">// back</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a buffer object</span></span><br><span class="line">var vertexColorBuffer = gl.createBuffer();</span><br><span class="line">var indexBuffer = gl.createBuffer();</span><br><span class="line"><span class="keyword">if</span> (!vertexColorBuffer || !indexBuffer) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the vertex coordinates and color to the buffer object</span></span><br><span class="line">gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);</span><br><span class="line">gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">var FSIZE = verticesColors.BYTES_PER_ELEMENT;</span><br><span class="line"><span class="comment">// Assign the buffer object to a_Position and enable the assignment</span></span><br><span class="line">var a_Position = gl.getAttribLocation(gl.program, 'a_Position');</span><br><span class="line"><span class="keyword">if</span>(a_Position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">console.log('Failed to get the storage location of a_Position');</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">gl.vertexAttribPointer(a_Position, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">gl.enableVertexAttribArray(a_Position);</span><br><span class="line"><span class="comment">// Assign the buffer object to a_Color and enable the assignment</span></span><br><span class="line">var a_Color = gl.getAttribLocation(gl.program, 'a_Color');</span><br><span class="line"><span class="keyword">if</span>(a_Color &lt; <span class="number">0</span>) &#123;</span><br><span class="line">console.log('Failed to get the storage location of a_Color');</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">gl.vertexAttribPointer(a_Color, <span class="number">3</span>, gl.FLOAT, <span class="literal">false</span>, FSIZE * <span class="number">6</span>, FSIZE * <span class="number">3</span>);</span><br><span class="line">gl.enableVertexAttribArray(a_Color);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write the indices to the buffer object</span></span><br><span class="line">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);</span><br><span class="line">gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> indices.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中使用到的创建WebGL渲染环境、初始化着色器、创建矩阵的操作，读者可以自行找相应的代码库替代。<br>或者在下面的链接中下载：<br><a href="http://pan.baidu.com/s/1mhVH5Ba" target="_blank" rel="noopener">WebGL Lib</a>， 密码：tncd。</p><p>PPT文档如下：</p><iframe src="https://onedrive.live.com/embed?cid=4330CD349D9ADD44&resid=4330CD349D9ADD44%21739&authkey=AF3XGkUj4jdHiF8&em=2" width="900" height="700" frameborder="0" scrolling="no"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍编写一个原生的WebGL程序需要哪些步骤。&lt;/p&gt;
&lt;h2 id=&quot;WebGL程序的软件结构&quot;&gt;&lt;a href=&quot;#WebGL程序的软件结构&quot; class=&quot;headerlink&quot; title=&quot;WebGL程序的软件结构&quot;&gt;&lt;/a&gt;WebGL程序的软件结构&lt;/h2&gt;&lt;p&gt;默认情况下，一个动态网页程序只包括HTML和JavaScript两种语言。&lt;br&gt;而在WebGL程序中，还包括了第三种语言：GLSL ES。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="WebGL" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/"/>
    
    
      <category term="WebGL" scheme="http://xiaopengcheng.top/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>虚幻三引擎游戏命令</title>
    <link href="http://xiaopengcheng.top/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E6%B8%B8%E6%88%8F%E5%91%BD%E4%BB%A4/"/>
    <id>http://xiaopengcheng.top/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E6%B8%B8%E6%88%8F%E5%91%BD%E4%BB%A4/</id>
    <published>2016-12-03T14:06:24.000Z</published>
    <updated>2021-12-26T07:51:47.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令行参数和控制台命令"><a href="#命令行参数和控制台命令" class="headerlink" title="命令行参数和控制台命令"></a>命令行参数和控制台命令</h2><p>游戏命令包括两种，一种是运行游戏时候指定的命令行参数，另外一种则指的是进入游戏后输入的控制命令。</p><h2 id="控制台命令"><a href="#控制台命令" class="headerlink" title="控制台命令"></a>控制台命令</h2><p>对于虚幻三来说，控制台命令分为两种，一种是引擎中已经支持的可执行命令，这些命令都是在C++类的Exec函数中进行处理的。另一种是带exec前缀的脚本函数，称为可执行函数。<br>下面根据用途统一总结，不进行区分。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="exit-quit"><a href="#exit-quit" class="headerlink" title="exit(quit)"></a>exit(quit)</h4><p>退出游戏</p><h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h4><p>暂停游戏，按pause break键也可以。</p><h4 id="open-url"><a href="#open-url" class="headerlink" title="open [url]"></a>open [url]</h4><p>打开地图，额外的参数同命令行参数的url部分。比如，在大厅中开始游戏就是用的该命令打开服务器下发的ip地址。</p><h4 id="restartLevel"><a href="#restartLevel" class="headerlink" title="restartLevel"></a>restartLevel</h4><p>重启当前关卡</p><h4 id="reconnect-disconnect-cancel"><a href="#reconnect-disconnect-cancel" class="headerlink" title="reconnect/disconnect/cancel"></a>reconnect/disconnect/cancel</h4><p>重新连接服务器，断开服务器连接，取消进行的服务器连接操作。</p><h4 id="Kill系列"><a href="#Kill系列" class="headerlink" title="Kill系列"></a>Kill系列</h4><ol><li>KillAll [class] - 销毁或破坏关卡中特定类的所有实例。</li><li>KillPawns - 销毁关卡中的所有 pawn。</li><li>KillBadGuys - 销毁所有不在同一个团队作为玩家的 pawns。</li><li>Suicide -玩家自杀</li></ol><h4 id="god-fly-walk"><a href="#god-fly-walk" class="headerlink" title="god/fly/walk"></a>god/fly/walk</h4><p>幽灵模式（可以飞、穿墙）/飞行模式/正常模式</p><h4 id="AllAmmo"><a href="#AllAmmo" class="headerlink" title="AllAmmo"></a>AllAmmo</h4><p>将弹药数目设置为所有武器的最大值</p><h4 id="SetRes"><a href="#SetRes" class="headerlink" title="SetRes"></a>SetRes</h4><p>setres [width] [x|X] [height] [w|f]<br>改变分辨率（width为宽，height为高）<br>模式(w = 窗口; f = 全屏)，<br>比如 800x600w表示分辨率为800乘以600的窗口模式，<br>1024x768f表示分辨率为1024乘以768的全屏模式。</p><h4 id="FreeCamera"><a href="#FreeCamera" class="headerlink" title="FreeCamera"></a>FreeCamera</h4><p>将玩家的相机设置为自由轨道相机模式（第三人称视角），FreeCamera false恢复。</p><h4 id="Addbots"><a href="#Addbots" class="headerlink" title="Addbots"></a>Addbots</h4><ol><li>AddBots [number] - 为了进行测试，会向关卡中添加指定机器人数.</li><li>AddBlueBots [number] - 在团队游戏中为蓝队添加指定的机器人数。</li><li>AddRedBots [number] - 在团队游戏中为红队添加指定的机器人数。</li><li>AddNamedBot [name] [bUseTeamNum] [teamnum] - 添加一个使用指定名称的机器人。如果 bUseTeamNum 为真而且指定了团队数，那么将该机器人添加到指定的团队。</li></ol><h4 id="Shot"><a href="#Shot" class="headerlink" title="Shot"></a>Shot</h4><ol><li>shot/screenshot 以当前的屏幕分辨率截取屏幕截图。</li><li>tiledshot [factor] 以当前分辨率乘以指定因数为分辨率来获取屏幕截图。比如，tiledshot 2会得到2乘以2的shot截图，分辨率也是shot的2倍。</li><li>SHOTNOHUD，不截屏hud。</li></ol><h3 id="渲染命令"><a href="#渲染命令" class="headerlink" title="渲染命令"></a>渲染命令</h3><h4 id="ViewMode"><a href="#ViewMode" class="headerlink" title="ViewMode"></a>ViewMode</h4><p>viewmode命令设置渲染模式<br>1. detaillight 默认模式，使用受到法线贴图的光照影响的中性色彩材质渲染场景<br>2. unlit 无光照<br>3. lightingonly 只使用光照<br>4. wireframe 线框模式<br>5. brushwireframe 线框模式，但是显示画刷边缘<br>6. lightcomplexity 显示光照复杂度<br>7. lightmapdensity 显示光照贴图密度<br>8. litlightmapdensity 显示光照贴图像素密度 6和7的结合<br>9. texturedensity 显示每个表面上漫反射通道上的贴图像素密度<br>10. shadercomplexity 显示每个表面上所应用的材质的复杂度</p><h4 id="Show"><a href="#Show" class="headerlink" title="Show"></a>Show</h4><p>切换各种项目的显示(仅用于客户端)<br>1. bounds  切换actor边界的显示（包围盒和包围球）<br>2. volumes 切换体积的显示（体积盒）<br>3. collision 切换碰撞体的显示状态<br>4. bsp  切换bsp几何体的显示（用bsp画刷制作的物体，比如墙）<br>5. fog  切换雾actors的显示<br>6. particles 切换粒子几何体的显示（比如烟雾弹，特效做的门）<br>7. paths 切换路径或导航网格物体的显示<br>8. navnodes 切换和寻路相关的actors的显示<br>9. foliage 切换植被的显示<br>10. terrain 切换地形几何体的显示<br>11. terrainpatches 切换地形块的显示。在每个块的周围描画一个轮廓。<br>12. staticmeshes 切换静态网格物体几何体的显示<br>13. decal 切换decal actors的显示<br>14. decalinfo 切换decals（贴花）的调试开发信息的显示(平头截体、切线轴等)。<br>15. staticmeshes 切换静态网格物体几何体的显示。<br>16. postprocess  切换后期处理特效的显示<br>17. skelmeshes/skeletalmeshes 切换骨架网格物体几何体的显示<br>18. MISSINGCOLLISION  切换高亮显示启用了碰撞但是没有碰撞网格物体的静态网格物体</p><h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><h4 id="display系列"><a href="#display系列" class="headerlink" title="display系列"></a>display系列</h4><h4 id="displayall-class-prop"><a href="#displayall-class-prop" class="headerlink" title="displayall class prop"></a>displayall class prop</h4><p>在屏幕上实时地显示类class所有实例的属性prop的值</p><h4 id="display-obj-prop"><a href="#display-obj-prop" class="headerlink" title="display obj prop"></a>display obj prop</h4><p>在屏幕上实时地显示对象obj的属性prop的值。</p><h4 id="displayallstate-class"><a href="#displayallstate-class" class="headerlink" title="displayallstate class"></a>displayallstate class</h4><p>在屏幕上实时地显示类class所有实例的当前处于的状态，比如行走，空闲，攻击等</p><h4 id="displayclear"><a href="#displayclear" class="headerlink" title="displayclear"></a>displayclear</h4><p>清楚display系列命令所有的输出</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>set class/obj prop value<br>1. 设置给定类class（包括其子类）的所有对象的属性prop的值为value<br>2. 设置给定对象obj的属性prop的值为value</p><p>可以用displayall实时显示出来这个属性，再用set设置后观察属性变化。</p><h3 id="统计命令"><a href="#统计命令" class="headerlink" title="统计命令"></a>统计命令</h3><p>stat命令负责在游戏运行时在屏幕上启用显示统计数据功能。</p><h3 id="none"><a href="#none" class="headerlink" title="none"></a>none</h3><p>关闭所有统计数据的显示</p><h4 id="fps"><a href="#fps" class="headerlink" title="fps"></a>fps</h4><p>切换帧频率统计数据的显示</p><h4 id="anim"><a href="#anim" class="headerlink" title="anim"></a>anim</h4><p>切换动画系统统计数据的显示状态</p><h4 id="net"><a href="#net" class="headerlink" title="net"></a>net</h4><p>切换网络统计数据显示的 打开/关闭 状态</p><h4 id="game"><a href="#game" class="headerlink" title="game"></a>game</h4><p>切换游戏统计数据的显示。(更新时间等)</p><h4 id="ui"><a href="#ui" class="headerlink" title="ui"></a>ui</h4><p>切换UIScene统计数据的显示</p><h4 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h4><p>切换碰撞统计数据的显示状态</p><h4 id="octree"><a href="#octree" class="headerlink" title="octree"></a>octree</h4><p>切换八叉树相关统计数据的显示</p><h4 id="physics"><a href="#physics" class="headerlink" title="physics"></a>physics</h4><p>切换一般物理统计数据的显示<br>1. physicscloth 切换关于布料仿真统计数据的显示。<br>2. physicsfields 切换关于物理域的统计数据的显示状态。<br>3. physicsfluids 切换关于PhysX流体仿真统计数据的显示。</p><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p>切换一般内存统计数据的显示</p><h4 id="memorychurn"><a href="#memorychurn" class="headerlink" title="memorychurn"></a>memorychurn</h4><p>切换处理内存分配的统计数据的显示</p><h4 id="scenerendering"><a href="#scenerendering" class="headerlink" title="scenerendering"></a>scenerendering</h4><p>切换场景渲染统计数据的显示</p><h4 id="startfile-stopfile"><a href="#startfile-stopfile" class="headerlink" title="startfile/stopfile"></a>startfile/stopfile</h4><ol><li>startfile开始捕获统计数据文件以便和StatsViewer结合使用。</li><li>stopfile完成捕获统计数据文件。</li><li>文件存储位置：UDKGame\Profiling\UE3Stats\xxx文件..ustats</li><li>打开工具：Binaries\StatsViewer.exe</li></ol><h4 id="GameProfile-ProfileGame"><a href="#GameProfile-ProfileGame" class="headerlink" title="GameProfile/ProfileGame"></a>GameProfile/ProfileGame</h4><p>该命令在虚幻三和UDK中用于统计脚本函数的运行时间。<br>1. start 开始Profile<br>2. stop 结束Profile<br>3. 文件：UDKGame\Profiling\T-2016.11.29-19.26.55.gprof<br>4. 打开工具：Binaries\GameplayProfiler.exe<br>5. UObject::CallFunction中统计了每个函数的调用时间。</p><h3 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h3><p>调试命令的结果是控制台形式的输出，并不是在游戏窗口中显示。在逆战中，需要按f8显示控制台窗口，再输入调试命令。其余类型的命令可以使用f7也可以使用f8。</p><h4 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h4><h5 id="gc-garbage"><a href="#gc-garbage" class="headerlink" title="gc/garbage"></a>gc/garbage</h5><p>强制进行垃圾回收清理。</p><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>显示包中的一个类别的所有物体的列表。<br>1. obj list显示包中所有的物体列表。<br>2. obj list class=pawn 只显示指定的类的所有物体的对象列表，比如pawn。</p><h5 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h5><p>dump objname<br>在控制台中输出某个对象的所有属性，可以先用displayall找到这个对象名。</p><h3 id="物理命令"><a href="#物理命令" class="headerlink" title="物理命令"></a>物理命令</h3><h5 id="nxvis-collision…"><a href="#nxvis-collision…" class="headerlink" title="nxvis collision…"></a>nxvis collision…</h5><p>碰撞相关命令</p><h5 id="nxvis-joint…"><a href="#nxvis-joint…" class="headerlink" title="nxvis joint…"></a>nxvis joint…</h5><p>关节相关命令</p><h5 id="nxvis-cloth…"><a href="#nxvis-cloth…" class="headerlink" title="nxvis cloth…"></a>nxvis cloth…</h5><p>布料相关命令</p><h5 id="nxvis-fluid…"><a href="#nxvis-fluid…" class="headerlink" title="nxvis fluid…"></a>nxvis fluid…</h5><p>流体相关命令</p><h5 id="nxvis-softbody…"><a href="#nxvis-softbody…" class="headerlink" title="nxvis softbody…"></a>nxvis softbody…</h5><p>软体相关命令</p><h3 id="内存命令"><a href="#内存命令" class="headerlink" title="内存命令"></a>内存命令</h3><h5 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h5><p>显示内存分配信息<br>1.  mem<br>2.  mem detailed<br>3.  mem stat</p><h5 id="configmem"><a href="#configmem" class="headerlink" title="configmem"></a>configmem</h5><p>显示配置文件内存分配信息</p><h5 id="particlememory"><a href="#particlememory" class="headerlink" title="particlememory"></a>particlememory</h5><p>粒子内存信息</p><h5 id="memfragcheck"><a href="#memfragcheck" class="headerlink" title="memfragcheck"></a>memfragcheck</h5><p>内存碎片检测</p><h5 id="memleakcheck"><a href="#memleakcheck" class="headerlink" title="memleakcheck"></a>memleakcheck</h5><p>内存泄漏检测</p><h3 id="UI-GFX命令"><a href="#UI-GFX命令" class="headerlink" title="UI/GFX命令"></a>UI/GFX命令</h3><h3 id="ShowHUD"><a href="#ShowHUD" class="headerlink" title="ShowHUD"></a>ShowHUD</h3><p>显示(隐藏)所有的HUD</p><h5 id="ShowScores"><a href="#ShowScores" class="headerlink" title="ShowScores"></a>ShowScores</h5><p>显示(隐藏)积分面板</p><h5 id="Toggleui"><a href="#Toggleui" class="headerlink" title="Toggleui"></a>Toggleui</h5><p>切换UI的更新和显示</p><h5 id="gfxinvoke"><a href="#gfxinvoke" class="headerlink" title="gfxinvoke"></a>gfxinvoke</h5><p>调用GfxMovie对应的flash文件的as函数</p><h5 id="dumpsftextures"><a href="#dumpsftextures" class="headerlink" title="dumpsftextures"></a>dumpsftextures</h5><p>输出GFx Texture Usage到log文件中。</p><h2 id="虚幻三控制台命令调用流程"><a href="#虚幻三控制台命令调用流程" class="headerlink" title="虚幻三控制台命令调用流程"></a>虚幻三控制台命令调用流程</h2><ul><li>APlayerController::ConsoleCommand。</li><li><ul><li>ULocalPlayer::Exec，处理一部分命令。</li></ul></li><li><ul><li><ul><li>UGameViewportClient::Exec，引擎自带的大部分命令在此函数中实现。</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UGFxInteraction::Exec，执行gfx相关的命令。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UUIInteraction::Exec，处理一部分命令。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>UUIInteraction::ScriptConsoleExec。</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li>UGameUISceneClient::Exec。</li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li>UUISceneClient::Exec.</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li>UUISceneClient::ScriptConsoleExec.</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UGameViewportClient::ScriptConsoleExec。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UEngine::Exec，处理一部分命令。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li>UPlayer::Exec，处理一部分命令。</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>UWorld::Exec。</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>APlayerInput::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>APlayerController::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>APawn::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AInvManager::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AWeapon::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AHUD::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AGameInfo::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>ACheatManager::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>AInteraction::ScriptConsoleExec</li></ul></li></ul></li></ul></li><li>返回APlayerController::ConsoleCommand，命令未处理。</li></ul><p>注意：UObkect::ScriptConsoleExec，处理的是当前类中自定义脚本命令（执行带exec前缀的脚本函数）。<br>因此，流程中带有ScriptConsoleExec函数执行的类（以及子类）都可以定exec脚本函数来执行控制台命令。只有在处理流程中的命令才有效，处理流程外的命令无法被处理。</p><h3 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h3><h4 id="Native命令"><a href="#Native命令" class="headerlink" title="Native命令"></a>Native命令</h4><p>在控制台命令调用流程中涉及到的C++类的Exec函数中添加对新命令的处理逻辑。</p><h4 id="脚本命令"><a href="#脚本命令" class="headerlink" title="脚本命令"></a>脚本命令</h4><p>在处理流程中的有ScriptConsoleExec调用的类(Interaction、UISceneClient、GameViewportClient、PlayerInput、PlayerController、Pawn、InvManager、Weapon、HUD、GameInfo、CheatManager)<br>中添加exec前缀的脚本函数。</p><p>更多的游戏命令可以参考文档：<a href="https://wiki.beyondunreal.com/Legacy:Console_Commands" target="_blank" rel="noopener">Console Commands</a>。</p><h3 id="虚幻引擎游戏命令"><a href="#虚幻引擎游戏命令" class="headerlink" title="虚幻引擎游戏命令"></a>虚幻引擎游戏命令</h3><div class="video-container"><iframe src="https://onedrive.live.com/embed?cid=4330CD349D9ADD44&resid=4330CD349D9ADD44%21723&authkey=AFSrpMCVspcze0g&em=2" width="800" height="700" frameborder="0" allowfullscreen="allowfullscreen"></iframe></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令行参数和控制台命令&quot;&gt;&lt;a href=&quot;#命令行参数和控制台命令&quot; class=&quot;headerlink&quot; title=&quot;命令行参数和控制台命令&quot;&gt;&lt;/a&gt;命令行参数和控制台命令&lt;/h2&gt;&lt;p&gt;游戏命令包括两种，一种是运行游戏时候指定的命令行参数，另外一种则指的是进入游戏后输入的控制命令。&lt;/p&gt;
&lt;h2 id=&quot;控制台命令&quot;&gt;&lt;a href=&quot;#控制台命令&quot; class=&quot;headerlink&quot; title=&quot;控制台命令&quot;&gt;&lt;/a&gt;控制台命令&lt;/h2&gt;
    
    </summary>
    
    
      <category term="游戏开发" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="UnrealEngine" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UnrealEngine/"/>
    
    
      <category term="UnrealEngine" scheme="http://xiaopengcheng.top/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>虚幻三命令行参数</title>
    <link href="http://xiaopengcheng.top/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <id>http://xiaopengcheng.top/2016/12/03/%E8%99%9A%E5%B9%BB%E4%B8%89%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</id>
    <published>2016-12-03T13:17:20.000Z</published>
    <updated>2021-12-26T07:51:36.338Z</updated>
    
    <content type="html"><![CDATA[<p>命令行参数是指通过命令行或者可执行文件快捷方式启动游戏进程的时候，附加在后面的一系列参数。</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>命令行参数分为两种，一种是编译游戏代码时候需要用到的命令行参数。另一种则是在启动游戏进程时候指定的参数。</p><h3 id="编译命令行参数"><a href="#编译命令行参数" class="headerlink" title="编译命令行参数"></a>编译命令行参数</h3><p>编译代码期间会用到的参数如下：</p><ol><li>版本 -debug -release&lt;/p&gt;</li><li><p>全量 -full （默认增量）</p></li><li><p>自动更新C++头文件，不弹框确认 -auto<br>注意：虚幻三编译脚本.uc文件时候，会更新.h头文件</p></li><li><p>移除.u文件中的源代码信息 -stripsource注意：.u文件是虚幻三脚本文件编译后的字节码文件，虚幻四中不存在</p><p>因此，编译代码时候最多可能指定以下参数组合：<br>make -debug -full -auto -stripsource<br>make -release -full -auto  -stripsource</p></li></ol><p><strong>注意：通过在vs中指定make命令可以调试编译代码的过程。</strong><br>如下图所示：<br><img alt="enter description here" data-src="https://c2.staticflickr.com/6/5486/31353510066_d0fd3565ee_o.png"></p><h3 id="运行命令行参数"><a href="#运行命令行参数" class="headerlink" title="运行命令行参数"></a>运行命令行参数</h3><p>启动游戏进程指定的命令行参数分为两个个部分，第一个部分用于指定进程的运行模式（客户端、服务器、编辑器），第二个部分用于指定地图的URL以及附加选项。</p><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><p>游戏进程可以用三种不同的模式进行启动，分别是客户端、服务器、编辑器模式。因此，虚幻引擎生成的游戏可执行文件同时可以作为游戏服务器、游戏客户端、游戏编辑器运行。这是一个很神奇的地方。</p><ol><li><p>客户端模式<br>默认情况下，启动的游戏进程就是客户端模式，不需要指定额外的命令行参数。<br>在UE4中，也可以指定-game参数。</p></li><li><p>服务器模式<br>通过指定server参数，可以启动一个游戏服务器。<br>比如，udk.exe server，则是使用udk启动一个游戏服务器。<br>对于UE4，则是UE4Editor.exe -server。<br>实际上，可以修改游戏引擎设置，输出自定义的游戏执行文件。在启动这个游戏可执行文件时候，只需要附近sever参数就可以启动一个游戏服务器。</p></li><li><p>编辑器模式<br>通过指定editor参数，可以启动一个游戏服务器。<br>比如，udk.exe editor，则是使用udk启动游戏编辑器。<br>对于UE4，则是UE4Editor.exe -editor。</p></li></ol><h4 id="模式的URL参数"><a href="#模式的URL参数" class="headerlink" title="模式的URL参数"></a>模式的URL参数</h4><p>URL分为两个部分：地图名称或者服务器地址，可选的附加参数。<br>地图部分用于强制游戏启动时候加载特定的地图，附加参数用于设置额外的启动方式，比如设置分辨率，是否打开log窗口等。这些参数和server或editor模式结合起来就可以启动特定地图的服务器或者用编辑器打开特定地图。<br>如果没有url参数，那么游戏进程会打开默认的地图。URL参数必须在可执行命令名称的后面或者在模式参数后面。</p><ol><li><p>地图<br>如果运行本地游戏，则指定Maps目录下的地图名称，比如MyMap. umap。<br>如果运行网络游戏，则指定游戏服务器的IP地址（server模式启动的游戏进程就是游戏服务器）。</p></li><li><p>附加参数<br>附加参数与地图之间用”?”分隔。<br>附加参数分为两种类型，一种是用”=”指定的选项，一种是用”-“指定的开关。</p><p>常用的选项参数：<br>dedicated：指定服务器作为专用服务器。<br>listen: 指定服务器作为监听服务器 。<br>spectatoronly：以观看模式启动游戏<br>class: 告诉引擎要使用的玩家类(覆盖默认值)。<br>game:: 指定使用的GameInfo类。<br>name: 要使用的玩家名称。<br>team: 指定玩家所在的团队。<br>resx/resy: 设置游戏窗口的分辨率。<br>consolex/consoley：设置控制台窗口(log窗口)分辨率。</p><p>常用的开关参数：<br>log: 打开日志窗口。<br>windowed：窗口模式运行。<br>nomoviestartup: 略过启动动画。<br>nosplash: 略过启动splash窗口。</p><p></p><p>更多的附加参数请参考文档：<a href="https://docs.unrealengine.com/latest/CHN/Programming/Basics/CommandLineArguments/index.html" target="_blank" rel="noopener">虚幻四引擎命令行参数</a></p></li><li><p>一些示例：<br>UDK.exe server MyMap.udk<br>UDK.exe 127.0.0.1<br>UDK.exe MyMap.udk?-resX=640 -resY=480 -log log=log.txt<br>UDKLift.exe DM-发电站?Game=UTGame.UTTeamGame?listen=true?TeamIndex=0?Name=FS01 -log -windowed -resX=640 -resY=360 -nomoviestartup -nosplash windowPosX=0 windowPosY=0 -consolePosX=0 -consolePosY=365<br>MyGame.exe editor MyMap.umap -NoLoadStartupPackages -NoGADWarning</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令行参数是指通过命令行或者可执行文件快捷方式启动游戏进程的时候，附加在后面的一系列参数。&lt;/p&gt;
&lt;h2 id=&quot;命令行参数&quot;&gt;&lt;a href=&quot;#命令行参数&quot; class=&quot;headerlink&quot; title=&quot;命令行参数&quot;&gt;&lt;/a&gt;命令行参数&lt;/h2&gt;&lt;p&gt;命令行参数分为两种，一种是编译游戏代码时候需要用到的命令行参数。另一种则是在启动游戏进程时候指定的参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏开发" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
      <category term="UnrealEngine" scheme="http://xiaopengcheng.top/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/UnrealEngine/"/>
    
    
      <category term="UnrealEngine" scheme="http://xiaopengcheng.top/tags/UnrealEngine/"/>
    
  </entry>
  
  <entry>
    <title>使用DebugView实时显示Log</title>
    <link href="http://xiaopengcheng.top/2016/08/15/%E4%BD%BF%E7%94%A8DebugView%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BALog/"/>
    <id>http://xiaopengcheng.top/2016/08/15/%E4%BD%BF%E7%94%A8DebugView%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BALog/</id>
    <published>2016-08-15T12:48:18.000Z</published>
    <updated>2021-12-26T12:45:54.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DebugView简介"><a href="#DebugView简介" class="headerlink" title="DebugView简介"></a>DebugView简介</h3><p>DebugView是一个监视本地系统或者通过tcp/ip连接的网络系统的OutputDebugString输出的应用程序。DebugView不仅能够监视Win32应用的debug输出，还可以监视内核模型的debug输出。因此，如果使用OutputDebugString来打印调试信息的话，就可以在程序运行时候通过DebugView来实时显示程序的调试信息。<br>这种方式在某种意义上，比将Log打印到文件中，关闭程序后再查看Log输出的方式更加方便。而且可以将这两种调试程序的方式结合起来，既使用DebugView来实时显示调试信息，又将调试信息输出到Log文件中，方便以后分析。</p><h2 id="安装DebugView"><a href="#安装DebugView" class="headerlink" title="安装DebugView"></a>安装DebugView</h2><p>下载地址：<a href="https://technet.microsoft.com/en-us/sysinternals/debugview.aspx" target="_blank" rel="noopener">DebugView</a><br>下载后面后解压压缩包，发现里面有三个文件：Dbgview.exe、dbgview.chm、Eula.txt。<br>Dbgview.exe就是我们要使用的实时显示Log工具。dbgview.chm是自带的文档，有不懂的地方可以查阅该文档。<br>现在可以将DebugView.exe放到任何你喜欢的目录，比如桌面。</p><h2 id="配置DebugView"><a href="#配置DebugView" class="headerlink" title="配置DebugView"></a>配置DebugView</h2><h3 id="配置Capture"><a href="#配置Capture" class="headerlink" title="配置Capture"></a>配置Capture</h3><p>如下图所示，要记得勾选Capture Win32和Capture Global Win32。Capture Global Win32用于网络模式下捕获网络主机的Debug输出的时候。如果需要捕获内核模式的调试输出，记得勾选Capture Kernel Win32。<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8750/28713108000_0384dfb06a_o.png"><br>如果点击Capture Global Win32菜单出现提示：<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8315/28999300555_61681b6880_o.png"><br>重新以管理员的身份启动DebugView。<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8897/28999300535_075a591b02_o.png"></p><h3 id="配置Filter"><a href="#配置Filter" class="headerlink" title="配置Filter"></a>配置Filter</h3><p>如下图所示，打开Filter对话框，<br><img alt="enter description here" data-src="https://c2.staticflickr.com/8/7507/28923046321_72cd949daa_o.png"><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8744/28713274070_2809e64189_o.png"><br>然后在Include中输入要包含的字符串，比如”hankpcxiao”，多个字符串用;分隔，比如”hankpcxiao;xpc”。<br>这样就只会捕获包括过滤字符串hankpcxiao或者xpc的OutputDebugString输出。<br>如果我们在每个OutputDebugString输出前自动加上过滤字符串，那么DebugView就只会输出我们的Log信息了。</p><h3 id="开启捕获"><a href="#开启捕获" class="headerlink" title="开启捕获"></a>开启捕获</h3><p>最后确保开启了捕获，如下图所示：<br><img alt="enter description here" data-src="https://c1.staticflickr.com/9/8842/28999300405_0355a4405f_o.png"></p><h2 id="如何在程序中输出Log信息？"><a href="#如何在程序中输出Log信息？" class="headerlink" title="如何在程序中输出Log信息？"></a>如何在程序中输出Log信息？</h2><p>默认情况下，DebugView会捕获函数OutputDebugString的输出，但是这个函数的参数是个字符串指针，不太方便。下面我们通过一些列步骤来创建一个方便使用的Log类。</p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>我们习惯使用printf这样的函数来格式化输出信息，因此这次我们也把OutputDebugString包装成可变参数形式的格式化输出函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DebugViewOutput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line"></span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, fm);</span><br><span class="line">    vsprintf_s(szMsg, fm, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line"></span><br><span class="line">    OutputDebugString(szMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让DebugView在VS调试程序时候也能够捕获Log"><a href="#让DebugView在VS调试程序时候也能够捕获Log" class="headerlink" title="让DebugView在VS调试程序时候也能够捕获Log"></a>让DebugView在VS调试程序时候也能够捕获Log</h3><p>网上有不少介绍DebugView使用的文章，但是都忽略了一个事实，那就是默认情况下，使用VS运行程序时候，OutputDebugString的输出是到VS的输出窗口中，DebugView中并没有任何信息。只有单独运行程序的时候，DebugView才能够捕捉到信息。<br>但是这样就不能结合打断点调试和DebugView两个强大的调试方法了。不过，还是有解决办法的。通过一个叫做DBWin通信机制可以实现调试程序时候，把OutputDebugString的输出信息显示到DebugView窗口中。这套机制的本质是通过内存映射文件来跨进程交换数据。<br>具体参考以下的类代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">XpcDebugView</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        XpcDebugView() &#123;&#125;</span><br><span class="line">        ~XpcDebugView() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">XpcDebugViewOutput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">DBWinBuffer</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            DWORD ProcessId;</span><br><span class="line">            <span class="keyword">char</span> Data[<span class="number">4096</span> - <span class="keyword">sizeof</span>(DWORD)];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UnInitialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        HANDLE m_mutex;</span><br><span class="line">        HANDLE m_fileMapping;</span><br><span class="line">        HANDLE m_bufferReadyEvent;</span><br><span class="line">        HANDLE m_dataReadyEvent;</span><br><span class="line">        DBWinBuffer* m_buffer;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> XpcDebugView::Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex = OpenMutex(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWinMutex"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER</span></span><br><span class="line">        m_fileMapping = OpenFileMapping(FILE_MAP_WRITE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_fileMapping == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER_READY</span></span><br><span class="line">        m_bufferReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_DATA_READY</span></span><br><span class="line">        m_dataReadyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT(<span class="string">"DBWIN_DATA_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待DBWIN_BUFFER就绪</span></span><br><span class="line">        WaitForSingleObject(m_bufferReadyEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把DBWIN_BUFFER映射到某个地址</span></span><br><span class="line">        m_buffer = (DBWinBuffer*)MapViewOfFile(m_fileMapping, FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        m_buffer-&gt;ProcessId = GetCurrentProcessId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::UnInitialize()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//释放和关闭DBWIN_BUFFER</span></span><br><span class="line">        FlushViewOfFile(m_buffer, <span class="number">0</span>);</span><br><span class="line">        UnmapViewOfFile(m_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发DBWIN_DATA_READY</span></span><br><span class="line">        SetEvent(m_dataReadyEvent);</span><br><span class="line"></span><br><span class="line">        CloseHandle(m_fileMapping);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理</span></span><br><span class="line">        CloseHandle(m_dataReadyEvent);</span><br><span class="line">        CloseHandle(m_bufferReadyEvent);</span><br><span class="line">        ReleaseMutex(m_mutex);</span><br><span class="line">        CloseHandle(m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::XpcDebugViewOutput(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Initialize() == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line"></span><br><span class="line">        va_list argList;</span><br><span class="line">        va_start(argList, fm);</span><br><span class="line">        vsprintf_s(szMsg, fm, argList);</span><br><span class="line">        va_end(argList);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( push )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( disable: 4996 )</span></span><br><span class="line">        <span class="comment">//向DBWIN_BUFFER写入数据</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_buffer-&gt;Data, szMsg);</span><br><span class="line">        <span class="built_in">printf</span>(szMsg);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( pop )</span></span><br><span class="line"></span><br><span class="line">        UnInitialize();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用的时候直接调用类成员函数XpcDebugViewOutput即可。<br>关于这部分的内容更具体的可以参考文章，<a href="http://dooof.lofter.com/tag/DebugView" target="_blank" rel="noopener">如何让OutputDebugString绕过调试器</a></p><h3 id="输出到DebugView的同时输出到Log文件"><a href="#输出到DebugView的同时输出到Log文件" class="headerlink" title="输出到DebugView的同时输出到Log文件"></a>输出到DebugView的同时输出到Log文件</h3><p>我将上面的类改造成下面的样子，在初始化时候创建一个Log文件，在反初始化时候关闭Log文件，每次调用XpcDebugViewOutput使用调用fprintf将格式化字符串输出到文件中。这样就能达到输出Log信息到DebugView中的同时，又能够将Log信息持久化保存了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">XpcDebugView</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        XpcDebugView() &#123; m_pszLogName = <span class="string">"DefaultLog.txt"</span>; Initialize();  &#125;</span><br><span class="line">        XpcDebugView(<span class="keyword">const</span> <span class="keyword">char</span>* pszLogName) &#123; m_pszLogName = pszLogName; Initialize();&#125;</span><br><span class="line">        ~XpcDebugView() &#123; UnInitialize(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">XpcDebugViewOutput</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">DBWinBuffer</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            DWORD ProcessId;</span><br><span class="line">            <span class="keyword">char</span> Data[<span class="number">4096</span> - <span class="keyword">sizeof</span>(DWORD)];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UnInitialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">InitializeDBWin</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UnInitializeDBWin</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        HANDLE m_mutex;</span><br><span class="line">        HANDLE m_fileMapping;</span><br><span class="line">        HANDLE m_bufferReadyEvent;</span><br><span class="line">        HANDLE m_dataReadyEvent;</span><br><span class="line">        DBWinBuffer* m_buffer;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* m_pszLogName;</span><br><span class="line">        FILE* m_pFileLog;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( push )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( disable: 4996 )</span></span><br><span class="line">    <span class="keyword">bool</span> XpcDebugView::Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pFileLog = fopen(m_pszLogName, <span class="string">"w"</span>);</span><br><span class="line">        <span class="keyword">return</span> m_pFileLog != <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::UnInitialize()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pFileLog)</span><br><span class="line">        &#123;</span><br><span class="line">            fclose(m_pFileLog);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> XpcDebugView::InitializeDBWin()</span><br><span class="line">    &#123;</span><br><span class="line">        m_mutex = OpenMutex(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWinMutex"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER</span></span><br><span class="line">        m_fileMapping = OpenFileMapping(FILE_MAP_WRITE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_fileMapping == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_BUFFER_READY</span></span><br><span class="line">        m_bufferReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT(<span class="string">"DBWIN_BUFFER_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开DBWIN_DATA_READY</span></span><br><span class="line">        m_dataReadyEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT(<span class="string">"DBWIN_DATA_READY"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待DBWIN_BUFFER就绪</span></span><br><span class="line">        WaitForSingleObject(m_bufferReadyEvent, INFINITE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把DBWIN_BUFFER映射到某个地址</span></span><br><span class="line">        m_buffer = (DBWinBuffer*)MapViewOfFile(m_fileMapping, FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        m_buffer-&gt;ProcessId = GetCurrentProcessId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::UnInitializeDBWin()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//释放和关闭DBWIN_BUFFER</span></span><br><span class="line">        FlushViewOfFile(m_buffer, <span class="number">0</span>);</span><br><span class="line">        UnmapViewOfFile(m_buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触发DBWIN_DATA_READY</span></span><br><span class="line">        SetEvent(m_dataReadyEvent);</span><br><span class="line"></span><br><span class="line">        CloseHandle(m_fileMapping);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理</span></span><br><span class="line">        CloseHandle(m_dataReadyEvent);</span><br><span class="line">        CloseHandle(m_bufferReadyEvent);</span><br><span class="line">        ReleaseMutex(m_mutex);</span><br><span class="line">        CloseHandle(m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> XpcDebugView::XpcDebugViewOutput(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (InitializeDBWin() == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line"></span><br><span class="line">        va_list argList;</span><br><span class="line">        va_start(argList, fm);</span><br><span class="line">        vsprintf_s(szMsg, fm, argList);</span><br><span class="line">        va_end(argList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向DBWIN_BUFFER写入数据</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_buffer-&gt;Data, szMsg);</span><br><span class="line">        <span class="keyword">if</span> (m_pFileLog)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(m_pFileLog, szMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UnInitializeDBWin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>( pop )</span></span><br></pre></td></tr></table></figure><h3 id="如何使用XpcDebugView类"><a href="#如何使用XpcDebugView类" class="headerlink" title="如何使用XpcDebugView类"></a>如何使用XpcDebugView类</h3><p>最简单的方式是定义一个XpcDebugView的全局变量，比如：<br>XpcDebugView myDebugview(“myLog.txt”);<br>输出Log信息的时候调用函数myDebugview.XpcDebugViewOutput(“%d %d %s\n”, 1, 2, “log”):<br>为了方便使用，可以在XpcDebugViewOutput的输出后面添加换行符，这样每次调用后就会自动换行了。<br>并且加上过滤字符串前缀，这样DebugView就只会捕获我们的输出了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> XpcDebugView::XpcDebugViewOutput(<span class="keyword">const</span> <span class="keyword">char</span>* fm, ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szMsg[MAX_PATH];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> szOutput[MAX_PATH];</span><br><span class="line"></span><br><span class="line">    va_list argList;</span><br><span class="line">    va_start(argList, fm);</span><br><span class="line">    vsprintf_s(szMsg, fm, argList);</span><br><span class="line">    va_end(argList);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(szOutput, <span class="string">"[hankpcxiao] "</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(szOutput, szMsg);</span><br><span class="line">    <span class="built_in">strcat</span>(szOutput, <span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_pFileLog)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(m_pFileLog, szOutput);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向DBWIN_BUFFER写入数据</span></span><br><span class="line">    <span class="keyword">if</span> (InitializeDBWin())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(m_buffer-&gt;Data, szOutput);</span><br><span class="line">        UnInitializeDBWin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先需要下载好DebugView程序，然后配置capture选项，另外是Filter字符串。最后为了保证在VS中调试程序时候，能够将调试信息输出到DebugView，需要使用DBWin通信进制。为此，我封装了一个Log类，在将Log输出到DebugView的同时也将Log输出到日志文件中。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>&#91;1]    <a href="https://community.sophos.com/kb/en-us/119577" target="_blank" rel="noopener">Frequently asked questions on the Microsoft application DebugView.exe</a><br>&#91;2]    <a href="http://dooof.lofter.com/tag/DebugView" target="_blank" rel="noopener">如何让OutputDebugString绕过调试器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DebugView简介&quot;&gt;&lt;a href=&quot;#DebugView简介&quot; class=&quot;headerlink&quot; title=&quot;DebugView简介&quot;&gt;&lt;/a&gt;DebugView简介&lt;/h3&gt;&lt;p&gt;DebugView是一个监视本地系统或者通过tcp/ip连接的网络系统的OutputDebugString输出的应用程序。DebugView不仅能够监视Win32应用的debug输出，还可以监视内核模型的debug输出。因此，如果使用OutputDebugString来打印调试信息的话，就可以在程序运行时候通过DebugView来实时显示程序的调试信息。&lt;br&gt;这种方式在某种意义上，比将Log打印到文件中，关闭程序后再查看Log输出的方式更加方便。而且可以将这两种调试程序的方式结合起来，既使用DebugView来实时显示调试信息，又将调试信息输出到Log文件中，方便以后分析。&lt;/p&gt;
&lt;h2 id=&quot;安装DebugView&quot;&gt;&lt;a href=&quot;#安装DebugView&quot; class=&quot;headerlink&quot; title=&quot;安装DebugView&quot;&gt;&lt;/a&gt;安装DebugView&lt;/h2&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://xiaopengcheng.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C/C++" scheme="http://xiaopengcheng.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"/>
    
    
      <category term="DebugView" scheme="http://xiaopengcheng.top/tags/DebugView/"/>
    
  </entry>
  
  <entry>
    <title>WebGL介绍</title>
    <link href="http://xiaopengcheng.top/2016/07/09/WebGL%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xiaopengcheng.top/2016/07/09/WebGL%E4%BB%8B%E7%BB%8D/</id>
    <published>2016-07-09T14:22:43.000Z</published>
    <updated>2019-12-19T16:22:33.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebGL概述"><a href="#WebGL概述" class="headerlink" title="WebGL概述"></a>WebGL概述</h2><p>什么是WebGL？WebGL简单的说就是在Web中渲染OpenGL的技术，也可以理解为把OpenGL的接口移植到浏览器中使用。具体的可以参考<a href="https://zh.wikipedia.org/wiki/WebGL" target="_blank" rel="noopener">WebGL的维基百科</a>。<br>使用WebGL可以通过编写网页代码在浏览器中渲染三维图像，而且不需要任何的插件，比如Adobe Flash Player等。<br>WebGL在最新的浏览器中得到了广泛支持。</p><h2 id="WebGL与HTML5的关系"><a href="#WebGL与HTML5的关系" class="headerlink" title="WebGL与HTML5的关系"></a>WebGL与HTML5的关系</h2><p><a href="https://zh.wikipedia.org/zh-cn/HTML5" target="_blank" rel="noopener">HTML5</a>是最新的HTML（超文本标记语言）的最新修订版本。<br>HTML5中新增了<code>&lt;canvas&gt;</code>标签用于绘图。在HTML5之前，只能使用<code>&lt;img&gt;</code>标签在网页中显示静态图片，如果要显示动画得借助于Adobe Flash Player等第三方插件。在HTML5中，可以在<code>&lt;canvas&gt;</code>标签上绘制二维图像，也可以使用WebGL绘制三维图像。<br>WebGL相对于HTML5的关系就好比是OpenGL库和三维应用程序的关系。WebGL只是提供了底层的渲染和计算的函数。</p><h2 id="WebGL与JavaScript的关系"><a href="#WebGL与JavaScript的关系" class="headerlink" title="WebGL与JavaScript的关系"></a>WebGL与JavaScript的关系</h2><p><a href="https://zh.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a>是一种浏览器中运行的动态脚本语言。WebGL也需要依靠JavaScript来操作浏览器中的对象。JavaScript与WebGL的关系类似于C或者C++和OpenGL的关系。</p><h2 id="WebGL与OpenGL的关系"><a href="#WebGL与OpenGL的关系" class="headerlink" title="WebGL与OpenGL的关系"></a>WebGL与OpenGL的关系</h2><p>WebGL基于OpenGL ES 2.0，WebGL实现了OpenGL ES 2.0的一个子集。WebGL使用Javascript进行内存管理，使用GLSL ES作为着色器语言。具体的关系可以参考下图：<br><img alt="WebGL与OpenGL" data-src="https://c2.staticflickr.com/8/7581/28115784971_1e25355d87_o.png"></p><h2 id="WebGL程序的结构"><a href="#WebGL程序的结构" class="headerlink" title="WebGL程序的结构"></a>WebGL程序的结构</h2><p>默认情况下，网页程序包括HTML和Javascript脚本语言两部分。但是WebGL程序，还有特殊的GLSL ES着色器语言部分。<br>具体结构如下图所示：<br><img alt="WebGL程序的结构" data-src="https://c1.staticflickr.com/9/8738/27578325223_d5b354ecce_o.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍WebGL的基本概念，以及WebGL和HTML、JavaScript、OpenGL之间的关系等。接下来的文章会介绍具体的WebGL编程知识。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>&#91;1] WebGL编程指南<br>&#91;2] 维基百科</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WebGL概述&quot;&gt;&lt;a href=&quot;#WebGL概述&quot; class=&quot;headerlink&quot; title=&quot;WebGL概述&quot;&gt;&lt;/a&gt;WebGL概述&lt;/h2&gt;&lt;p&gt;什么是WebGL？WebGL简单的说就是在Web中渲染OpenGL的技术，也可以理解为把OpenGL的接口移植到浏览器中使用。具体的可以参考&lt;a href=&quot;https://zh.wikipedia.org/wiki/WebGL&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebGL的维基百科&lt;/a&gt;。&lt;br&gt;使用WebGL可以通过编写网页代码在浏览器中渲染三维图像，而且不需要任何的插件，比如Adobe Flash Player等。&lt;br&gt;WebGL在最新的浏览器中得到了广泛支持。&lt;/p&gt;
&lt;h2 id=&quot;WebGL与HTML5的关系&quot;&gt;&lt;a href=&quot;#WebGL与HTML5的关系&quot; class=&quot;headerlink&quot; title=&quot;WebGL与HTML5的关系&quot;&gt;&lt;/a&gt;WebGL与HTML5的关系&lt;/h2&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="WebGL" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/WebGL/"/>
    
    
      <category term="WebGL" scheme="http://xiaopengcheng.top/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>使用MFC创建基于图片的不规则窗口程序</title>
    <link href="http://xiaopengcheng.top/2016/04/23/%E4%BD%BF%E7%94%A8MFC%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8D%E8%A7%84%E5%88%99%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
    <id>http://xiaopengcheng.top/2016/04/23/%E4%BD%BF%E7%94%A8MFC%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%8D%E8%A7%84%E5%88%99%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/</id>
    <published>2016-04-23T12:45:25.000Z</published>
    <updated>2021-12-26T07:59:41.585Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章定制IE浏览器弹窗中的外部窗口就是一个不规则窗口，这篇文章介绍下其是如何实现的。思路是根据这张图片创建一个不规则区域，然后将窗口的区域设置为该不规则区域。</p><h2 id="第一步，在资源文件rc中设置对话框的属性"><a href="#第一步，在资源文件rc中设置对话框的属性" class="headerlink" title="第一步，在资源文件rc中设置对话框的属性"></a><strong>第一步，在资源文件rc中设置对话框的属性</strong></h2><p>Border：None</p><p>Style：Popup</p><h2 id="第二步，导入背景图片到程序资源中"><a href="#第二步，导入背景图片到程序资源中" class="headerlink" title="第二步，导入背景图片到程序资源中"></a><strong>第二步，导入背景图片到程序资源中</strong></h2><p>最好是导入位图，虽然也可以导入其它格式的图片。假设导入位图ID为IDB_BITMAP_BACK。</p><h2 id="第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域"><a href="#第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域" class="headerlink" title="第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域"></a><strong>第三步，在OnInitialDlg函数中，创建区域，并将其设置为窗口区域</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OnInitDialog()中</span><br><span class="line">CRgn wndRgn;</span><br><span class="line"></span><br><span class="line">m_bitmapBack.LoadBitmap(IDB_BITMAP_BACK);</span><br><span class="line">CreateRgn(m_bitmapBack, RGB(255, 255, 255), wndRgn);</span><br><span class="line">SetWindowRgn(wndRgn, TRUE);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据图片创建区域的函数</span><br><span class="line">void CClientBrowserDlg::CreateRgn(CBitmap cBitmap, COLORREF dwColorKey, CRgn wndRgn)  </span><br><span class="line">&#123;  </span><br><span class="line">    CDC *pDC &#x3D; this-&gt;GetDC();  </span><br><span class="line">    CDC memDC;  </span><br><span class="line">    &#x2F;&#x2F;创建与传入DC兼容的临时DC  </span><br><span class="line">    memDC.CreateCompatibleDC(pDC);  </span><br><span class="line"></span><br><span class="line">    CBitmap *pOldMemBmp&#x3D;NULL;  </span><br><span class="line">    &#x2F;&#x2F;将位图选入临时DC  </span><br><span class="line">    pOldMemBmp &#x3D; memDC.SelectObject(cBitmap);  </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建总的窗体区域，初始region为0  </span><br><span class="line">    wndRgn.CreateRectRgn(0,0,0,0);  </span><br><span class="line"></span><br><span class="line">    BITMAP bit;     </span><br><span class="line">    cBitmap.GetBitmap (bit);&#x2F;&#x2F;取得位图参数，这里要用到位图的长和宽       </span><br><span class="line"></span><br><span class="line">    int y;  </span><br><span class="line">    for(y&#x3D;0; y &lt;&#x3D; bit.bmHeight; y++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CRgn rgnTemp;  </span><br><span class="line">        int iX &#x3D; 0;  </span><br><span class="line">        do  </span><br><span class="line">        &#123;  </span><br><span class="line">            &#x2F;&#x2F;跳过透明色找到下一个非透明色的点.  </span><br><span class="line">            while (iX &lt;&#x3D; bit.bmWidth   memDC.GetPixel(iX, y) &#x3D;&#x3D; dwColorKey)  </span><br><span class="line">                iX++;  </span><br><span class="line">            &#x2F;&#x2F;记住这个起始点  </span><br><span class="line">            int iLeftX &#x3D; iX;  </span><br><span class="line">            &#x2F;&#x2F;寻找下个透明色的点  </span><br><span class="line">            while (iX &lt;&#x3D; bit.bmWidth   memDC.GetPixel(iX, y) !&#x3D; dwColorKey)  </span><br><span class="line">                ++iX;  </span><br><span class="line">            &#x2F;&#x2F;创建一个包含起点与重点间高为1像素的临时“region”  </span><br><span class="line">            rgnTemp.CreateRectRgn(iLeftX, y, iX, y+1);  </span><br><span class="line">            &#x2F;&#x2F;合并到主&quot;region&quot;.  </span><br><span class="line">            wndRgn.CombineRgn(wndRgn, rgnTemp, RGN_OR);  </span><br><span class="line">            &#x2F;&#x2F;删除临时&quot;region&quot;,否则下次创建时和出错  </span><br><span class="line">            rgnTemp.DeleteObject();  </span><br><span class="line">        &#125; while(iX &lt; bit.bmWidth );  </span><br><span class="line">        iX &#x3D; 0;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    if(pOldMemBmp)  </span><br><span class="line">        memDC.SelectObject(pOldMemBmp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四步，在OnPaint-绘制窗口背景图片"><a href="#第四步，在OnPaint-绘制窗口背景图片" class="headerlink" title="第四步，在OnPaint()绘制窗口背景图片"></a><strong>第四步，在OnPaint()绘制窗口背景图片</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">void CClientBrowserDlg::OnPaint()</span><br><span class="line">&#123;</span><br><span class="line">    if (IsIconic())</span><br><span class="line">    &#123;</span><br><span class="line">        CPaintDC dc(this); &#x2F;&#x2F; device context for painting</span><br><span class="line"></span><br><span class="line">        SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Center icon in client rectangle</span><br><span class="line">        int cxIcon &#x3D; GetSystemMetrics(SM_CXICON);</span><br><span class="line">        int cyIcon &#x3D; GetSystemMetrics(SM_CYICON);</span><br><span class="line">        CRect rect;</span><br><span class="line">        GetClientRect(rect);</span><br><span class="line">        int x &#x3D; (rect.Width() - cxIcon + 1) &#x2F; 2;</span><br><span class="line">        int y &#x3D; (rect.Height() - cyIcon + 1) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Draw the icon</span><br><span class="line">        dc.DrawIcon(x, y, m_hIcon);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;选入DC  </span><br><span class="line">        CClientDC cdc(this);</span><br><span class="line">        CDC comdc;  </span><br><span class="line">        comdc.CreateCompatibleDC(cdc);  </span><br><span class="line">        comdc.SelectObject(m_bitmapBack);  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;生成BITMAP  </span><br><span class="line">        BITMAP bit;  </span><br><span class="line">        m_bitmapBack.GetBitmap(bit);  </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;客户区域  </span><br><span class="line">        CRect rect;  </span><br><span class="line">        GetClientRect(rect);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用客户区的DC绘制所生成的BITMAP，并适应为窗口大小  </span><br><span class="line">        cdc.StretchBlt(0,0,rect.Width(),rect.Height(),comdc,0,0,bit.bmWidth,bit.bmHeight,SRCCOPY);</span><br><span class="line"></span><br><span class="line">        CDialog::OnPaint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五步，点击客户区移动窗口"><a href="#第五步，点击客户区移动窗口" class="headerlink" title="第五步，点击客户区移动窗口"></a><strong>第五步，点击客户区移动窗口</strong></h2><p>这一点还是有意义的，比如上一篇定制IE浏览器窗口的文章，其外部窗口就是使用这里介绍的不规则窗体。不规则窗体由于是无边框的，因此无法点击边框移动窗口了。因此，设置点击客户端移动是有意义的。而<strong>且窗口的内部区域已经被浏览器控件占据了，只有外部的边界区域可以点击到，因此这样刚好模拟出了点击正常窗口边框的效果。</strong></p><p>设置客户区可以点击的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CClientBrowserDlg::OnNcHitTest(CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: Add your message handler code here and&#x2F;or call default</span><br><span class="line">    &#x2F;&#x2F; 取得鼠标所在的窗口区域</span><br><span class="line">    UINT nHitTest &#x3D; CDialog::OnNcHitTest(point);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果鼠标在窗口客户区，则返回标题条代号给Windows</span><br><span class="line">    &#x2F;&#x2F; 使Windows按鼠标在标题条上类进行处理，即可单击移动窗口</span><br><span class="line">    return (nHitTest &#x3D;&#x3D; HTCLIENT) ? HTCAPTION : nHitTest;</span><br><span class="line">    &#x2F;&#x2F;return CDialog::OnNcHitTest(point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章定制IE浏览器弹窗中的外部窗口就是一个不规则窗口，这篇文章介绍下其是如何实现的。思路是根据这张图片创建一个不规则区域，然后将窗口的区域设置为该不规则区域。&lt;/p&gt;
&lt;h2 id=&quot;第一步，在资源文件rc中设置对话框的属性&quot;&gt;&lt;a href=&quot;#第一步，在资源文件rc中设置对话框的属性&quot; class=&quot;headerlink&quot; title=&quot;第一步，在资源文件rc中设置对话框的属性&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一步，在资源文件rc中设置对话框的属性&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Border：None&lt;/p&gt;
    
    </summary>
    
    
      <category term="MFC" scheme="http://xiaopengcheng.top/categories/MFC/"/>
    
    
      <category term="MFC" scheme="http://xiaopengcheng.top/tags/MFC/"/>
    
  </entry>
  
  <entry>
    <title>使用CWebBrowser2定制IE浏览器窗口</title>
    <link href="http://xiaopengcheng.top/2016/04/21/%E4%BD%BF%E7%94%A8CWebBrowser2%E5%AE%9A%E5%88%B6IE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://xiaopengcheng.top/2016/04/21/%E4%BD%BF%E7%94%A8CWebBrowser2%E5%AE%9A%E5%88%B6IE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2016-04-21T13:06:41.000Z</published>
    <updated>2019-12-19T16:22:33.320Z</updated>
    
    <content type="html"><![CDATA[<p>在客户端程序中嵌入浏览器，有两种方式，一种是使用微软的IE控件，一种是使用CEF。这里介绍的是使用CWebBrowser2类（在MFC程序中插入IE的Active控件生成），定制内嵌浏览器窗口的一些经验。</p><p>本文的经验积累于实现逆战退出游戏时候的广告弹窗的过程中，下面Show一下这个自带萌妹子的弹窗吧。</p><p><img alt data-src="https://farm2.staticflickr.com/1575/25953542404_086b3470a8_o.png"></p><p>这是一个无边框的Windows对话框程序，并且是一个基于背景图片的不规则弹窗窗口；内部嵌入了一个浏览器控件窗口，这个漂亮的妹子就是浏览器控件打开的网页显示出来的。对这个妹子有兴趣的，可以去玩一把逆战，退出客户端的时候就会出来这个弹窗了。</p><p>下面介绍一些关于实现该弹窗浏览器的Tips。</p><h2 id="一、如何获得CWebBrowser2"><a href="#一、如何获得CWebBrowser2" class="headerlink" title="一、如何获得CWebBrowser2"></a>一、如何获得CWebBrowser2</h2><p>方法1：网络搜索下载，比如我以前的一篇博文里面有下载链接：vc内嵌浏览器。</p><p>方法2：在MFC程序中插入IE对应的Activex控件，工程中就会生成这个类。</p><p>为了定制浏览器窗口，我继承了该类，自定义了浏览器窗口类CYXBrwser。</p><h2 id="二、让浏览器窗口适应对话框窗口大小"><a href="#二、让浏览器窗口适应对话框窗口大小" class="headerlink" title="二、让浏览器窗口适应对话框窗口大小"></a>二、让浏览器窗口适应对话框窗口大小</h2><p>在对话框类的OnInitDialog()函数中，添加如下代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m_pBrowser = new CYXBrowser(); </span><br><span class="line">RECT rect; </span><br><span class="line">GetClientRect(rect);</span><br><span class="line">rect.left += 8;</span><br><span class="line">rect.right -= 8;</span><br><span class="line">rect.top += 8;</span><br><span class="line">rect.bottom -= 1;</span><br><span class="line">m_pBrowser-&gt;Create(TEXT("NZBrowser"), WS_CHILD | WS_VISIBLE, rect, this, MY_IEBROWSER_ID);</span><br></pre></td></tr></table></figure><p>注意，rect的大小需要调节来获得需要的效果。</p><h2 id="三、屏蔽右键"><a href="#三、屏蔽右键" class="headerlink" title="三、屏蔽右键"></a>三、屏蔽右键</h2><p>有种比较的方法是在PreTranslateMessage中过滤WM_RBUTTONDOWN消息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏蔽右键</span></span><br><span class="line">BOOL CYXBrowser::PreTranslateMessage(MSG* pMsg) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Add your specialized code here and/or call the base class</span></span><br><span class="line">    <span class="keyword">if</span>(WM_RBUTTONDOWN == pMsg-&gt;message)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//AfxMessageBox(_T("Right Menu!"));</span></span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    return CWnd::PreTranslateMessage(pMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、隐藏网页的滚动条"><a href="#四、隐藏网页的滚动条" class="headerlink" title="四、隐藏网页的滚动条"></a>四、隐藏网页的滚动条</h2><p>这是最难处理的一个地方。不仅仅需要修改程序，而且需要web端的配合。</p><p>第一步：添加DocumentComplete事件响应。在C<em>*</em>Dlg的cpp中添加如下宏：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">BEGIN_EVENTSINK_MAP</span><span class="params">(CClientBrowserDlg, CDialog)</span></span></span><br><span class="line">    ON_EVENT(CClientBrowserDlg, MY_IEBROWSER_ID, DISPID_DOCUMENTCOMPLETE, DocumentComplete, VTS_DISPATCH VTS_PVARIANT)</span><br><span class="line"><span class="function"><span class="title">END_EVENTSINK_MAP</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>注意，CClientBrowserDlg是响应函数所在的类，MY_IEBROWSER_ID是二中指定的浏览器窗口ID。DocumentComplete是CClientBrowserDlg中的响应该事件的成员函数。</p><p>第二步：实现该函数，直接贴代码。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void CClientBrowserDlg::DocumentComplete(LPDISPATCH pDisp, VARIANT* URL)</span><br><span class="line">&#123;</span><br><span class="line">    UNUSED_ALWAYS(pDisp);</span><br><span class="line">    ASSERT(V_VT(URL) == VT_BSTR);</span><br><span class="line"></span><br><span class="line">    CString str(V_BSTR(URL));</span><br><span class="line">    m_pBrowser-&gt;OnDocumentComplete(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnDocumentComplete(LPCTSTR lpszURL)</span><br><span class="line">&#123;</span><br><span class="line">    m_bDocumentComplete = true;</span><br><span class="line">    HideScrollBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::HideScrollBar()</span><br><span class="line">&#123;</span><br><span class="line">    HRESULT hr;</span><br><span class="line">    IDispatch *pDisp = GetDocument();</span><br><span class="line">    IHTMLDocument2 *pDocument = NULL;</span><br><span class="line">    IHTMLElement*   pEl;  </span><br><span class="line">    IHTMLBodyElement   *pBodyEl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDisp)</span><br><span class="line">    &#123;</span><br><span class="line">        hr = pDisp-&gt;QueryInterface(IID_IHTMLDocument2, (void**)pDocument);</span><br><span class="line">        <span class="keyword">if</span> (!SUCCEEDED(hr))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pDocument  SUCCEEDED(pDocument-&gt;get_body(pEl)))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(pEl  SUCCEEDED(pEl-&gt;QueryInterface(IID_IHTMLBodyElement, (void**)pBodyEl)))  </span><br><span class="line">        &#123;  </span><br><span class="line">            pBodyEl-&gt;put_scroll(L"no");//去滚动条</span><br><span class="line">        &#125;  </span><br><span class="line">        IHTMLStyle   *phtmlStyle;  </span><br><span class="line">        pEl-&gt;get_style(phtmlStyle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(phtmlStyle  != NULL)  </span><br><span class="line">        &#123;  </span><br><span class="line">            phtmlStyle-&gt;put_overflow(L"hidden");</span><br><span class="line">            <span class="comment">//需要设置网页源码DOCTYPE为&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span></span><br><span class="line">            <span class="comment">//去除边框才有效</span></span><br><span class="line">            phtmlStyle-&gt;put_border(L"none");//   去除边框</span><br><span class="line"></span><br><span class="line">            phtmlStyle-&gt;Release();  </span><br><span class="line">            pEl-&gt;Release();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数是HideScrollBar()。</p><p>第三步：在浏览器内嵌网页的最前面添加，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span></span><br></pre></td></tr></table></figure><p>注意，第三步是不可缺少的。</p><h2 id="五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框"><a href="#五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框" class="headerlink" title="五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框**"></a>五、屏蔽多次点击浏览器窗口的提示：”服务器正在运行中”要选择”切换到…”或”重试”的对话框**</h2><p>在CClientBrowserDlg::OnInitDialog()中添加如下代码，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*屏蔽掉"服务器正在运行中"要选择"切换到..."或"重试"的对话框*/</span></span><br><span class="line">AfxOleGetMessageFilter()-&gt;EnableBusyDialog(FALSE);</span><br><span class="line">AfxOleGetMessageFilter()-&gt;SetBusyReply(SERVERCALL_RETRYLATER);</span><br><span class="line">AfxOleGetMessageFilter()-&gt;EnableNotRespondingDialog(TRUE);</span><br><span class="line">AfxOleGetMessageFilter()-&gt;SetMessagePendingDelay(-1);</span><br></pre></td></tr></table></figure><h2 id="六、点击网页打开系统默认浏览器"><a href="#六、点击网页打开系统默认浏览器" class="headerlink" title="六、点击网页打开系统默认浏览器"></a>六、点击网页打开系统默认浏览器</h2><p>第一步：绑定NEWWINDOW2事件。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ON_EVENT</span><span class="params">(CClientBrowserDlg, MY_IEBROWSER_ID, DISPID_NEWWINDOW2, OnNewWindow2, VTS_PDISPATCH VTS_PBOOL)</span></span></span><br></pre></td></tr></table></figure><p>第二步：设置该OnNewWindow2的*bCancel为true，并且调用ShellExecute打开网页。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void CClientBrowserDlg::OnNewWindow2(LPDISPATCH* ppDisp, BOOL* bCancel)</span><br><span class="line">&#123;</span><br><span class="line">    m_pBrowser-&gt;OnNewWindow2(ppDisp, bCancel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnNewWindow2(LPDISPATCH* ppDisp, BOOL* bCancel)</span><br><span class="line">&#123;</span><br><span class="line">    *bCancel = TRUE;//禁止弹出新窗口（因为会使用IE弹窗）</span><br><span class="line"></span><br><span class="line">    HRESULT hr;</span><br><span class="line">    IDispatch *pDisp = GetDocument();</span><br><span class="line">    IHTMLDocument2 *pHTMLDocument2 = NULL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pDisp)</span><br><span class="line">    &#123;</span><br><span class="line">        hr = pDisp-&gt;QueryInterface(IID_IHTMLDocument2, (void**)pHTMLDocument2);</span><br><span class="line">        <span class="keyword">if</span> (!SUCCEEDED(hr))</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHTMLDocument2 != NULL)  </span><br><span class="line">    &#123;  </span><br><span class="line">        CComPtr&lt;IHTMLElement&gt; pIHTMLElement;  </span><br><span class="line">        pHTMLDocument2-&gt;get_activeElement(pIHTMLElement);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pIHTMLElement != NULL)  </span><br><span class="line">        &#123;  </span><br><span class="line">            variant_t url;  </span><br><span class="line">            hr = pIHTMLElement-&gt;getAttribute(L"href", 0, url);  </span><br><span class="line">            <span class="keyword">if</span> (SUCCEEDED(hr))  </span><br><span class="line">            &#123;  </span><br><span class="line">                CString strURL(V_BSTR(url));</span><br><span class="line">                <span class="comment">//打开默认浏览器</span></span><br><span class="line">                ShellExecute(m_hWndOwner, NULL, strURL, NULL, NULL, SW_NORMAL);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理了六，五也就不需要了，因为点击网页不会再弹出IE浏览器了。</p><h2 id="七、为网页元素的添加事件处理：比如web按钮的点击等"><a href="#七、为网页元素的添加事件处理：比如web按钮的点击等" class="headerlink" title="七、为网页元素的添加事件处理：比如web按钮的点击等"></a>七、为网页元素的添加事件处理：比如web按钮的点击等</h2><p>第一步：继承CCmdTarget新建类CHtmlEventHandle，代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pragma</span> once</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#import</span> &lt;mshtml.tlb&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CHtmlEventHandle command target</span></span><br><span class="line">class CYXBrowser;</span><br><span class="line"></span><br><span class="line">class CHtmlEventHandle : public CCmdTarget</span><br><span class="line">&#123;</span><br><span class="line">    DECLARE_DYNAMIC(CHtmlEventHandle)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    CHtmlEventHandle();</span><br><span class="line">    virtual ~CHtmlEventHandle();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void SetWnd(CWnd* pWnd) &#123; m_pWnd = pWnd;&#125;</span><br><span class="line">    void SetWebBrowser(CYXBrowser* pWebBroswer) &#123; m_pWebBrowser = pWebBroswer; &#125;</span><br><span class="line">    <span class="comment">// 消息处理函数</span></span><br><span class="line">    void OnClick(MSHTML::IHTMLEventObjPtr pEvtObj);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CWnd* m_pWnd;</span><br><span class="line">    CYXBrowser* m_pWebBrowser;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    DECLARE_MESSAGE_MAP()</span><br><span class="line">    DECLARE_DISPATCH_MAP()</span><br><span class="line">    DECLARE_INTERFACE_MAP()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HtmlEventHandle.cpp : implementation file</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"stdafx.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"ClientBrowser.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"HtmlEventHandle.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"mshtmdid.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"MsHTML.h"</span></span><br><span class="line"><span class="selector-id">#include</span> <span class="string">"YXBrowser.h"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHtmlEventHandle</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">IMPLEMENT_DYNAMIC</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line"></span><br><span class="line">CHtmlEventHandle::CHtmlEventHandle()</span><br><span class="line">&#123;</span><br><span class="line">    EnableAutomation();  // 重要：激活 IDispatch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHtmlEventHandle::~CHtmlEventHandle()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">BEGIN_MESSAGE_MAP</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line"><span class="function"><span class="title">END_MESSAGE_MAP</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">BEGIN_DISPATCH_MAP</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line">    DISP_FUNCTION_ID(CHtmlEventHandle, <span class="string">"HTMLELEMENTEVENTS2_ONCLICK"</span>,</span><br><span class="line">    DISPID_HTMLELEMENTEVENTS2_ONCLICK, OnClick,</span><br><span class="line">    VT_EMPTY, VTS_DISPATCH)</span><br><span class="line"><span class="function"><span class="title">END_DISPATCH_MAP</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">BEGIN_INTERFACE_MAP</span><span class="params">(CHtmlEventHandle, CCmdTarget)</span></span></span><br><span class="line">    INTERFACE_PART(CHtmlEventHandle,</span><br><span class="line">    DIID_HTMLButtonElementEvents2, Dispatch)</span><br><span class="line"><span class="function"><span class="title">END_INTERFACE_MAP</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHtmlEventHandle message handlers</span></span><br><span class="line"></span><br><span class="line">void CHtmlEventHandle::OnClick(MSHTML::IHTMLEventObjPtr pEvtObj)</span><br><span class="line">&#123;</span><br><span class="line">    MSHTML::IHTMLElementPtr pElement =</span><br><span class="line">        pEvtObj-&gt;GetsrcElement(); // 事件发生的对象元素</span><br><span class="line">    while(pElement) <span class="comment">// 逐层向上检查</span></span><br><span class="line">    &#123;</span><br><span class="line">        _bstr_t strId;</span><br><span class="line">        pElement-&gt;get_id(strId.GetBSTR());</span><br><span class="line">        <span class="keyword">if</span>(_bstr_t(HTML_CLOSE_BUTTON) == strId)<span class="comment">//响应关闭按钮点击</span></span><br><span class="line">        &#123;</span><br><span class="line">            PostQuitMessage(0);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_bstr_t(HTML_SET_BUTTON) == strId)<span class="comment">//30天不弹出设置</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pElement = pElement-&gt;GetparentElement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意那几个宏。宏的具体解释我没有去深究，仿照DISP_FUNCTION_ID可以为点击外的其它事件添加处理。</span></span><br></pre></td></tr></table></figure><p>第二步：在CYXBrowser中注册这个web事件处理类。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加成员</span></span><br><span class="line">private:</span><br><span class="line">    void InstallEventHandler();</span><br><span class="line">    void UninstallEventHandler();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CHtmlEventHandle *m_pEventHandler;</span><br><span class="line">    DWORD m_dwDocCookie;    // 用于卸载事件响应函数</span><br><span class="line">    IDispatch *m_pDispDoc;  // 用于卸载事件响应函数</span><br><span class="line">    bool m_bDocumentComplete;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相应的函数实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装响应函数。省略了一些失败判断以突出主要步骤</span></span><br><span class="line">void CYXBrowser::InstallEventHandler()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_dwDocCookie)   <span class="comment">// 已安装，卸载先。最后一次安装的才有效</span></span><br><span class="line">        UninstallEventHandler();</span><br><span class="line"></span><br><span class="line">    m_pDispDoc = GetDocument();</span><br><span class="line">    IConnectionPointContainerPtr pCPC = m_pDispDoc;</span><br><span class="line">    IConnectionPointPtr pCP;</span><br><span class="line">    <span class="comment">// 找到安装点</span></span><br><span class="line">    pCPC-&gt;FindConnectionPoint(DIID_HTMLDocumentEvents2, pCP);</span><br><span class="line">    IUnknown* pUnk = m_pEventHandler-&gt;GetInterface(IID_IUnknown);</span><br><span class="line">    <span class="comment">//安装</span></span><br><span class="line">    HRESULT hr = pCP-&gt;Advise(pUnk, m_dwDocCookie);</span><br><span class="line">    <span class="keyword">if</span>(!SUCCEEDED(hr))  <span class="comment">// 安装失败</span></span><br><span class="line">        m_dwDocCookie = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载响应函数。省略了一些失败判断以突出主要步骤</span></span><br><span class="line">void CYXBrowser::UninstallEventHandler()</span><br><span class="line">&#123;</span><br><span class="line">    if(0 == m_dwDocCookie) return;</span><br><span class="line"></span><br><span class="line">    IConnectionPointContainerPtr pCPC = m_pDispDoc;</span><br><span class="line">    IConnectionPointPtr pCP;</span><br><span class="line">    pCPC-&gt;FindConnectionPoint(DIID_HTMLDocumentEvents2, pCP);</span><br><span class="line">    HRESULT hr = pCP-&gt;Unadvise(m_dwDocCookie);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在OnDocumentComplete中安装事件处理</span></span><br><span class="line">CYXBrowser::CYXBrowser()</span><br><span class="line">&#123;</span><br><span class="line">    m_pEventHandler = new CHtmlEventHandle;</span><br><span class="line">    m_pEventHandler-&gt;SetWnd(m_pParent);</span><br><span class="line">    m_pEventHandler-&gt;SetWebBrowser(this);</span><br><span class="line">    m_dwDocCookie = 0;    // 用于卸载事件响应函数</span><br><span class="line">    m_pDispDoc = NULL;  // 用于卸载事件响应函数</span><br><span class="line">    m_bDocumentComplete = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnDocumentComplete(LPCTSTR lpszURL)</span><br><span class="line">&#123;</span><br><span class="line">    m_bDocumentComplete = true;</span><br><span class="line">    HideScrollBar();</span><br><span class="line">    InstallEventHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在OnBeforeNavigate2和OnDestroy中卸载处理</span></span><br><span class="line"><span class="comment">// 在 BeforeNavigate2 和 Destroy 事件中卸载响应函数</span></span><br><span class="line">void CYXBrowser::OnBeforeNavigate2(LPCTSTR lpszURL, DWORD nFlags,</span><br><span class="line">                                   LPCTSTR lpszTargetFrameName, CByteArray baPostedData,</span><br><span class="line">                                   LPCTSTR lpszHeaders, BOOL* pbCancel)</span><br><span class="line">&#123;</span><br><span class="line">    UninstallEventHandler();</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CYXBrowser::OnDestroy()</span><br><span class="line">&#123;</span><br><span class="line">    UninstallEventHandler();</span><br><span class="line">    CWebBrowser2::OnDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就可以在void CHtmlEventHandle::OnClick(MSHTML::IHTMLEventObjPtr pEvtObj)函数内捕获网页按钮之类的点击了。处理代码的思路是从当前元素开始，不断往上查找父元素，直到匹配的元素ID为止。</p><h2 id="八、判断url是否有效，如果无效则打开资源url，防止Web页面为空"><a href="#八、判断url是否有效，如果无效则打开资源url，防止Web页面为空" class="headerlink" title="八、判断url是否有效，如果无效则打开资源url，防止Web页面为空"></a>八、判断url是否有效，如果无效则打开资源url，防止Web页面为空</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用该函数判断url是否能打开</span></span><br><span class="line">bool CYXBrowser::IsUrlAvailable(CString strUrl)</span><br><span class="line">&#123;</span><br><span class="line">    CInternetSession* session = new CInternetSession(); </span><br><span class="line">    CInternetFile* file = NULL; </span><br><span class="line">    bool bAvailable = true;</span><br><span class="line"></span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        file = (CInternetFile*)session-&gt;OpenURL(strUrl); </span><br><span class="line">    &#125;</span><br><span class="line">    catch (CInternetException*)</span><br><span class="line">    &#123;</span><br><span class="line">        bAvailable = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete session;</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">    &#123;</span><br><span class="line">        bAvailable = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bAvailable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在对话框初始化时候，判断外网url是否能打开，如果不能则加载资源内的url</span></span><br><span class="line"><span class="keyword">if</span> (m_pBrowser-&gt;IsUrlAvailable(theApp.m_strUrl))</span><br><span class="line">&#123;</span><br><span class="line">    m_pBrowser-&gt;Navigate2(theApp.m_strUrl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    TCHAR szModule[MAX_PATH];</span><br><span class="line">    GetModuleFileName(theApp.m_hInstance, szModule, MAX_PATH);</span><br><span class="line">    theApp.m_strUrl.Format(_T("res://%s/%s"), szModule, theApp.m_strLocalUrl);</span><br><span class="line">    m_pBrowser-&gt;Navigate2(theApp.m_strUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意资源url的格式是res://模块名/网页名，因此需要在该程序中导入自定义的资源，并且将其命名为theApp.m_strLocalUrl代表的字符串值，比如”NZ.HTML”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在客户端程序中嵌入浏览器，有两种方式，一种是使用微软的IE控件，一种是使用CEF。这里介绍的是使用CWebBrowser2类（在MFC程序中插入IE的Active控件生成），定制内嵌浏览器窗口的一些经验。&lt;/p&gt;
&lt;p&gt;本文的经验积累于实现逆战退出游戏时候的广告弹窗的过程中，下面Show一下这个自带萌妹子的弹窗吧。&lt;/p&gt;
&lt;p&gt;&lt;img alt data-src=&quot;https://farm2.staticflickr.com/1575/25953542404_086b3470a8_o.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MFC" scheme="http://xiaopengcheng.top/categories/MFC/"/>
    
    
      <category term="CWebBrowser2" scheme="http://xiaopengcheng.top/tags/CWebBrowser2/"/>
    
  </entry>
  
  <entry>
    <title>三维表面上基于笔画的纹理交互式合成</title>
    <link href="http://xiaopengcheng.top/2016/03/17/%E4%B8%89%E7%BB%B4%E8%A1%A8%E9%9D%A2%E4%B8%8A%E5%9F%BA%E4%BA%8E%E7%AC%94%E7%94%BB%E7%9A%84%E7%BA%B9%E7%90%86%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%90%88%E6%88%90/"/>
    <id>http://xiaopengcheng.top/2016/03/17/%E4%B8%89%E7%BB%B4%E8%A1%A8%E9%9D%A2%E4%B8%8A%E5%9F%BA%E4%BA%8E%E7%AC%94%E7%94%BB%E7%9A%84%E7%BA%B9%E7%90%86%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%90%88%E6%88%90/</id>
    <published>2016-03-17T12:41:27.000Z</published>
    <updated>2019-12-19T17:57:28.518Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的毕业论文题目，两年前的东西了，来出来纪念下吧。后面附演讲pdf。</p><p>这讲的是在一个三维模型上手绘纹理的故事，纹理是用户选择的样本纹理。因此，实际上我的毕业论文就是做了一个上纹理的工具。用户选择不同的模型，同时选择不同的样本纹理（符合马尔科夫随机场的样本纹理），就可以用鼠标在模型上刷三维纹理了。</p><p>看起来挺好玩的，实际上整个系统的实现过程非常繁杂。这个系统主要用了两个算法，一个是扩展指数映射计算笔画的局部参数化，另外一个是根据样本纹理动态合成新的大纹理（要贴到笔画区域），这个用了并行可控制纹理合成算法，在约束条件下做了特殊实现。由于扩展指数映射用的是他人的实现代码，严重影响了整个系统的速度，也影响了我后面做实验的效果，非常恶心，所以不到无奈时候，千万不要用所谓的牛人的资源。</p><p>系统流程：</p><p><img alt data-src="https://c2.staticflickr.com/8/7736/27418072966_11479198e3_o.png"></p><p>最终效果：</p><p><a href="https://c2.staticflickr.com/8/7178/27380808391_b2dabb9474_o.png" target="_blank" rel="noopener"><img alt data-src="https://c2.staticflickr.com/8/7178/27380808391_b2dabb9474_o.png"></a></p><p><a href="https://c2.staticflickr.com/8/7678/26845040783_b243d6bff6_o.png" target="_blank" rel="noopener"><img alt data-src="https://c2.staticflickr.com/8/7678/26845040783_b243d6bff6_o.png"></a></p><p>PDF下载：<a href="https://pan.baidu.com/s/1dDTrBIL" target="_blank" rel="noopener">三维表面上基于笔画的纹理交互式合成</a></p><p>预览如下：</p><iframe src="https://onedrive.live.com/embed?cid=4330CD349D9ADD44&amp;resid=4330CD349D9ADD44%21366&amp;authkey=AIXNiZJrZHuLNX8&amp;em=2&amp;wdStartOn=1" width="800" height="700" frameborder="0" allowfullscreen="allowfullscreen"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我的毕业论文题目，两年前的东西了，来出来纪念下吧。后面附演讲pdf。&lt;/p&gt;
&lt;p&gt;这讲的是在一个三维模型上手绘纹理的故事，纹理是用户选择的样本纹理。因此，实际上我的毕业论文就是做了一个上纹理的工具。用户选择不同的模型，同时选择不同的样本纹理（符合马尔科夫随机场的样本纹理），就可以用鼠标在模型上刷三维纹理了。&lt;/p&gt;
&lt;p&gt;看起来挺好玩的，实际上整个系统的实现过程非常繁杂。这个系统主要用了两个算法，一个是扩展指数映射计算笔画的局部参数化，另外一个是根据样本纹理动态合成新的大纹理（要贴到笔画区域），这个用了并行可控制纹理合成算法，在约束条件下做了特殊实现。由于扩展指数映射用的是他人的实现代码，严重影响了整个系统的速度，也影响了我后面做实验的效果，非常恶心，所以不到无奈时候，千万不要用所谓的牛人的资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图形学" scheme="http://xiaopengcheng.top/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="纹理" scheme="http://xiaopengcheng.top/tags/%E7%BA%B9%E7%90%86/"/>
    
      <category term="三维模型处理" scheme="http://xiaopengcheng.top/tags/%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B%E5%A4%84%E7%90%86/"/>
    
      <category term="纹理合成" scheme="http://xiaopengcheng.top/tags/%E7%BA%B9%E7%90%86%E5%90%88%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>C/C++编写的程序启动过程</title>
    <link href="http://xiaopengcheng.top/2016/01/16/C%20C++%E7%BC%96%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://xiaopengcheng.top/2016/01/16/C%20C++%E7%BC%96%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2016-01-16T09:21:46.000Z</published>
    <updated>2021-12-26T12:46:31.234Z</updated>
    
    <content type="html"><![CDATA[<p>记得以前学汇编和PE文件的时候知道，系统不会直接调用我们编写的main，而是调用指定的入口地址。实际上这个入口地址，是在链接时候指定的，MS C/C++中使用链接命令/entry:function可以修改默认设置。</p><p>那么，默认情况下，我们使用VC编写的应用程序使用的是什么入口函数了？</p><div class="table-container"><table><thead><tr><th>函数</th><th>默认</th></tr></thead><tbody><tr><td><strong>mainCRTStartup</strong> (or <strong>wmainCRTStartup</strong>)</td><td>An application using /SUBSYSTEM:<strong>CONSOLE</strong>; calls <strong>main</strong> (or <strong>wmain</strong>)</td></tr><tr><td><strong>WinMainCRTStartup</strong> (or <strong>wWinMainCRTStartup</strong>)</td><td>An application using /SUBSYSTEM:<strong>WINDOWS</strong>; calls <strong>WinMain</strong> (or <strong>wWinMain</strong>), which must be defined with <strong>__stdcall</strong></td></tr></tbody></table></div><p>注意，区分入口函数和主函数（main，WinMain）。</p><p>默认情况下，控制台程序使用<strong>mainCRTStartup</strong>作为入口函数，窗口程序使用<strong>WinMainCRTStartup</strong>作为入口函数。同时，这两个函数都有对应的Unicode版本（前缀加w)。</p><p>现在要考虑的是，这些启动函数都做了什么事情？</p><p>在crtexe.c文件中可以找到这几个启动函数的定义，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _WINMAIN_</span><br><span class="line"></span><br><span class="line">#ifdef WPRFLAG</span><br><span class="line">int wWinMainCRTStartup(</span><br><span class="line">#else  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line">int WinMainCRTStartup(</span><br><span class="line">#endif  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line"></span><br><span class="line">#else  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line"></span><br><span class="line">#ifdef WPRFLAG</span><br><span class="line">int wmainCRTStartup(</span><br><span class="line">#else  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line">int mainCRTStartup(</span><br><span class="line">#endif  &#x2F;* WPRFLAG *&#x2F;</span><br><span class="line"></span><br><span class="line">#endif  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line">        void</span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * The &#x2F;GS security cookie must be initialized before any exception</span><br><span class="line">         * handling targetting the current image is registered.  No function</span><br><span class="line">         * using exception handling can be called in the current image until</span><br><span class="line">         * after __security_init_cookie has been called.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        __security_init_cookie();</span><br><span class="line"></span><br><span class="line">        return __tmainCRTStartup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，实际上是根据平台（Windows或者Console），多字节还是Unicode，生成不同的默认入口函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">__declspec(noinline)</span><br><span class="line">int</span><br><span class="line">__tmainCRTStartup(</span><br><span class="line">         void</span><br><span class="line">         )</span><br><span class="line">&#123;</span><br><span class="line">        int initret;</span><br><span class="line">        int mainret&#x3D;0;</span><br><span class="line">        int managedapp;</span><br><span class="line">#ifdef _WINMAIN_</span><br><span class="line">        _TUCHAR *lpszCommandLine;</span><br><span class="line">        STARTUPINFO StartupInfo;</span><br><span class="line"></span><br><span class="line">        __try &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">            Note: MSDN specifically notes that GetStartupInfo returns no error, and throws unspecified SEH if it fails, so</span><br><span class="line">            the very general exception handler below is appropriate</span><br><span class="line">            *&#x2F;</span><br><span class="line">            GetStartupInfo( amp;StartupInfo );</span><br><span class="line">        &#125; __except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">            return 255;</span><br><span class="line">        &#125;</span><br><span class="line">#endif  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Determine if this is a managed application</span><br><span class="line">         *&#x2F;</span><br><span class="line">        managedapp &#x3D; check_managed_app();</span><br><span class="line"></span><br><span class="line">        if ( !_heap_init(1) )               &#x2F;* initialize heap *&#x2F;</span><br><span class="line">            fast_error_exit(_RT_HEAPINIT);  &#x2F;* write message and die *&#x2F;</span><br><span class="line"></span><br><span class="line">        if( !_mtinit() )                    &#x2F;* initialize multi-thread *&#x2F;</span><br><span class="line">            fast_error_exit(_RT_THREAD);    &#x2F;* write message and die *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;* Enable buffer count checking if linking against static lib *&#x2F;</span><br><span class="line">        _CrtSetCheckCount(TRUE);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Initialize the Runtime Checks stuff</span><br><span class="line">         *&#x2F;</span><br><span class="line">#ifdef _RTC</span><br><span class="line">        _RTC_Initialize();</span><br><span class="line">#endif  &#x2F;* _RTC *&#x2F;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Guard the remainder of the initialization code and the call</span><br><span class="line">         * to user&#39;s main, or WinMain, function in a __try&#x2F;__except</span><br><span class="line">         * statement.</span><br><span class="line">         *&#x2F;</span><br><span class="line"></span><br><span class="line">        __try &#123;</span><br><span class="line"></span><br><span class="line">            if ( _ioinit() lt; 0 )            &#x2F;* initialize lowio *&#x2F;</span><br><span class="line">                _amsg_exit(_RT_LOWIOINIT);</span><br><span class="line"></span><br><span class="line">            &#x2F;* get wide cmd line info *&#x2F;</span><br><span class="line">            _tcmdln &#x3D; (_TSCHAR *)GetCommandLineT();</span><br><span class="line"></span><br><span class="line">            &#x2F;* get wide environ info *&#x2F;</span><br><span class="line">            _tenvptr &#x3D; (_TSCHAR *)GetEnvironmentStringsT();</span><br><span class="line"></span><br><span class="line">            if ( _tsetargv() lt; 0 )</span><br><span class="line">                _amsg_exit(_RT_SPACEARG);</span><br><span class="line">            if ( _tsetenvp() lt; 0 )</span><br><span class="line">                _amsg_exit(_RT_SPACEENV);</span><br><span class="line"></span><br><span class="line">            initret &#x3D; _cinit(TRUE);                  &#x2F;* do C data initialize *&#x2F;</span><br><span class="line">            if (initret !&#x3D; 0)</span><br><span class="line">                _amsg_exit(initret);</span><br><span class="line"></span><br><span class="line">#ifdef _WINMAIN_</span><br><span class="line"></span><br><span class="line">            lpszCommandLine &#x3D; _twincmdln();</span><br><span class="line">            mainret &#x3D; _tWinMain( (HINSTANCE)amp;__ImageBase,</span><br><span class="line">                                 NULL,</span><br><span class="line">                                 lpszCommandLine,</span><br><span class="line">                                 StartupInfo.dwFlags amp; STARTF_USESHOWWINDOW</span><br><span class="line">                                      ? StartupInfo.wShowWindow</span><br><span class="line">                                      : SW_SHOWDEFAULT</span><br><span class="line">                                );</span><br><span class="line">#else  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line">            _tinitenv &#x3D; _tenviron;</span><br><span class="line">            mainret &#x3D; _tmain(__argc, _targv, _tenviron);</span><br><span class="line">#endif  &#x2F;* _WINMAIN_ *&#x2F;</span><br><span class="line"></span><br><span class="line">            if ( !managedapp )</span><br><span class="line">                exit(mainret);</span><br><span class="line"></span><br><span class="line">            _cexit();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * Should never reach here</span><br><span class="line">             *&#x2F;</span><br><span class="line"></span><br><span class="line">            mainret &#x3D; GetExceptionCode();</span><br><span class="line"></span><br><span class="line">            if ( !managedapp )</span><br><span class="line">                _exit(mainret);</span><br><span class="line"></span><br><span class="line">            _c_exit();</span><br><span class="line"></span><br><span class="line">        &#125; &#x2F;* end of try - except *&#x2F;</span><br><span class="line"></span><br><span class="line">        return mainret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码，可以很清晰了解启动函数到底做了什么事情。</p><p>Console版本</p><p>1.初始化C的堆申请（_heap_init(1)）</p><p>2.初始化多线程（_mtinit()）</p><p>3.获取命令行（GetCommandLineT()）</p><p>4.获取环境变量（GetEnvironmentStringsT()）</p><p>5.初始化C和C++的全局变量（_cinit(TRUE)）</p><p>6.调用main函数（_tmain(__argc, _targv, _tenviron)）</p><p>Windows版本</p><p>1.获取StartupInfo（GetStartupInfo( StartupInfo )）</p><p>2.初始化C的堆申请（_heap_init(1)）</p><p>3.初始化多线程（_mtinit()）</p><p>4.获取命令行（GetCommandLineT()）</p><p>5.获取环境变量（GetEnvironmentStringsT()）</p><p>6.初始化C和C++的全局变量（_cinit(TRUE)）</p><p>7.调用WinMain函数</p><p>最后再看看_cinit(TRUE)到底做了什么事情？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl _cinit (</span><br><span class="line">        int initFloatingPrecision</span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">        int initret;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * initialize floating point package, if present</span><br><span class="line">         *&#x2F;</span><br><span class="line">#ifdef CRTDLL</span><br><span class="line">        _fpmath(initFloatingPrecision);</span><br><span class="line">#else  &#x2F;* CRTDLL *&#x2F;</span><br><span class="line">        if (_FPinit !&#x3D; NULL amp;amp;</span><br><span class="line">            _IsNonwritableInCurrentImage((PBYTE)amp;_FPinit))</span><br><span class="line">        &#123;</span><br><span class="line">            (*_FPinit)(initFloatingPrecision);</span><br><span class="line">        &#125;</span><br><span class="line">        _initp_misc_cfltcvt_tab();</span><br><span class="line">#endif  &#x2F;* CRTDLL *&#x2F;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * do initializations</span><br><span class="line">         *&#x2F;</span><br><span class="line">        initret &#x3D; _initterm_e( __xi_a, __xi_z );</span><br><span class="line">        if ( initret !&#x3D; 0 )</span><br><span class="line">            return initret;</span><br><span class="line"></span><br><span class="line">#ifdef _RTC</span><br><span class="line">        atexit(_RTC_Terminate);</span><br><span class="line">#endif  &#x2F;* _RTC *&#x2F;</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * do C++ initializations</span><br><span class="line">         *&#x2F;</span><br><span class="line">        _initterm( __xc_a, __xc_z );</span><br><span class="line"></span><br><span class="line">#ifndef CRTDLL</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * If we have any dynamically initialized __declspec(thread)</span><br><span class="line">         * variables, then invoke their initialization for the thread on</span><br><span class="line">         * which the DLL is being loaded, by calling __dyn_tls_init through</span><br><span class="line">         * a callback defined in tlsdyn.obj.  We can&#39;t rely on the OS</span><br><span class="line">         * calling __dyn_tls_init with DLL_PROCESS_ATTACH because, on</span><br><span class="line">         * Win2K3 and before, that call happens before the CRT is</span><br><span class="line">         * initialized.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (__dyn_tls_init_callback !&#x3D; NULL amp;amp;</span><br><span class="line">            _IsNonwritableInCurrentImage((PBYTE)amp;__dyn_tls_init_callback))</span><br><span class="line">        &#123;</span><br><span class="line">            __dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">#endif  &#x2F;* CRTDLL *&#x2F;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的两行，initret = _initterm_e( <strong>xi_a, </strong>xi_z )和_initterm( <strong>xc_a, </strong>xc_z )。这两行的作用分别是初始化C标准库中的全局变量和初始化C++的全局变量。</p><p>至此，对C++程序的默认启动函数的基本过程有个了解了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得以前学汇编和PE文件的时候知道，系统不会直接调用我们编写的main，而是调用指定的入口地址。实际上这个入口地址，是在链接时候指定的，MS C/C++中使用链接命令/entry:function可以修改默认设置。&lt;/p&gt;
&lt;p&gt;那么，默认情况下，我们使用VC编写的应用程序使用的是什么入口函数了？&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;默认&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;mainCRTStartup&lt;/strong&gt; (or &lt;strong&gt;wmainCRTStartup&lt;/strong&gt;)&lt;/td&gt;
&lt;td&gt;An application using /SUBSYSTEM:&lt;strong&gt;CONSOLE&lt;/strong&gt;; calls &lt;strong&gt;main&lt;/strong&gt; (or &lt;strong&gt;wmain&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;WinMainCRTStartup&lt;/strong&gt; (or &lt;strong&gt;wWinMainCRTStartup&lt;/strong&gt;)&lt;/td&gt;
&lt;td&gt;An application using /SUBSYSTEM:&lt;strong&gt;WINDOWS&lt;/strong&gt;; calls &lt;strong&gt;WinMain&lt;/strong&gt; (or &lt;strong&gt;wWinMain&lt;/strong&gt;), which must be defined with &lt;strong&gt;__stdcall&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://xiaopengcheng.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C/C++" scheme="http://xiaopengcheng.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C-C/"/>
    
    
      <category term="程序启动" scheme="http://xiaopengcheng.top/tags/%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件推荐列表</title>
    <link href="http://xiaopengcheng.top/2015/12/18/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8/"/>
    <id>http://xiaopengcheng.top/2015/12/18/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8/</id>
    <published>2015-12-18T07:22:59.000Z</published>
    <updated>2019-12-19T16:22:33.355Z</updated>
    
    <content type="html"><![CDATA[<p>1.发布博客软件：Windows Live Write，可以参考<a href="http://www.xpc-yx.com/2015/11/25/%E8%AF%95%E8%AF%95windows-live-write%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">我的WindowsLiveWrite博文</a>。</p><p>2.Windows7/Xp上显示TGA图片的缩略图：MysticThumbs，可以参考<a href="http://www.xpc-yx.com/2015/10/12/%E5%A6%82%E4%BD%95%E8%AE%A9tga%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/" target="_blank" rel="noopener">我的MysticThumbs博文</a>。</p><p>3.记笔记：印象笔记（Evernote），不用介绍了，任何设备上都可以用（电脑，手机，ipad…)。</p><p>4.注册表浏览器：registryworkshop，比Windows默认的注册表舒服很多。</p><p>5.破解工具：<strong>TrialReset。</strong>该软件可以清除很多软件的保护信息，比如visual assist X，我就用它清楚过VA的保护信息。搜索该软件会得到一些介绍，单纯的清除信息操作很简单，清除后相当于<strong>无限延长试用期</strong>。试试会得到你意想不到的结果。</p><p>6.阅读软件：<strong>calibre</strong>。calibre是一个非常优秀的书籍管理软件。当然，我找到它的原因是它可以非常方便的转mobi,epub等。这样就可以将任意格式的书籍放到kindle或者多看阅读器（支持多种设备，手机，ipad，kindle等）上面去看了。这对于用阅读打法无聊时光的我，非常有用。calibre还可以在PC上当做书籍管理和阅读软件，我正在用它看epub格式的书籍了，因为多看阅读器不支持Windows平台。更多功能我就不知道了，有待挖掘。</p><p>7.文件内容搜索工具：<strong>FileSeek</strong>。这款软件能够下载到破解版，我现在主要用来搜索as代码（逆战的界面使用的是ScaleForm开发的，需要写as代码）。Windows自带的搜索功能对于文件内容搜索确实不方便额。</p><p>持续更新…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.发布博客软件：Windows Live Write，可以参考&lt;a href=&quot;http://www.xpc-yx.com/2015/11/25/%E8%AF%95%E8%AF%95windows-live-write%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的WindowsLiveWrite博文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2.Windows7/Xp上显示TGA图片的缩略图：MysticThumbs，可以参考&lt;a href=&quot;http://www.xpc-yx.com/2015/10/12/%E5%A6%82%E4%BD%95%E8%AE%A9tga%E6%A0%BC%E5%BC%8F%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我的MysticThumbs博文&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;3.记笔记：印象笔记（Evernote），不用介绍了，任何设备上都可以用（电脑，手机，ipad…)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://xiaopengcheng.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="推荐" scheme="http://xiaopengcheng.top/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>CTex下如何使Beamer支持中文</title>
    <link href="http://xiaopengcheng.top/2015/11/28/CTex%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BFBeamer%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87/"/>
    <id>http://xiaopengcheng.top/2015/11/28/CTex%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BFBeamer%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87/</id>
    <published>2015-11-28T11:17:05.000Z</published>
    <updated>2019-12-19T16:22:33.195Z</updated>
    
    <content type="html"><![CDATA[<p>我使用的是windows下的最新版CTex，版本号是CTeX_2.9.2.164_Full.exe。注意使用full版本，如果不是，可能不支持beamer。beamer是一个流行的演讲文档模板，有多种主题，效果也还不错。</p><p>我在尝试beamer的过程中，发现网上大部分例子都不支持中文，或者不支持我使用的环境下的中文，即windows下的最新版CTex。折腾了几天，试了很多个模板，发现xeCJK能够完美解决这个问题，因为很多老的模板都是用的CJK，我将其中一个模板改成xeCJK就支持中文了。<br> 下面给出这个模板的设置。  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;beamer&#125;</span><br><span class="line">\usetheme&#123;Warsaw&#125;</span><br><span class="line">\usepackage&#123;fontspec,xunicode,xltxtra&#125;</span><br><span class="line">\usepackage[slantfont,boldfont]&#123;xeCJK&#125; % 允许斜体和粗体</span><br><span class="line">\setbeamercovered&#123;transparent&#125;</span><br><span class="line">\usepackage[english]&#123;babel&#125;</span><br><span class="line">% or whatever</span><br><span class="line">\usepackage&#123;hyperref&#125;</span><br><span class="line">\usepackage[T1]&#123;fontenc&#125;</span><br><span class="line">% or whatever</span><br><span class="line">\usefonttheme&#123;professionalfonts&#125;</span><br><span class="line">\usepackage&#123;times&#125;</span><br><span class="line">\usepackage&#123;mathptmx&#125;</span><br><span class="line">\usepackage&#123;tabularx&#125;</span><br><span class="line">% Or whatever. Note that the encoding and the font should match. If T1</span><br><span class="line">% does not look nice, try deleting the line with the fontenc.</span><br><span class="line">\usepackage&#123;xcolor&#125;</span><br><span class="line">\usepackage&#123;booktabs, multirow, enumerate&#125;</span><br><span class="line">\usepackage&#123;animate&#125;</span><br><span class="line">\usepackage&#123;multimedia&#125;</span><br><span class="line"></span><br><span class="line">% ... or whatever. Note that the encoding and the font should match.</span><br><span class="line">% If T1 does not look nice, try deleting the line with the fontenc.</span><br><span class="line">\usepackage&#123;lmodern&#125; %optional</span><br><span class="line">\usepackage&#123;listings&#125;</span><br><span class="line"></span><br><span class="line">% Delete this, if you do not want the table of contents to pop up at</span><br><span class="line">% the beginning of each subsection:</span><br><span class="line">\AtBeginSection[]</span><br><span class="line">&#123;</span><br><span class="line">    \begin&#123;frame&#125;&lt;beamer&gt;</span><br><span class="line">        \frametitle&#123;内容大纲&#125;</span><br><span class="line">        \tableofcontents[currentsection]</span><br><span class="line">    \end&#123;frame&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\setCJKmainfont&#123;Microsoft YaHei&#125;   % 设置缺省中文字体</span><br><span class="line">\setCJKmonofont&#123;SimSun&#125;   % 设置等宽字体</span><br><span class="line">\setmainfont&#123;TeX Gyre Pagella&#125; % 英文衬线字体</span><br><span class="line">\setmonofont&#123;Microsoft YaHei&#125; % 英文等宽字体</span><br><span class="line">\setsansfont&#123;Trebuchet MS&#125; % 英文无衬线字体</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\title[***纹理***]% optional, use only with long paper titles</span><br><span class="line">&#123; ***纹理***\\[<span class="number">2ex</span>]&#125;</span><br><span class="line"></span><br><span class="line">%\subtitle[malloc] %optional</span><br><span class="line">%&#123;malloc\ 实现&#125;</span><br><span class="line"></span><br><span class="line">\author[yx] % optional, use only with lots of authors</span><br><span class="line">&#123;</span><br><span class="line">\textcolor[rgb]&#123;<span class="number">0.00</span>, <span class="number">0.41</span>, <span class="number">0.66</span>&#125;&#123;yx&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% the titlepage</span><br><span class="line">% the plain option removes the sidebar and header from the title page</span><br><span class="line">\begin&#123;frame&#125;[plain]</span><br><span class="line">  \titlepage</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line">%%%%%%%%%%%%%%%%</span><br><span class="line"></span><br><span class="line">\begin&#123;frame&#125;</span><br><span class="line">        \frametitle&#123;内容大纲&#125;</span><br><span class="line">        \tableofcontents</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line"></span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">\section&#123;研究背景和意义&#125;</span><br><span class="line">%%%%%%%%%%%%%%%%</span><br><span class="line">\begin&#123;frame&#125;&#123;纹理的作用&#125;&#123;&#125;</span><br><span class="line">  \begin&#123;block&#125;&lt;<span class="number">1</span>-&gt;&#123;&#125;</span><br><span class="line">    纹理是图形学中增强真实性的重要手段。</span><br><span class="line">  \end&#123;block&#125;</span><br><span class="line">  \begin&#123;block&#125;&lt;<span class="number">2</span>-&gt;&#123;&#125;</span><br><span class="line">    应用纹理到三维表面能够有效的表示物体表面的颜色，材质，几何等属性。</span><br><span class="line">  \end&#123;block&#125;</span><br><span class="line">\end&#123;frame&#125;</span><br><span class="line">%%%%%%%%%%%%%%%%</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，请用utf8来保存该文档，并且在WinEdit中用utf8来打开，否则还是可能看到乱码的。<br>boats against the current, borne back ceaselessly into the past.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我使用的是windows下的最新版CTex，版本号是CTeX_2.9.2.164_Full.exe。注意使用full版本，如果不是，可能不支持beamer。beamer是一个流行的演讲文档模板，有多种主题，效果也还不错。&lt;/p&gt;
&lt;p&gt;我在尝试beamer的过程中，发现网上大部分例子都不支持中文，或者不支持我使用的环境下的中文，即windows下的最新版CTex。折腾了几天，试了很多个模板，发现xeCJK能够完美解决这个问题，因为很多老的模板都是用的CJK，我将其中一个模板改成xeCJK就支持中文了。&lt;br&gt; 下面给出这个模板的设置。  &lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;\documentclass&amp;#123;beamer&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usetheme&amp;#123;Warsaw&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;fontspec,xunicode,xltxtra&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage[slantfont,boldfont]&amp;#123;xeCJK&amp;#125; % 允许斜体和粗体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\setbeamercovered&amp;#123;transparent&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage[english]&amp;#123;babel&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% or whatever&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;hyperref&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage[T1]&amp;#123;fontenc&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% or whatever&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usefonttheme&amp;#123;professionalfonts&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;times&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;mathptmx&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;tabularx&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% Or whatever. Note that the encoding and the font should match. If T1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% does not look nice, try deleting the line with the fontenc.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;xcolor&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;booktabs, multirow, enumerate&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;animate&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;multimedia&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% ... or whatever. Note that the encoding and the font should match.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% If T1 does not look nice, try deleting the line with the fontenc.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;lmodern&amp;#125; %optional&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\usepackage&amp;#123;listings&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% Delete this, if you do not want the table of contents to pop up at&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% the beginning of each subsection:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\AtBeginSection[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \begin&amp;#123;frame&amp;#125;&amp;lt;beamer&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        \frametitle&amp;#123;内容大纲&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        \tableofcontents[currentsection]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \end&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\setCJKmainfont&amp;#123;Microsoft YaHei&amp;#125;   % 设置缺省中文字体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\setCJKmonofont&amp;#123;SimSun&amp;#125;   % 设置等宽字体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\setmainfont&amp;#123;TeX Gyre Pagella&amp;#125; % 英文衬线字体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\setmonofont&amp;#123;Microsoft YaHei&amp;#125; % 英文等宽字体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\setsansfont&amp;#123;Trebuchet MS&amp;#125; % 英文无衬线字体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\begin&amp;#123;document&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\title[***纹理***]% optional, use only with long paper titles&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; ***纹理***\\[&lt;span class=&quot;number&quot;&gt;2ex&lt;/span&gt;]&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%\subtitle[malloc] %optional&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%&amp;#123;malloc\ 实现&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\author[yx] % optional, use only with lots of authors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\textcolor[rgb]&amp;#123;&lt;span class=&quot;number&quot;&gt;0.00&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.41&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.66&lt;/span&gt;&amp;#125;&amp;#123;yx&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% the titlepage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;% the plain option removes the sidebar and header from the title page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\begin&amp;#123;frame&amp;#125;[plain]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  \titlepage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\end&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%%%%%%%%%%%%%%%&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\begin&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        \frametitle&amp;#123;内容大纲&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        \tableofcontents&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\end&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\section&amp;#123;研究背景和意义&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%%%%%%%%%%%%%%%&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\begin&amp;#123;frame&amp;#125;&amp;#123;纹理的作用&amp;#125;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  \begin&amp;#123;block&amp;#125;&amp;lt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-&amp;gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    纹理是图形学中增强真实性的重要手段。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  \end&amp;#123;block&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  \begin&amp;#123;block&amp;#125;&amp;lt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-&amp;gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    应用纹理到三维表面能够有效的表示物体表面的颜色，材质，几何等属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  \end&amp;#123;block&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\end&amp;#123;frame&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%%%%%%%%%%%%%%%&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\end&amp;#123;document&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://xiaopengcheng.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="CTex" scheme="http://xiaopengcheng.top/tags/CTex/"/>
    
  </entry>
  
</feed>
